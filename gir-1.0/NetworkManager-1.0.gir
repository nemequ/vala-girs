<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="DBusGLib" version="1.0"/>
  <include name="GObject" version="2.0"/>
  <package name="libnm-util"/>
  <namespace name="NetworkManager"
             version="1.0"
             shared-library="libnm-util.so.2"
             c:identifier-prefixes="NM"
             c:symbol-prefixes="nm">
    <bitfield name="80211ApFlags" c:type="NM80211ApFlags">
      <doc xml:space="preserve">802.11 access point flags.</doc>
      <member name="none" value="0" c:identifier="NM_802_11_AP_FLAGS_NONE">
        <doc xml:space="preserve">access point has no special capabilities</doc>
      </member>
      <member name="privacy"
              value="1"
              c:identifier="NM_802_11_AP_FLAGS_PRIVACY">
        <doc xml:space="preserve">access point requires authentication and
encryption (usually means WEP)</doc>
      </member>
    </bitfield>
    <bitfield name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags">
      <doc xml:space="preserve">802.11 access point security and authentication flags.  These flags describe
the current security requirements of an access point as determined from the
access point's beacon.</doc>
      <member name="none" value="0" c:identifier="NM_802_11_AP_SEC_NONE">
        <doc xml:space="preserve">the access point has no special security requirements</doc>
      </member>
      <member name="pair_wep40"
              value="1"
              c:identifier="NM_802_11_AP_SEC_PAIR_WEP40">
        <doc xml:space="preserve">40/64-bit WEP is supported for
pairwise/unicast encryption</doc>
      </member>
      <member name="pair_wep104"
              value="2"
              c:identifier="NM_802_11_AP_SEC_PAIR_WEP104">
        <doc xml:space="preserve">104/128-bit WEP is supported for
pairwise/unicast encryption</doc>
      </member>
      <member name="pair_tkip"
              value="4"
              c:identifier="NM_802_11_AP_SEC_PAIR_TKIP">
        <doc xml:space="preserve">TKIP is supported for pairwise/unicast encryption</doc>
      </member>
      <member name="pair_ccmp"
              value="8"
              c:identifier="NM_802_11_AP_SEC_PAIR_CCMP">
        <doc xml:space="preserve">AES/CCMP is supported for pairwise/unicast encryption</doc>
      </member>
      <member name="group_wep40"
              value="16"
              c:identifier="NM_802_11_AP_SEC_GROUP_WEP40">
        <doc xml:space="preserve">40/64-bit WEP is supported for group/broadcast
encryption</doc>
      </member>
      <member name="group_wep104"
              value="32"
              c:identifier="NM_802_11_AP_SEC_GROUP_WEP104">
        <doc xml:space="preserve">104/128-bit WEP is supported for
group/broadcast encryption</doc>
      </member>
      <member name="group_tkip"
              value="64"
              c:identifier="NM_802_11_AP_SEC_GROUP_TKIP">
        <doc xml:space="preserve">TKIP is supported for group/broadcast encryption</doc>
      </member>
      <member name="group_ccmp"
              value="128"
              c:identifier="NM_802_11_AP_SEC_GROUP_CCMP">
        <doc xml:space="preserve">AES/CCMP is supported for group/broadcast
encryption</doc>
      </member>
      <member name="key_mgmt_psk"
              value="256"
              c:identifier="NM_802_11_AP_SEC_KEY_MGMT_PSK">
        <doc xml:space="preserve">WPA/RSN Pre-Shared Key encryption is
supported</doc>
      </member>
      <member name="key_mgmt_802_1x"
              value="512"
              c:identifier="NM_802_11_AP_SEC_KEY_MGMT_802_1X">
        <doc xml:space="preserve">802.1x authentication and key management
is supported</doc>
      </member>
    </bitfield>
    <enumeration name="80211Mode" c:type="NM80211Mode">
      <doc xml:space="preserve">Indicates the 802.11 mode an access point or device is currently in.</doc>
      <member name="unknown" value="0" c:identifier="NM_802_11_MODE_UNKNOWN">
        <doc xml:space="preserve">the device or access point mode is unknown</doc>
      </member>
      <member name="adhoc" value="1" c:identifier="NM_802_11_MODE_ADHOC">
        <doc xml:space="preserve">for both devices and access point objects, indicates
  the object is part of an Ad-Hoc 802.11 network without a central
  coordinating access point.</doc>
      </member>
      <member name="infra" value="2" c:identifier="NM_802_11_MODE_INFRA">
        <doc xml:space="preserve">the device or access point is in infrastructure mode.
  For devices, this indicates the device is an 802.11 client/station.  For
  access point objects, this indicates the object is an access point that
  provides connectivity to clients.</doc>
      </member>
      <member name="ap" value="3" c:identifier="NM_802_11_MODE_AP">
        <doc xml:space="preserve">the device is an access point/hotspot.  Not valid for
  access point objects; used only for hotspot mode on the local machine.</doc>
      </member>
    </enumeration>
    <enumeration name="ActiveConnectionState" c:type="NMActiveConnectionState">
      <doc xml:space="preserve">#NMActiveConnectionState values indicate the state of a connection to a
specific network while it is starting, connected, or disconnecting from that
network.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_UNKNOWN">
        <doc xml:space="preserve">the state of the connection is unknown</doc>
      </member>
      <member name="activating"
              value="1"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_ACTIVATING">
        <doc xml:space="preserve">a network connection is being prepared</doc>
      </member>
      <member name="activated"
              value="2"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_ACTIVATED">
        <doc xml:space="preserve">there is a connection to the network</doc>
      </member>
      <member name="deactivating"
              value="3"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_DEACTIVATING">
        <doc xml:space="preserve">the network connection is being
  torn down and cleaned up</doc>
      </member>
      <member name="deactivated"
              value="4"
              c:identifier="NM_ACTIVE_CONNECTION_STATE_DEACTIVATED">
        <doc xml:space="preserve">the network connection is disconnected
  and will be removed</doc>
      </member>
    </enumeration>
    <bitfield name="BluetoothCapabilities" c:type="NMBluetoothCapabilities">
      <doc xml:space="preserve">#NMBluetoothCapabilities values indicate the usable capabilities of a
Bluetooth device.</doc>
      <member name="none" value="0" c:identifier="NM_BT_CAPABILITY_NONE">
        <doc xml:space="preserve">device has no usable capabilities</doc>
      </member>
      <member name="dun" value="1" c:identifier="NM_BT_CAPABILITY_DUN">
        <doc xml:space="preserve">device provides Dial-Up Networking capability</doc>
      </member>
      <member name="nap" value="2" c:identifier="NM_BT_CAPABILITY_NAP">
        <doc xml:space="preserve">device provides Network Access Point capability</doc>
      </member>
    </bitfield>
    <constant name="CONNECTION_CHANGED"
              value="changed"
              c:type="NM_CONNECTION_CHANGED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD"
              value="ip6-config-method"
              c:type="NM_CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_PATH" value="path" c:type="NM_CONNECTION_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_SECRETS_CLEARED"
              value="secrets-cleared"
              c:type="NM_CONNECTION_SECRETS_CLEARED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONNECTION_SECRETS_UPDATED"
              value="secrets-updated"
              c:type="NM_CONNECTION_SECRETS_UPDATED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Connection"
           c:symbol-prefix="connection"
           c:type="NMConnection"
           parent="GObject.Object"
           glib:type-name="NMConnection"
           glib:get-type="nm_connection_get_type"
           glib:type-struct="ConnectionClass">
      <doc xml:space="preserve">The NMConnection struct contains only private data.
It should only be accessed through the functions described below.</doc>
      <constructor name="new" c:identifier="nm_connection_new">
        <doc xml:space="preserve">Creates a new #NMConnection object with no #NMSetting objects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMConnection object</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_hash"
                   c:identifier="nm_connection_new_from_hash"
                   throws="1">
        <doc xml:space="preserve">Creates a new #NMConnection from a hash table describing the connection.  See
nm_connection_to_hash() for a description of the expected hash table.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #NMConnection object, populated with settings created
from the values in the hash table, or %NULL if the connection failed to
validate</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:space="preserve">the #GHashTable describing
the connection</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.HashTable">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="create_setting"
                c:identifier="nm_connection_create_setting">
        <doc xml:space="preserve">Create a new #NMSetting object of the desired type, given a setting name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new setting object, or %NULL if the setting name was unknown</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a setting name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_setting_type"
                c:identifier="nm_connection_lookup_setting_type">
        <doc xml:space="preserve">Returns the #GType of the setting's class for a given setting name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of the setting's class</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a setting name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_setting_type_by_quark"
                c:identifier="nm_connection_lookup_setting_type_by_quark">
        <doc xml:space="preserve">Returns the #GType of the setting's class for a given setting error quark.
Useful for figuring out which setting a returned error is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType of the setting's class</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="error_quark" transfer-ownership="none">
            <doc xml:space="preserve">a setting error quark</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="secrets_updated">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_setting" c:identifier="nm_connection_add_setting">
        <doc xml:space="preserve">Adds a #NMSetting to the connection, replacing any previous #NMSetting of the
same name which has previously been added to the #NMConnection.  The
connection takes ownership of the #NMSetting object and does not increase
the setting object's reference count.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting" transfer-ownership="full">
            <doc xml:space="preserve">the #NMSetting to add to the connection object</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_secrets" c:identifier="nm_connection_clear_secrets">
        <doc xml:space="preserve">Clears and frees any secrets that may be stored in the connection, to avoid
keeping secret data in memory when not needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_secrets_with_flags"
              c:identifier="nm_connection_clear_secrets_with_flags">
        <doc xml:space="preserve">Clears and frees secrets determined by @func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">function to be called to determine whether a
    specific secret should be cleared or not</doc>
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-supplied data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="nm_connection_compare">
        <doc xml:space="preserve">Compares two #NMConnection objects for similarity, with comparison behavior
modified by a set of flags.  See nm_setting_compare() for a description of
each flag's behavior.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the comparison succeeds, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMConnection to compare with the first</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="diff" c:identifier="nm_connection_diff">
        <doc xml:space="preserve">Compares two #NMConnection objects for similarity, with comparison behavior
modified by a set of flags.  See nm_setting_compare() for a description of
each flag's behavior.  If the connections differ, settings and keys within
each setting that differ are added to the returned @out_settings hash table.
No values are returned, only key names.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connections contain the same values, %FALSE if they do
not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMConnection to compare with the first</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
          <parameter name="out_settings" transfer-ownership="none">
            <doc xml:space="preserve">if the
connections differ, on return a hash table mapping setting names to
second-level GHashTable (utf8 to guint32), which contains the key names that
differ mapped to one or more of %NMSettingDiffResult as a bitfield</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GLib.HashTable">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="nm_connection_dump">
        <doc xml:space="preserve">Print the connection to stdout.  For debugging purposes ONLY, should NOT
be used for serialization of the connection or machine-parsed in any way. The
output format is not guaranteed to be stable and may change at any time.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="duplicate" c:identifier="nm_connection_duplicate">
        <doc xml:space="preserve">Duplicates a #NMConnection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMConnection containing the same settings and properties
as the source #NMConnection</doc>
          <type name="Connection" c:type="NMConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to duplicate</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="for_each_setting_value"
              c:identifier="nm_connection_for_each_setting_value">
        <doc xml:space="preserve">Iterates over the properties of each #NMSetting object in the #NMConnection,
calling the supplied user function for each property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">user-supplied function called for each setting's property</doc>
            <type name="SettingValueIterFn" c:type="NMSettingValueIterFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to @func at each invocation</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_connection_get_connection_type"
              version="0.9.10">
        <doc xml:space="preserve">A shortcut to return the type from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_connection_get_id">
        <doc xml:space="preserve">A shortcut to return the ID from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the ID from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_connection_get_interface_name"
              version="1.0">
        <doc xml:space="preserve">Returns the interface name as stored in NMSettingConnection:interface_name.
If the connection contains no NMSettingConnection, it will return %NULL.

For hardware devices and software devices created outside of NetworkManager,
this name is used to match the device. for software devices created by
NetworkManager, this is the name of the created interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Name of the kernel interface or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path" c:identifier="nm_connection_get_path">
        <doc xml:space="preserve">Returns the connection's D-Bus path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the D-Bus path of the connection, previously set by a call to
nm_connection_set_path().</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting" c:identifier="nm_connection_get_setting">
        <doc xml:space="preserve">Gets the #NMSetting with the given #GType, if one has been previously added
to the #NMConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting, or %NULL if no setting of that type was previously
added to the #NMConnection</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the setting object to return</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_setting_802_1x"
              c:identifier="nm_connection_get_setting_802_1x">
        <doc xml:space="preserve">A shortcut to return any #NMSetting8021x the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSetting8021x if the connection contains one, otherwise %NULL</doc>
          <type name="Setting8021x" c:type="NMSetting8021x*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_adsl"
              c:identifier="nm_connection_get_setting_adsl">
        <doc xml:space="preserve">A shortcut to return any #NMSettingAdsl the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingAdsl if the connection contains one, otherwise %NULL</doc>
          <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bluetooth"
              c:identifier="nm_connection_get_setting_bluetooth">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBluetooth the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBluetooth if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBluetooth" c:type="NMSettingBluetooth*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bond"
              c:identifier="nm_connection_get_setting_bond">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBond the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBond if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBond" c:type="NMSettingBond*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bridge"
              c:identifier="nm_connection_get_setting_bridge">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBridge the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBridge if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBridge" c:type="NMSettingBridge*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_bridge_port"
              c:identifier="nm_connection_get_setting_bridge_port">
        <doc xml:space="preserve">A shortcut to return any #NMSettingBridgePort the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingBridgePort if the connection contains one, otherwise %NULL</doc>
          <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_by_name"
              c:identifier="nm_connection_get_setting_by_name">
        <doc xml:space="preserve">Gets the #NMSetting with the given name, if one has been previously added
the #NMConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting, or %NULL if no setting with that name was previously
added to the #NMConnection</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a setting name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_setting_cdma"
              c:identifier="nm_connection_get_setting_cdma">
        <doc xml:space="preserve">A shortcut to return any #NMSettingCdma the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingCdma if the connection contains one, otherwise %NULL</doc>
          <type name="SettingCdma" c:type="NMSettingCdma*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_connection"
              c:identifier="nm_connection_get_setting_connection">
        <doc xml:space="preserve">A shortcut to return any #NMSettingConnection the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingConnection if the connection contains one, otherwise %NULL</doc>
          <type name="SettingConnection" c:type="NMSettingConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_dcb"
              c:identifier="nm_connection_get_setting_dcb"
              version="0.9.10">
        <doc xml:space="preserve">A shortcut to return any #NMSettingDcb the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingDcb if the connection contains one, otherwise NULL</doc>
          <type name="SettingDcb" c:type="NMSettingDcb*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_generic"
              c:identifier="nm_connection_get_setting_generic"
              version="0.9.10">
        <doc xml:space="preserve">A shortcut to return any #NMSettingGeneric the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingGeneric if the connection contains one, otherwise NULL</doc>
          <type name="SettingGeneric" c:type="NMSettingGeneric*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_gsm"
              c:identifier="nm_connection_get_setting_gsm">
        <doc xml:space="preserve">A shortcut to return any #NMSettingGsm the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingGsm if the connection contains one, otherwise %NULL</doc>
          <type name="SettingGsm" c:type="NMSettingGsm*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_infiniband"
              c:identifier="nm_connection_get_setting_infiniband">
        <doc xml:space="preserve">A shortcut to return any #NMSettingInfiniband the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingInfiniband if the connection contains one, otherwise %NULL</doc>
          <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_ip4_config"
              c:identifier="nm_connection_get_setting_ip4_config">
        <doc xml:space="preserve">A shortcut to return any #NMSettingIP4Config the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingIP4Config if the connection contains one, otherwise %NULL</doc>
          <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_ip6_config"
              c:identifier="nm_connection_get_setting_ip6_config">
        <doc xml:space="preserve">A shortcut to return any #NMSettingIP6Config the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingIP6Config if the connection contains one, otherwise %NULL</doc>
          <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_olpc_mesh"
              c:identifier="nm_connection_get_setting_olpc_mesh">
        <doc xml:space="preserve">A shortcut to return any #NMSettingOlpcMesh the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingOlpcMesh if the connection contains one, otherwise %NULL</doc>
          <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_ppp"
              c:identifier="nm_connection_get_setting_ppp">
        <doc xml:space="preserve">A shortcut to return any #NMSettingPPP the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingPPP if the connection contains one, otherwise %NULL</doc>
          <type name="SettingPPP" c:type="NMSettingPPP*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_pppoe"
              c:identifier="nm_connection_get_setting_pppoe">
        <doc xml:space="preserve">A shortcut to return any #NMSettingPPPOE the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingPPPOE if the connection contains one, otherwise %NULL</doc>
          <type name="SettingPPPOE" c:type="NMSettingPPPOE*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_serial"
              c:identifier="nm_connection_get_setting_serial">
        <doc xml:space="preserve">A shortcut to return any #NMSettingSerial the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingSerial if the connection contains one, otherwise %NULL</doc>
          <type name="SettingSerial" c:type="NMSettingSerial*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_team"
              c:identifier="nm_connection_get_setting_team"
              version="0.9.10">
        <doc xml:space="preserve">A shortcut to return any #NMSettingTeam the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingTeam if the connection contains one, otherwise %NULL</doc>
          <type name="SettingTeam" c:type="NMSettingTeam*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_team_port"
              c:identifier="nm_connection_get_setting_team_port"
              version="0.9.10">
        <doc xml:space="preserve">A shortcut to return any #NMSettingTeamPort the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingTeamPort if the connection contains one, otherwise %NULL</doc>
          <type name="SettingTeamPort" c:type="NMSettingTeamPort*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_vlan"
              c:identifier="nm_connection_get_setting_vlan">
        <doc xml:space="preserve">A shortcut to return any #NMSettingVlan the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingVlan if the connection contains one, otherwise %NULL</doc>
          <type name="SettingVlan" c:type="NMSettingVlan*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_vpn"
              c:identifier="nm_connection_get_setting_vpn">
        <doc xml:space="preserve">A shortcut to return any #NMSettingVPN the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingVPN if the connection contains one, otherwise %NULL</doc>
          <type name="SettingVPN" c:type="NMSettingVPN*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wimax"
              c:identifier="nm_connection_get_setting_wimax">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWimax the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWimax if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWimax" c:type="NMSettingWimax*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wired"
              c:identifier="nm_connection_get_setting_wired">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWired the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWired if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWired" c:type="NMSettingWired*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wireless"
              c:identifier="nm_connection_get_setting_wireless">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWireless the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWireless if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWireless" c:type="NMSettingWireless*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_setting_wireless_security"
              c:identifier="nm_connection_get_setting_wireless_security">
        <doc xml:space="preserve">A shortcut to return any #NMSettingWirelessSecurity the connection might contain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an #NMSettingWirelessSecurity if the connection contains one, otherwise %NULL</doc>
          <type name="SettingWirelessSecurity"
                c:type="NMSettingWirelessSecurity*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="nm_connection_get_uuid">
        <doc xml:space="preserve">A shortcut to return the UUID from the connection's #NMSettingConnection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the UUID from the connection's 'connection' setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_virtual_device_description"
              c:identifier="nm_connection_get_virtual_device_description"
              version="0.9.10">
        <doc xml:space="preserve">Returns the name that nm_device_disambiguate_names() would
return for the virtual device that would be created for @connection.
Eg, "VLAN (eth1.1)".</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the name of @connection's device,
  or %NULL if @connection is not a virtual connection type</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">an #NMConnection for a virtual device type</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_virtual_iface_name"
              c:identifier="nm_connection_get_virtual_iface_name">
        <doc xml:space="preserve">Returns the name of the virtual kernel interface which the connection
needs to use if specified in the settings. This function abstracts all
connection types which require this functionality. For all other
connection types, this function will return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Name of the kernel interface or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">The #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_type" c:identifier="nm_connection_is_type">
        <doc xml:space="preserve">A convenience function to check if the given @connection is a particular
type (ie wired, Wi-Fi, ppp, etc). Checks the #NMSettingConnection:type
property of the connection and matches that against @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is of the given @type, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a setting name to check the connection's type against (like
%NM_SETTING_WIRELESS_SETTING_NAME or %NM_SETTING_WIRED_SETTING_NAME)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="need_secrets" c:identifier="nm_connection_need_secrets">
        <doc xml:space="preserve">Returns the name of the first setting object in the connection which would
need secrets to make a successful connection.  The returned hints are only
intended as a guide to what secrets may be required, because in some
circumstances, there is no way to conclusively determine exactly which
secrets are needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the setting name of the #NMSetting object which has invalid or
  missing secrets</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="hints"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">
  the address of a pointer to a #GPtrArray, initialized to %NULL, which on
  return points to an allocated #GPtrArray containing the property names of
  secrets of the #NMSetting which may be required; the caller owns the array
  and must free the array itself with g_ptr_array_free(), but not free its
  elements</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="normalize"
              c:identifier="nm_connection_normalize"
              version="1.0"
              throws="1">
        <doc xml:space="preserve">Does some basic normalization and fixup of well known inconsistencies
and deprecated fields. If the connection was modified in any way,
the output parameter @modified is set %TRUE.

Finally the connection will be verified and %TRUE returns if the connection
is valid. As this function only performs some specific normalization steps
it cannot repair all connections. If the connection has errors that
cannot be normalized, the connection will not be modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to normalize</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GHashTable with
normalization parameters to allow customization of the normalization by providing
specific arguments. Unknown arguments will be ignored and the default will be
used. The keys must be strings, hashed by g_str_hash() and g_str_equal() functions.
The values are opaque and depend on the parameter name.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="gpointer"/>
            </type>
          </parameter>
          <parameter name="modified"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">outputs whether any settings were modified.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_setting"
              c:identifier="nm_connection_remove_setting">
        <doc xml:space="preserve">Removes the #NMSetting with the given #GType from the #NMConnection.  This
operation dereferences the #NMSetting object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:space="preserve">the #GType of the setting object to remove</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_settings"
              c:identifier="nm_connection_replace_settings"
              throws="1">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the settings were valid and added to the connection, %FALSE
if they were not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="new_settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable of settings</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.HashTable">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="replace_settings_from_connection"
              c:identifier="nm_connection_replace_settings_from_connection"
              version="0.9.10"
              throws="1">
        <doc xml:space="preserve">Deep-copies the settings of @new_conenction and replaces the settings of @connection
with the copied settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the settings were valid after replacing the connection, %FALSE
if they were not. Regardless of whether %TRUE or %FALSE is returned, the connection
is successfully replaced. %FALSE only means, that the connection does not verify
at the end of the operation.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="new_connection" transfer-ownership="none">
            <doc xml:space="preserve">a #NMConnection to replace the settings of @connection with</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_path" c:identifier="nm_connection_set_path">
        <doc xml:space="preserve">Sets the D-Bus path of the connection.  This property is not serialized, and
is only for the reference of the caller.  Sets the #NMConnection:path
property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the D-Bus path of the connection as given by the settings service
which provides the connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hash" c:identifier="nm_connection_to_hash">
        <doc xml:space="preserve">Converts the #NMConnection into a #GHashTable describing the connection,
suitable for marshalling over D-Bus or serializing.  The hash table mapping
is string:#GHashTable with each element in the returned hash representing
a #NMSetting object.  The keys are setting object names, and the values
are #GHashTables mapping string:GValue, each of which represents the
properties of the #NMSetting object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new
#GHashTable describing the connection, its settings, and each setting's
properties.  The caller owns the hash table and must unref the hash table
with g_hash_table_unref() when it is no longer needed.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.HashTable">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">hash flags, e.g. %NM_SETTING_HASH_FLAG_ALL</doc>
            <type name="SettingHashFlags" c:type="NMSettingHashFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_secrets"
              c:identifier="nm_connection_update_secrets"
              throws="1">
        <doc xml:space="preserve">Update the specified setting's secrets, given a hash table of secrets
intended for that setting (deserialized from D-Bus for example).  Will also
extract the given setting's secrets hash if given a hash of hashes, as would
be returned from nm_connection_to_hash().  If @setting_name is %NULL, expects
a fully serialized #NMConnection as returned by nm_connection_to_hash() and
will update all secrets from all settings contained in @secrets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secrets were successfully updated, %FALSE if the update
failed (tried to update secrets for a setting that doesn't exist, etc)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the setting object name to which the secrets apply</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="secrets" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable mapping
string:#GValue of setting property names and secrets of the given @setting_name</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="nm_connection_verify" throws="1">
        <doc xml:space="preserve">Validates the connection and all its settings.  Each setting's properties
have allowed values, and some values are dependent on other values.  For
example, if a Wi-Fi connection is security enabled, the #NMSettingWireless
setting object's 'security' property must contain the setting name of the
#NMSettingWirelessSecurity object, which must also be present in the
connection for the connection to be valid.  As another example, the
#NMSettingWired object's 'mac-address' property must be a validly formatted
MAC address.  The returned #GError contains information about which
setting and which property failed validation, and how it failed validation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">the #NMConnection to verify</doc>
            <type name="Connection" c:type="NMConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="path"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The connection's D-Bus path, used only by the calling process as a record
of the D-Bus path of the connection as provided by a settings service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="first" version="0.9.10">
        <doc xml:space="preserve">The ::changed signal is emitted when any property of any property
(including secrets) of any setting of the connection is modified,
or when settings are added or removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secrets-cleared" when="first">
        <doc xml:space="preserve">The ::secrets-cleared signal is emitted when the secrets of a connection
are cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="secrets-updated" when="first">
        <doc xml:space="preserve">The ::secrets-updated signal is emitted when the secrets of a setting
have been changed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="setting_name" transfer-ownership="none">
            <doc xml:space="preserve">the setting name of the #NMSetting for which secrets were
updated</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ConnectionClass"
            c:type="NMConnectionClass"
            glib:is-gtype-struct-for="Connection">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="secrets_updated">
        <callback name="secrets_updated">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="NMConnection*"/>
            </parameter>
            <parameter name="setting" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="ConnectionError"
                 glib:type-name="NMConnectionError"
                 glib:get-type="nm_connection_error_get_type"
                 c:type="NMConnectionError"
                 glib:error-domain="nm-connection-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a #NMConnection.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_CONNECTION_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="ConnectionSettingNotFound"
              value="1"
              c:identifier="NM_CONNECTION_ERROR_CONNECTION_SETTING_NOT_FOUND"
              glib:nick="ConnectionSettingNotFound">
        <doc xml:space="preserve">the #NMConnection object
  did not contain the required #NMSettingConnection object, which must be
  present for all connections</doc>
      </member>
      <member name="ConnectionTypeInvalid"
              value="2"
              c:identifier="NM_CONNECTION_ERROR_CONNECTION_TYPE_INVALID"
              glib:nick="ConnectionTypeInvalid">
        <doc xml:space="preserve">the 'type' property of the
  'connection' setting did not point to a valid connection base type; ie
  it was not a hardware-related setting like #NMSettingWired or
  #NMSettingWireless.</doc>
      </member>
      <member name="SettingNotFound"
              value="3"
              c:identifier="NM_CONNECTION_ERROR_SETTING_NOT_FOUND"
              glib:nick="SettingNotFound">
        <doc xml:space="preserve">the #NMConnection object
  did not contain the specified #NMSetting object</doc>
      </member>
      <member name="InvalidSetting"
              value="4"
              c:identifier="NM_CONNECTION_ERROR_INVALID_SETTING"
              glib:nick="InvalidSetting">
        <doc xml:space="preserve">the #NMConnection object contains
  a conflicting setting object</doc>
      </member>
      <function name="quark" c:identifier="nm_connection_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMConnection if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMConnection errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="ConnectivityState"
                 version="0.9.8.6"
                 c:type="NMConnectivityState">
      <member name="unknown" value="0" c:identifier="NM_CONNECTIVITY_UNKNOWN">
        <doc xml:space="preserve">Network connectivity is unknown.</doc>
      </member>
      <member name="none" value="1" c:identifier="NM_CONNECTIVITY_NONE">
        <doc xml:space="preserve">The host is not connected to any network.</doc>
      </member>
      <member name="portal" value="2" c:identifier="NM_CONNECTIVITY_PORTAL">
        <doc xml:space="preserve">The host is behind a captive portal and
  cannot reach the full Internet.</doc>
      </member>
      <member name="limited" value="3" c:identifier="NM_CONNECTIVITY_LIMITED">
        <doc xml:space="preserve">The host is connected to a network, but
  does not appear to be able to reach the full Internet.</doc>
      </member>
      <member name="full" value="4" c:identifier="NM_CONNECTIVITY_FULL">
        <doc xml:space="preserve">The host is connected to a network, and
  appears to be able to reach the full Internet.</doc>
      </member>
    </enumeration>
    <constant name="DBUS_IFACE_SETTINGS"
              value="org.freedesktop.NetworkManager.Settings"
              c:type="NM_DBUS_IFACE_SETTINGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_IFACE_SETTINGS_CONNECTION"
              value="org.freedesktop.NetworkManager.Settings.Connection"
              c:type="NM_DBUS_IFACE_SETTINGS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_IFACE_SETTINGS_CONNECTION_SECRETS"
              value="org.freedesktop.NetworkManager.Settings.Connection.Secrets"
              c:type="NM_DBUS_IFACE_SETTINGS_CONNECTION_SECRETS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE"
              value="org.freedesktop.NetworkManager"
              c:type="NM_DBUS_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_VPN"
              value="org.freedesktop.NetworkManager.VPN.Manager"
              c:type="NM_DBUS_INTERFACE_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INTERFACE_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPN.Connection"
              c:type="NM_DBUS_INTERFACE_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_INVALID_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPNConnections.InvalidVPNConnection"
              c:type="NM_DBUS_INVALID_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_NO_ACTIVE_VPN_CONNECTION"
              value="org.freedesktop.NetworkManager.VPNConnections.NoActiveVPNConnection"
              c:type="NM_DBUS_NO_ACTIVE_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_NO_VPN_CONNECTIONS"
              value="org.freedesktop.NetworkManager.VPNConnections.NoVPNConnections"
              c:type="NM_DBUS_NO_VPN_CONNECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH"
              value="/org/freedesktop/NetworkManager"
              c:type="NM_DBUS_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_AGENT_MANAGER"
              value="/org/freedesktop/NetworkManager/AgentManager"
              c:type="NM_DBUS_PATH_AGENT_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SECRET_AGENT"
              value="/org/freedesktop/NetworkManager/SecretAgent"
              c:type="NM_DBUS_PATH_SECRET_AGENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SETTINGS"
              value="/org/freedesktop/NetworkManager/Settings"
              c:type="NM_DBUS_PATH_SETTINGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_SETTINGS_CONNECTION"
              value="/org/freedesktop/NetworkManager/Settings/Connection"
              c:type="NM_DBUS_PATH_SETTINGS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_VPN"
              value="/org/freedesktop/NetworkManager/VPN/Manager"
              c:type="NM_DBUS_PATH_VPN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_PATH_VPN_CONNECTION"
              value="/org/freedesktop/NetworkManager/VPN/Connection"
              c:type="NM_DBUS_PATH_VPN_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_SERVICE"
              value="org.freedesktop.NetworkManager"
              c:type="NM_DBUS_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ALREADY_STARTED"
              value="AlreadyStarted"
              c:type="NM_DBUS_VPN_ALREADY_STARTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ALREADY_STOPPED"
              value="AlreadyStopped"
              c:type="NM_DBUS_VPN_ALREADY_STOPPED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_BAD_ARGUMENTS"
              value="BadArguments"
              c:type="NM_DBUS_VPN_BAD_ARGUMENTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_ERROR_PREFIX"
              value="org.freedesktop.NetworkManager.VPN.Error"
              c:type="NM_DBUS_VPN_ERROR_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_INTERACTIVE_NOT_SUPPORTED"
              value="InteractiveNotSupported"
              c:type="NM_DBUS_VPN_INTERACTIVE_NOT_SUPPORTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_CONNECT_FAILED"
              value="ConnectFailed"
              c:type="NM_DBUS_VPN_SIGNAL_CONNECT_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_IP4_CONFIG"
              value="IP4Config"
              c:type="NM_DBUS_VPN_SIGNAL_IP4_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_IP_CONFIG_BAD"
              value="IPConfigBad"
              c:type="NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LAUNCH_FAILED"
              value="LaunchFailed"
              c:type="NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LOGIN_BANNER"
              value="LoginBanner"
              c:type="NM_DBUS_VPN_SIGNAL_LOGIN_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_LOGIN_FAILED"
              value="LoginFailed"
              c:type="NM_DBUS_VPN_SIGNAL_LOGIN_FAILED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_STATE_CHANGE"
              value="StateChange"
              c:type="NM_DBUS_VPN_SIGNAL_STATE_CHANGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_SIGNAL_VPN_CONFIG_BAD"
              value="VPNConfigBad"
              c:type="NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_STARTING_IN_PROGRESS"
              value="StartingInProgress"
              c:type="NM_DBUS_VPN_STARTING_IN_PROGRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_STOPPING_IN_PROGRESS"
              value="StoppingInProgress"
              c:type="NM_DBUS_VPN_STOPPING_IN_PROGRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="DBUS_VPN_WRONG_STATE"
              value="WrongState"
              c:type="NM_DBUS_VPN_WRONG_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <bitfield name="DeviceCapabilities" c:type="NMDeviceCapabilities">
      <doc xml:space="preserve">General device capability flags.</doc>
      <member name="none" value="0" c:identifier="NM_DEVICE_CAP_NONE">
        <doc xml:space="preserve">device has no special capabilities</doc>
      </member>
      <member name="nm_supported"
              value="1"
              c:identifier="NM_DEVICE_CAP_NM_SUPPORTED">
        <doc xml:space="preserve">NetworkManager supports this device</doc>
      </member>
      <member name="carrier_detect"
              value="2"
              c:identifier="NM_DEVICE_CAP_CARRIER_DETECT">
        <doc xml:space="preserve">this device can indicate carrier status</doc>
      </member>
      <member name="is_software"
              value="4"
              c:identifier="NM_DEVICE_CAP_IS_SOFTWARE">
        <doc xml:space="preserve">this device is a software device</doc>
      </member>
    </bitfield>
    <bitfield name="DeviceModemCapabilities"
              c:type="NMDeviceModemCapabilities">
      <doc xml:space="preserve">#NMDeviceModemCapabilities values indicate the generic radio access
technology families a modem device supports.  For more information on the
specific access technologies the device supports use the ModemManager D-Bus
API.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_NONE">
        <doc xml:space="preserve">modem has no usable capabilities</doc>
      </member>
      <member name="pots"
              value="1"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_POTS">
        <doc xml:space="preserve">modem uses the analog wired telephone
network and is not a wireless/cellular device</doc>
      </member>
      <member name="cdma_evdo"
              value="2"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO">
        <doc xml:space="preserve">modem supports at least one of CDMA
1xRTT, EVDO revision 0, EVDO revision A, or EVDO revision B</doc>
      </member>
      <member name="gsm_umts"
              value="4"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS">
        <doc xml:space="preserve">modem supports at least one of GSM,
GPRS, EDGE, UMTS, HSDPA, HSUPA, or HSPA+ packet switched data capability</doc>
      </member>
      <member name="lte"
              value="8"
              c:identifier="NM_DEVICE_MODEM_CAPABILITY_LTE">
        <doc xml:space="preserve">modem has LTE data capability</doc>
      </member>
    </bitfield>
    <enumeration name="DeviceState" c:type="NMDeviceState">
      <member name="unknown" value="0" c:identifier="NM_DEVICE_STATE_UNKNOWN">
        <doc xml:space="preserve">the device's state is unknown</doc>
      </member>
      <member name="unmanaged"
              value="10"
              c:identifier="NM_DEVICE_STATE_UNMANAGED">
        <doc xml:space="preserve">the device is recognized, but not managed by
  NetworkManager</doc>
      </member>
      <member name="unavailable"
              value="20"
              c:identifier="NM_DEVICE_STATE_UNAVAILABLE">
        <doc xml:space="preserve">the device is managed by NetworkManager, but
  is not available for use.  Reasons may include the wireless switched off,
  missing firmware, no ethernet carrier, missing supplicant or modem manager,
  etc.</doc>
      </member>
      <member name="disconnected"
              value="30"
              c:identifier="NM_DEVICE_STATE_DISCONNECTED">
        <doc xml:space="preserve">the device can be activated, but is currently
  idle and not connected to a network.</doc>
      </member>
      <member name="prepare" value="40" c:identifier="NM_DEVICE_STATE_PREPARE">
        <doc xml:space="preserve">the device is preparing the connection to the
  network.  This may include operations like changing the MAC address,
  setting physical link properties, and anything else required to connect
  to the requested network.</doc>
      </member>
      <member name="config" value="50" c:identifier="NM_DEVICE_STATE_CONFIG">
        <doc xml:space="preserve">the device is connecting to the requested network.
  This may include operations like associating with the WiFi AP, dialing
  the modem, connecting to the remote Bluetooth device, etc.</doc>
      </member>
      <member name="need_auth"
              value="60"
              c:identifier="NM_DEVICE_STATE_NEED_AUTH">
        <doc xml:space="preserve">the device requires more information to continue
  connecting to the requested network.  This includes secrets like WiFi
  passphrases, login passwords, PIN codes, etc.</doc>
      </member>
      <member name="ip_config"
              value="70"
              c:identifier="NM_DEVICE_STATE_IP_CONFIG">
        <doc xml:space="preserve">the device is requesting IPv4 and/or IPv6
  addresses and routing information from the network.</doc>
      </member>
      <member name="ip_check"
              value="80"
              c:identifier="NM_DEVICE_STATE_IP_CHECK">
        <doc xml:space="preserve">the device is checking whether further action is
  required for the requested network connection.  This may include checking
  whether only local network access is available, whether a captive portal
  is blocking access to the Internet, etc.</doc>
      </member>
      <member name="secondaries"
              value="90"
              c:identifier="NM_DEVICE_STATE_SECONDARIES">
        <doc xml:space="preserve">the device is waiting for a secondary
  connection (like a VPN) which must activated before the device can be
  activated</doc>
      </member>
      <member name="activated"
              value="100"
              c:identifier="NM_DEVICE_STATE_ACTIVATED">
        <doc xml:space="preserve">the device has a network connection, either local
  or global.</doc>
      </member>
      <member name="deactivating"
              value="110"
              c:identifier="NM_DEVICE_STATE_DEACTIVATING">
        <doc xml:space="preserve">a disconnection from the current network
  connection was requested, and the device is cleaning up resources used for
  that connection.  The network connection may still be valid.</doc>
      </member>
      <member name="failed" value="120" c:identifier="NM_DEVICE_STATE_FAILED">
        <doc xml:space="preserve">the device failed to connect to the requested
  network and is cleaning up the connection request</doc>
      </member>
    </enumeration>
    <enumeration name="DeviceStateReason" c:type="NMDeviceStateReason">
      <doc xml:space="preserve">Device state change reason codes</doc>
      <member name="none" value="0" c:identifier="NM_DEVICE_STATE_REASON_NONE">
        <doc xml:space="preserve">No reason given</doc>
      </member>
      <member name="unknown"
              value="1"
              c:identifier="NM_DEVICE_STATE_REASON_UNKNOWN">
        <doc xml:space="preserve">Unknown error</doc>
      </member>
      <member name="now_managed"
              value="2"
              c:identifier="NM_DEVICE_STATE_REASON_NOW_MANAGED">
        <doc xml:space="preserve">Device is now managed</doc>
      </member>
      <member name="now_unmanaged"
              value="3"
              c:identifier="NM_DEVICE_STATE_REASON_NOW_UNMANAGED">
        <doc xml:space="preserve">Device is now unmanaged</doc>
      </member>
      <member name="config_failed"
              value="4"
              c:identifier="NM_DEVICE_STATE_REASON_CONFIG_FAILED">
        <doc xml:space="preserve">The device could not be readied for configuration</doc>
      </member>
      <member name="ip_config_unavailable"
              value="5"
              c:identifier="NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE">
        <doc xml:space="preserve">IP configuration could not be reserved (no available address, timeout, etc)</doc>
      </member>
      <member name="ip_config_expired"
              value="6"
              c:identifier="NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED">
        <doc xml:space="preserve">The IP config is no longer valid</doc>
      </member>
      <member name="no_secrets"
              value="7"
              c:identifier="NM_DEVICE_STATE_REASON_NO_SECRETS">
        <doc xml:space="preserve">Secrets were required, but not provided</doc>
      </member>
      <member name="supplicant_disconnect"
              value="8"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT">
        <doc xml:space="preserve">802.1x supplicant disconnected</doc>
      </member>
      <member name="supplicant_config_failed"
              value="9"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED">
        <doc xml:space="preserve">802.1x supplicant configuration failed</doc>
      </member>
      <member name="supplicant_failed"
              value="10"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED">
        <doc xml:space="preserve">802.1x supplicant failed</doc>
      </member>
      <member name="supplicant_timeout"
              value="11"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT">
        <doc xml:space="preserve">802.1x supplicant took too long to authenticate</doc>
      </member>
      <member name="ppp_start_failed"
              value="12"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_START_FAILED">
        <doc xml:space="preserve">PPP service failed to start</doc>
      </member>
      <member name="ppp_disconnect"
              value="13"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_DISCONNECT">
        <doc xml:space="preserve">PPP service disconnected</doc>
      </member>
      <member name="ppp_failed"
              value="14"
              c:identifier="NM_DEVICE_STATE_REASON_PPP_FAILED">
        <doc xml:space="preserve">PPP failed</doc>
      </member>
      <member name="dhcp_start_failed"
              value="15"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_START_FAILED">
        <doc xml:space="preserve">DHCP client failed to start</doc>
      </member>
      <member name="dhcp_error"
              value="16"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_ERROR">
        <doc xml:space="preserve">DHCP client error</doc>
      </member>
      <member name="dhcp_failed"
              value="17"
              c:identifier="NM_DEVICE_STATE_REASON_DHCP_FAILED">
        <doc xml:space="preserve">DHCP client failed</doc>
      </member>
      <member name="shared_start_failed"
              value="18"
              c:identifier="NM_DEVICE_STATE_REASON_SHARED_START_FAILED">
        <doc xml:space="preserve">Shared connection service failed to start</doc>
      </member>
      <member name="shared_failed"
              value="19"
              c:identifier="NM_DEVICE_STATE_REASON_SHARED_FAILED">
        <doc xml:space="preserve">Shared connection service failed</doc>
      </member>
      <member name="autoip_start_failed"
              value="20"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED">
        <doc xml:space="preserve">AutoIP service failed to start</doc>
      </member>
      <member name="autoip_error"
              value="21"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_ERROR">
        <doc xml:space="preserve">AutoIP service error</doc>
      </member>
      <member name="autoip_failed"
              value="22"
              c:identifier="NM_DEVICE_STATE_REASON_AUTOIP_FAILED">
        <doc xml:space="preserve">AutoIP service failed</doc>
      </member>
      <member name="modem_busy"
              value="23"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_BUSY">
        <doc xml:space="preserve">The line is busy</doc>
      </member>
      <member name="modem_no_dial_tone"
              value="24"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE">
        <doc xml:space="preserve">No dial tone</doc>
      </member>
      <member name="modem_no_carrier"
              value="25"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER">
        <doc xml:space="preserve">No carrier could be established</doc>
      </member>
      <member name="modem_dial_timeout"
              value="26"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT">
        <doc xml:space="preserve">The dialing request timed out</doc>
      </member>
      <member name="modem_dial_failed"
              value="27"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED">
        <doc xml:space="preserve">The dialing attempt failed</doc>
      </member>
      <member name="modem_init_failed"
              value="28"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED">
        <doc xml:space="preserve">Modem initialization failed</doc>
      </member>
      <member name="gsm_apn_failed"
              value="29"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_APN_FAILED">
        <doc xml:space="preserve">Failed to select the specified APN</doc>
      </member>
      <member name="gsm_registration_not_searching"
              value="30"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING">
        <doc xml:space="preserve">Not searching for networks</doc>
      </member>
      <member name="gsm_registration_denied"
              value="31"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED">
        <doc xml:space="preserve">Network registration denied</doc>
      </member>
      <member name="gsm_registration_timeout"
              value="32"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT">
        <doc xml:space="preserve">Network registration timed out</doc>
      </member>
      <member name="gsm_registration_failed"
              value="33"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED">
        <doc xml:space="preserve">Failed to register with the requested network</doc>
      </member>
      <member name="gsm_pin_check_failed"
              value="34"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED">
        <doc xml:space="preserve">PIN check failed</doc>
      </member>
      <member name="firmware_missing"
              value="35"
              c:identifier="NM_DEVICE_STATE_REASON_FIRMWARE_MISSING">
        <doc xml:space="preserve">Necessary firmware for the device may be missing</doc>
      </member>
      <member name="removed"
              value="36"
              c:identifier="NM_DEVICE_STATE_REASON_REMOVED">
        <doc xml:space="preserve">The device was removed</doc>
      </member>
      <member name="sleeping"
              value="37"
              c:identifier="NM_DEVICE_STATE_REASON_SLEEPING">
        <doc xml:space="preserve">NetworkManager went to sleep</doc>
      </member>
      <member name="connection_removed"
              value="38"
              c:identifier="NM_DEVICE_STATE_REASON_CONNECTION_REMOVED">
        <doc xml:space="preserve">The device's active connection disappeared</doc>
      </member>
      <member name="user_requested"
              value="39"
              c:identifier="NM_DEVICE_STATE_REASON_USER_REQUESTED">
        <doc xml:space="preserve">Device disconnected by user or client</doc>
      </member>
      <member name="carrier"
              value="40"
              c:identifier="NM_DEVICE_STATE_REASON_CARRIER">
        <doc xml:space="preserve">Carrier/link changed</doc>
      </member>
      <member name="connection_assumed"
              value="41"
              c:identifier="NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED">
        <doc xml:space="preserve">The device's existing connection was assumed</doc>
      </member>
      <member name="supplicant_available"
              value="42"
              c:identifier="NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE">
        <doc xml:space="preserve">The supplicant is now available</doc>
      </member>
      <member name="modem_not_found"
              value="43"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND">
        <doc xml:space="preserve">The modem could not be found</doc>
      </member>
      <member name="bt_failed"
              value="44"
              c:identifier="NM_DEVICE_STATE_REASON_BT_FAILED">
        <doc xml:space="preserve">The Bluetooth connection failed or timed out</doc>
      </member>
      <member name="gsm_sim_not_inserted"
              value="45"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED">
        <doc xml:space="preserve">GSM Modem's SIM Card not inserted</doc>
      </member>
      <member name="gsm_sim_pin_required"
              value="46"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED">
        <doc xml:space="preserve">GSM Modem's SIM Pin required</doc>
      </member>
      <member name="gsm_sim_puk_required"
              value="47"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED">
        <doc xml:space="preserve">GSM Modem's SIM Puk required</doc>
      </member>
      <member name="gsm_sim_wrong"
              value="48"
              c:identifier="NM_DEVICE_STATE_REASON_GSM_SIM_WRONG">
        <doc xml:space="preserve">GSM Modem's SIM wrong</doc>
      </member>
      <member name="infiniband_mode"
              value="49"
              c:identifier="NM_DEVICE_STATE_REASON_INFINIBAND_MODE">
        <doc xml:space="preserve">InfiniBand device does not support connected mode</doc>
      </member>
      <member name="dependency_failed"
              value="50"
              c:identifier="NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED">
        <doc xml:space="preserve">A dependency of the connection failed</doc>
      </member>
      <member name="br2684_failed"
              value="51"
              c:identifier="NM_DEVICE_STATE_REASON_BR2684_FAILED">
        <doc xml:space="preserve">Problem with the RFC 2684 Ethernet over ADSL bridge</doc>
      </member>
      <member name="modem_manager_unavailable"
              value="52"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE">
        <doc xml:space="preserve">ModemManager not running</doc>
      </member>
      <member name="ssid_not_found"
              value="53"
              c:identifier="NM_DEVICE_STATE_REASON_SSID_NOT_FOUND">
        <doc xml:space="preserve">The WiFi network could not be found</doc>
      </member>
      <member name="secondary_connection_failed"
              value="54"
              c:identifier="NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED">
        <doc xml:space="preserve">A secondary connection of the base connection failed</doc>
      </member>
      <member name="dcb_fcoe_failed"
              value="55"
              c:identifier="NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED">
        <doc xml:space="preserve">DCB or FCoE setup failed</doc>
      </member>
      <member name="teamd_control_failed"
              value="56"
              c:identifier="NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED">
        <doc xml:space="preserve">teamd control failed</doc>
      </member>
      <member name="modem_failed"
              value="57"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_FAILED">
        <doc xml:space="preserve">Modem failed or no longer available</doc>
      </member>
      <member name="modem_available"
              value="58"
              c:identifier="NM_DEVICE_STATE_REASON_MODEM_AVAILABLE">
        <doc xml:space="preserve">Modem now ready and available</doc>
      </member>
      <member name="sim_pin_incorrect"
              value="59"
              c:identifier="NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT">
        <doc xml:space="preserve">SIM PIN was incorrect</doc>
      </member>
      <member name="new_activation"
              value="60"
              c:identifier="NM_DEVICE_STATE_REASON_NEW_ACTIVATION">
        <doc xml:space="preserve">New connection activation was enqueued</doc>
      </member>
      <member name="parent_changed"
              value="61"
              c:identifier="NM_DEVICE_STATE_REASON_PARENT_CHANGED">
        <doc xml:space="preserve">the device's parent changed</doc>
      </member>
      <member name="parent_managed_changed"
              value="62"
              c:identifier="NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED">
        <doc xml:space="preserve">the device parent's management changed</doc>
      </member>
      <member name="last"
              value="65535"
              c:identifier="NM_DEVICE_STATE_REASON_LAST">
      </member>
    </enumeration>
    <enumeration name="DeviceType" c:type="NMDeviceType">
      <doc xml:space="preserve">#NMDeviceType values indicate the type of hardware represented by
an #NMDevice.</doc>
      <member name="unknown" value="0" c:identifier="NM_DEVICE_TYPE_UNKNOWN">
        <doc xml:space="preserve">unknown device</doc>
      </member>
      <member name="ethernet" value="1" c:identifier="NM_DEVICE_TYPE_ETHERNET">
        <doc xml:space="preserve">a wired ethernet device</doc>
      </member>
      <member name="wifi" value="2" c:identifier="NM_DEVICE_TYPE_WIFI">
        <doc xml:space="preserve">an 802.11 WiFi device</doc>
      </member>
      <member name="unused1" value="3" c:identifier="NM_DEVICE_TYPE_UNUSED1">
        <doc xml:space="preserve">not used</doc>
      </member>
      <member name="unused2" value="4" c:identifier="NM_DEVICE_TYPE_UNUSED2">
        <doc xml:space="preserve">not used</doc>
      </member>
      <member name="bt" value="5" c:identifier="NM_DEVICE_TYPE_BT">
        <doc xml:space="preserve">a Bluetooth device supporting PAN or DUN access protocols</doc>
      </member>
      <member name="olpc_mesh"
              value="6"
              c:identifier="NM_DEVICE_TYPE_OLPC_MESH">
        <doc xml:space="preserve">an OLPC XO mesh networking device</doc>
      </member>
      <member name="wimax" value="7" c:identifier="NM_DEVICE_TYPE_WIMAX">
        <doc xml:space="preserve">an 802.16e Mobile WiMAX broadband device</doc>
      </member>
      <member name="modem" value="8" c:identifier="NM_DEVICE_TYPE_MODEM">
        <doc xml:space="preserve">a modem supporting analog telephone, CDMA/EVDO,
GSM/UMTS, or LTE network access protocols</doc>
      </member>
      <member name="infiniband"
              value="9"
              c:identifier="NM_DEVICE_TYPE_INFINIBAND">
        <doc xml:space="preserve">an IP-over-InfiniBand device</doc>
      </member>
      <member name="bond" value="10" c:identifier="NM_DEVICE_TYPE_BOND">
        <doc xml:space="preserve">a bond master interface</doc>
      </member>
      <member name="vlan" value="11" c:identifier="NM_DEVICE_TYPE_VLAN">
        <doc xml:space="preserve">an 802.1Q VLAN interface</doc>
      </member>
      <member name="adsl" value="12" c:identifier="NM_DEVICE_TYPE_ADSL">
        <doc xml:space="preserve">ADSL modem</doc>
      </member>
      <member name="bridge" value="13" c:identifier="NM_DEVICE_TYPE_BRIDGE">
        <doc xml:space="preserve">a bridge master interface</doc>
      </member>
      <member name="generic" value="14" c:identifier="NM_DEVICE_TYPE_GENERIC">
        <doc xml:space="preserve">generic support for unrecognized device types</doc>
      </member>
      <member name="team" value="15" c:identifier="NM_DEVICE_TYPE_TEAM">
        <doc xml:space="preserve">a team master interface</doc>
      </member>
      <member name="tun" value="16" c:identifier="NM_DEVICE_TYPE_TUN">
        <doc xml:space="preserve">a TUN/TAP interface</doc>
      </member>
      <member name="ip_tunnel"
              value="17"
              c:identifier="NM_DEVICE_TYPE_IP_TUNNEL">
        <doc xml:space="preserve">an IP tunnel interface</doc>
      </member>
      <member name="macvlan" value="18" c:identifier="NM_DEVICE_TYPE_MACVLAN">
        <doc xml:space="preserve">a MACVLAN interface</doc>
      </member>
      <member name="vxlan" value="19" c:identifier="NM_DEVICE_TYPE_VXLAN">
        <doc xml:space="preserve">a VXLAN interface</doc>
      </member>
      <member name="veth" value="20" c:identifier="NM_DEVICE_TYPE_VETH">
        <doc xml:space="preserve">a VETH interface</doc>
      </member>
    </enumeration>
    <bitfield name="DeviceWifiCapabilities" c:type="NMDeviceWifiCapabilities">
      <doc xml:space="preserve">802.11 specific device encryption and authentication capabilities.</doc>
      <member name="none" value="0" c:identifier="NM_WIFI_DEVICE_CAP_NONE">
        <doc xml:space="preserve">device has no encryption/authentication capabilities</doc>
      </member>
      <member name="cipher_wep40"
              value="1"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_WEP40">
        <doc xml:space="preserve">device supports 40/64-bit WEP encryption</doc>
      </member>
      <member name="cipher_wep104"
              value="2"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_WEP104">
        <doc xml:space="preserve">device supports 104/128-bit WEP encryption</doc>
      </member>
      <member name="cipher_tkip"
              value="4"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_TKIP">
        <doc xml:space="preserve">device supports TKIP encryption</doc>
      </member>
      <member name="cipher_ccmp"
              value="8"
              c:identifier="NM_WIFI_DEVICE_CAP_CIPHER_CCMP">
        <doc xml:space="preserve">device supports AES/CCMP encryption</doc>
      </member>
      <member name="wpa" value="16" c:identifier="NM_WIFI_DEVICE_CAP_WPA">
        <doc xml:space="preserve">device supports WPA1 authentication</doc>
      </member>
      <member name="rsn" value="32" c:identifier="NM_WIFI_DEVICE_CAP_RSN">
        <doc xml:space="preserve">device supports WPA2/RSN authentication</doc>
      </member>
      <member name="ap" value="64" c:identifier="NM_WIFI_DEVICE_CAP_AP">
        <doc xml:space="preserve">device supports Access Point mode</doc>
      </member>
      <member name="adhoc" value="128" c:identifier="NM_WIFI_DEVICE_CAP_ADHOC">
        <doc xml:space="preserve">device supports Ad-Hoc mode</doc>
      </member>
      <member name="freq_valid"
              value="256"
              c:identifier="NM_WIFI_DEVICE_CAP_FREQ_VALID">
        <doc xml:space="preserve">device reports frequency capabilities</doc>
      </member>
      <member name="freq_2ghz"
              value="512"
              c:identifier="NM_WIFI_DEVICE_CAP_FREQ_2GHZ">
        <doc xml:space="preserve">device supports 2.4GHz frequencies</doc>
      </member>
      <member name="freq_5ghz"
              value="1024"
              c:identifier="NM_WIFI_DEVICE_CAP_FREQ_5GHZ">
        <doc xml:space="preserve">device supports 5GHz frequencies</doc>
      </member>
    </bitfield>
    <record name="IP4Address"
            c:type="NMIP4Address"
            glib:type-name="NMIP4Address"
            glib:get-type="nm_ip4_address_get_type"
            c:symbol-prefix="ip4_address">
      <constructor name="new" c:identifier="nm_ip4_address_new">
        <doc xml:space="preserve">Creates and returns a new #NMIP4Address object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMIP4Address object</doc>
          <type name="IP4Address" c:type="NMIP4Address*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip4_address_compare">
        <doc xml:space="preserve">Determines if two #NMIP4Address objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address to compare @address to.</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip4_address_dup">
        <doc xml:space="preserve">Copies a given #NMIP4Address object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of the given #NMIP4Address copy</doc>
          <type name="IP4Address" c:type="NMIP4Address*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address object to copy</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address" c:identifier="nm_ip4_address_get_address">
        <doc xml:space="preserve">Gets the IPv4 address property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gateway" c:identifier="nm_ip4_address_get_gateway">
        <doc xml:space="preserve">Gets the IPv4 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 gateway address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prefix" c:identifier="nm_ip4_address_get_prefix">
        <doc xml:space="preserve">Gets the IPv4 address prefix (ie "24" or "30" etc) property of this address
object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 address prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="nm_ip4_address_ref">
        <doc xml:space="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_address" c:identifier="nm_ip4_address_set_address">
        <doc xml:space="preserve">Sets the IPv4 address property of this object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">the IPv4 address in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gateway" c:identifier="nm_ip4_address_set_gateway">
        <doc xml:space="preserve">Sets the IPv4 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
          <parameter name="gateway" transfer-ownership="none">
            <doc xml:space="preserve">the IPv4 default gateway in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip4_address_set_prefix">
        <doc xml:space="preserve">Sets the IPv4 address prefix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the address prefix, a number between 1 and 32 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip4_address_unref">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Address</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="IP4Route"
            c:type="NMIP4Route"
            glib:type-name="NMIP4Route"
            glib:get-type="nm_ip4_route_get_type"
            c:symbol-prefix="ip4_route">
      <constructor name="new" c:identifier="nm_ip4_route_new">
        <doc xml:space="preserve">Creates and returns a new #NMIP4Route object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMIP4Route object</doc>
          <type name="IP4Route" c:type="NMIP4Route*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip4_route_compare">
        <doc xml:space="preserve">Determines if two #NMIP4Route objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route to compare @route to.</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip4_route_dup">
        <doc xml:space="preserve">Copies a given #NMIP4Route object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of the given #NMIP4Route copy</doc>
          <type name="IP4Route" c:type="NMIP4Route*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route object to copy</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dest" c:identifier="nm_ip4_route_get_dest">
        <doc xml:space="preserve">Gets the IPv4 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_metric" c:identifier="nm_ip4_route_get_metric">
        <doc xml:space="preserve">Gets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the route metric</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next_hop" c:identifier="nm_ip4_route_get_next_hop">
        <doc xml:space="preserve">Gets the IPv4 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 address in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prefix" c:identifier="nm_ip4_route_get_prefix">
        <doc xml:space="preserve">Gets the IPv4 prefix (ie "24" or "30" etc) of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="nm_ip4_route_ref">
        <doc xml:space="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_dest" c:identifier="nm_ip4_route_set_dest">
        <doc xml:space="preserve">Sets the IPv4 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">the destination address in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_metric" c:identifier="nm_ip4_route_set_metric">
        <doc xml:space="preserve">Sets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
          <parameter name="metric" transfer-ownership="none">
            <doc xml:space="preserve">the route metric</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next_hop" c:identifier="nm_ip4_route_set_next_hop">
        <doc xml:space="preserve">Sets the IPv4 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
          <parameter name="next_hop" transfer-ownership="none">
            <doc xml:space="preserve">the IPv4 address of the next hop in network byte order</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip4_route_set_prefix">
        <doc xml:space="preserve">Sets the IPv4 prefix of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the prefix, a number between 1 and 32 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip4_route_unref">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP4Route</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="IP6Address"
            c:type="NMIP6Address"
            glib:type-name="NMIP6Address"
            glib:get-type="nm_ip6_address_get_type"
            c:symbol-prefix="ip6_address">
      <constructor name="new" c:identifier="nm_ip6_address_new">
        <doc xml:space="preserve">Creates and returns a new #NMIP6Address object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMIP6Address object</doc>
          <type name="IP6Address" c:type="NMIP6Address*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip6_address_compare">
        <doc xml:space="preserve">Determines if two #NMIP6Address objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address to compare @address to.</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip6_address_dup">
        <doc xml:space="preserve">Copies a given #NMIP6Address object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of the given #NMIP6Address copy</doc>
          <type name="IP6Address" c:type="NMIP6Address*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address object to copy</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address" c:identifier="nm_ip6_address_get_address">
        <doc xml:space="preserve">Gets the IPv6 address property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         the IPv6 address</doc>
          <array zero-terminated="0" c:type="gpointer*" fixed-size="16">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gateway" c:identifier="nm_ip6_address_get_gateway">
        <doc xml:space="preserve">Gets the IPv6 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         the IPv6 gateway address</doc>
          <array zero-terminated="0" c:type="gpointer*" fixed-size="16">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prefix" c:identifier="nm_ip6_address_get_prefix">
        <doc xml:space="preserve">Gets the IPv6 address prefix property of this address object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv6 address prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="nm_ip6_address_ref">
        <doc xml:space="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_address" c:identifier="nm_ip6_address_set_address">
        <doc xml:space="preserve">Sets the IPv6 address property of this object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
          <parameter name="addr"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IPv6 address</doc>
            <type name="gpointer" c:type="const in6_addr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gateway" c:identifier="nm_ip6_address_set_gateway">
        <doc xml:space="preserve">Sets the IPv6 default gateway property of this address object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
          <parameter name="gateway"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IPv6 default gateway</doc>
            <type name="gpointer" c:type="const in6_addr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip6_address_set_prefix">
        <doc xml:space="preserve">Sets the IPv6 address prefix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the address prefix, a number between 0 and 128 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip6_address_unref">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Address</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="IP6Route"
            c:type="NMIP6Route"
            glib:type-name="NMIP6Route"
            glib:get-type="nm_ip6_route_get_type"
            c:symbol-prefix="ip6_route">
      <constructor name="new" c:identifier="nm_ip6_route_new">
        <doc xml:space="preserve">Creates and returns a new #NMIP6Route object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMIP6Route object</doc>
          <type name="IP6Route" c:type="NMIP6Route*"/>
        </return-value>
      </constructor>
      <method name="compare" c:identifier="nm_ip6_route_compare">
        <doc xml:space="preserve">Determines if two #NMIP6Route objects contain the same values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the objects contain the same values, %FALSE if they do not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route to compare @route to.</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nm_ip6_route_dup">
        <doc xml:space="preserve">Copies a given #NMIP6Route object and returns the copy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the copy of the given #NMIP6Route copy</doc>
          <type name="IP6Route" c:type="NMIP6Route*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route object to copy</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dest" c:identifier="nm_ip6_route_get_dest">
        <doc xml:space="preserve">Gets the IPv6 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         the IPv6 address of destination</doc>
          <array zero-terminated="0" c:type="gpointer*" fixed-size="16">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_metric" c:identifier="nm_ip6_route_get_metric">
        <doc xml:space="preserve">Gets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the route metric</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next_hop" c:identifier="nm_ip6_route_get_next_hop">
        <doc xml:space="preserve">Gets the IPv6 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
         the IPv6 address of next hop</doc>
          <array zero-terminated="0" c:type="gpointer*" fixed-size="16">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prefix" c:identifier="nm_ip6_route_get_prefix">
        <doc xml:space="preserve">Gets the IPv6 prefix (ie "32" or "64" etc) of this route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv6 prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="nm_ip6_route_ref">
        <doc xml:space="preserve">Increases the reference count of the object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_dest" c:identifier="nm_ip6_route_set_dest">
        <doc xml:space="preserve">Sets the IPv6 destination address property of this route object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the destination address</doc>
            <type name="gpointer" c:type="const in6_addr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_metric" c:identifier="nm_ip6_route_set_metric">
        <doc xml:space="preserve">Sets the route metric property of this route object; lower values indicate
"better" or more preferred routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
          <parameter name="metric" transfer-ownership="none">
            <doc xml:space="preserve">the route metric</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_next_hop" c:identifier="nm_ip6_route_set_next_hop">
        <doc xml:space="preserve">Sets the IPv6 address of the next hop of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
          <parameter name="next_hop"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IPv6 address of the next hop</doc>
            <type name="gpointer" c:type="const in6_addr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefix" c:identifier="nm_ip6_route_set_prefix">
        <doc xml:space="preserve">Sets the IPv6 prefix of this route.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve">the prefix, a number between 1 and 128 inclusive</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="nm_ip6_route_unref">
        <doc xml:space="preserve">Decreases the reference count of the object.  If the reference count
reaches zero, the object will be destroyed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the #NMIP6Route</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <constant name="MAJOR_VERSION" value="1" c:type="NM_MAJOR_VERSION">
      <doc xml:space="preserve">Evaluates to the major version number of NetworkManager which this source
is compiled against.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="0" c:type="NM_MICRO_VERSION">
      <doc xml:space="preserve">Evaluates to the micro version number of NetworkManager which this source
compiled against.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="11" c:type="NM_MINOR_VERSION">
      <doc xml:space="preserve">Evaluates to the minor version number of NetworkManager which this source
is compiled against.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_802_1X_ALTSUBJECT_MATCHES"
              value="altsubject-matches"
              c:type="NM_SETTING_802_1X_ALTSUBJECT_MATCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_ANONYMOUS_IDENTITY"
              value="anonymous-identity"
              c:type="NM_SETTING_802_1X_ANONYMOUS_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_CERT"
              value="ca-cert"
              c:type="NM_SETTING_802_1X_CA_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CA_PATH"
              value="ca-path"
              c:type="NM_SETTING_802_1X_CA_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_CLIENT_CERT"
              value="client-cert"
              c:type="NM_SETTING_802_1X_CLIENT_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_EAP"
              value="eap"
              c:type="NM_SETTING_802_1X_EAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_IDENTITY"
              value="identity"
              c:type="NM_SETTING_802_1X_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PAC_FILE"
              value="pac-file"
              c:type="NM_SETTING_802_1X_PAC_FILE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD"
              value="password"
              c:type="NM_SETTING_802_1X_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_802_1X_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_RAW"
              value="password-raw"
              c:type="NM_SETTING_802_1X_PASSWORD_RAW">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PASSWORD_RAW_FLAGS"
              value="password-raw-flags"
              c:type="NM_SETTING_802_1X_PASSWORD_RAW_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_FAST_PROVISIONING"
              value="phase1-fast-provisioning"
              c:type="NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_PEAPLABEL"
              value="phase1-peaplabel"
              c:type="NM_SETTING_802_1X_PHASE1_PEAPLABEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE1_PEAPVER"
              value="phase1-peapver"
              c:type="NM_SETTING_802_1X_PHASE1_PEAPVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES"
              value="phase2-altsubject-matches"
              c:type="NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_AUTH"
              value="phase2-auth"
              c:type="NM_SETTING_802_1X_PHASE2_AUTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_AUTHEAP"
              value="phase2-autheap"
              c:type="NM_SETTING_802_1X_PHASE2_AUTHEAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_CERT"
              value="phase2-ca-cert"
              c:type="NM_SETTING_802_1X_PHASE2_CA_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CA_PATH"
              value="phase2-ca-path"
              c:type="NM_SETTING_802_1X_PHASE2_CA_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_CLIENT_CERT"
              value="phase2-client-cert"
              c:type="NM_SETTING_802_1X_PHASE2_CLIENT_CERT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY"
              value="phase2-private-key"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD"
              value="phase2-private-key-password"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS"
              value="phase2-private-key-password-flags"
              c:type="NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PHASE2_SUBJECT_MATCH"
              value="phase2-subject-match"
              c:type="NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PIN"
              value="pin"
              c:type="NM_SETTING_802_1X_PIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PIN_FLAGS"
              value="pin-flags"
              c:type="NM_SETTING_802_1X_PIN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY"
              value="private-key"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY_PASSWORD"
              value="private-key-password"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS"
              value="private-key-password-flags"
              c:type="NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SETTING_NAME"
              value="802-1x"
              c:type="NM_SETTING_802_1X_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SUBJECT_MATCH"
              value="subject-match"
              c:type="NM_SETTING_802_1X_SUBJECT_MATCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_802_1X_SYSTEM_CA_CERTS"
              value="system-ca-certs"
              c:type="NM_SETTING_802_1X_SYSTEM_CA_CERTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_ENCAPSULATION"
              value="encapsulation"
              c:type="NM_SETTING_ADSL_ENCAPSULATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_ENCAPSULATION_LLC"
              value="llc"
              c:type="NM_SETTING_ADSL_ENCAPSULATION_LLC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_ENCAPSULATION_VCMUX"
              value="vcmux"
              c:type="NM_SETTING_ADSL_ENCAPSULATION_VCMUX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PASSWORD"
              value="password"
              c:type="NM_SETTING_ADSL_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_ADSL_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL"
              value="protocol"
              c:type="NM_SETTING_ADSL_PROTOCOL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL_IPOATM"
              value="ipoatm"
              c:type="NM_SETTING_ADSL_PROTOCOL_IPOATM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL_PPPOA"
              value="pppoa"
              c:type="NM_SETTING_ADSL_PROTOCOL_PPPOA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_PROTOCOL_PPPOE"
              value="pppoe"
              c:type="NM_SETTING_ADSL_PROTOCOL_PPPOE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_SETTING_NAME"
              value="adsl"
              c:type="NM_SETTING_ADSL_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_USERNAME"
              value="username"
              c:type="NM_SETTING_ADSL_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_VCI" value="vci" c:type="NM_SETTING_ADSL_VCI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_ADSL_VPI" value="vpi" c:type="NM_SETTING_ADSL_VPI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_BDADDR"
              value="bdaddr"
              c:type="NM_SETTING_BLUETOOTH_BDADDR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_SETTING_NAME"
              value="bluetooth"
              c:type="NM_SETTING_BLUETOOTH_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE"
              value="type"
              c:type="NM_SETTING_BLUETOOTH_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE_DUN"
              value="dun"
              c:type="NM_SETTING_BLUETOOTH_TYPE_DUN">
      <doc xml:space="preserve">Connection type describing a connection to devices that support the Bluetooth
DUN profile.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BLUETOOTH_TYPE_PANU"
              value="panu"
              c:type="NM_SETTING_BLUETOOTH_TYPE_PANU">
      <doc xml:space="preserve">Connection type describing a connection to devices that support the Bluetooth
NAP (Network Access Point) protocol, which accepts connections via PANU.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_BOND_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTIONS"
              value="options"
              c:type="NM_SETTING_BOND_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_AD_SELECT"
              value="ad_select"
              c:type="NM_SETTING_BOND_OPTION_AD_SELECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_INTERVAL"
              value="arp_interval"
              c:type="NM_SETTING_BOND_OPTION_ARP_INTERVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_IP_TARGET"
              value="arp_ip_target"
              c:type="NM_SETTING_BOND_OPTION_ARP_IP_TARGET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_ARP_VALIDATE"
              value="arp_validate"
              c:type="NM_SETTING_BOND_OPTION_ARP_VALIDATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_DOWNDELAY"
              value="downdelay"
              c:type="NM_SETTING_BOND_OPTION_DOWNDELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_FAIL_OVER_MAC"
              value="fail_over_mac"
              c:type="NM_SETTING_BOND_OPTION_FAIL_OVER_MAC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_LACP_RATE"
              value="lacp_rate"
              c:type="NM_SETTING_BOND_OPTION_LACP_RATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_MIIMON"
              value="miimon"
              c:type="NM_SETTING_BOND_OPTION_MIIMON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_MODE"
              value="mode"
              c:type="NM_SETTING_BOND_OPTION_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_PRIMARY"
              value="primary"
              c:type="NM_SETTING_BOND_OPTION_PRIMARY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_PRIMARY_RESELECT"
              value="primary_reselect"
              c:type="NM_SETTING_BOND_OPTION_PRIMARY_RESELECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_RESEND_IGMP"
              value="resend_igmp"
              c:type="NM_SETTING_BOND_OPTION_RESEND_IGMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_UPDELAY"
              value="updelay"
              c:type="NM_SETTING_BOND_OPTION_UPDELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_USE_CARRIER"
              value="use_carrier"
              c:type="NM_SETTING_BOND_OPTION_USE_CARRIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_OPTION_XMIT_HASH_POLICY"
              value="xmit_hash_policy"
              c:type="NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BOND_SETTING_NAME"
              value="bond"
              c:type="NM_SETTING_BOND_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_AGEING_TIME"
              value="ageing-time"
              c:type="NM_SETTING_BRIDGE_AGEING_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_FORWARD_DELAY"
              value="forward-delay"
              c:type="NM_SETTING_BRIDGE_FORWARD_DELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_HELLO_TIME"
              value="hello-time"
              c:type="NM_SETTING_BRIDGE_HELLO_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_BRIDGE_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_BRIDGE_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_MAX_AGE"
              value="max-age"
              c:type="NM_SETTING_BRIDGE_MAX_AGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_HAIRPIN_MODE"
              value="hairpin-mode"
              c:type="NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_PATH_COST"
              value="path-cost"
              c:type="NM_SETTING_BRIDGE_PORT_PATH_COST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_PRIORITY"
              value="priority"
              c:type="NM_SETTING_BRIDGE_PORT_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PORT_SETTING_NAME"
              value="bridge-port"
              c:type="NM_SETTING_BRIDGE_PORT_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_PRIORITY"
              value="priority"
              c:type="NM_SETTING_BRIDGE_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_SETTING_NAME"
              value="bridge"
              c:type="NM_SETTING_BRIDGE_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_BRIDGE_STP"
              value="stp"
              c:type="NM_SETTING_BRIDGE_STP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_NUMBER"
              value="number"
              c:type="NM_SETTING_CDMA_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_PASSWORD"
              value="password"
              c:type="NM_SETTING_CDMA_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_CDMA_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_SETTING_NAME"
              value="cdma"
              c:type="NM_SETTING_CDMA_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CDMA_USERNAME"
              value="username"
              c:type="NM_SETTING_CDMA_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_AUTOCONNECT"
              value="autoconnect"
              c:type="NM_SETTING_CONNECTION_AUTOCONNECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_GATEWAY_PING_TIMEOUT"
              value="gateway-ping-timeout"
              c:type="NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ID"
              value="id"
              c:type="NM_SETTING_CONNECTION_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_CONNECTION_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_MASTER"
              value="master"
              c:type="NM_SETTING_CONNECTION_MASTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_PERMISSIONS"
              value="permissions"
              c:type="NM_SETTING_CONNECTION_PERMISSIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_READ_ONLY"
              value="read-only"
              c:type="NM_SETTING_CONNECTION_READ_ONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SECONDARIES"
              value="secondaries"
              c:type="NM_SETTING_CONNECTION_SECONDARIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SETTING_NAME"
              value="connection"
              c:type="NM_SETTING_CONNECTION_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_SLAVE_TYPE"
              value="slave-type"
              c:type="NM_SETTING_CONNECTION_SLAVE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_TIMESTAMP"
              value="timestamp"
              c:type="NM_SETTING_CONNECTION_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_TYPE"
              value="type"
              c:type="NM_SETTING_CONNECTION_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_UUID"
              value="uuid"
              c:type="NM_SETTING_CONNECTION_UUID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_CONNECTION_ZONE"
              value="zone"
              c:type="NM_SETTING_CONNECTION_ZONE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FCOE_FLAGS"
              value="app-fcoe-flags"
              c:type="NM_SETTING_DCB_APP_FCOE_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FCOE_MODE"
              value="app-fcoe-mode"
              c:type="NM_SETTING_DCB_APP_FCOE_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FCOE_PRIORITY"
              value="app-fcoe-priority"
              c:type="NM_SETTING_DCB_APP_FCOE_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FIP_FLAGS"
              value="app-fip-flags"
              c:type="NM_SETTING_DCB_APP_FIP_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_FIP_PRIORITY"
              value="app-fip-priority"
              c:type="NM_SETTING_DCB_APP_FIP_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_ISCSI_FLAGS"
              value="app-iscsi-flags"
              c:type="NM_SETTING_DCB_APP_ISCSI_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_APP_ISCSI_PRIORITY"
              value="app-iscsi-priority"
              c:type="NM_SETTING_DCB_APP_ISCSI_PRIORITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_FCOE_MODE_FABRIC"
              value="fabric"
              c:type="NM_SETTING_DCB_FCOE_MODE_FABRIC"
              version="0.9.10">
      <doc xml:space="preserve">Indicates that the FCoE controller should use "fabric" mode (default)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_FCOE_MODE_VN2VN"
              value="vn2vn"
              c:type="NM_SETTING_DCB_FCOE_MODE_VN2VN"
              version="0.9.10">
      <doc xml:space="preserve">Indicates that the FCoE controller should use "VN2VN" mode.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_BANDWIDTH"
              value="priority-bandwidth"
              c:type="NM_SETTING_DCB_PRIORITY_BANDWIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_FLOW_CONTROL"
              value="priority-flow-control"
              c:type="NM_SETTING_DCB_PRIORITY_FLOW_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS"
              value="priority-flow-control-flags"
              c:type="NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_GROUP_BANDWIDTH"
              value="priority-group-bandwidth"
              c:type="NM_SETTING_DCB_PRIORITY_GROUP_BANDWIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_GROUP_FLAGS"
              value="priority-group-flags"
              c:type="NM_SETTING_DCB_PRIORITY_GROUP_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_GROUP_ID"
              value="priority-group-id"
              c:type="NM_SETTING_DCB_PRIORITY_GROUP_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_STRICT_BANDWIDTH"
              value="priority-strict-bandwidth"
              c:type="NM_SETTING_DCB_PRIORITY_STRICT_BANDWIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_PRIORITY_TRAFFIC_CLASS"
              value="priority-traffic-class"
              c:type="NM_SETTING_DCB_PRIORITY_TRAFFIC_CLASS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_DCB_SETTING_NAME"
              value="dcb"
              c:type="NM_SETTING_DCB_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GENERIC_SETTING_NAME"
              value="generic"
              c:type="NM_SETTING_GENERIC_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_ALLOWED_BANDS"
              value="allowed-bands"
              c:type="NM_SETTING_GSM_ALLOWED_BANDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_APN" value="apn" c:type="NM_SETTING_GSM_APN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_BANDS_MAX"
              value="0"
              c:type="NM_SETTING_GSM_BANDS_MAX"
              deprecated="1"
              deprecated-version="0.9.10">
      <doc xml:space="preserve">#NM_SETTING_GSM_BANDS_MAX macro indicate the maximal value that can be used
as the allowed frequency bands (#NMSettingGsm:allowed-bands property).</doc>
      <doc-deprecated xml:space="preserve">No longer used.</doc-deprecated>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_GSM_HOME_ONLY"
              value="home-only"
              c:type="NM_SETTING_GSM_HOME_ONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NETWORK_ID"
              value="network-id"
              c:type="NM_SETTING_GSM_NETWORK_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NETWORK_TYPE"
              value="network-type"
              c:type="NM_SETTING_GSM_NETWORK_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_NUMBER"
              value="number"
              c:type="NM_SETTING_GSM_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PASSWORD"
              value="password"
              c:type="NM_SETTING_GSM_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_GSM_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PIN" value="pin" c:type="NM_SETTING_GSM_PIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_PIN_FLAGS"
              value="pin-flags"
              c:type="NM_SETTING_GSM_PIN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_SETTING_NAME"
              value="gsm"
              c:type="NM_SETTING_GSM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_GSM_USERNAME"
              value="username"
              c:type="NM_SETTING_GSM_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_INFINIBAND_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_MTU"
              value="mtu"
              c:type="NM_SETTING_INFINIBAND_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_PARENT"
              value="parent"
              c:type="NM_SETTING_INFINIBAND_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_P_KEY"
              value="p-key"
              c:type="NM_SETTING_INFINIBAND_P_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_SETTING_NAME"
              value="infiniband"
              c:type="NM_SETTING_INFINIBAND_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_INFINIBAND_TRANSPORT_MODE"
              value="transport-mode"
              c:type="NM_SETTING_INFINIBAND_TRANSPORT_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_SETTING_IP4_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_CLIENT_ID"
              value="dhcp-client-id"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_HOSTNAME"
              value="dhcp-hostname"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_SEND_HOSTNAME"
              value="dhcp-send-hostname"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_SEND_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DHCP_TIMEOUT"
              value="dhcp-timeout"
              c:type="NM_SETTING_IP4_CONFIG_DHCP_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DNS"
              value="dns"
              c:type="NM_SETTING_IP4_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_DNS_SEARCH"
              value="dns-search"
              c:type="NM_SETTING_IP4_CONFIG_DNS_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_IGNORE_AUTO_DNS"
              value="ignore-auto-dns"
              c:type="NM_SETTING_IP4_CONFIG_IGNORE_AUTO_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_IGNORE_AUTO_ROUTES"
              value="ignore-auto-routes"
              c:type="NM_SETTING_IP4_CONFIG_IGNORE_AUTO_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_MAY_FAIL"
              value="may-fail"
              c:type="NM_SETTING_IP4_CONFIG_MAY_FAIL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD"
              value="method"
              c:type="NM_SETTING_IP4_CONFIG_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_AUTO"
              value="auto"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_AUTO">
      <doc xml:space="preserve">IPv4 configuration should be automatically determined via a method appropriate
for the hardware interface, ie DHCP or PPP or some other device-specific
manner.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_DISABLED"
              value="disabled"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_DISABLED">
      <doc xml:space="preserve">This connection does not use or require IPv4 address and it should be disabled.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_LINK_LOCAL"
              value="link-local"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL">
      <doc xml:space="preserve">IPv4 configuration should be automatically configured for link-local-only
operation.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_MANUAL"
              value="manual"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_MANUAL">
      <doc xml:space="preserve">All necessary IPv4 configuration (addresses, prefix, DNS, etc) is specified
in the setting's properties.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_METHOD_SHARED"
              value="shared"
              c:type="NM_SETTING_IP4_CONFIG_METHOD_SHARED">
      <doc xml:space="preserve">This connection specifies configuration that allows other computers to
connect through it to the default network (usually the Internet).  The
connection's interface will be assigned a private address, and a DHCP server,
caching DNS server, and Network Address Translation (NAT) functionality will
be started on this connection's interface to allow other devices to connect
through that interface to the default network.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_SETTING_IP4_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_ROUTES"
              value="routes"
              c:type="NM_SETTING_IP4_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_ROUTE_METRIC"
              value="route-metric"
              c:type="NM_SETTING_IP4_CONFIG_ROUTE_METRIC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP4_CONFIG_SETTING_NAME"
              value="ipv4"
              c:type="NM_SETTING_IP4_CONFIG_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_ADDRESSES"
              value="addresses"
              c:type="NM_SETTING_IP6_CONFIG_ADDRESSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_DHCP_HOSTNAME"
              value="dhcp-hostname"
              c:type="NM_SETTING_IP6_CONFIG_DHCP_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_DNS"
              value="dns"
              c:type="NM_SETTING_IP6_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_DNS_SEARCH"
              value="dns-search"
              c:type="NM_SETTING_IP6_CONFIG_DNS_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_IGNORE_AUTO_DNS"
              value="ignore-auto-dns"
              c:type="NM_SETTING_IP6_CONFIG_IGNORE_AUTO_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_IGNORE_AUTO_ROUTES"
              value="ignore-auto-routes"
              c:type="NM_SETTING_IP6_CONFIG_IGNORE_AUTO_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_IP6_PRIVACY"
              value="ip6-privacy"
              c:type="NM_SETTING_IP6_CONFIG_IP6_PRIVACY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_MAY_FAIL"
              value="may-fail"
              c:type="NM_SETTING_IP6_CONFIG_MAY_FAIL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD"
              value="method"
              c:type="NM_SETTING_IP6_CONFIG_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_AUTO"
              value="auto"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_AUTO">
      <doc xml:space="preserve">IPv6 configuration should be automatically determined via a method appropriate
for the hardware interface, ie router advertisements, DHCP, or PPP or some
other device-specific manner.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_DHCP"
              value="dhcp"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_DHCP">
      <doc xml:space="preserve">IPv6 configuration should be automatically determined via DHCPv6 only and
router advertisements should be ignored.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_IGNORE"
              value="ignore"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_IGNORE">
      <doc xml:space="preserve">IPv6 is not required or is handled by some other mechanism, and NetworkManager
should not configure IPv6 for this connection.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_LINK_LOCAL"
              value="link-local"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL">
      <doc xml:space="preserve">IPv6 configuration should be automatically configured for link-local-only
operation.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_MANUAL"
              value="manual"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_MANUAL">
      <doc xml:space="preserve">All necessary IPv6 configuration (addresses, prefix, DNS, etc) is specified
in the setting's properties.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_METHOD_SHARED"
              value="shared"
              c:type="NM_SETTING_IP6_CONFIG_METHOD_SHARED">
      <doc xml:space="preserve">This connection specifies configuration that allows other computers to
connect through it to the default network (usually the Internet).  The
connection's interface will be assigned a private address, and router
advertisements, a caching DNS server, and Network Address Translation (NAT)
functionality will be started on this connection's interface to allow other
devices to connect through that interface to the default network. (not yet
supported for IPv6)</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_SETTING_IP6_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_ROUTES"
              value="routes"
              c:type="NM_SETTING_IP6_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_ROUTE_METRIC"
              value="route-metric"
              c:type="NM_SETTING_IP6_CONFIG_ROUTE_METRIC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_IP6_CONFIG_SETTING_NAME"
              value="ipv6"
              c:type="NM_SETTING_IP6_CONFIG_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_NAME" value="name" c:type="NM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_CHANNEL"
              value="channel"
              c:type="NM_SETTING_OLPC_MESH_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS"
              value="dhcp-anycast-address"
              c:type="NM_SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_SETTING_NAME"
              value="802-11-olpc-mesh"
              c:type="NM_SETTING_OLPC_MESH_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_OLPC_MESH_SSID"
              value="ssid"
              c:type="NM_SETTING_OLPC_MESH_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PARAM_FUZZY_IGNORE"
              value="8"
              c:type="NM_SETTING_PARAM_FUZZY_IGNORE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_REQUIRED"
              value="2"
              c:type="NM_SETTING_PARAM_REQUIRED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_SECRET"
              value="4"
              c:type="NM_SETTING_PARAM_SECRET">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PARAM_SERIALIZE"
              value="1"
              c:type="NM_SETTING_PARAM_SERIALIZE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SETTING_PPPOE_PASSWORD"
              value="password"
              c:type="NM_SETTING_PPPOE_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_PASSWORD_FLAGS"
              value="password-flags"
              c:type="NM_SETTING_PPPOE_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_SERVICE"
              value="service"
              c:type="NM_SETTING_PPPOE_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_SETTING_NAME"
              value="pppoe"
              c:type="NM_SETTING_PPPOE_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPPOE_USERNAME"
              value="username"
              c:type="NM_SETTING_PPPOE_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_BAUD"
              value="baud"
              c:type="NM_SETTING_PPP_BAUD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_CRTSCTS"
              value="crtscts"
              c:type="NM_SETTING_PPP_CRTSCTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_LCP_ECHO_FAILURE"
              value="lcp-echo-failure"
              c:type="NM_SETTING_PPP_LCP_ECHO_FAILURE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_LCP_ECHO_INTERVAL"
              value="lcp-echo-interval"
              c:type="NM_SETTING_PPP_LCP_ECHO_INTERVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MPPE_STATEFUL"
              value="mppe-stateful"
              c:type="NM_SETTING_PPP_MPPE_STATEFUL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MRU" value="mru" c:type="NM_SETTING_PPP_MRU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_MTU" value="mtu" c:type="NM_SETTING_PPP_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NOAUTH"
              value="noauth"
              c:type="NM_SETTING_PPP_NOAUTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NOBSDCOMP"
              value="nobsdcomp"
              c:type="NM_SETTING_PPP_NOBSDCOMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NODEFLATE"
              value="nodeflate"
              c:type="NM_SETTING_PPP_NODEFLATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_NO_VJ_COMP"
              value="no-vj-comp"
              c:type="NM_SETTING_PPP_NO_VJ_COMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_CHAP"
              value="refuse-chap"
              c:type="NM_SETTING_PPP_REFUSE_CHAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_EAP"
              value="refuse-eap"
              c:type="NM_SETTING_PPP_REFUSE_EAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_MSCHAP"
              value="refuse-mschap"
              c:type="NM_SETTING_PPP_REFUSE_MSCHAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_MSCHAPV2"
              value="refuse-mschapv2"
              c:type="NM_SETTING_PPP_REFUSE_MSCHAPV2">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REFUSE_PAP"
              value="refuse-pap"
              c:type="NM_SETTING_PPP_REFUSE_PAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REQUIRE_MPPE"
              value="require-mppe"
              c:type="NM_SETTING_PPP_REQUIRE_MPPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_REQUIRE_MPPE_128"
              value="require-mppe-128"
              c:type="NM_SETTING_PPP_REQUIRE_MPPE_128">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_PPP_SETTING_NAME"
              value="ppp"
              c:type="NM_SETTING_PPP_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_BAUD"
              value="baud"
              c:type="NM_SETTING_SERIAL_BAUD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_BITS"
              value="bits"
              c:type="NM_SETTING_SERIAL_BITS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_PARITY"
              value="parity"
              c:type="NM_SETTING_SERIAL_PARITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_SEND_DELAY"
              value="send-delay"
              c:type="NM_SETTING_SERIAL_SEND_DELAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_SETTING_NAME"
              value="serial"
              c:type="NM_SETTING_SERIAL_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_SERIAL_STOPBITS"
              value="stopbits"
              c:type="NM_SETTING_SERIAL_STOPBITS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_CONFIG"
              value="config"
              c:type="NM_SETTING_TEAM_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_TEAM_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_PORT_CONFIG"
              value="config"
              c:type="NM_SETTING_TEAM_PORT_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_PORT_SETTING_NAME"
              value="team-port"
              c:type="NM_SETTING_TEAM_PORT_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_TEAM_SETTING_NAME"
              value="team"
              c:type="NM_SETTING_TEAM_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_EGRESS_PRIORITY_MAP"
              value="egress-priority-map"
              c:type="NM_SETTING_VLAN_EGRESS_PRIORITY_MAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_FLAGS"
              value="flags"
              c:type="NM_SETTING_VLAN_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_ID" value="id" c:type="NM_SETTING_VLAN_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_INGRESS_PRIORITY_MAP"
              value="ingress-priority-map"
              c:type="NM_SETTING_VLAN_INGRESS_PRIORITY_MAP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_INTERFACE_NAME"
              value="interface-name"
              c:type="NM_SETTING_VLAN_INTERFACE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_PARENT"
              value="parent"
              c:type="NM_SETTING_VLAN_PARENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VLAN_SETTING_NAME"
              value="vlan"
              c:type="NM_SETTING_VLAN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_DATA"
              value="data"
              c:type="NM_SETTING_VPN_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_PERSISTENT"
              value="persistent"
              c:type="NM_SETTING_VPN_PERSISTENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SECRETS"
              value="secrets"
              c:type="NM_SETTING_VPN_SECRETS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SERVICE_TYPE"
              value="service-type"
              c:type="NM_SETTING_VPN_SERVICE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_SETTING_NAME"
              value="vpn"
              c:type="NM_SETTING_VPN_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_VPN_USER_NAME"
              value="user-name"
              c:type="NM_SETTING_VPN_USER_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIMAX_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_NETWORK_NAME"
              value="network-name"
              c:type="NM_SETTING_WIMAX_NETWORK_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIMAX_SETTING_NAME"
              value="wimax"
              c:type="NM_SETTING_WIMAX_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_AUTO_NEGOTIATE"
              value="auto-negotiate"
              c:type="NM_SETTING_WIRED_AUTO_NEGOTIATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_CLONED_MAC_ADDRESS"
              value="cloned-mac-address"
              c:type="NM_SETTING_WIRED_CLONED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_DUPLEX"
              value="duplex"
              c:type="NM_SETTING_WIRED_DUPLEX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIRED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MAC_ADDRESS_BLACKLIST"
              value="mac-address-blacklist"
              c:type="NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_MTU"
              value="mtu"
              c:type="NM_SETTING_WIRED_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_PORT"
              value="port"
              c:type="NM_SETTING_WIRED_PORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_NETTYPE"
              value="s390-nettype"
              c:type="NM_SETTING_WIRED_S390_NETTYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_OPTIONS"
              value="s390-options"
              c:type="NM_SETTING_WIRED_S390_OPTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_S390_SUBCHANNELS"
              value="s390-subchannels"
              c:type="NM_SETTING_WIRED_S390_SUBCHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_SETTING_NAME"
              value="802-3-ethernet"
              c:type="NM_SETTING_WIRED_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRED_SPEED"
              value="speed"
              c:type="NM_SETTING_WIRED_SPEED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_BAND"
              value="band"
              c:type="NM_SETTING_WIRELESS_BAND">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_BSSID"
              value="bssid"
              c:type="NM_SETTING_WIRELESS_BSSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_CHANNEL"
              value="channel"
              c:type="NM_SETTING_WIRELESS_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_CLONED_MAC_ADDRESS"
              value="cloned-mac-address"
              c:type="NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_HIDDEN"
              value="hidden"
              c:type="NM_SETTING_WIRELESS_HIDDEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MAC_ADDRESS"
              value="mac-address"
              c:type="NM_SETTING_WIRELESS_MAC_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST"
              value="mac-address-blacklist"
              c:type="NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE"
              value="mode"
              c:type="NM_SETTING_WIRELESS_MODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_ADHOC"
              value="adhoc"
              c:type="NM_SETTING_WIRELESS_MODE_ADHOC">
      <doc xml:space="preserve">Indicates Ad-Hoc mode where no access point is expected to be present.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_AP"
              value="ap"
              c:type="NM_SETTING_WIRELESS_MODE_AP"
              version="0.9.8">
      <doc xml:space="preserve">Indicates AP/master mode where the wireless device is started as an access
point/hotspot.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MODE_INFRA"
              value="infrastructure"
              c:type="NM_SETTING_WIRELESS_MODE_INFRA">
      <doc xml:space="preserve">Indicates infrastructure mode where an access point is expected to be present
for this connection.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_MTU"
              value="mtu"
              c:type="NM_SETTING_WIRELESS_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_POWERSAVE"
              value="powersave"
              c:type="NM_SETTING_WIRELESS_POWERSAVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_RATE"
              value="rate"
              c:type="NM_SETTING_WIRELESS_RATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SEC"
              value="security"
              c:type="NM_SETTING_WIRELESS_SEC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_AUTH_ALG"
              value="auth-alg"
              c:type="NM_SETTING_WIRELESS_SECURITY_AUTH_ALG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_GROUP"
              value="group"
              c:type="NM_SETTING_WIRELESS_SECURITY_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_KEY_MGMT"
              value="key-mgmt"
              c:type="NM_SETTING_WIRELESS_SECURITY_KEY_MGMT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_PASSWORD"
              value="leap-password"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS"
              value="leap-password-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_LEAP_USERNAME"
              value="leap-username"
              c:type="NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PAIRWISE"
              value="pairwise"
              c:type="NM_SETTING_WIRELESS_SECURITY_PAIRWISE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PROTO"
              value="proto"
              c:type="NM_SETTING_WIRELESS_SECURITY_PROTO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PSK"
              value="psk"
              c:type="NM_SETTING_WIRELESS_SECURITY_PSK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_PSK_FLAGS"
              value="psk-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_SETTING_NAME"
              value="802-11-wireless-security"
              c:type="NM_SETTING_WIRELESS_SECURITY_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY0"
              value="wep-key0"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY0">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY1"
              value="wep-key1"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY1">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY2"
              value="wep-key2"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY2">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY3"
              value="wep-key3"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY3">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS"
              value="wep-key-flags"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE"
              value="wep-key-type"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX"
              value="wep-tx-keyidx"
              c:type="NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SEEN_BSSIDS"
              value="seen-bssids"
              c:type="NM_SETTING_WIRELESS_SEEN_BSSIDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SETTING_NAME"
              value="802-11-wireless"
              c:type="NM_SETTING_WIRELESS_SETTING_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_SSID"
              value="ssid"
              c:type="NM_SETTING_WIRELESS_SSID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="SETTING_WIRELESS_TX_POWER"
              value="tx-power"
              c:type="NM_SETTING_WIRELESS_TX_POWER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Setting"
           c:symbol-prefix="setting"
           c:type="NMSetting"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="NMSetting"
           glib:get-type="nm_setting_get_type"
           glib:type-struct="SettingClass">
      <doc xml:space="preserve">The NMSetting struct contains only private data.
It should only be accessed through the functions described below.</doc>
      <constructor name="new_from_hash"
                   c:identifier="nm_setting_new_from_hash">
        <doc xml:space="preserve">Creates a new #NMSetting object and populates that object with the properties
contained in the hash table, using each hash key as the property to set,
and each hash value as the value to set that property to.  Setting properties
are strongly typed, thus the GValue type of the hash value must be correct.
See the documentation on each #NMSetting object subclass for the correct
property names and value types.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMSetting object populated with the properties from the
hash table, or %NULL on failure</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <parameter name="setting_type" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting type which the hash contains properties for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="hash" transfer-ownership="none">
            <doc xml:space="preserve">the #GHashTable containing a
string to GValue mapping of properties that apply to the setting</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="clear_secrets_with_flags" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2">
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="compare_property">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="prop_spec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="const GParamSpec*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_secret_flags" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="verify_secret" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="out_flags" transfer-ownership="none">
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_virtual_iface_name"
                      invoker="get_virtual_iface_name">
        <doc xml:space="preserve">Returns the name of the virtual kernel interface which the connection
needs to use if specified in the settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Name of the virtual interface or %NULL if the setting does not
support this feature</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="need_secrets" invoker="need_secrets">
        <doc xml:space="preserve">Returns an array of property names for each secret which may be required
to make a successful connection.  The returned hints are only intended as a
guide to what secrets may be required, because in some circumstances, there
is no way to conclusively determine exactly which secrets are needed.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GPtrArray containing
the property names of secrets of the #NMSetting which may be required; the
caller owns the array and must free it with g_ptr_array_free(), but must not
free the elements.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_secret_flags" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="verify_secret" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_one_secret" throws="1">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="verify" introspectable="0" throws="1">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="all_settings" transfer-ownership="none">
            <type name="GLib.SList" c:type="GSList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear_secrets" c:identifier="nm_setting_clear_secrets">
        <doc xml:space="preserve">Resets and clears any secrets in the setting.  Secrets should be added to the
setting only when needed, and cleared immediately after use to prevent
leakage of information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_secrets_with_flags"
              c:identifier="nm_setting_clear_secrets_with_flags">
        <doc xml:space="preserve">Clears and frees secrets determined by @func.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">function to be called to determine whether a
    specific secret should be cleared or not</doc>
            <type name="SettingClearSecretsWithFlagsFn"
                  c:type="NMSettingClearSecretsWithFlagsFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">caller-supplied data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="compare" c:identifier="nm_setting_compare">
        <doc xml:space="preserve">Compares two #NMSetting objects for similarity, with comparison behavior
modified by a set of flags.  See the documentation for #NMSettingCompareFlags
for a description of each flag's behavior.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the comparison succeeds, %FALSE if it does not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMSetting to compare with the first</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="diff" c:identifier="nm_setting_diff">
        <doc xml:space="preserve">Compares two #NMSetting objects for similarity, with comparison behavior
modified by a set of flags.  See the documentation for #NMSettingCompareFlags
for a description of each flag's behavior.  If the settings differ, the keys
of each setting that differ from the other are added to @results, mapped to
one or more #NMSettingDiffResult values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the settings contain the same values, %FALSE if they do not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">a second #NMSetting to compare with the first</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">compare flags, e.g. %NM_SETTING_COMPARE_FLAG_EXACT</doc>
            <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
          </parameter>
          <parameter name="invert_results" transfer-ownership="none">
            <doc xml:space="preserve">this parameter is used internally by libnm-util and should
be set to %FALSE.  If %TRUE inverts the meaning of the #NMSettingDiffResult.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="results"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">if the
settings differ, on return a hash table mapping the differing keys to one or
more %NMSettingDiffResult values OR-ed together.  If the settings do not
differ, any hash table passed in is unmodified.  If no hash table is passed
in and the settings differ, a new one is created and returned.</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="guint32"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="duplicate" c:identifier="nm_setting_duplicate">
        <doc xml:space="preserve">Duplicates a #NMSetting.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #NMSetting containing the same properties and values as the
source #NMSetting</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting to duplicate</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="enumerate_values"
              c:identifier="nm_setting_enumerate_values">
        <doc xml:space="preserve">Iterates over each property of the #NMSetting object, calling the supplied
user function for each property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">user-supplied function called for each property of the setting</doc>
            <type name="SettingValueIterFn" c:type="NMSettingValueIterFn"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to @func at each invocation</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="nm_setting_get_name">
        <doc xml:space="preserve">Returns the type name of the #NMSetting object</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a string containing the type name of the #NMSetting object,
like 'ppp' or 'wireless' or 'wired'.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secret_flags"
              c:identifier="nm_setting_get_secret_flags"
              throws="1">
        <doc xml:space="preserve">For a given secret, retrieves the #NMSettingSecretFlags describing how to
handle that secret.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success (if the given secret name was a valid property of
this setting, and if that property is secret), %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:space="preserve">the secret key name to get flags for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="out_flags" transfer-ownership="none">
            <doc xml:space="preserve">on success, the #NMSettingSecretFlags for the secret</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_virtual_iface_name"
              c:identifier="nm_setting_get_virtual_iface_name">
        <doc xml:space="preserve">Returns the name of the virtual kernel interface which the connection
needs to use if specified in the settings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Name of the virtual interface or %NULL if the setting does not
support this feature</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="need_secrets" c:identifier="nm_setting_need_secrets">
        <doc xml:space="preserve">Returns an array of property names for each secret which may be required
to make a successful connection.  The returned hints are only intended as a
guide to what secrets may be required, because in some circumstances, there
is no way to conclusively determine exactly which secrets are needed.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a #GPtrArray containing
the property names of secrets of the #NMSetting which may be required; the
caller owns the array and must free it with g_ptr_array_free(), but must not
free the elements.</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_secret_flags"
              c:identifier="nm_setting_set_secret_flags"
              throws="1">
        <doc xml:space="preserve">For a given secret, stores the #NMSettingSecretFlags describing how to
handle that secret.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success (if the given secret name was a valid property of
this setting, and if that property is secret), %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secret_name" transfer-ownership="none">
            <doc xml:space="preserve">the secret key name to set flags for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSecretFlags for the secret</doc>
            <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hash" c:identifier="nm_setting_to_hash">
        <doc xml:space="preserve">Converts the #NMSetting into a #GHashTable mapping each setting property
name to a GValue describing that property, suitable for marshalling over
D-Bus or serializing.  The mapping is string to GValue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GHashTable
describing the setting's properties</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">hash flags, e.g. %NM_SETTING_HASH_FLAG_ALL</doc>
            <type name="SettingHashFlags" c:type="NMSettingHashFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="nm_setting_to_string">
        <doc xml:space="preserve">Convert the setting into a string.  For debugging purposes ONLY, should NOT
be used for serialization of the setting, or machine-parsed in any way. The
output format is not guaranteed to be stable and may change at any time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an allocated string containing a textual representation of the
setting's properties and values (including secrets!), which the caller should
free with g_free()</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update_secrets"
              c:identifier="nm_setting_update_secrets"
              throws="1">
        <doc xml:space="preserve">Update the setting's secrets, given a hash table of secrets intended for that
setting (deserialized from D-Bus for example).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secrets were successfully updated, %FALSE on failure to
update one or more of the secrets.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="secrets" transfer-ownership="none">
            <doc xml:space="preserve">a #GHashTable mapping
string to #GValue of setting property names and secrets</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="verify" c:identifier="nm_setting_verify" throws="1">
        <doc xml:space="preserve">Validates the setting.  Each setting's properties have allowed values, and
some are dependent on other values (hence the need for @all_settings).  The
returned #GError contains information about which property of the setting
failed validation, and in what way that property failed validation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the setting is valid, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting to verify</doc>
            <type name="Setting" c:type="NMSetting*"/>
          </instance-parameter>
          <parameter name="all_settings" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList of all settings
    in the connection from which @setting came</doc>
            <type name="GLib.SList" c:type="GSList*">
              <type name="Setting"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="name" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The setting's name, which uniquely identifies the setting within the
connection.  Each setting type has a name unique to that type, for
example "ppp" or "wireless" or "wired".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="Setting8021x"
           c:symbol-prefix="setting_802_1x"
           c:type="NMSetting8021x"
           parent="Setting"
           glib:type-name="NMSetting8021x"
           glib:get-type="nm_setting_802_1x_get_type"
           glib:type-struct="Setting8021xClass">
      <constructor name="new" c:identifier="nm_setting_802_1x_new">
        <doc xml:space="preserve">Creates a new #NMSetting8021x object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSetting8021x object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_altsubject_match"
              c:identifier="nm_setting_802_1x_add_altsubject_match">
        <doc xml:space="preserve">Adds an allowed alternate subject name match.  Until at least one
match is added, the altSubjectName of the remote authentication
server is not verified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the alternative subject name match was
 successfully added, %FALSE if it was already allowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the altSubjectName to allow for this connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_eap_method"
              c:identifier="nm_setting_802_1x_add_eap_method">
        <doc xml:space="preserve">Adds an allowed EAP method.  The setting is not valid until at least one
EAP method has been added.  See #NMSetting8021x:eap property for a list of
allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the EAP method was successfully added, %FALSE if it was
 not a valid method or if it was already allowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="eap" transfer-ownership="none">
            <doc xml:space="preserve">the name of the EAP method to allow for this connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_add_phase2_altsubject_match">
        <doc xml:space="preserve">Adds an allowed alternate subject name match for "phase 2".  Until
at least one match is added, the altSubjectName of the "phase 2"
remote authentication server is not verified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the "phase 2" alternative subject name match was
 successfully added, %FALSE if it was already allowed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="phase2_altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the "phase 2" altSubjectName to allow for this
connection</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_altsubject_matches"
              c:identifier="nm_setting_802_1x_clear_altsubject_matches">
        <doc xml:space="preserve">Clears all altSubjectName matches.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_eap_methods"
              c:identifier="nm_setting_802_1x_clear_eap_methods">
        <doc xml:space="preserve">Clears all allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_phase2_altsubject_matches"
              c:identifier="nm_setting_802_1x_clear_phase2_altsubject_matches">
        <doc xml:space="preserve">Clears all "phase 2" altSubjectName matches.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_altsubject_match"
              c:identifier="nm_setting_802_1x_get_altsubject_match">
        <doc xml:space="preserve">Returns the altSubjectName match at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the altSubjectName match at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the array of altSubjectName matches</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_anonymous_identity"
              c:identifier="nm_setting_802_1x_get_anonymous_identity">
        <doc xml:space="preserve">Returns the anonymous identifier used by some EAP methods (like TTLS) to
authenticate the user in the outer unencrypted "phase 1" authentication.  The
inner "phase 2" authentication will use the #NMSetting8021x:identity in
a secure form, if applicable for that EAP method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the anonymous identifier</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_blob"
              c:identifier="nm_setting_802_1x_get_ca_cert_blob">
        <doc xml:space="preserve">Returns the CA certificate blob if the CA certificate is stored using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use a
CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the CA certificate data</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_path"
              c:identifier="nm_setting_802_1x_get_ca_cert_path">
        <doc xml:space="preserve">Returns the CA certificate path if the CA certificate is stored using the
%NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use a
CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the CA certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_cert_scheme"
              c:identifier="nm_setting_802_1x_get_ca_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the CA certificate.  If the returned scheme
is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_ca_cert_blob();
if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_ca_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the CA certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ca_path" c:identifier="nm_setting_802_1x_get_ca_path">
        <doc xml:space="preserve">Returns the path of the CA certificate directory if previously set.  Systems
will often have a directory that contains multiple individual CA certificates
which the supplicant can then add to the verification chain.  This may be
used in addition to the #NMSetting8021x:ca-cert property to add more CA
certificates for verifying the network to client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the CA certificate directory path</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_blob"
              c:identifier="nm_setting_802_1x_get_client_cert_blob">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the client certificate data</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_path"
              c:identifier="nm_setting_802_1x_get_client_cert_path">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the client certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_client_cert_scheme"
              c:identifier="nm_setting_802_1x_get_client_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the client certificate.  If the returned scheme
is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use nm_setting_802_1x_get_client_cert_blob();
if %NM_SETTING_802_1X_CK_SCHEME_PATH, use nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the client certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_eap_method"
              c:identifier="nm_setting_802_1x_get_eap_method">
        <doc xml:space="preserve">Returns the name of the allowed EAP method at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of the allowed EAP method at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the EAP method name to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identity"
              c:identifier="nm_setting_802_1x_get_identity">
        <doc xml:space="preserve">Returns the identifier used by some EAP methods (like TLS) to
authenticate the user.  Often this is a username or login name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the user identifier</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_altsubject_matches"
              c:identifier="nm_setting_802_1x_get_num_altsubject_matches">
        <doc xml:space="preserve">Returns the number of entries in the
#NMSetting8021x:altsubject-matches property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of altsubject-matches entries.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_eap_methods"
              c:identifier="nm_setting_802_1x_get_num_eap_methods">
        <doc xml:space="preserve">Returns the number of eap methods allowed for use when connecting to the
network.  Generally only one EAP method is used.  Use the functions
nm_setting_802_1x_get_eap_method(), nm_setting_802_1x_add_eap_method(),
and nm_setting_802_1x_remove_eap_method() for adding, removing, and retrieving
allowed EAP methods.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of allowed EAP methods</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_phase2_altsubject_matches"
              c:identifier="nm_setting_802_1x_get_num_phase2_altsubject_matches">
        <doc xml:space="preserve">Returns the number of entries in the
#NMSetting8021x:phase2-altsubject-matches property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of phase2-altsubject-matches entries.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pac_file"
              c:identifier="nm_setting_802_1x_get_pac_file">
        <doc xml:space="preserve">Returns the file containing PAC credentials used by EAP-FAST method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the PAC file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password"
              c:identifier="nm_setting_802_1x_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used by the authentication method, if any, as specified
  by the #NMSetting8021x:password property</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_802_1x_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSetting8021x:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_raw"
              c:identifier="nm_setting_802_1x_get_password_raw">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password used by the authentication method as a
UTF-8-encoded array of bytes, as specified by the
#NMSetting8021x:password-raw property</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_raw_flags"
              c:identifier="nm_setting_802_1x_get_password_raw_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
  #NMSetting8021x:password-raw</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase1_fast_provisioning"
              c:identifier="nm_setting_802_1x_get_phase1_fast_provisioning">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether "phase 1" PEAP fast provisioning should be used, as specified
 by the #NMSetting8021x:phase1-fast-provisioning property.  See the
 wpa_supplicant documentation for more details.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase1_peaplabel"
              c:identifier="nm_setting_802_1x_get_phase1_peaplabel">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the "phase 1" PEAP label is new-style or old-style, to be
 used when authenticating with EAP-PEAP, as contained in the
 #NMSetting8021x:phase1-peaplabel property.  Valid values are %NULL (unset),
 "0" (use old-style label), and "1" (use new-style label).  See the
 wpa_supplicant documentation for more details.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase1_peapver"
              c:identifier="nm_setting_802_1x_get_phase1_peapver">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 1" PEAP version to be used when authenticating with
 EAP-PEAP as contained in the #NMSetting8021x:phase1-peapver property.  Valid
 values are %NULL (unset), "0" (PEAP version 0), and "1" (PEAP version 1).</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_get_phase2_altsubject_match">
        <doc xml:space="preserve">Returns the "phase 2" altSubjectName match at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" altSubjectName match at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the array of "phase 2" altSubjectName matches</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_phase2_auth"
              c:identifier="nm_setting_802_1x_get_phase2_auth">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" non-EAP (ex MD5) allowed authentication method as
  specified by the #NMSetting8021x:phase2-auth property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_autheap"
              c:identifier="nm_setting_802_1x_get_phase2_autheap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" EAP-based (ex TLS) allowed authentication method as
  specified by the #NMSetting8021x:phase2-autheap property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_blob"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_blob">
        <doc xml:space="preserve">Returns the "phase 2" CA certificate blob if the CA certificate is stored
using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme.  Not all EAP methods use
a CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" CA certificate data</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_path"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_path">
        <doc xml:space="preserve">Returns the "phase 2" CA certificate path if the CA certificate is stored
using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.  Not all EAP methods use
a CA certificate (LEAP for example), and those that can take advantage of the
CA certificate allow it to be unset.  Note that lack of a CA certificate
reduces security by allowing man-in-the-middle attacks, because the identity
of the network cannot be confirmed by the client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the "phase 2" CA certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_cert_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_ca_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the "phase 2" CA certificate.  If the
returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_ca_cert_blob(); if %NM_SETTING_802_1X_CK_SCHEME_PATH,
use nm_setting_802_1x_get_ca_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the "phase 2" CA certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_ca_path"
              c:identifier="nm_setting_802_1x_get_phase2_ca_path">
        <doc xml:space="preserve">Returns the path of the "phase 2" CA certificate directory if previously set.
Systems will often have a directory that contains multiple individual CA
certificates which the supplicant can then add to the verification chain.
This may be used in addition to the #NMSetting8021x:phase2-ca-cert property
to add more CA certificates for verifying the network to client.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" CA certificate directory path</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_blob"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_blob">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" client certificate data</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_path"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_path">
        <doc xml:space="preserve">Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the "phase 2" client certificate file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_client_cert_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_client_cert_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the "phase 2" client certificate.  If the
returned scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the "phase 2" client certificate (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_blob"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_blob">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

WARNING: the phase2 private key property is not a "secret" property, and thus
unencrypted private key data may be readable by unprivileged users.  Private
keys should always be encrypted with a private key password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the "phase 2" private key data</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_format"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_format">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data format of the "phase 2" private key data stored in the
  #NMSetting8021x:phase2-private-key property</doc>
          <type name="Setting8021xCKFormat" c:type="NMSetting8021xCKFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_password"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the private key password used to decrypt the private key if
 previously set with nm_setting_802_1x_set_phase2_private_key() or the
 #NMSetting8021x:phase2-private-key-password property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_password_flags"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:phase2-private-key-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_path"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_path">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the "phase 2" private key file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_private_key_scheme"
              c:identifier="nm_setting_802_1x_get_phase2_private_key_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the "phase 2" private key.  If the returned
scheme is %NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the "phase 2" private key (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_phase2_subject_match"
              c:identifier="nm_setting_802_1x_get_phase2_subject_match">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting8021x:phase2-subject-match property. This is
the substring to be matched against the subject of the "phase 2"
authentication server certificate, or %NULL no subject verification
is to be performed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin" c:identifier="nm_setting_802_1x_get_pin">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the PIN used by the authentication method, if any, as specified
  by the #NMSetting8021x:pin property</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin_flags"
              c:identifier="nm_setting_802_1x_get_pin_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:pin</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_blob"
              c:identifier="nm_setting_802_1x_get_private_key_blob">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

WARNING: the private key property is not a "secret" property, and thus
unencrypted private key data may be readable by unprivileged users.  Private
keys should always be encrypted with a private key password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the private key data</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_format"
              c:identifier="nm_setting_802_1x_get_private_key_format">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data format of the private key data stored in the
  #NMSetting8021x:private-key property</doc>
          <type name="Setting8021xCKFormat" c:type="NMSetting8021xCKFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_password"
              c:identifier="nm_setting_802_1x_get_private_key_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the private key password used to decrypt the private key if
 previously set with nm_setting_802_1x_set_private_key(), or the
 #NMSetting8021x:private-key-password property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_password_flags"
              c:identifier="nm_setting_802_1x_get_private_key_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSetting8021x:private-key-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_path"
              c:identifier="nm_setting_802_1x_get_private_key_path">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">path to the private key file</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key_scheme"
              c:identifier="nm_setting_802_1x_get_private_key_scheme">
        <doc xml:space="preserve">Returns the scheme used to store the private key.  If the returned scheme is
%NM_SETTING_802_1X_CK_SCHEME_BLOB, use
nm_setting_802_1x_get_client_cert_blob(); if
%NM_SETTING_802_1X_CK_SCHEME_PATH, use
nm_setting_802_1x_get_client_cert_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">scheme used to store the private key (blob or path)</doc>
          <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject_match"
              c:identifier="nm_setting_802_1x_get_subject_match">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSetting8021x:subject-match property. This is the
substring to be matched against the subject of the authentication
server certificate, or %NULL no subject verification is to be
performed.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_system_ca_certs"
              c:identifier="nm_setting_802_1x_get_system_ca_certs">
        <doc xml:space="preserve">Sets the #NMSetting8021x:system-ca-certs property. The
#NMSetting8021x:ca-path and #NMSetting8021x:phase2-ca-path
properties are ignored if the #NMSetting8021x:system-ca-certs property is
%TRUE, in which case a system-wide CA certificate directory specified at
compile time (using the --system-ca-path configure option) is used in place
of these properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a system CA certificate path should be used, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_altsubject_match"
              c:identifier="nm_setting_802_1x_remove_altsubject_match">
        <doc xml:space="preserve">Removes the allowed altSubjectName at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the altSubjectName match to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_altsubject_match_by_value"
              c:identifier="nm_setting_802_1x_remove_altsubject_match_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the allowed altSubjectName @altsubject_match.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the alternative subject name match was found and removed,
         %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the altSubjectName to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_eap_method"
              c:identifier="nm_setting_802_1x_remove_eap_method">
        <doc xml:space="preserve">Removes the allowed EAP method at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the EAP method to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_eap_method_by_value"
              c:identifier="nm_setting_802_1x_remove_eap_method_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the allowed EAP method @method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the EAP method was founs and removed, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="eap" transfer-ownership="none">
            <doc xml:space="preserve">the name of the EAP method to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_phase2_altsubject_match"
              c:identifier="nm_setting_802_1x_remove_phase2_altsubject_match">
        <doc xml:space="preserve">Removes the allowed "phase 2" altSubjectName at the specified index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of the "phase 2" altSubjectName match to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_phase2_altsubject_match_by_value"
              c:identifier="nm_setting_802_1x_remove_phase2_altsubject_match_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the allowed "phase 2" altSubjectName @phase2_altsubject_match.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the alternative subject name match for "phase 2" was found and removed,
         %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="phase2_altsubject_match" transfer-ownership="none">
            <doc xml:space="preserve">the "phase 2" altSubjectName to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ca_cert"
              c:identifier="nm_setting_802_1x_set_ca_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:ca-cert property
with the raw certificate data if using the %NM_SETTING_802_1X_CK_SCHEME_BLOB
scheme, or with the path to the certificate file if using the
%NM_SETTING_802_1X_CK_SCHEME_PATH scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the CA certificate
  file (PEM or DER format).  The path must be UTF-8 encoded; use
  g_filename_to_utf8() to convert if needed.  Passing %NULL with any @scheme
  clears the CA certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_client_cert"
              c:identifier="nm_setting_802_1x_set_client_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:client-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the client
  certificate file (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8
  encoded; use g_filename_to_utf8() to convert if needed.  Passing %NULL with
  any @scheme clears the client certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_ca_cert"
              c:identifier="nm_setting_802_1x_set_phase2_ca_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:phase2-ca-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" CA
  certificate file (PEM or DER format).  The path must be UTF-8 encoded; use
  g_filename_to_utf8() to convert if needed.  Passing %NULL with any @scheme
  clears the "phase2" CA certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_client_cert"
              c:identifier="nm_setting_802_1x_set_phase2_client_cert"
              throws="1">
        <doc xml:space="preserve">Reads a certificate from disk and sets the #NMSetting8021x:phase2-client-cert
property with the raw certificate data if using the
%NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the certificate
file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

Client certificates are used to identify the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="cert_path" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH
  or %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" client
  certificate file (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8
  encoded; use g_filename_to_utf8() to convert if needed.  Passing %NULL with
  any @scheme clears the "phase2" client certificate.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the certificate</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the certificate added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_phase2_private_key"
              c:identifier="nm_setting_802_1x_set_phase2_private_key"
              throws="1">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

This function reads a private key from disk and sets the
#NMSetting8021x:phase2-private-key property with the private key file data if
using the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the
private key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

If @password is given, this function attempts to decrypt the private key to
verify that @password is correct, and if it is, updates the
#NMSetting8021x:phase2-private-key-password property with the given
@password.  If the decryption is unsuccessful, %FALSE is returned, @error is
set, and no internal data is changed.  If no @password is given, the private
key is assumed to be valid, no decryption is performed, and the password may
be set at a later time.

WARNING: the "phase2" private key property is not a "secret" property, and
thus unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a private
key password to prevent unauthorized access to unencrypted private key data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="key_path" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or
  %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the "phase2" private
  key file (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8 encoded;
  use g_filename_to_utf8() to convert if needed.  Passing %NULL with any
  @scheme clears the private key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">password used to decrypt the private key, or %NULL if the password
  is unknown.  If the password is given but fails to decrypt the private key,
  an error is returned.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the private key</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the private key added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_private_key"
              c:identifier="nm_setting_802_1x_set_private_key"
              throws="1">
        <doc xml:space="preserve">Private keys are used to authenticate the connecting client to the network
when EAP-TLS is used as either the "phase 1" or "phase 2" 802.1x
authentication method.

This function reads a private key from disk and sets the
#NMSetting8021x:private-key property with the private key file data if using
the %NM_SETTING_802_1X_CK_SCHEME_BLOB scheme, or with the path to the private
key file if using the %NM_SETTING_802_1X_CK_SCHEME_PATH scheme.

If @password is given, this function attempts to decrypt the private key to
verify that @password is correct, and if it is, updates the
#NMSetting8021x:private-key-password property with the given @password.  If
the decryption is unsuccessful, %FALSE is returned, @error is set, and no
internal data is changed.  If no @password is given, the private key is
assumed to be valid, no decryption is performed, and the password may be set
at a later time.

WARNING: the private key property is not a "secret" property, and thus
unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a private
key password to prevent unauthorized access to unencrypted private key data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the operation succeeded, %FALSE if it was unsuccessful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSetting8021x</doc>
            <type name="Setting8021x" c:type="NMSetting8021x*"/>
          </instance-parameter>
          <parameter name="key_path" transfer-ownership="none">
            <doc xml:space="preserve">when @scheme is set to either %NM_SETTING_802_1X_CK_SCHEME_PATH or
  %NM_SETTING_802_1X_CK_SCHEME_BLOB, pass the path of the private key file
  (PEM, DER, or PKCS#&lt;!-- --&gt;12 format).  The path must be UTF-8 encoded; use
  g_filename_to_utf8() to convert if needed.  Passing %NULL with any @scheme
  clears the private key.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">password used to decrypt the private key, or %NULL if the password
  is unknown.  If the password is given but fails to decrypt the private key,
  an error is returned.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:space="preserve">desired storage scheme for the private key</doc>
            <type name="Setting8021xCKScheme" c:type="NMSetting8021xCKScheme"/>
          </parameter>
          <parameter name="out_format" transfer-ownership="none">
            <doc xml:space="preserve">on successful return, the type of the private key added</doc>
            <type name="Setting8021xCKFormat"
                  c:type="NMSetting8021xCKFormat*"/>
          </parameter>
        </parameters>
      </method>
      <property name="altsubject-matches"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of strings to be matched against the altSubjectName of the
certificate presented by the authentication server. If the list is empty,
no verification of the server certificate's altSubjectName is performed.</doc>
        <type/>
      </property>
      <property name="anonymous-identity"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Anonymous identity string for EAP authentication methods.  Used as the
unencrypted identity with EAP types that support different tunneled
identity like EAP-TTLS.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="ca-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the CA certificate if used by the EAP method specified in the
#NMSetting8021x:eap property.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte. This
property can be unset even if the EAP method supports CA certificates,
but this allows man-in-the-middle attacks and is NOT recommended.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_ca_cert() function instead.</doc>
        <type/>
      </property>
      <property name="ca-path" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded path to a directory containing PEM or DER formatted
certificates to be added to the verification chain in addition to the
certificate specified in the #NMSetting8021x:ca-cert property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="client-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the client certificate if used by the EAP method specified in
the #NMSetting8021x:eap property.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_client_cert() function instead.</doc>
        <type/>
      </property>
      <property name="eap"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The allowed EAP method to be used when authenticating to the network with
802.1x.  Valid methods are: "leap", "md5", "tls", "peap", "ttls", "pwd",
and "fast".  Each method requires different configuration using the
properties of this setting; refer to wpa_supplicant documentation for the
allowed combinations.</doc>
        <type/>
      </property>
      <property name="identity" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Identity string for EAP authentication methods.  Often the user's user or
login name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pac-file" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded file path containing PAC for EAP-FAST.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded password used for EAP authentication methods. If both the
#NMSetting8021x:password property and the #NMSetting8021x:password-raw
property are specified, #NMSetting8021x:password is preferred.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:password property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="password-raw"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Password used for EAP authentication methods, given as a byte array to
allow passwords in other encodings than UTF-8 to be used. If both the
#NMSetting8021x:password property and the #NMSetting8021x:password-raw
property are specified, #NMSetting8021x:password is preferred.</doc>
        <type/>
      </property>
      <property name="password-raw-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:password-raw property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="phase1-fast-provisioning"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Enables or disables in-line provisioning of EAP-FAST credentials when
FAST is specified as the EAP method in the #NMSetting8021x:eap property.
Recognized values are "0" (disabled), "1" (allow unauthenticated
provisioning), "2" (allow authenticated provisioning), and "3" (allow
both authenticated and unauthenticated provisioning).  See the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase1-peaplabel" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Forces use of the new PEAP label during key derivation.  Some RADIUS
servers may require forcing the new PEAP label to interoperate with
PEAPv1.  Set to "1" to force use of the new PEAP label.  See the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase1-peapver" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Forces which PEAP version is used when PEAP is set as the EAP method in
the #NMSetting8021x:eap property.  When unset, the version reported by
the server will be used.  Sometimes when using older RADIUS servers, it
is necessary to force the client to use a particular PEAP version.  To do
so, this property may be set to "0" or "1" to force that specific PEAP
version.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-altsubject-matches"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of strings to be matched against the altSubjectName of the
certificate presented by the authentication server during the inner
"phase 2" authentication. If the list is empty, no verification of the
server certificate's altSubjectName is performed.</doc>
        <type/>
      </property>
      <property name="phase2-auth" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specifies the allowed "phase 2" inner non-EAP authentication methods when
an EAP method that uses an inner TLS tunnel is specified in the
#NMSetting8021x:eap property.  Recognized non-EAP "phase 2" methods are
"pap", "chap", "mschap", "mschapv2", "gtc", "otp", "md5", and "tls".
Each "phase 2" inner method requires specific parameters for successful
authentication; see the wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-autheap" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specifies the allowed "phase 2" inner EAP-based authentication methods
when an EAP method that uses an inner TLS tunnel is specified in the
#NMSetting8021x:eap property.  Recognized EAP-based "phase 2" methods are
"md5", "mschapv2", "otp", "gtc", and "tls". Each "phase 2" inner method
requires specific parameters for successful authentication; see the
wpa_supplicant documentation for more details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-ca-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the "phase 2" CA certificate if used by the EAP method specified
in the #NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap
properties.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte. This
property can be unset even if the EAP method supports CA certificates,
but this allows man-in-the-middle attacks and is NOT recommended.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_ca_cert() function instead.</doc>
        <type/>
      </property>
      <property name="phase2-ca-path" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">UTF-8 encoded path to a directory containing PEM or DER formatted
certificates to be added to the verification chain in addition to the
certificate specified in the #NMSetting8021x:phase2-ca-cert property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-client-cert"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the "phase 2" client certificate if used by the EAP method
specified in the #NMSetting8021x:phase2-auth or
#NMSetting8021x:phase2-autheap properties.

Certificate data is specified using a "scheme"; two are currently
supported: blob and path. When using the blob scheme (which is backwards
compatible with NM 0.7.x) this property should be set to the
certificate's DER encoded data. When using the path scheme, this property
should be set to the full UTF-8 encoded path of the certificate, prefixed
with the string "file://" and ending with a terminating NUL byte. This
property can be unset even if the EAP method supports CA certificates,
but this allows man-in-the-middle attacks and is NOT recommended.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_client_cert() function instead.</doc>
        <type/>
      </property>
      <property name="phase2-private-key"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the "phase 2" inner private key when the
#NMSetting8021x:phase2-auth or #NMSetting8021x:phase2-autheap property is
set to "tls".

Key data is specified using a "scheme"; two are currently supported: blob
and path. When using the blob scheme and private keys, this property
should be set to the key's encrypted PEM encoded data. When using private
keys with the path scheme, this property should be set to the full UTF-8
encoded path of the key, prefixed with the string "file://" and ending
with a terminating NUL byte. When using PKCS#&lt;!-- --&gt;12 format private keys and
the blob scheme, this property should be set to the PKCS#&lt;!-- --&gt;12 data and the
#NMSetting8021x:phase2-private-key-password property must be set to
password used to decrypt the PKCS#&lt;!-- --&gt;12 certificate and key. When using
PKCS#&lt;!-- --&gt;12 files and the path scheme, this property should be set to the
full UTF-8 encoded path of the key, prefixed with the string "file://"
and ending with a terminating NUL byte, and as with the blob scheme
the #NMSetting8021x:phase2-private-key-password property must be set to
the password used to decode the PKCS#&lt;!-- --&gt;12 private key and certificate.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_phase2_private_key() function instead.</doc>
        <type/>
      </property>
      <property name="phase2-private-key-password"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to decrypt the "phase 2" private key specified in the
#NMSetting8021x:phase2-private-key property when the private key either
uses the path scheme, or is a PKCS#&lt;!-- --&gt;12 format key.  Setting this property
directly is not generally necessary except when returning secrets to
NetworkManager; it is generally set automatically when setting the
private key by the nm_setting_802_1x_set_phase2_private_key() function.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="phase2-private-key-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the
#NMSetting8021x:phase2-private-key-password property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="phase2-subject-match"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Substring to be matched against the subject of the certificate presented
by the authentication server during the inner "phase 2"
authentication. When unset, no verification of the authentication server
certificate's subject is performed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pin" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">PIN used for EAP authentication methods.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pin-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:pin property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="private-key"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Contains the private key when the #NMSetting8021x:eap property is set to
"tls".

Key data is specified using a "scheme"; two are currently supported: blob
and path. When using the blob scheme and private keys, this property
should be set to the key's encrypted PEM encoded data. When using private
keys with the path scheme, this property should be set to the full UTF-8
encoded path of the key, prefixed with the string "file://" and ending
with a terminating NUL byte. When using PKCS#&lt;!-- --&gt;12 format private keys and
the blob scheme, this property should be set to the PKCS#&lt;!-- --&gt;12 data and the
#NMSetting8021x:private-key-password property must be set to password
used to decrypt the PKCS#&lt;!-- --&gt;12 certificate and key. When using PKCS#&lt;!-- --&gt;12 files
and the path scheme, this property should be set to the full UTF-8
encoded path of the key, prefixed with the string "file://" and
ending with a terminating NUL byte, and as with the blob scheme the
"private-key-password" property must be set to the password used to
decode the PKCS#&lt;!-- --&gt;12 private key and certificate.

Setting this property directly is discouraged; use the
nm_setting_802_1x_set_private_key() function instead.

WARNING: #NMSetting8021x:private-key is not a "secret" property, and thus
unencrypted private key data using the BLOB scheme may be readable by
unprivileged users.  Private keys should always be encrypted with a
private key password to prevent unauthorized access to unencrypted
private key data.</doc>
        <type/>
      </property>
      <property name="private-key-password"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The password used to decrypt the private key specified in the
#NMSetting8021x:private-key property when the private key either uses the
path scheme, or if the private key is a PKCS#&lt;!-- --&gt;12 format key.  Setting this
property directly is not generally necessary except when returning
secrets to NetworkManager; it is generally set automatically when setting
the private key by the nm_setting_802_1x_set_private_key() function.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="private-key-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSetting8021x:private-key-password
property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="subject-match" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Substring to be matched against the subject of the certificate presented
by the authentication server. When unset, no verification of the
authentication server certificate's subject is performed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="system-ca-certs"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When %TRUE, overrides the #NMSetting8021x:ca-path and
#NMSetting8021x:phase2-ca-path properties using the system CA directory
specified at configure time with the --system-ca-path switch.  The
certificates in this directory are added to the verification chain in
addition to any certificates specified by the #NMSetting8021x:ca-cert and
#NMSetting8021x:phase2-ca-cert properties.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <enumeration name="Setting8021xCKFormat"
                 glib:type-name="NMSetting8021xCKFormat"
                 glib:get-type="nm_setting_802_1x_ck_format_get_type"
                 c:type="NMSetting8021xCKFormat">
      <doc xml:space="preserve">#NMSetting8021xCKFormat values indicate the general type of a certificate
or private key</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown file format</doc>
      </member>
      <member name="x509"
              value="1"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_X509"
              glib:nick="x509">
        <doc xml:space="preserve">file contains an X.509 format certificate</doc>
      </member>
      <member name="raw_key"
              value="2"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_RAW_KEY"
              glib:nick="raw-key">
        <doc xml:space="preserve">file contains an old-style OpenSSL PEM
or DER private key</doc>
      </member>
      <member name="pkcs12"
              value="3"
              c:identifier="NM_SETTING_802_1X_CK_FORMAT_PKCS12"
              glib:nick="pkcs12">
        <doc xml:space="preserve">file contains a PKCS#&lt;!-- --&gt;12 certificate
and private key</doc>
      </member>
    </enumeration>
    <enumeration name="Setting8021xCKScheme"
                 glib:type-name="NMSetting8021xCKScheme"
                 glib:get-type="nm_setting_802_1x_ck_scheme_get_type"
                 c:type="NMSetting8021xCKScheme">
      <doc xml:space="preserve">#NMSetting8021xCKScheme values indicate how a certificate or private key is
stored in the setting properties, either as a blob of the item's data, or as
a path to a certificate or private key file on the filesystem</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown certificate or private key
scheme</doc>
      </member>
      <member name="blob"
              value="1"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_BLOB"
              glib:nick="blob">
        <doc xml:space="preserve">certificate or key is stored as the raw
item data</doc>
      </member>
      <member name="path"
              value="2"
              c:identifier="NM_SETTING_802_1X_CK_SCHEME_PATH"
              glib:nick="path">
        <doc xml:space="preserve">certificate or key is stored as a path
to a file containing the certificate or key data</doc>
      </member>
    </enumeration>
    <record name="Setting8021xClass"
            c:type="NMSetting8021xClass"
            glib:is-gtype-struct-for="Setting8021x">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="Setting8021xError"
                 glib:type-name="NMSetting8021xError"
                 glib:get-type="nm_setting_802_1x_error_get_type"
                 c:type="NMSetting8021xError"
                 glib:error-domain="nm-setting-802-1x-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_802_1X_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_802_1X_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_802_1X_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_802_1x_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSetting8021x if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSetting8021x errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingAdsl"
           c:symbol-prefix="setting_adsl"
           c:type="NMSettingAdsl"
           parent="Setting"
           glib:type-name="NMSettingAdsl"
           glib:get-type="nm_setting_adsl_get_type"
           glib:type-struct="SettingAdslClass">
      <constructor name="new" c:identifier="nm_setting_adsl_new">
        <doc xml:space="preserve">Creates a new #NMSettingAdsl object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingAdsl object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_encapsulation"
              c:identifier="nm_setting_adsl_get_encapsulation">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:encapsulation property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="nm_setting_adsl_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_adsl_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingAdsl:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="nm_setting_adsl_get_protocol">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:protocol property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_adsl_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vci" c:identifier="nm_setting_adsl_get_vci">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:vci property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_vpi" c:identifier="nm_setting_adsl_get_vpi">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingAdsl:vpi property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingAdsl</doc>
            <type name="SettingAdsl" c:type="NMSettingAdsl*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="encapsulation" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Encapsulation of ADSL connection.  Can be "vcmux" or "llc".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Password used to authenticate with the ADSL service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingAdsl:password property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="protocol" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">ADSL connection protocol.  Can be "pppoa", "pppoe" or "ipoatm".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Username used to authenticate with the ADSL service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="vci" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">VCI of ADSL connection</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="vpi" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">VPI of ADSL connection</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingAdslClass"
            c:type="NMSettingAdslClass"
            glib:is-gtype-struct-for="SettingAdsl">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingAdslError"
                 glib:type-name="NMSettingAdslError"
                 glib:get-type="nm_setting_adsl_error_get_type"
                 c:type="NMSettingAdslError"
                 glib:error-domain="nm-setting-adsl-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_ADSL_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_ADSL_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_ADSL_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_adsl_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingAdsl if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingAdsl errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingBluetooth"
           c:symbol-prefix="setting_bluetooth"
           c:type="NMSettingBluetooth"
           parent="Setting"
           glib:type-name="NMSettingBluetooth"
           glib:get-type="nm_setting_bluetooth_get_type"
           glib:type-struct="SettingBluetoothClass">
      <constructor name="new" c:identifier="nm_setting_bluetooth_new">
        <doc xml:space="preserve">Creates a new #NMSettingBluetooth object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBluetooth object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_bdaddr" c:identifier="nm_setting_bluetooth_get_bdaddr">
        <doc xml:space="preserve">Gets the Bluetooth address of the remote device which this setting
describes a connection to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the Bluetooth address</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBluetooth</doc>
            <type name="SettingBluetooth" c:type="NMSettingBluetooth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_setting_bluetooth_get_connection_type">
        <doc xml:space="preserve">Returns the connection method for communicating with the remote device (i.e.
either DUN to a DUN-capable device or PANU to a NAP-capable device).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type, either %NM_SETTING_BLUETOOTH_TYPE_PANU or
  %NM_SETTING_BLUETOOTH_TYPE_DUN</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBluetooth</doc>
            <type name="SettingBluetooth" c:type="NMSettingBluetooth*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bdaddr"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Bluetooth address of the device.</doc>
        <type/>
      </property>
      <property name="type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Either "dun" for Dial-Up Networking connections or "panu" for Personal
Area Networking connections to devices supporting the NAP profile.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBluetoothClass"
            c:type="NMSettingBluetoothClass"
            glib:is-gtype-struct-for="SettingBluetooth">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingBluetoothError"
                 glib:type-name="NMSettingBluetoothError"
                 glib:get-type="nm_setting_bluetooth_error_get_type"
                 c:type="NMSettingBluetoothError"
                 glib:error-domain="nm-setting-bluetooth-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="TypeSettingNotFound"
              value="3"
              c:identifier="NM_SETTING_BLUETOOTH_ERROR_TYPE_SETTING_NOT_FOUND"
              glib:nick="TypeSettingNotFound">
        <doc xml:space="preserve">the connection
did not contain a required type setting, ie for DUN connections the connection
must also contain an #NMSettingGsm or #NMSettingCdma as appropriate</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_bluetooth_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingBluetooth if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingBluetooth errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingBond"
           c:symbol-prefix="setting_bond"
           c:type="NMSettingBond"
           parent="Setting"
           glib:type-name="NMSettingBond"
           glib:get-type="nm_setting_bond_get_type"
           glib:type-struct="SettingBondClass">
      <constructor name="new" c:identifier="nm_setting_bond_new">
        <doc xml:space="preserve">Creates a new #NMSettingBond object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBond object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <function name="validate_option"
                c:identifier="nm_setting_bond_validate_option"
                version="0.9.10">
        <doc xml:space="preserve">Checks whether @name is a valid bond option and @value is a valid value for
the @name. If @value is %NULL, the function only validates the option name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE, if the @value is valid for the given name.
If the @name is not a valid option, %FALSE will be returned.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the option to validate</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">the value of the option to validate</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_option" c:identifier="nm_setting_bond_add_option">
        <doc xml:space="preserve">Add an option to the table.  The option is compared to an internal list
of allowed options.  Option names may contain only alphanumeric characters
(ie [a-zA-Z0-9]).  Adding a new name replaces any existing name/value pair
that may already exist.

The order of how to set several options is relevant because there are options
that conflict with each other.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was valid and was added to the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_bond_get_interface_name">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBond:interface-name property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_options"
              c:identifier="nm_setting_bond_get_num_options">
        <doc xml:space="preserve">Returns the number of options that should be set for this bond when it
is activated. This can be used to retrieve each option individually
using nm_setting_bond_get_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bonding options</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_option" c:identifier="nm_setting_bond_get_option">
        <doc xml:space="preserve">Given an index, return the value of the bonding option at that index.  Indexes
are *not* guaranteed to be static across modifications to options done by
nm_setting_bond_add_option() and nm_setting_bond_remove_option(),
and should not be used to refer to options except for short periods of time
such as during option iteration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success if the index was valid and an option was found,
%FALSE if the index was invalid (ie, greater than the number of options
currently held by the setting)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the desired option, from 0 to
nm_setting_bond_get_num_options() - 1</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, the name of the bonding option; this
value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, the value of the name of the bonding
option; this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_option_by_name"
              c:identifier="nm_setting_bond_get_option_by_name">
        <doc xml:space="preserve">Returns the value associated with the bonding option specified by
@name, if it exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value, or %NULL if the key/value pair was never added to the
setting; the value is owned by the setting and must not be modified</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the option name for which to retrieve the value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_option_default"
              c:identifier="nm_setting_bond_get_option_default">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value of the bond option if not overridden by an entry in
  the #NMSettingBond:options property.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_options"
              c:identifier="nm_setting_bond_get_valid_options">
        <doc xml:space="preserve">Returns a list of valid bond options.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %NULL-terminated array of strings of valid bond options.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_option"
              c:identifier="nm_setting_bond_remove_option">
        <doc xml:space="preserve">Remove the bonding option referenced by @name from the internal option
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was found and removed from the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBond</doc>
            <type name="SettingBond" c:type="NMSettingBond*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">name of the option to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="interface-name" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the virtual in-kernel bonding network interface</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="options"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of bonding options.  Both keys and values
must be strings. Option names must contain only alphanumeric characters
(ie, [a-zA-Z0-9]).</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBondClass"
            c:type="NMSettingBondClass"
            glib:is-gtype-struct-for="SettingBond">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingBondError"
                 glib:type-name="NMSettingBondError"
                 glib:get-type="nm_setting_bond_error_get_type"
                 c:type="NMSettingBondError"
                 glib:error-domain="nm-setting-bond-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_BOND_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_BOND_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_BOND_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is</doc>
      </member>
      <member name="InvalidOption"
              value="3"
              c:identifier="NM_SETTING_BOND_ERROR_INVALID_OPTION"
              glib:nick="InvalidOption">
        <doc xml:space="preserve">the option was invalid</doc>
      </member>
      <member name="MissingOption"
              value="4"
              c:identifier="NM_SETTING_BOND_ERROR_MISSING_OPTION"
              glib:nick="MissingOption">
        <doc xml:space="preserve">the option was missing
required</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_bond_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingBond if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingBond errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingBridge"
           c:symbol-prefix="setting_bridge"
           c:type="NMSettingBridge"
           parent="Setting"
           glib:type-name="NMSettingBridge"
           glib:get-type="nm_setting_bridge_get_type"
           glib:type-struct="SettingBridgeClass">
      <constructor name="new"
                   c:identifier="nm_setting_bridge_new"
                   version="0.9.8">
        <doc xml:space="preserve">Creates a new #NMSettingBridge object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBridge object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_ageing_time"
              c:identifier="nm_setting_bridge_get_ageing_time"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:ageing-time property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_forward_delay"
              c:identifier="nm_setting_bridge_get_forward_delay"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:forward-delay property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hello_time"
              c:identifier="nm_setting_bridge_get_hello_time"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:hello-time property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_bridge_get_interface_name"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:interface-name property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_bridge_get_mac_address"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_age"
              c:identifier="nm_setting_bridge_get_max_age"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:max-age property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority"
              c:identifier="nm_setting_bridge_get_priority"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:priority property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stp"
              c:identifier="nm_setting_bridge_get_stp"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridge:stp property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridge</doc>
            <type name="SettingBridge" c:type="NMSettingBridge*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="ageing-time"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Ethernet MAC address aging time, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="forward-delay"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) forwarding delay, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="hello-time"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) hello time, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="interface-name"
                version="0.9.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The name of the virtual in-kernel bridging network interface</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mac-address"
                version="0.9.10"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, the MAC address of bridge. When creating a new bridge, this
MAC address will be set. When matching an existing (outside
NetworkManager created) bridge, this MAC address must match.</doc>
        <type/>
      </property>
      <property name="max-age"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) maximum message age, in seconds.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="priority"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Sets the Spanning Tree Protocol (STP) priority for this bridge.  Lower
values are "better"; the lowest priority bridge will be elected the root
bridge.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="stp"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Controls whether Spanning Tree Protocol (STP) is enabled for this bridge.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBridgeClass"
            c:type="NMSettingBridgeClass"
            glib:is-gtype-struct-for="SettingBridge">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingBridgeError"
                 version="0.9.8"
                 glib:type-name="NMSettingBridgeError"
                 glib:get-type="nm_setting_bridge_error_get_type"
                 c:type="NMSettingBridgeError"
                 glib:error-domain="nm-setting-bridge-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_BRIDGE_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_BRIDGE_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_BRIDGE_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_bridge_error_quark"
                version="0.9.8">
        <doc xml:space="preserve">Registers an error quark for #NMSettingBridge if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingBridge errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingBridgePort"
           c:symbol-prefix="setting_bridge_port"
           c:type="NMSettingBridgePort"
           parent="Setting"
           glib:type-name="NMSettingBridgePort"
           glib:get-type="nm_setting_bridge_port_get_type"
           glib:type-struct="SettingBridgePortClass">
      <constructor name="new"
                   c:identifier="nm_setting_bridge_port_new"
                   version="0.9.8">
        <doc xml:space="preserve">Creates a new #NMSettingBridgePort object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingBridgePort object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_hairpin_mode"
              c:identifier="nm_setting_bridge_port_get_hairpin_mode"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridgePort:hairpin-mode property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridgePort</doc>
            <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path_cost"
              c:identifier="nm_setting_bridge_port_get_path_cost"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridgePort:path-cost property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridgePort</doc>
            <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority"
              c:identifier="nm_setting_bridge_port_get_priority"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingBridgePort:priority property of the setting</doc>
          <type name="guint16" c:type="guint16"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingBridgePort</doc>
            <type name="SettingBridgePort" c:type="NMSettingBridgePort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="hairpin-mode"
                version="0.9.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Enables or disables "hairpin mode" for the port, which allows frames to
be sent back out through the port the frame was received on.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="path-cost"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) port cost for destinations via this
port.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="priority"
                version="0.9.8"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The Spanning Tree Protocol (STP) priority of this bridge port.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingBridgePortClass"
            c:type="NMSettingBridgePortClass"
            glib:is-gtype-struct-for="SettingBridgePort">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingBridgePortError"
                 version="0.9.8"
                 glib:type-name="NMSettingBridgePortError"
                 glib:get-type="nm_setting_bridge_port_error_get_type"
                 c:type="NMSettingBridgePortError"
                 glib:error-domain="nm-setting-bridge-port-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_BRIDGE_PORT_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_BRIDGE_PORT_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_BRIDGE_PORT_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and
is required</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_bridge_port_error_quark"
                version="0.9.8">
        <doc xml:space="preserve">Registers an error quark for #NMSettingBridgePort if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingBridgePort errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingCdma"
           c:symbol-prefix="setting_cdma"
           c:type="NMSettingCdma"
           parent="Setting"
           glib:type-name="NMSettingCdma"
           glib:get-type="nm_setting_cdma_get_type"
           glib:type-struct="SettingCdmaClass">
      <constructor name="new" c:identifier="nm_setting_cdma_new">
        <doc xml:space="preserve">Creates a new #NMSettingCdma object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingCdma object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_number" c:identifier="nm_setting_cdma_get_number">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingCdma:number property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="nm_setting_cdma_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingCdma:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_cdma_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingCdma:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_cdma_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingCdma:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingCdma</doc>
            <type name="SettingCdma" c:type="NMSettingCdma*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="number" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The number to dial to establish the connection to the CDMA-based mobile
broadband network, if any.  If not specified, the default number (#777)
is used when required.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The password used to authenticate with the network, if required.  Many
providers do not require a password, or accept any password.  But if a
password is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingCdma:password property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The username used to authenticate with the network, if required.  Many
providers do not require a username, or accept any username.  But if a
username is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingCdmaClass"
            c:type="NMSettingCdmaClass"
            glib:is-gtype-struct-for="SettingCdma">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingCdmaError"
                 glib:type-name="NMSettingCdmaError"
                 glib:get-type="nm_setting_cdma_error_get_type"
                 c:type="NMSettingCdmaError"
                 glib:error-domain="nm-setting-cdma-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_CDMA_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_CDMA_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_CDMA_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="MissingSerialSetting"
              value="3"
              c:identifier="NM_SETTING_CDMA_ERROR_MISSING_SERIAL_SETTING"
              glib:nick="MissingSerialSetting">
        <doc xml:space="preserve">the required #NMSettingSerial
is missing in the connection</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_cdma_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingCdma if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingCdma errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="SettingClass"
            c:type="NMSettingClass"
            glib:is-gtype-struct-for="Setting">
      <field name="parent">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="verify" introspectable="0">
        <callback name="verify" introspectable="0" throws="1">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="all_settings" transfer-ownership="none">
              <type name="GLib.SList" c:type="GSList*">
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="need_secrets">
        <callback name="need_secrets">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">a #GPtrArray containing
the property names of secrets of the #NMSetting which may be required; the
caller owns the array and must free it with g_ptr_array_free(), but must not
free the elements.</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <doc xml:space="preserve">the #NMSetting</doc>
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="update_one_secret">
        <callback name="update_one_secret" throws="1">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GObject.Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_secret_flags">
        <callback name="get_secret_flags" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="secret_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="verify_secret" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="out_flags" transfer-ownership="none">
              <type name="SettingSecretFlags" c:type="NMSettingSecretFlags*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_secret_flags">
        <callback name="set_secret_flags" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="secret_name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
            <parameter name="verify_secret" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="compare_property">
        <callback name="compare_property">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="other" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="prop_spec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="const GParamSpec*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SettingCompareFlags" c:type="NMSettingCompareFlags"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_secrets_with_flags" introspectable="0">
        <callback name="clear_secrets_with_flags" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="func" transfer-ownership="none" closure="3">
              <type name="SettingClearSecretsWithFlagsFn"
                    c:type="NMSettingClearSecretsWithFlagsFn"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_virtual_iface_name">
        <callback name="get_virtual_iface_name">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Name of the virtual interface or %NULL if the setting does not
support this feature</doc>
            <type name="utf8" c:type="const char*"/>
          </return-value>
          <parameters>
            <parameter name="setting" transfer-ownership="none">
              <doc xml:space="preserve">the #NMSetting</doc>
              <type name="Setting" c:type="NMSetting*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="SettingClearSecretsWithFlagsFn"
              c:type="NMSettingClearSecretsWithFlagsFn">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE to clear the secret, %FALSE to not clear the secret</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve">The setting for which secrets are being iterated</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </parameter>
        <parameter name="secret" transfer-ownership="none">
          <doc xml:space="preserve">The secret's name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">The secret's flags, eg %NM_SETTING_SECRET_FLAG_AGENT_OWNED</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">User data passed to nm_connection_clear_secrets_with_flags()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SettingCompareFlags"
                 glib:type-name="NMSettingCompareFlags"
                 glib:get-type="nm_setting_compare_flags_get_type"
                 c:type="NMSettingCompareFlags">
      <doc xml:space="preserve">These flags modify the comparison behavior when comparing two settings or
two connections.</doc>
      <member name="exact"
              value="0"
              c:identifier="NM_SETTING_COMPARE_FLAG_EXACT"
              glib:nick="exact">
        <doc xml:space="preserve">match all properties exactly</doc>
      </member>
      <member name="fuzzy"
              value="1"
              c:identifier="NM_SETTING_COMPARE_FLAG_FUZZY"
              glib:nick="fuzzy">
        <doc xml:space="preserve">match only important attributes, like SSID,
  type, security settings, etc.  Does not match, for example, connection ID
  or UUID.</doc>
      </member>
      <member name="ignore_id"
              value="2"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_ID"
              glib:nick="ignore-id">
        <doc xml:space="preserve">ignore the connection's ID</doc>
      </member>
      <member name="ignore_secrets"
              value="4"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS"
              glib:nick="ignore-secrets">
        <doc xml:space="preserve">ignore all secrets</doc>
      </member>
      <member name="ignore_agent_owned_secrets"
              value="8"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS"
              glib:nick="ignore-agent-owned-secrets">
        <doc xml:space="preserve">ignore secrets for which
the secret's flags indicate the secret is owned by a user secret agent
(ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_AGENT_OWNED)</doc>
      </member>
      <member name="ignore_not_saved_secrets"
              value="16"
              c:identifier="NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS"
              glib:nick="ignore-not-saved-secrets">
        <doc xml:space="preserve">ignore secrets for which
the secret's flags indicate the secret should not be saved to persistent
storage (ie, the secret's flag includes @NM_SETTING_SECRET_FLAG_NOT_SAVED)</doc>
      </member>
      <member name="diff_result_with_default"
              value="32"
              c:identifier="NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT"
              glib:nick="diff-result-with-default">
        <doc xml:space="preserve">if this flag is set,
nm_setting_diff() and nm_connection_diff() will also include properties that
are set to their default value. See also @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT.</doc>
      </member>
      <member name="diff_result_no_default"
              value="64"
              c:identifier="NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT"
              glib:nick="diff-result-no-default">
        <doc xml:space="preserve">if this flag is set,
nm_setting_diff() and nm_connection_diff() will not include properties that
are set to their default value. This is the opposite of
@NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT. If both flags are set together,
@NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT wins. If both flags are unset,
this means to exclude default properties if there is a setting to compare,
but include all properties, if the setting 'b' is missing. This is the legacy
behaviour of libnm-util, where nm_setting_diff() behaved differently depending
on whether the setting 'b' was available. If @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT
is set, nm_setting_diff() will also set the flags @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT
and @NM_SETTING_DIFF_RESULT_IN_B_DEFAULT, if the values are default values.</doc>
      </member>
    </enumeration>
    <class name="SettingConnection"
           c:symbol-prefix="setting_connection"
           c:type="NMSettingConnection"
           parent="Setting"
           glib:type-name="NMSettingConnection"
           glib:get-type="nm_setting_connection_get_type"
           glib:type-struct="SettingConnectionClass">
      <doc xml:space="preserve">The NMSettingConnection struct contains only private data.
It should only be accessed through the functions described below.</doc>
      <constructor name="new" c:identifier="nm_setting_connection_new">
        <doc xml:space="preserve">Creates a new #NMSettingConnection object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingConnection object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_permission"
              c:identifier="nm_setting_connection_add_permission">
        <doc xml:space="preserve">Adds a permission to the connection's permission list.  At this time, only
the "user" permission type is supported, and @pitem must be a username. See
#NMSettingConnection:permissions: for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was unique and was successfully added to the
list, %FALSE if @ptype or @pitem was invalid or it the permission was already
present in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="ptype" transfer-ownership="none">
            <doc xml:space="preserve">the permission type; at this time only "user" is supported</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pitem" transfer-ownership="none">
            <doc xml:space="preserve">the permission item formatted as required for @ptype</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="detail"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">unused at this time; must be %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_secondary"
              c:identifier="nm_setting_connection_add_secondary"
              version="0.9.8">
        <doc xml:space="preserve">Adds a new secondary connetion UUID to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secondary connection UUID was added; %FALSE if the UUID
was already present</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="sec_uuid" transfer-ownership="none">
            <doc xml:space="preserve">the secondary connection UUID to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_autoconnect"
              c:identifier="nm_setting_connection_get_autoconnect">
        <doc xml:space="preserve">Returns the #NMSettingConnection:autoconnect property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's autoconnect behavior</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_connection_type"
              c:identifier="nm_setting_connection_get_connection_type">
        <doc xml:space="preserve">Returns the #NMSettingConnection:type property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection type</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gateway_ping_timeout"
              c:identifier="nm_setting_connection_get_gateway_ping_timeout"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value contained in the #NMSettingConnection:gateway-ping-timeout
property.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_setting_connection_get_id">
        <doc xml:space="preserve">Returns the #NMSettingConnection:id property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection ID</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_connection_get_interface_name"
              version="0.9.10">
        <doc xml:space="preserve">Returns the #NMSettingConnection:interface-name property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's interface name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_master"
              c:identifier="nm_setting_connection_get_master">
        <doc xml:space="preserve">Returns the #NMSettingConnection:master property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">interface name of the master device or UUID of the master
connection.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_permissions"
              c:identifier="nm_setting_connection_get_num_permissions">
        <doc xml:space="preserve">Returns the number of entries in the #NMSettingConnection:permissions
property of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of permissions entries</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_secondaries"
              c:identifier="nm_setting_connection_get_num_secondaries"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured secondary connection UUIDs</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_permission"
              c:identifier="nm_setting_connection_get_permission">
        <doc xml:space="preserve">Retrieve one of the entries of the #NMSettingConnection:permissions property
of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a permission was returned, %FALSE if @idx was invalid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the permissions entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_ptype" transfer-ownership="none">
            <doc xml:space="preserve">on return, the permission type (at this time, always "user")</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_pitem" transfer-ownership="none">
            <doc xml:space="preserve">on return, the permission item (formatted accoring to @ptype, see
#NMSettingConnection:permissions for more detail</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_detail" transfer-ownership="none">
            <doc xml:space="preserve">on return, the permission detail (at this time, always %NULL)</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_read_only"
              c:identifier="nm_setting_connection_get_read_only">
        <doc xml:space="preserve">Returns the #NMSettingConnection:read-only property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the connection is read-only, %FALSE if it is not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secondary"
              c:identifier="nm_setting_connection_get_secondary"
              version="0.9.8">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the secondary connection UUID at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the secondary connection UUID entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_slave_type"
              c:identifier="nm_setting_connection_get_slave_type">
        <doc xml:space="preserve">Returns the #NMSettingConnection:slave-type property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of slave this connection is, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timestamp"
              c:identifier="nm_setting_connection_get_timestamp">
        <doc xml:space="preserve">Returns the #NMSettingConnection:timestamp property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection's timestamp</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uuid" c:identifier="nm_setting_connection_get_uuid">
        <doc xml:space="preserve">Returns the #NMSettingConnection:uuid property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the connection UUID</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_zone" c:identifier="nm_setting_connection_get_zone">
        <doc xml:space="preserve">Returns the #NMSettingConnection:zone property of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the trust level of a connection</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_slave_type"
              c:identifier="nm_setting_connection_is_slave_type">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if connection is of the given slave @type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the setting name (ie #NM_SETTING_BOND_SETTING_NAME) to be matched
against @setting's slave type</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="permissions_user_allowed"
              c:identifier="nm_setting_connection_permissions_user_allowed">
        <doc xml:space="preserve">Checks whether the given username is allowed to view/access this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the requested user is allowed to view this connection,
%FALSE if the given user is not allowed to view this connection</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="uname" transfer-ownership="none">
            <doc xml:space="preserve">the user name to check permissions for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_permission"
              c:identifier="nm_setting_connection_remove_permission">
        <doc xml:space="preserve">Removes the permission at index @idx from the connection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the permission to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_permission_by_value"
              c:identifier="nm_setting_connection_remove_permission_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the permission from the connection.
At this time, only the "user" permission type is supported, and @pitem must
be a username. See #NMSettingConnection:permissions: for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the permission was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="ptype" transfer-ownership="none">
            <doc xml:space="preserve">the permission type; at this time only "user" is supported</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pitem" transfer-ownership="none">
            <doc xml:space="preserve">the permission item formatted as required for @ptype</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="detail"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">unused at this time; must be %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_secondary"
              c:identifier="nm_setting_connection_remove_secondary"
              version="0.9.8">
        <doc xml:space="preserve">Removes the secondary coonnection UUID at index @idx.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the secondary connection UUID</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_secondary_by_value"
              c:identifier="nm_setting_connection_remove_secondary_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the secondary coonnection UUID @sec_uuid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secondary connection UUID was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingConnection</doc>
            <type name="SettingConnection" c:type="NMSettingConnection*"/>
          </instance-parameter>
          <parameter name="sec_uuid" transfer-ownership="none">
            <doc xml:space="preserve">the secondary connection UUID to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="autoconnect"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Whether or not the connection should be automatically connected by
NetworkManager when the resources for the connection are available.
%TRUE to automatically activate the connection, %FALSE to require manual
intervention to activate the connection.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="gateway-ping-timeout"
                version="0.9.10"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If greater than zero, delay success of IP addressing until either the
timeout is reached, or an IP gateway replies to a ping.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="id" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A human readable unique identifier for the connection, like "Work Wi-Fi"
or "T-Mobile 3G".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="interface-name"
                version="0.9.10"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The name of the network interface this connection is bound to. If not
set, then the connection can be attached to any interface of the
appropriate type (subject to restrictions imposed by other settings).

For software devices this specifies the name of the created device.

For connection types where interface names cannot easily be made
persistent (e.g. mobile broadband or USB Ethernet), this property should
not be used. Setting this property restricts the interfaces a connection
can be used with, and if interface names change or are reordered the
connection may be applied to the wrong interface.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="master" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Interface name of the master device or UUID of the master connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="permissions"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of strings defining what access a given user has to this
connection.  If this is %NULL or empty, all users are allowed to access
this connection.  Otherwise a user is allowed to access this connection
if and only if they are in this list. Each entry is of the form
"[type]:[id]:[reserved]"; for example, "user:dcbw:blah".

At this time only the "user" [type] is allowed.  Any other values are
ignored and reserved for future use.  [id] is the username that this
permission refers to, which may not contain the ":" character. Any
[reserved] information present must be ignored and is reserved for future
use.  All of [type], [id], and [reserved] must be valid UTF-8.</doc>
        <type/>
      </property>
      <property name="read-only"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if the connection can be modified using the provided settings
service's D-Bus interface with the right privileges, or %TRUE if the
connection is read-only and cannot be modified.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="secondaries"
                version="0.9.8"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of connection UUIDs that should be activated when the base
connection itself is activated. Currently only VPN connections are
supported.</doc>
        <type/>
      </property>
      <property name="slave-type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Setting name of the device type of this slave's master connection (eg,
%NM_SETTING_BOND_SETTING_NAME), or %NULL if this connection is not a
slave.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="timestamp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The time, in seconds since the Unix Epoch, that the connection was last
_successfully_ fully activated.

NetworkManager updates the connection timestamp periodically when the
connection is active to ensure that an active connection has the latest
timestamp. The property is only meant for reading (changes to this
property will not be preserved).</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Base type of the connection. For hardware-dependent connections, should
contain the setting name of the hardware-type specific setting (ie,
"802-3-ethernet" or "802-11-wireless" or "bluetooth", etc), and for
non-hardware dependent connections like VPN or otherwise, should contain
the setting name of that setting type (ie, "vpn" or "bridge", etc).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uuid" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A universally unique identifier for the connection, for example generated
with libuuid.  It should be assigned when the connection is created, and
never changed as long as the connection still applies to the same
network.  For example, it should not be changed when the
#NMSettingConnection:id property or #NMSettingIP4Config changes, but
might need to be re-created when the Wi-Fi SSID, mobile broadband network
provider, or #NMSettingConnection:type property changes.

The UUID must be in the format "2815492f-7e56-435e-b2e9-246bd7cdc664"
(ie, contains only hexadecimal characters and "-").  A suitable UUID may
be generated by nm_utils_uuid_generate() or
nm_utils_uuid_generate_from_string().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="zone"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The trust level of a the connection.  Free form case-insensitive string
(for example "Home", "Work", "Public").  %NULL or unspecified zone means
the connection will be placed in the default zone as defined by the
firewall.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingConnectionClass"
            c:type="NMSettingConnectionClass"
            glib:is-gtype-struct-for="SettingConnection">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingConnectionError"
                 glib:type-name="NMSettingConnectionError"
                 glib:get-type="nm_setting_connection_error_get_type"
                 c:type="NMSettingConnectionError"
                 glib:error-domain="nm-setting-connection-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a
#NMSettingConnection.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_CONNECTION_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_CONNECTION_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property's value is
  invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_CONNECTION_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">a required property is not
  present</doc>
      </member>
      <member name="TypeSettingNotFound"
              value="3"
              c:identifier="NM_SETTING_CONNECTION_ERROR_TYPE_SETTING_NOT_FOUND"
              glib:nick="TypeSettingNotFound">
        <doc xml:space="preserve">the #NMSetting object
  referenced by the setting name contained in the
  #NMSettingConnection:type property was not present in the #NMConnection</doc>
      </member>
      <member name="IpConfigNotAllowed"
              value="4"
              c:identifier="NM_SETTING_CONNECTION_ERROR_IP_CONFIG_NOT_ALLOWED"
              glib:nick="IpConfigNotAllowed">
        <doc xml:space="preserve">ip configuration is not
  allowed to be present.</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_connection_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingConnection if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingConnection errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingDcb"
           c:symbol-prefix="setting_dcb"
           c:type="NMSettingDcb"
           parent="Setting"
           glib:type-name="NMSettingDcb"
           glib:get-type="nm_setting_dcb_get_type"
           glib:type-struct="SettingDcbClass">
      <constructor name="new"
                   c:identifier="nm_setting_dcb_new"
                   version="0.9.10">
        <doc xml:space="preserve">Creates a new #NMSettingDcb object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingDcb object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_app_fcoe_flags"
              c:identifier="nm_setting_dcb_get_app_fcoe_flags"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fcoe-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fcoe_mode"
              c:identifier="nm_setting_dcb_get_app_fcoe_mode"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fcoe-mode property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fcoe_priority"
              c:identifier="nm_setting_dcb_get_app_fcoe_priority"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fcoe-priority property of the setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fip_flags"
              c:identifier="nm_setting_dcb_get_app_fip_flags"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fip-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_fip_priority"
              c:identifier="nm_setting_dcb_get_app_fip_priority"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-fip-priority property of the setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_iscsi_flags"
              c:identifier="nm_setting_dcb_get_app_iscsi_flags"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-iscsi-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_app_iscsi_priority"
              c:identifier="nm_setting_dcb_get_app_iscsi_priority"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:app-iscsi-priority property of the setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority_bandwidth"
              c:identifier="nm_setting_dcb_get_priority_bandwidth"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the allowed bandwidth percentage of @user_priority in its priority group.
These values are only valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve the group bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_flow_control"
              c:identifier="nm_setting_dcb_get_priority_flow_control"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if flow control is enabled for the given @user_priority,
%FALSE if not enabled</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve flow control for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_flow_control_flags"
              c:identifier="nm_setting_dcb_get_priority_flow_control_flags"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:priority-flow-control-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority_group_bandwidth"
              c:identifier="nm_setting_dcb_get_priority_group_bandwidth"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the bandwidth percentage assigned to @group_id.  These values are
only valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="group_id" transfer-ownership="none">
            <doc xml:space="preserve">the priority group (0 - 7) to retrieve the bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_group_flags"
              c:identifier="nm_setting_dcb_get_priority_group_flags"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingDcb:priority-group-flags property of the setting</doc>
          <type name="SettingDcbFlags" c:type="NMSettingDcbFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority_group_id"
              c:identifier="nm_setting_dcb_get_priority_group_id"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the group number @user_priority is assigned to.  These values are
only valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve the group ID for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_strict_bandwidth"
              c:identifier="nm_setting_dcb_get_priority_strict_bandwidth"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @user_priority may use all of the bandwidth allocated to its
assigned group, or %FALSE if not. These values are only valid when
#NMSettingDcb:priority-group-flags includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve strict bandwidth for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_priority_traffic_class"
              c:identifier="nm_setting_dcb_get_priority_traffic_class"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the traffic class assigned to @user_priority. These values are only
valid when #NMSettingDcb:priority-group-flags includes the
%NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to retrieve the traffic class for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_bandwidth"
              c:identifier="nm_setting_dcb_set_priority_bandwidth"
              version="0.9.10">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set the bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bandwidth_percent" transfer-ownership="none">
            <doc xml:space="preserve">the bandwidth percentage (0 - 100) that @user_priority is
allowed to use within its priority group</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_flow_control"
              c:identifier="nm_setting_dcb_set_priority_flow_control"
              version="0.9.10">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-flow-control includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set flow control for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to enable flow control for this priority, %FALSE to disable it</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_group_bandwidth"
              c:identifier="nm_setting_dcb_set_priority_group_bandwidth"
              version="0.9.10">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="group_id" transfer-ownership="none">
            <doc xml:space="preserve">the priority group (0 - 7) to set the bandwidth percentage for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bandwidth_percent" transfer-ownership="none">
            <doc xml:space="preserve">the bandwidth percentage (0 - 100) to assign to @group_id to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_group_id"
              c:identifier="nm_setting_dcb_set_priority_group_id"
              version="0.9.10">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set flow control for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="group_id" transfer-ownership="none">
            <doc xml:space="preserve">the group (0 - 7) to assign @user_priority to, or 15 for the
unrestricted group.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_strict_bandwidth"
              c:identifier="nm_setting_dcb_set_priority_strict_bandwidth"
              version="0.9.10">
        <doc xml:space="preserve">These values are only valid when #NMSettingDcb:priority-group-flags includes
the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingDcb</doc>
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <doc xml:space="preserve">the User Priority (0 - 7) to set strict bandwidth for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="strict" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to allow @user_priority to use all the bandwidth allocated to
its priority group, or %FALSE if not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_traffic_class"
              c:identifier="nm_setting_dcb_set_priority_traffic_class">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="SettingDcb" c:type="NMSettingDcb*"/>
          </instance-parameter>
          <parameter name="user_priority" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="traffic_class" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="app-fcoe-flags"
                version="0.9.10"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for the DCB FCoE application.  Flags may
be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="app-fcoe-mode"
                version="0.9.10"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The FCoE controller mode; either %NM_SETTING_DCB_FCOE_MODE_FABRIC
(default) or %NM_SETTING_DCB_FCOE_MODE_VN2VN.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="app-fcoe-priority"
                version="0.9.10"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The highest User Priority (0 - 7) which FCoE frames should use, or -1 for
default priority.  Only used when the #NMSettingDcb:app-fcoe-flags
property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="app-fip-flags"
                version="0.9.10"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for the DCB FIP application.  Flags may
be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="app-fip-priority"
                version="0.9.10"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The highest User Priority (0 - 7) which FIP frames should use, or -1 for
default priority.  Only used when the #NMSettingDcb:app-fip-flags
property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="app-iscsi-flags"
                version="0.9.10"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for the DCB iSCSI application.  Flags
may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="app-iscsi-priority"
                version="0.9.10"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The highest User Priority (0 - 7) which iSCSI frames should use, or -1
for default priority. Only used when the #NMSettingDcb:app-iscsi-flags
property includes the %NM_SETTING_DCB_FLAG_ENABLE flag.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="priority-bandwidth"
                version="0.9.10"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates the percentage of bandwidth of
the priority's assigned group that the priority may use.  The sum of all
percentages for priorities which belong to the same group must total 100
percents.</doc>
        <type/>
      </property>
      <property name="priority-flow-control"
                version="0.9.10"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates whether or not the corresponding
priority should transmit priority pause.  Allowed values are 0 (do not
transmit pause) and 1 (transmit pause).</doc>
        <type/>
      </property>
      <property name="priority-flow-control-flags"
                version="0.9.10"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for DCB Priority Flow Control (PFC).
Flags may be any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="priority-group-bandwidth"
                version="0.9.10"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the
Priority Group ID (0 - 7) and the value indicates the percentage of link
bandwidth allocated to that group.  Allowed values are 0 - 100, and the
sum of all values must total 100 percents.</doc>
        <type/>
      </property>
      <property name="priority-group-flags"
                version="0.9.10"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Specifies the #NMSettingDcbFlags for DCB Priority Groups.  Flags may be
any combination of %NM_SETTING_DCB_FLAG_ENABLE,
%NM_SETTING_DCB_FLAG_ADVERTISE, and %NM_SETTING_DCB_FLAG_WILLING.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="priority-group-id"
                version="0.9.10"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates the Priority Group ID.  Allowed
Priority Group ID values are 0 - 7 or 15 for the unrestricted group.</doc>
        <type/>
      </property>
      <property name="priority-strict-bandwidth"
                version="0.9.10"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates whether or not the priority may
use all of the bandwidth allocated to its assigned group.  Allowed values
are 0 (the priority may not utilize all bandwidth) or 1 (the priority may
utilize all bandwidth).</doc>
        <type/>
      </property>
      <property name="priority-traffic-class"
                version="0.9.10"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">An array of 8 uint values, where the array index corresponds to the User
Priority (0 - 7) and the value indicates the traffic class (0 - 7) to
which the priority is mapped.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingDcbClass"
            c:type="NMSettingDcbClass"
            glib:is-gtype-struct-for="SettingDcb">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingDcbError"
                 glib:type-name="NMSettingDcbError"
                 glib:get-type="nm_setting_dcb_error_get_type"
                 c:type="NMSettingDcbError"
                 glib:error-domain="nm-setting-dcb-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_DCB_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_DCB_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_DCB_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_dcb_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMSettingDcb if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingDcb errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingDcbFlags"
                 version="0.9.10"
                 glib:type-name="NMSettingDcbFlags"
                 glib:get-type="nm_setting_dcb_flags_get_type"
                 c:type="NMSettingDcbFlags">
      <doc xml:space="preserve">DCB feature flags.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_DCB_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flag</doc>
      </member>
      <member name="enable"
              value="1"
              c:identifier="NM_SETTING_DCB_FLAG_ENABLE"
              glib:nick="enable">
        <doc xml:space="preserve">the feature is enabled</doc>
      </member>
      <member name="advertise"
              value="2"
              c:identifier="NM_SETTING_DCB_FLAG_ADVERTISE"
              glib:nick="advertise">
        <doc xml:space="preserve">the feature is advertised</doc>
      </member>
      <member name="willing"
              value="4"
              c:identifier="NM_SETTING_DCB_FLAG_WILLING"
              glib:nick="willing">
        <doc xml:space="preserve">the feature is willing to change based on
peer configuration advertisements</doc>
      </member>
    </enumeration>
    <enumeration name="SettingDiffResult"
                 glib:type-name="NMSettingDiffResult"
                 glib:get-type="nm_setting_diff_result_get_type"
                 c:type="NMSettingDiffResult">
      <doc xml:space="preserve">These values indicate the result of a setting difference operation.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_DIFF_RESULT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown result</doc>
      </member>
      <member name="in_a"
              value="1"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_A"
              glib:nick="in-a">
        <doc xml:space="preserve">the property is present in setting A</doc>
      </member>
      <member name="in_b"
              value="2"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_B"
              glib:nick="in-b">
        <doc xml:space="preserve">the property is present in setting B</doc>
      </member>
      <member name="in_a_default"
              value="4"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_A_DEFAULT"
              glib:nick="in-a-default">
        <doc xml:space="preserve">the property is present in
setting A but is set to the default value. This flag is only set,
if you specify @NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT.</doc>
      </member>
      <member name="in_b_default"
              value="4"
              c:identifier="NM_SETTING_DIFF_RESULT_IN_B_DEFAULT"
              glib:nick="in-b-default">
        <doc xml:space="preserve">analog to @NM_SETTING_DIFF_RESULT_IN_A_DEFAULT.</doc>
      </member>
    </enumeration>
    <enumeration name="SettingError"
                 glib:type-name="NMSettingError"
                 glib:get-type="nm_setting_error_get_type"
                 c:type="NMSettingError"
                 glib:error-domain="nm-setting-error-quark">
      <doc xml:space="preserve">Describes errors that may result from operations involving a #NMSetting.</doc>
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="PropertyNotFound"
              value="1"
              c:identifier="NM_SETTING_ERROR_PROPERTY_NOT_FOUND"
              glib:nick="PropertyNotFound">
        <doc xml:space="preserve">a property required by the operation
  was not found; for example, an attempt to update an invalid secret</doc>
      </member>
      <member name="PropertyNotSecret"
              value="2"
              c:identifier="NM_SETTING_ERROR_PROPERTY_NOT_SECRET"
              glib:nick="PropertyNotSecret">
        <doc xml:space="preserve">an operation which requires a secret
  was attempted on a non-secret property</doc>
      </member>
      <member name="PropertyTypeMismatch"
              value="3"
              c:identifier="NM_SETTING_ERROR_PROPERTY_TYPE_MISMATCH"
              glib:nick="PropertyTypeMismatch">
        <doc xml:space="preserve">the operation requires a property
  of a specific type, or the value couldn't be transformed to the same type
  as the property being acted upon</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSetting if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for NMSetting errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingGeneric"
           c:symbol-prefix="setting_generic"
           c:type="NMSettingGeneric"
           parent="Setting"
           glib:type-name="NMSettingGeneric"
           glib:get-type="nm_setting_generic_get_type"
           glib:type-struct="SettingGenericClass">
      <constructor name="new"
                   c:identifier="nm_setting_generic_new"
                   version="0.9.10">
        <doc xml:space="preserve">Creates a new #NMSettingGeneric object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingGeneric object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingGenericClass"
            c:type="NMSettingGenericClass"
            glib:is-gtype-struct-for="SettingGeneric">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingGenericError"
                 version="0.9.10"
                 glib:type-name="NMSettingGenericError"
                 glib:get-type="nm_setting_generic_error_get_type"
                 c:type="NMSettingGenericError"
                 glib:error-domain="nm-setting-generic-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_GENERIC_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_GENERIC_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_GENERIC_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and
is required</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_generic_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMSettingGeneric if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingGeneric errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingGsm"
           c:symbol-prefix="setting_gsm"
           c:type="NMSettingGsm"
           parent="Setting"
           glib:type-name="NMSettingGsm"
           glib:get-type="nm_setting_gsm_get_type"
           glib:type-struct="SettingGsmClass">
      <constructor name="new" c:identifier="nm_setting_gsm_new">
        <doc xml:space="preserve">Creates a new #NMSettingGsm object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingGsm object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_allowed_bands"
              c:identifier="nm_setting_gsm_get_allowed_bands"
              deprecated="1"
              deprecated-version="0.9.10">
        <doc-deprecated xml:space="preserve">No longer used. Bands setting should be done talking to ModemManager directly.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:allowed-bands property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_apn" c:identifier="nm_setting_gsm_get_apn">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:apn property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_home_only" c:identifier="nm_setting_gsm_get_home_only">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:home-only property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_id"
              c:identifier="nm_setting_gsm_get_network_id">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:network-id property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_type"
              c:identifier="nm_setting_gsm_get_network_type"
              deprecated="1"
              deprecated-version="0.9.10">
        <doc-deprecated xml:space="preserve">No longer used. Network type setting should be done talking to ModemManager directly.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:network-type property of the setting</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_number" c:identifier="nm_setting_gsm_get_number">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:number property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password" c:identifier="nm_setting_gsm_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_gsm_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingGsm:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin" c:identifier="nm_setting_gsm_get_pin">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:pin property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pin_flags" c:identifier="nm_setting_gsm_get_pin_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingGsm:pin</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_gsm_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingGsm:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingGsm</doc>
            <type name="SettingGsm" c:type="NMSettingGsm*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="allowed-bands"
                deprecated="1"
                deprecated-version="0.9.10"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Bitfield of allowed frequency bands.  Note that not all devices allow
frequency band control.  Permitted values are those specified by
#NMSettingGsmNetworkBand.</doc>
        <doc-deprecated xml:space="preserve">No longer used. Band setting should be done by
talking to ModemManager directly.</doc-deprecated>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="apn" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The GPRS Access Point Name specifying the APN used when establishing a
data session with the GSM-based network.  The APN often determines how
the user will be billed for their network usage and whether the user has
access to the Internet or just a provider-specific walled-garden, so it
is important to use the correct APN for the user's mobile broadband plan.
The APN may only be composed of the characters a-z, 0-9, ., and - per GSM
03.60 Section 14.9.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="home-only" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">When %TRUE, only connections to the home network will be allowed.
Connections to roaming networks will not be made.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="network-id" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The Network ID (GSM LAI format, ie MCC-MNC) to force specific network
registration.  If the Network ID is specified, NetworkManager will
attempt to force the device to register only on the specified network.
This can be used to ensure that the device does not roam when direct
roaming control of the device is not otherwise possible.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="network-type"
                deprecated="1"
                deprecated-version="0.9.10"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Network preference to force the device to only use specific network
technologies. The permitted values are %NM_SETTING_GSM_NETWORK_TYPE_ANY,
%NM_SETTING_GSM_NETWORK_TYPE_UMTS_HSPA,
%NM_SETTING_GSM_NETWORK_TYPE_GPRS_EDGE,
%NM_SETTING_GSM_NETWORK_TYPE_PREFER_UMTS_HSPA,
%NM_SETTING_GSM_NETWORK_TYPE_PREFER_GPRS_EDGE,
%NM_SETTING_GSM_NETWORK_TYPE_PREFER_4G, and
%NM_SETTING_GSM_NETWORK_TYPE_4G.  Note that not all devices allow network
preference control.</doc>
        <doc-deprecated xml:space="preserve">No longer used. Network type setting should be done
by talking to ModemManager directly.</doc-deprecated>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="number" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Number to dial when establishing a PPP data session with the GSM-based
mobile broadband network.  Many modems do not require PPP for connections
to the mobile network and thus this property should be left blank, which
allows NetworkManager to select the appropriate settings automatically.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The password used to authenticate with the network, if required.  Many
providers do not require a password, or accept any password.  But if a
password is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingGsm:password property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="pin" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the SIM is locked with a PIN it must be unlocked before any other
operations are requested.  Specify the PIN here to allow operation of the
device.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pin-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingGsm:pin property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The username used to authenticate with the network, if required.  Many
providers do not require a username, or accept any username.  But if a
username is required, it is specified here.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingGsmClass"
            c:type="NMSettingGsmClass"
            glib:is-gtype-struct-for="SettingGsm">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingGsmError"
                 glib:type-name="NMSettingGsmError"
                 glib:get-type="nm_setting_gsm_error_get_type"
                 c:type="NMSettingGsmError"
                 glib:error-domain="nm-setting-gsm-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_GSM_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_GSM_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_GSM_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="MissingSerialSetting"
              value="3"
              c:identifier="NM_SETTING_GSM_ERROR_MISSING_SERIAL_SETTING"
              glib:nick="MissingSerialSetting">
        <doc xml:space="preserve">the required #NMSettingSerial
is missing in the connection</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_gsm_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingGsm if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingGsm errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingGsmNetworkBand"
                 deprecated="1"
                 deprecated-version="0.9.10"
                 glib:type-name="NMSettingGsmNetworkBand"
                 glib:get-type="nm_setting_gsm_network_band_get_type"
                 c:type="NMSettingGsmNetworkBand">
      <doc xml:space="preserve">#NMSettingGsmNetworkBand values indicate the allowed frequency bands
the device may use when connecting to this network.</doc>
      <doc-deprecated xml:space="preserve">No longer used.</doc-deprecated>
      <member name="unknown"
              value="0"
              c:identifier="NM_SETTING_GSM_BAND_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or no band specified</doc>
      </member>
      <member name="any"
              value="1"
              c:identifier="NM_SETTING_GSM_BAND_ANY"
              glib:nick="any">
        <doc xml:space="preserve">any band is allowed</doc>
      </member>
      <member name="egsm"
              value="2"
              c:identifier="NM_SETTING_GSM_BAND_EGSM"
              glib:nick="egsm">
        <doc xml:space="preserve">900 MHz original GSM band</doc>
      </member>
      <member name="dcs"
              value="4"
              c:identifier="NM_SETTING_GSM_BAND_DCS"
              glib:nick="dcs">
        <doc xml:space="preserve">1800 MHz DCS band</doc>
      </member>
      <member name="pcs"
              value="8"
              c:identifier="NM_SETTING_GSM_BAND_PCS"
              glib:nick="pcs">
        <doc xml:space="preserve">US 1900 MHz PCS band</doc>
      </member>
      <member name="g850"
              value="16"
              c:identifier="NM_SETTING_GSM_BAND_G850"
              glib:nick="g850">
        <doc xml:space="preserve">US 850 MHz Cellular band</doc>
      </member>
      <member name="u2100"
              value="32"
              c:identifier="NM_SETTING_GSM_BAND_U2100"
              glib:nick="u2100">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 2100 MHz (Class I)</doc>
      </member>
      <member name="u1800"
              value="64"
              c:identifier="NM_SETTING_GSM_BAND_U1800"
              glib:nick="u1800">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 1800 MHz (Class III)</doc>
      </member>
      <member name="u17iv"
              value="128"
              c:identifier="NM_SETTING_GSM_BAND_U17IV"
              glib:nick="u17iv">
        <doc xml:space="preserve">WCDMA 3GPP AWS 1700/2100 MHz (Class IV)</doc>
      </member>
      <member name="u800"
              value="256"
              c:identifier="NM_SETTING_GSM_BAND_U800"
              glib:nick="u800">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 800 MHz (Class VI)</doc>
      </member>
      <member name="u850"
              value="512"
              c:identifier="NM_SETTING_GSM_BAND_U850"
              glib:nick="u850">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 850 MHz (Class V)</doc>
      </member>
      <member name="u900"
              value="1024"
              c:identifier="NM_SETTING_GSM_BAND_U900"
              glib:nick="u900">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 900 MHz (Class VIII)</doc>
      </member>
      <member name="u17ix"
              value="2048"
              c:identifier="NM_SETTING_GSM_BAND_U17IX"
              glib:nick="u17ix">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 1700 MHz (Class IX)</doc>
      </member>
      <member name="u1900"
              value="4096"
              c:identifier="NM_SETTING_GSM_BAND_U1900"
              glib:nick="u1900">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 1900 MHz (Class II)</doc>
      </member>
      <member name="u2600"
              value="8192"
              c:identifier="NM_SETTING_GSM_BAND_U2600"
              glib:nick="u2600">
        <doc xml:space="preserve">WCDMA 3GPP UMTS 2600 MHz (Class VII, internal)</doc>
      </member>
    </enumeration>
    <enumeration name="SettingGsmNetworkType"
                 deprecated="1"
                 deprecated-version="0.9.10"
                 glib:type-name="NMSettingGsmNetworkType"
                 glib:get-type="nm_setting_gsm_network_type_get_type"
                 c:type="NMSettingGsmNetworkType">
      <doc xml:space="preserve">#NMSettingGsmNetworkType values indicate the allowed access technologies
the device may use when connecting to this network.</doc>
      <doc-deprecated xml:space="preserve">No longer used.</doc-deprecated>
      <member name="any"
              value="-1"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_ANY"
              glib:nick="any">
        <doc xml:space="preserve">any access technology may be used</doc>
      </member>
      <member name="umts_hspa"
              value="0"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_UMTS_HSPA"
              glib:nick="umts-hspa">
        <doc xml:space="preserve">only 3G-type (UMTS and HSPA)
technologies may be used</doc>
      </member>
      <member name="gprs_edge"
              value="1"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_GPRS_EDGE"
              glib:nick="gprs-edge">
        <doc xml:space="preserve">only 2G-type (GPRS and EDGE)
technologies may be used</doc>
      </member>
      <member name="prefer_umts_hspa"
              value="2"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_PREFER_UMTS_HSPA"
              glib:nick="prefer-umts-hspa">
        <doc xml:space="preserve">3G-type technologies are
preferred but 2G-type technologies may be used as a fallback</doc>
      </member>
      <member name="prefer_gprs_edge"
              value="3"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_PREFER_GPRS_EDGE"
              glib:nick="prefer-gprs-edge">
        <doc xml:space="preserve">2G-type technologies are
preferred but 3G-type technologies may be used as a fallback</doc>
      </member>
      <member name="prefer_4g"
              value="4"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_PREFER_4G"
              glib:nick="prefer-4g">
        <doc xml:space="preserve">4G/LTE-type technologies are
preferred but 3G/2/-type technologies may be used as a fallback</doc>
      </member>
      <member name="4g"
              value="5"
              c:identifier="NM_SETTING_GSM_NETWORK_TYPE_4G"
              glib:nick="4g">
        <doc xml:space="preserve">only 4G/LTE type
technologies may be used</doc>
      </member>
    </enumeration>
    <enumeration name="SettingHashFlags"
                 glib:type-name="NMSettingHashFlags"
                 glib:get-type="nm_setting_hash_flags_get_type"
                 c:type="NMSettingHashFlags">
      <doc xml:space="preserve">These flags determine which properties are added to the resulting hash
when calling nm_setting_to_hash().</doc>
      <member name="all"
              value="0"
              c:identifier="NM_SETTING_HASH_FLAG_ALL"
              glib:nick="all">
        <doc xml:space="preserve">hash all properties (including secrets)</doc>
      </member>
      <member name="no_secrets"
              value="1"
              c:identifier="NM_SETTING_HASH_FLAG_NO_SECRETS"
              glib:nick="no-secrets">
        <doc xml:space="preserve">do not include secrets</doc>
      </member>
      <member name="only_secrets"
              value="2"
              c:identifier="NM_SETTING_HASH_FLAG_ONLY_SECRETS"
              glib:nick="only-secrets">
        <doc xml:space="preserve">only hash secrets</doc>
      </member>
    </enumeration>
    <class name="SettingIP4Config"
           c:symbol-prefix="setting_ip4_config"
           c:type="NMSettingIP4Config"
           parent="Setting"
           glib:type-name="NMSettingIP4Config"
           glib:get-type="nm_setting_ip4_config_get_type"
           glib:type-struct="SettingIP4ConfigClass">
      <constructor name="new" c:identifier="nm_setting_ip4_config_new">
        <doc xml:space="preserve">Creates a new #NMSettingIP4Config object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingIP4Config object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_address"
              c:identifier="nm_setting_ip4_config_add_address">
        <doc xml:space="preserve">Adds a new IPv4 address and associated information to the setting.  The
given address is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the address was added; %FALSE if the address was already
known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the new address to add</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns" c:identifier="nm_setting_ip4_config_add_dns">
        <doc xml:space="preserve">Adds a new DNS server to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS server was added; %FALSE if the server was already
known</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="dns" transfer-ownership="none">
            <doc xml:space="preserve">the IPv4 address (network byte order) of the DNS server to add</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns_search"
              c:identifier="nm_setting_ip4_config_add_dns_search">
        <doc xml:space="preserve">Adds a new DNS search domain to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS search domain was added; %FALSE if the search
domain was already known</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:space="preserve">the search domain to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_route" c:identifier="nm_setting_ip4_config_add_route">
        <doc xml:space="preserve">Adds a new IPv4 route and associated information to the setting.  The
given route is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the route was added; %FALSE if the route was already known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the route to add</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_addresses"
              c:identifier="nm_setting_ip4_config_clear_addresses">
        <doc xml:space="preserve">Removes all configured addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_dns" c:identifier="nm_setting_ip4_config_clear_dns">
        <doc xml:space="preserve">Removes all configured DNS servers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_dns_searches"
              c:identifier="nm_setting_ip4_config_clear_dns_searches">
        <doc xml:space="preserve">Removes all configured DNS search domains.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_routes"
              c:identifier="nm_setting_ip4_config_clear_routes">
        <doc xml:space="preserve">Removes all configured routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address"
              c:identifier="nm_setting_ip4_config_get_address">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the address at index @i</doc>
          <type name="IP4Address" c:type="NMIP4Address*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the address to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dhcp_client_id"
              c:identifier="nm_setting_ip4_config_get_dhcp_client_id">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-client-id
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured Client ID to send to the DHCP server when requesting
addresses via DHCP.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_hostname"
              c:identifier="nm_setting_ip4_config_get_dhcp_hostname">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-hostname
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured hostname to send to the DHCP server</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_send_hostname"
              c:identifier="nm_setting_ip4_config_get_dhcp_send_hostname">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-send-hostname
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if NetworkManager should send the machine hostname to the
DHCP server when requesting addresses to allow the server to automatically
update DNS information for this machine.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_timeout"
              c:identifier="nm_setting_ip4_config_get_dhcp_timeout">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:dhcp-timeout
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of seconds after which unfinished DHCP transaction
fails or zero for "default".</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns" c:identifier="nm_setting_ip4_config_get_dns">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPv4 address (network byte order) of the DNS server at index
@i</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS server to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dns_search"
              c:identifier="nm_setting_ip4_config_get_dns_search">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the DNS search domain at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS search domain to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_dns"
              c:identifier="nm_setting_ip4_config_get_ignore_auto_dns">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:ignore-auto-dns
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if automatically configured (ie via DHCP) DNS information
should be ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_routes"
              c:identifier="nm_setting_ip4_config_get_ignore_auto_routes">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:ignore-auto-routes
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if automatically configured (ie via DHCP) routes should be
ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_may_fail"
              c:identifier="nm_setting_ip4_config_get_may_fail">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:may-fail
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection doesn't require IPv4 addressing to complete
for the connection to succeed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method"
              c:identifier="nm_setting_ip4_config_get_method">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingIP4Config:method property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_never_default"
              c:identifier="nm_setting_ip4_config_get_never_default">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:never-default
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection should never be the default connection
for IPv4 addressing</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_addresses"
              c:identifier="nm_setting_ip4_config_get_num_addresses">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dns"
              c:identifier="nm_setting_ip4_config_get_num_dns">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured DNS servers</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dns_searches"
              c:identifier="nm_setting_ip4_config_get_num_dns_searches">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured DNS search domains</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_routes"
              c:identifier="nm_setting_ip4_config_get_num_routes">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured routes</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_route" c:identifier="nm_setting_ip4_config_get_route">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the route at index @i</doc>
          <type name="IP4Route" c:type="NMIP4Route*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the route to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_route_metric"
              c:identifier="nm_setting_ip4_config_get_route_metric"
              version="1.0">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP4Config:route-metric
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the route metric that is used for IPv4 routes that don't explicitly
specify a metric. See #NMSettingIP4Config:route-metric for more details.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_address"
              c:identifier="nm_setting_ip4_config_remove_address">
        <doc xml:space="preserve">Removes the address at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the address to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_address_by_value"
              c:identifier="nm_setting_ip4_config_remove_address_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the address @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the address was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the IP address to remove</doc>
            <type name="IP4Address" c:type="NMIP4Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns"
              c:identifier="nm_setting_ip4_config_remove_dns">
        <doc xml:space="preserve">Removes the DNS server at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS server to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_by_value"
              c:identifier="nm_setting_ip4_config_remove_dns_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the DNS server @dns.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS server was found and removed; %FALSE if it was not.
domain was already known</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="dns" transfer-ownership="none">
            <doc xml:space="preserve">the DNS server to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search"
              c:identifier="nm_setting_ip4_config_remove_dns_search">
        <doc xml:space="preserve">Removes the DNS search domain at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS search domain</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search_by_value"
              c:identifier="nm_setting_ip4_config_remove_dns_search_by_value">
        <doc xml:space="preserve">Removes the DNS search domain @dns_search.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS search domain was found and removed; %FALSE if it was not.

Since 0.9.10</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:space="preserve">the search domain to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route"
              c:identifier="nm_setting_ip4_config_remove_route">
        <doc xml:space="preserve">Removes the route at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the route</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route_by_value"
              c:identifier="nm_setting_ip4_config_remove_route_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the route @route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the route was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP4Config</doc>
            <type name="SettingIP4Config" c:type="NMSettingIP4Config*"/>
          </instance-parameter>
          <parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the route to remove</doc>
            <type name="IP4Route" c:type="NMIP4Route*"/>
          </parameter>
        </parameters>
      </method>
      <property name="addresses"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Array of IPv4 address structures.  Each IPv4 address structure is
composed of 3 32-bit values; the first being the IPv4 address (network
byte order), the second the prefix (1 - 32), and last the IPv4 gateway
(network byte order). The gateway may be left as 0 if no gateway exists
for that subnet.  For the "auto" method, given IP addresses are appended
to those returned by automatic configuration.  Addresses cannot be used
with the "shared", "link-local", or "disabled" methods as addressing is
either automatic or disabled with these methods.</doc>
        <type/>
      </property>
      <property name="dhcp-client-id" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A string sent to the DHCP server to identify the local machine which the
DHCP server may use to customize the DHCP lease and options.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dhcp-hostname" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the #NMSettingIP4Config:dhcp-send-hostname property is %TRUE, then the
specified name will be sent to the DHCP server when acquiring a lease.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dhcp-send-hostname"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, a hostname is sent to the DHCP server when acquiring a lease.
Some DHCP servers use this hostname to update DNS databases, essentially
providing a static hostname for the computer.  If the
#NMSettingIP4Config:dhcp-hostname property is empty and this property is
%TRUE, the current persistent hostname of the computer is sent.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="dhcp-timeout" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Number of seconds after which the unfinished DHCP transaction fails
or zero for default.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="dns"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of DNS servers (network byte order).  For the "auto" method, these
DNS servers are appended to those (if any) returned by automatic
configuration.  DNS servers cannot be used with the "shared",
"link-local", or "disabled" methods as there is no upstream network.  In
all other methods, these DNS servers are used as the only DNS servers for
this connection.</doc>
        <type/>
      </property>
      <property name="dns-search"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of DNS search domains.  For the "auto" method, these search domains
are appended to those returned by automatic configuration. Search domains
cannot be used with the "shared", "link-local", or "disabled" methods as
there is no upstream network.  In all other methods, these search domains
are used as the only search domains for this connection.</doc>
        <type/>
      </property>
      <property name="ignore-auto-dns"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When the method is set to "auto" and this property to %TRUE,
automatically configured nameservers and search domains are ignored and
only nameservers and search domains specified in the
#NMSettingIP4Config:dns and #NMSettingIP4Config:dns-search properties, if
any, are used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ignore-auto-routes"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When the method is set to "auto" and this property to %TRUE,
automatically configured routes are ignored and only routes specified in
the #NMSettingIP4Config:routes property, if any, are used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="may-fail"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, allow overall network configuration to proceed even if IPv4
configuration times out.  Note that at least one IP configuration must
succeed or overall network configuration will still fail.  For example,
in IPv6-only networks, setting this property to %TRUE allows the overall
network configuration to succeed if IPv4 configuration fails but IPv6
configuration completes successfully.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="method" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">IPv4 configuration method.  If "auto" is specified then the appropriate
automatic method (DHCP, PPP, etc) is used for the interface and most
other properties can be left unset.  If "link-local" is specified, then a
link-local address in the 169.254/16 range will be assigned to the
interface.  If "manual" is specified, static IP addressing is used and at
least one IP address must be given in the "addresses" property.  If
"shared" is specified (indicating that this connection will provide
network access to other computers) then the interface is assigned an
address in the 10.42.x.1/24 range and a DHCP and forwarding DNS server
are started, and the interface is NAT-ed to the current default network
connection.  "disabled" means IPv4 will not be used on this connection.
This property must be set.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="never-default"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, this connection will never be the default IPv4 connection,
meaning it will never be assigned the default route by NetworkManager.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="route-metric"
                version="1.0"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The default metric for routes that don't explicitly specify a metric.
The default value -1 means that the metric is chosen automatically
based on the device type.
The metric applies to dynamic routes, manual (static) routes that
don't have an explicit metric setting, address prefix routes, and
the default route.
As the linux kernel accepts zero (0) as a valid metric, zero is
a valid value.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="routes"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Array of IPv4 route structures.  Each IPv4 route structure is composed of
4 32-bit values; the first being the destination IPv4 network or address
(network byte order), the second the destination network or address
prefix (1 - 32), the third being the next-hop (network byte order) if
any, and the fourth being the route metric. For the "auto" method, given
IP routes are appended to those returned by automatic configuration.
Routes cannot be used with the "shared", "link-local", or "disabled"
methods because there is no upstream network.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingIP4ConfigClass"
            c:type="NMSettingIP4ConfigClass"
            glib:is-gtype-struct-for="SettingIP4Config">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingIP4ConfigError"
                 glib:type-name="NMSettingIP4ConfigError"
                 glib:get-type="nm_setting_ip4_config_error_get_type"
                 c:type="NMSettingIP4ConfigError"
                 glib:error-domain="nm-setting-ip4-config-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="NotAllowedForMethod"
              value="3"
              c:identifier="NM_SETTING_IP4_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD"
              glib:nick="NotAllowedForMethod">
        <doc xml:space="preserve">the property's value is
not valid with the given IP4 method</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_ip4_config_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingIP4Config if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingIP4Config errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingIP6Config"
           c:symbol-prefix="setting_ip6_config"
           c:type="NMSettingIP6Config"
           parent="Setting"
           glib:type-name="NMSettingIP6Config"
           glib:get-type="nm_setting_ip6_config_get_type"
           glib:type-struct="SettingIP6ConfigClass">
      <constructor name="new" c:identifier="nm_setting_ip6_config_new">
        <doc xml:space="preserve">Creates a new #NMSettingIP6Config object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingIP6Config object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_address"
              c:identifier="nm_setting_ip6_config_add_address">
        <doc xml:space="preserve">Adds a new IPv6 address and associated information to the setting.  The
given address is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the address was added; %FALSE if the address was already
known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the new address to add</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns" c:identifier="nm_setting_ip6_config_add_dns">
        <doc xml:space="preserve">Adds a new DNS server to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS server was added; %FALSE if the server was already
known</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="dns"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IPv6 address of the DNS server to add</doc>
            <type name="gpointer" c:type="const in6_addr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dns_search"
              c:identifier="nm_setting_ip6_config_add_dns_search">
        <doc xml:space="preserve">Adds a new DNS search domain to the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS search domain was added; %FALSE if the search
domain was already known</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:space="preserve">the search domain to add</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_route" c:identifier="nm_setting_ip6_config_add_route">
        <doc xml:space="preserve">Adds a new IPv6 route and associated information to the setting.  The
given route is duplicated internally and is not changed by this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the route was added; %FALSE if the route was already known.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the route to add</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_addresses"
              c:identifier="nm_setting_ip6_config_clear_addresses">
        <doc xml:space="preserve">Removes all configured addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_dns" c:identifier="nm_setting_ip6_config_clear_dns">
        <doc xml:space="preserve">Removes all configured DNS servers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_dns_searches"
              c:identifier="nm_setting_ip6_config_clear_dns_searches">
        <doc xml:space="preserve">Removes all configured DNS search domains.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_routes"
              c:identifier="nm_setting_ip6_config_clear_routes">
        <doc xml:space="preserve">Removes all configured routes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_address"
              c:identifier="nm_setting_ip6_config_get_address">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the address at index @i</doc>
          <type name="IP6Address" c:type="NMIP6Address*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the address to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dhcp_hostname"
              c:identifier="nm_setting_ip6_config_get_dhcp_hostname"
              version="0.9.8">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:dhcp-hostname
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the configured hostname to send to the DHCP server</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dns" c:identifier="nm_setting_ip6_config_get_dns">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the IPv6 address of the DNS server at index @i</doc>
          <type name="gpointer" c:type="const in6_addr*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS server to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dns_search"
              c:identifier="nm_setting_ip6_config_get_dns_search">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the DNS search domain at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS search domain to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_dns"
              c:identifier="nm_setting_ip6_config_get_ignore_auto_dns">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:ignore-auto-dns
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if automatically configured (ie via DHCP or router
advertisements) DNS information should be ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ignore_auto_routes"
              c:identifier="nm_setting_ip6_config_get_ignore_auto_routes">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:ignore-auto-routes
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if automatically configured (ie via DHCP) routes should be
ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ip6_privacy"
              c:identifier="nm_setting_ip6_config_get_ip6_privacy">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:ip6-privacy
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">IPv6 Privacy Extensions configuration value (#NMSettingIP6ConfigPrivacy).</doc>
          <type name="SettingIP6ConfigPrivacy"
                c:type="NMSettingIP6ConfigPrivacy"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_may_fail"
              c:identifier="nm_setting_ip6_config_get_may_fail">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:may-fail
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection doesn't require IPv6 addressing to complete
for the connection to succeed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_method"
              c:identifier="nm_setting_ip6_config_get_method">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingIP6Config:method property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_never_default"
              c:identifier="nm_setting_ip6_config_get_never_default">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:never-default
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if this connection should never be the default connection
for IPv6 addressing</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_addresses"
              c:identifier="nm_setting_ip6_config_get_num_addresses">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dns"
              c:identifier="nm_setting_ip6_config_get_num_dns">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured DNS servers</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_dns_searches"
              c:identifier="nm_setting_ip6_config_get_num_dns_searches">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured DNS search domains</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_routes"
              c:identifier="nm_setting_ip6_config_get_num_routes">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of configured routes</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_route" c:identifier="nm_setting_ip6_config_get_route">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the route at index @i</doc>
          <type name="IP6Route" c:type="NMIP6Route*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the route to return</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_route_metric"
              c:identifier="nm_setting_ip6_config_get_route_metric"
              version="1.0">
        <doc xml:space="preserve">Returns the value contained in the #NMSettingIP6Config:route-metric
property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the route metric that is used for IPv6 routes that don't explicitly
specify a metric. See #NMSettingIP6Config:route-metric for more details.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_address"
              c:identifier="nm_setting_ip6_config_remove_address">
        <doc xml:space="preserve">Removes the address at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the address to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_address_by_value"
              c:identifier="nm_setting_ip6_config_remove_address_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the address @address.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the address was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve">the address to remove</doc>
            <type name="IP6Address" c:type="NMIP6Address*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns"
              c:identifier="nm_setting_ip6_config_remove_dns">
        <doc xml:space="preserve">Removes the DNS server at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS server to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_by_value"
              c:identifier="nm_setting_ip6_config_remove_dns_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the DNS server at index @i.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS server was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="dns"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the IPv6 address of the DNS server to remove</doc>
            <type name="gpointer" c:type="const in6_addr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search"
              c:identifier="nm_setting_ip6_config_remove_dns_search">
        <doc xml:space="preserve">Removes the DNS search domain at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the DNS search domain</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dns_search_by_value"
              c:identifier="nm_setting_ip6_config_remove_dns_search_by_value">
        <doc xml:space="preserve">Removes the DNS search domain @dns_search.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the DNS search domain was found and removed; %FALSE if it was not.

Since 0.9.10</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="dns_search" transfer-ownership="none">
            <doc xml:space="preserve">the search domain to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route"
              c:identifier="nm_setting_ip6_config_remove_route">
        <doc xml:space="preserve">Removes the route at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index number of the route</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_route_by_value"
              c:identifier="nm_setting_ip6_config_remove_route_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the route @route.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the route was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingIP6Config</doc>
            <type name="SettingIP6Config" c:type="NMSettingIP6Config*"/>
          </instance-parameter>
          <parameter name="route" transfer-ownership="none">
            <doc xml:space="preserve">the route to remove</doc>
            <type name="IP6Route" c:type="NMIP6Route*"/>
          </parameter>
        </parameters>
      </method>
      <property name="addresses"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Array of IPv6 address structures.  Each IPv6 address structure is
composed of 3 members, the first being a byte array containing the IPv6
address (network byte order), the second a 32-bit integer containing the
IPv6 address prefix, and the third a byte array containing the IPv6
address (network byte order) of the gateway associated with this address,
if any.  If no gateway is given, the third element should be given as all
zeros.  For the "auto" method, given IP addresses are appended to those
returned by automatic configuration.  Addresses cannot be used with the
"shared" or "link-local" methods as the interface is automatically
assigned an address with these methods.</doc>
        <type/>
      </property>
      <property name="dhcp-hostname"
                version="0.9.8"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The specified name will be sent to the DHCP server when acquiring a
lease.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="dns"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Array of DNS servers, where each member of the array is a byte array
containing the IPv6 address of the DNS server (in network byte order).
For the "auto" method, these DNS servers are appended to those (if any)
returned by automatic configuration.  DNS servers cannot be used with the
"shared" or "link-local" methods as there is no usptream network. In all
other methods, these DNS servers are used as the only DNS servers for
this connection.</doc>
        <type/>
      </property>
      <property name="dns-search"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of DNS search domains.  For the "auto" method, these search domains
are appended to those returned by automatic configuration. Search domains
cannot be used with the "shared" or "link-local" methods as there is no
upstream network.  In all other methods, these search domains are used as
the only search domains for this connection.</doc>
        <type/>
      </property>
      <property name="ignore-auto-dns"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When the method is set to "auto" or "dhcp" and this property is set to
%TRUE, automatically configured nameservers and search domains are
ignored and only nameservers and search domains specified in the
#NMSettingIP6Config:dns and #NMSettingIP6Config:dns-search properties, if
any, are used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ignore-auto-routes"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When the method is set to "auto" or "dhcp" and this property is set to
%TRUE, automatically configured routes are ignored and only routes
specified in the #NMSettingIP6Config:routes property, if any, are used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ip6-privacy"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Configure IPv6 Privacy Extensions for SLAAC, described in RFC4941.  If
enabled, it makes the kernel generate a temporary IPv6 address in
addition to the public one generated from MAC address via modified
EUI-64.  This enhances privacy, but could cause problems in some
applications, on the other hand.  The permitted values are: 0: disabled,
1: enabled (prefer public address), 2: enabled (prefer temporary
addresses).</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="may-fail"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, allow overall network configuration to proceed even if IPv6
configuration times out.  Note that at least one IP configuration must
succeed or overall network configuration will still fail.  For example,
in IPv4-only networks, setting this property to %TRUE allows the overall
network configuration to succeed if IPv6 configuration fails but IPv4
configuration completes successfully.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="method" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">IPv6 configuration method.  If "auto" is specified then the appropriate
automatic method (PPP, router advertisement, etc) is used for the device
and most other properties can be left unset.  To force the use of DHCP
only, specify "dhcp"; this method is only valid for Ethernet- based
hardware.  If "link-local" is specified, then an IPv6 link-local address
will be assigned to the interface.  If "manual" is specified, static IP
addressing is used and at least one IP address must be given in the
"addresses" property.  If "ignore" is specified, IPv6 configuration is
not done. This property must be set.  Note: the "shared" method is not
yet supported.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="never-default"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, this connection will never be the default IPv6 connection,
meaning it will never be assigned the default IPv6 route by
NetworkManager.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="route-metric"
                version="1.0"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The default metric for routes that don't explicitly specify a metric.
The default value -1 means that the metric is chosen automatically
based on the device type.
The metric applies to dynamic routes, manual (static) routes that
don't have an explicit metric setting, address prefix routes, and
the default route.
As the linux kernel replaces zero (0) by 1024 (user-default), setting
this property to 0 means effectively setting it to 1024.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="routes"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Array of IPv6 route structures.  Each IPv6 route structure is composed of
4 members; the first being the destination IPv6 network or address
(network byte order) as a byte array, the second the destination network
or address IPv6 prefix, the third being the next-hop IPv6 address
(network byte order) if any, and the fourth being the route metric. For
the "auto" method, given IP routes are appended to those returned by
automatic configuration.  Routes cannot be used with the "shared" or
"link-local" methods because there is no upstream network.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingIP6ConfigClass"
            c:type="NMSettingIP6ConfigClass"
            glib:is-gtype-struct-for="SettingIP6Config">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingIP6ConfigError"
                 glib:type-name="NMSettingIP6ConfigError"
                 glib:get-type="nm_setting_ip6_config_error_get_type"
                 c:type="NMSettingIP6ConfigError"
                 glib:error-domain="nm-setting-ip6-config-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="NotAllowedForMethod"
              value="3"
              c:identifier="NM_SETTING_IP6_CONFIG_ERROR_NOT_ALLOWED_FOR_METHOD"
              glib:nick="NotAllowedForMethod">
        <doc xml:space="preserve">the property's value is
not valid with the given IPv6 method</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_ip6_config_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingIP6Config if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingIP6Config errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingIP6ConfigPrivacy"
                 glib:type-name="NMSettingIP6ConfigPrivacy"
                 glib:get-type="nm_setting_ip6_config_privacy_get_type"
                 c:type="NMSettingIP6ConfigPrivacy">
      <doc xml:space="preserve">#NMSettingIP6ConfigPrivacy values indicate if and how IPv6 Privacy
Extensions are used (RFC4941).</doc>
      <member name="unknown"
              value="-1"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or no value specified</doc>
      </member>
      <member name="disabled"
              value="0"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED"
              glib:nick="disabled">
        <doc xml:space="preserve">IPv6 Privacy Extensions are disabled</doc>
      </member>
      <member name="prefer_public_addr"
              value="1"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR"
              glib:nick="prefer-public-addr">
        <doc xml:space="preserve">IPv6 Privacy Extensions
are enabled, but public addresses are preferred over temporary addresses</doc>
      </member>
      <member name="prefer_temp_addr"
              value="2"
              c:identifier="NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR"
              glib:nick="prefer-temp-addr">
        <doc xml:space="preserve">IPv6 Privacy Extensions
are enabled and temporary addresses are preferred over public addresses</doc>
      </member>
    </enumeration>
    <class name="SettingInfiniband"
           c:symbol-prefix="setting_infiniband"
           c:type="NMSettingInfiniband"
           parent="Setting"
           glib:type-name="NMSettingInfiniband"
           glib:get-type="nm_setting_infiniband_get_type"
           glib:type-struct="SettingInfinibandClass">
      <constructor name="new" c:identifier="nm_setting_infiniband_new">
        <doc xml:space="preserve">Creates a new #NMSettingInfiniband object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingInfiniband object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mac_address"
              c:identifier="nm_setting_infiniband_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingInfiniband:mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_infiniband_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingInfiniband:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_p_key" c:identifier="nm_setting_infiniband_get_p_key">
        <doc xml:space="preserve">Returns the P_Key to use for this device. A value of -1 means to
use the default P_Key (aka "the P_Key at index 0"). Otherwise it is
a 16-bit unsigned integer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPoIB P_Key</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent"
              c:identifier="nm_setting_infiniband_get_parent">
        <doc xml:space="preserve">Returns the parent interface name for this device, if set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parent interface name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_transport_mode"
              c:identifier="nm_setting_infiniband_get_transport_mode">
        <doc xml:space="preserve">Returns the transport mode for this device. Either 'datagram' or
'connected'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the IPoIB transport mode</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingInfiniband</doc>
            <type name="SettingInfiniband" c:type="NMSettingInfiniband*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the IPoIB device whose
permanent MAC address matches. This property does not change the MAC
address of the device (i.e. MAC spoofing).</doc>
        <type/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="p-key"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The InfiniBand P_Key to use for this device. A value of -1 means to use
the default P_Key (aka "the P_Key at index 0").  Otherwise it is a 16-bit
unsigned integer, whose high bit is set if it is a "full membership"
P_Key.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="parent"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The interface name of the parent device of this device. Normally %NULL,
but if the #NMSettingInfiniband:p_key property is set, then you must
specify the base device by setting either this property or
#NMSettingInfiniband:mac-address.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="transport-mode"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The IP-over-InfiniBand transport mode. Either "datagram" or
"connected".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingInfinibandClass"
            c:type="NMSettingInfinibandClass"
            glib:is-gtype-struct-for="SettingInfiniband">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingInfinibandError"
                 glib:type-name="NMSettingInfinibandError"
                 glib:get-type="nm_setting_infiniband_error_get_type"
                 c:type="NMSettingInfinibandError"
                 glib:error-domain="nm-setting-infiniband-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_INFINIBAND_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_INFINIBAND_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_INFINIBAND_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_infiniband_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingInfiniband if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingInfiniband errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingOlpcMesh"
           c:symbol-prefix="setting_olpc_mesh"
           c:type="NMSettingOlpcMesh"
           parent="Setting"
           glib:type-name="NMSettingOlpcMesh"
           glib:get-type="nm_setting_olpc_mesh_get_type"
           glib:type-struct="SettingOlpcMeshClass">
      <constructor name="new" c:identifier="nm_setting_olpc_mesh_new">
        <doc xml:space="preserve">Creates a new #NMSettingOlpcMesh object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingOlpcMesh object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_channel"
              c:identifier="nm_setting_olpc_mesh_get_channel">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dhcp_anycast_address"
              c:identifier="nm_setting_olpc_mesh_get_dhcp_anycast_address">
        <return-value transfer-ownership="none">
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_setting_olpc_mesh_get_ssid">
        <return-value transfer-ownership="none">
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <type name="SettingOlpcMesh" c:type="NMSettingOlpcMesh*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="channel"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Channel on which the mesh network to join is located.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="dhcp-anycast-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Anycast DHCP MAC address used when requesting an IP address via DHCP.
The specific anycast address used determines which DHCP server class
answers the request.</doc>
        <type/>
      </property>
      <property name="ssid"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">SSID of the mesh network to join.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingOlpcMeshClass"
            c:type="NMSettingOlpcMeshClass"
            glib:is-gtype-struct-for="SettingOlpcMesh">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingOlpcMeshError"
                 glib:type-name="NMSettingOlpcMeshError"
                 glib:get-type="nm_setting_olpc_mesh_error_get_type"
                 c:type="NMSettingOlpcMeshError"
                 glib:error-domain="nm-setting-olpc-mesh-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_OLPC_MESH_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_OLPC_MESH_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_OLPC_MESH_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_olpc_mesh_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingPPP"
           c:symbol-prefix="setting_ppp"
           c:type="NMSettingPPP"
           parent="Setting"
           glib:type-name="NMSettingPPP"
           glib:get-type="nm_setting_ppp_get_type"
           glib:type-struct="SettingPPPClass">
      <constructor name="new" c:identifier="nm_setting_ppp_new">
        <doc xml:space="preserve">Creates a new #NMSettingPPP object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingPPP object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_baud" c:identifier="nm_setting_ppp_get_baud">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:baud property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_crtscts" c:identifier="nm_setting_ppp_get_crtscts">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:crtscts property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_lcp_echo_failure"
              c:identifier="nm_setting_ppp_get_lcp_echo_failure">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:lcp-echo-failure property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_lcp_echo_interval"
              c:identifier="nm_setting_ppp_get_lcp_echo_interval">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:lcp-echo-interval property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mppe_stateful"
              c:identifier="nm_setting_ppp_get_mppe_stateful">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:mppe-stateful property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mru" c:identifier="nm_setting_ppp_get_mru">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:mru property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_ppp_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_no_vj_comp"
              c:identifier="nm_setting_ppp_get_no_vj_comp">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:no-vj-comp property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_noauth" c:identifier="nm_setting_ppp_get_noauth">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:noauth property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nobsdcomp" c:identifier="nm_setting_ppp_get_nobsdcomp">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:nobsdcomp property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_nodeflate" c:identifier="nm_setting_ppp_get_nodeflate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:nodeflate property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_chap"
              c:identifier="nm_setting_ppp_get_refuse_chap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:refuse-chap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_eap"
              c:identifier="nm_setting_ppp_get_refuse_eap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:refuse-eap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_mschap"
              c:identifier="nm_setting_ppp_get_refuse_mschap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:refuse-mschap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_mschapv2"
              c:identifier="nm_setting_ppp_get_refuse_mschapv2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:refuse-mschapv2 property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refuse_pap"
              c:identifier="nm_setting_ppp_get_refuse_pap">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:refuse-pap property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_require_mppe"
              c:identifier="nm_setting_ppp_get_require_mppe">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:require-mppe property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_require_mppe_128"
              c:identifier="nm_setting_ppp_get_require_mppe_128">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPP:require-mppe-128 property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPP</doc>
            <type name="SettingPPP" c:type="NMSettingPPP*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="baud"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to set the serial port to the specified
baudrate.  This value should normally be left as 0 to automatically
choose the speed.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="crtscts"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, specify that pppd should set the serial port to use hardware
flow control with RTS and CTS signals.  This value should normally be set
to %FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="lcp-echo-failure"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to presume the connection to the peer has
failed if the specified number of LCP echo-requests go unanswered by the
peer.  The "lcp-echo-interval" property must also be set to a non-zero
value if this property is used.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="lcp-echo-interval"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to send an LCP echo-request frame to the peer
every n seconds (where n is the specified value).  Note that some PPP
peers will respond to echo requests and some will not, and it is not
possible to autodetect this.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mppe-stateful"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, stateful MPPE is used.  See pppd documentation for more
information on stateful MPPE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mru"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to request that the peer send packets no
larger than the specified size.  If non-zero, the MRU should be between
128 and 16384.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, instruct pppd to send packets no larger than the specified
size.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="no-vj-comp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, Van Jacobsen TCP header compression will not be requested.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="noauth"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, do not require the other side (usually the PPP server) to
authenticate itself to the client.  If %FALSE, require authentication
from the remote side.  In almost all cases, this should be %TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="nobsdcomp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, BSD compression will not be requested.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="nodeflate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, "deflate" compression will not be requested.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-chap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the CHAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-eap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the EAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-mschap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the MSCHAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-mschapv2"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the MSCHAPv2 authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="refuse-pap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, the PAP authentication method will not be used.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="require-mppe"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, MPPE (Microsoft Point-to-Point Encryption) will be required for
the PPP session.  If either 64-bit or 128-bit MPPE is not available the
session will fail.  Note that MPPE is not used on mobile broadband
connections.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="require-mppe-128"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, 128-bit MPPE (Microsoft Point-to-Point Encryption) will be
required for the PPP session, and the "require-mppe" property must also
be set to %TRUE.  If 128-bit MPPE is not available the session will fail.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingPPPClass"
            c:type="NMSettingPPPClass"
            glib:is-gtype-struct-for="SettingPPP">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingPPPError"
                 glib:type-name="NMSettingPPPError"
                 glib:get-type="nm_setting_ppp_error_get_type"
                 c:type="NMSettingPPPError"
                 glib:error-domain="nm-setting-ppp-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_PPP_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_PPP_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_PPP_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="RequireMPPENotAllowed"
              value="3"
              c:identifier="NM_SETTING_PPP_ERROR_REQUIRE_MPPE_NOT_ALLOWED"
              glib:nick="RequireMPPENotAllowed">
        <doc xml:space="preserve">requiring MPPE is not compatible
with other setting configuration parameters</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_ppp_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingPPP if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingPPP errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingPPPOE"
           c:symbol-prefix="setting_pppoe"
           c:type="NMSettingPPPOE"
           parent="Setting"
           glib:type-name="NMSettingPPPOE"
           glib:get-type="nm_setting_pppoe_get_type"
           glib:type-struct="SettingPPPOEClass">
      <constructor name="new" c:identifier="nm_setting_pppoe_new">
        <doc xml:space="preserve">Creates a new #NMSettingPPPOE object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingPPPOE object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_password" c:identifier="nm_setting_pppoe_get_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPPOE:password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPPOE</doc>
            <type name="SettingPPPOE" c:type="NMSettingPPPOE*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_flags"
              c:identifier="nm_setting_pppoe_get_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the #NMSettingPPPOE:password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPPOE</doc>
            <type name="SettingPPPOE" c:type="NMSettingPPPOE*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service" c:identifier="nm_setting_pppoe_get_service">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPPOE:service property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPPOE</doc>
            <type name="SettingPPPOE" c:type="NMSettingPPPOE*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_username" c:identifier="nm_setting_pppoe_get_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingPPPOE:username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingPPPOE</doc>
            <type name="SettingPPPOE" c:type="NMSettingPPPOE*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Password used to authenticate with the PPPoE service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingPPPOE:password property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="service" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, instruct PPPoE to only initiate sessions with access
concentrators that provide the specified service.  For most providers,
this should be left blank.  It is only required if there are multiple
access concentrators or a specific service is known to be required.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Username used to authenticate with the PPPoE service.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingPPPOEClass"
            c:type="NMSettingPPPOEClass"
            glib:is-gtype-struct-for="SettingPPPOE">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingPPPOEError"
                 glib:type-name="NMSettingPPPOEError"
                 glib:get-type="nm_setting_pppoe_error_get_type"
                 c:type="NMSettingPPPOEError"
                 glib:error-domain="nm-setting-pppoe-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_PPPOE_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_PPPOE_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_PPPOE_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="MissingPPPSetting"
              value="3"
              c:identifier="NM_SETTING_PPPOE_ERROR_MISSING_PPP_SETTING"
              glib:nick="MissingPPPSetting">
        <doc xml:space="preserve">the connection
did not contain a required PPP setting for PPP related options</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_pppoe_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingPPPOE if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingPPPOE errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingSecretFlags"
                 glib:type-name="NMSettingSecretFlags"
                 glib:get-type="nm_setting_secret_flags_get_type"
                 c:type="NMSettingSecretFlags">
      <doc xml:space="preserve">These flags indicate specific behavior related to handling of a secret.  Each
secret has a corresponding set of these flags which indicate how the secret
is to be stored and/or requested when it is needed.</doc>
      <member name="none"
              value="0"
              c:identifier="NM_SETTING_SECRET_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">the system is responsible for providing and
storing this secret (default)</doc>
      </member>
      <member name="agent_owned"
              value="1"
              c:identifier="NM_SETTING_SECRET_FLAG_AGENT_OWNED"
              glib:nick="agent-owned">
        <doc xml:space="preserve">a user secret agent is responsible
for providing and storing this secret; when it is required agents will be
asked to retrieve it</doc>
      </member>
      <member name="not_saved"
              value="2"
              c:identifier="NM_SETTING_SECRET_FLAG_NOT_SAVED"
              glib:nick="not-saved">
        <doc xml:space="preserve">this secret should not be saved, but
should be requested from the user each time it is needed</doc>
      </member>
      <member name="not_required"
              value="4"
              c:identifier="NM_SETTING_SECRET_FLAG_NOT_REQUIRED"
              glib:nick="not-required">
        <doc xml:space="preserve">in situations where it cannot be
automatically determined that the secret is required (some VPNs and PPP
providers dont require all secrets) this flag indicates that the specific
secret is not required</doc>
      </member>
    </enumeration>
    <class name="SettingSerial"
           c:symbol-prefix="setting_serial"
           c:type="NMSettingSerial"
           parent="Setting"
           glib:type-name="NMSettingSerial"
           glib:get-type="nm_setting_serial_get_type"
           glib:type-struct="SettingSerialClass">
      <constructor name="new" c:identifier="nm_setting_serial_new">
        <doc xml:space="preserve">Creates a new #NMSettingSerial object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingSerial object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_baud" c:identifier="nm_setting_serial_get_baud">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:baud property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bits" c:identifier="nm_setting_serial_get_bits">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:bits property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parity" c:identifier="nm_setting_serial_get_parity">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:parity property of the setting</doc>
          <type name="gchar" c:type="char"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_send_delay"
              c:identifier="nm_setting_serial_get_send_delay">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:send-delay property of the setting</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stopbits"
              c:identifier="nm_setting_serial_get_stopbits">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSerial:stopbits property of the setting</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingSerial</doc>
            <type name="SettingSerial" c:type="NMSettingSerial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="baud"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Speed to use for communication over the serial port.  Note that this
value usually has no effect for mobile broadband modems as they generally
ignore speed settings and use the highest available speed.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="bits"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Byte-width of the serial communication. The 8 in "8n1" for example.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="parity"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Parity setting of the serial port.  Either 'E' for even parity, 'o' for
odd parity, or 'n' for no parity.</doc>
        <type name="gchar" c:type="gchar"/>
      </property>
      <property name="send-delay"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Time to delay between each byte sent to the modem, in microseconds.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="stopbits"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Number of stop bits for communication on the serial port.  Either 1 or 2.
The 1 in "8n1" for example.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingSerialClass"
            c:type="NMSettingSerialClass"
            glib:is-gtype-struct-for="SettingSerial">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingSerialError"
                 glib:type-name="NMSettingSerialError"
                 glib:get-type="nm_setting_serial_error_get_type"
                 c:type="NMSettingSerialError"
                 glib:error-domain="nm-setting-serial-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_SERIAL_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_SERIAL_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_SERIAL_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="MissingPPPSetting"
              value="3"
              c:identifier="NM_SETTING_SERIAL_ERROR_MISSING_PPP_SETTING"
              glib:nick="MissingPPPSetting">
        <doc xml:space="preserve">one of the properties of the
setting requires the connection to contain an #NMSettingPPP setting</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_serial_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingSerial if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingSerial errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingTeam"
           c:symbol-prefix="setting_team"
           c:type="NMSettingTeam"
           parent="Setting"
           glib:type-name="NMSettingTeam"
           glib:get-type="nm_setting_team_get_type"
           glib:type-struct="SettingTeamClass">
      <constructor name="new"
                   c:identifier="nm_setting_team_new"
                   version="0.9.10">
        <doc xml:space="preserve">Creates a new #NMSettingTeam object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingTeam object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_config"
              c:identifier="nm_setting_team_get_config"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTeam:config property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTeam</doc>
            <type name="SettingTeam" c:type="NMSettingTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_team_get_interface_name"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTeam:interface-name property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTeam</doc>
            <type name="SettingTeam" c:type="NMSettingTeam*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="config" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The JSON configuration for the team network interface.  The property
should contain raw JSON configuration data suitable for teamd, because
the value is passed directly to teamd. If not specified, the default
configuration is used.  See man teamd.conf for the format details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="interface-name" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The name of the virtual in-kernel team network interface</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingTeamClass"
            c:type="NMSettingTeamClass"
            glib:is-gtype-struct-for="SettingTeam">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingTeamError"
                 glib:type-name="NMSettingTeamError"
                 glib:get-type="nm_setting_team_error_get_type"
                 c:type="NMSettingTeamError"
                 glib:error-domain="nm-setting-team-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_TEAM_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_TEAM_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_TEAM_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_team_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMSettingTeam if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingTeam errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingTeamPort"
           c:symbol-prefix="setting_team_port"
           c:type="NMSettingTeamPort"
           parent="Setting"
           glib:type-name="NMSettingTeamPort"
           glib:get-type="nm_setting_team_port_get_type"
           glib:type-struct="SettingTeamPortClass">
      <constructor name="new"
                   c:identifier="nm_setting_team_port_new"
                   version="0.9.10">
        <doc xml:space="preserve">Creates a new #NMSettingTeamPort object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingTeamPort object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_config"
              c:identifier="nm_setting_team_port_get_config"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingTeamPort:config property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingTeamPort</doc>
            <type name="SettingTeamPort" c:type="NMSettingTeamPort*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="config" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The JSON configuration for the team port. The property should contain raw
JSON configuration data suitable for teamd, because the value is passed
directly to teamd. If not specified, the default configuration is
used. See man teamd.conf for the format details.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingTeamPortClass"
            c:type="NMSettingTeamPortClass"
            glib:is-gtype-struct-for="SettingTeamPort">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingTeamPortError"
                 glib:type-name="NMSettingTeamPortError"
                 glib:get-type="nm_setting_team_port_error_get_type"
                 c:type="NMSettingTeamPortError"
                 glib:error-domain="nm-setting-team-port-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_TEAM_PORT_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_TEAM_PORT_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_TEAM_PORT_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and
is required</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_team_port_error_quark"
                version="0.9.10">
        <doc xml:space="preserve">Registers an error quark for #NMSettingTeamPort if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingTeamPort errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingVPN"
           c:symbol-prefix="setting_vpn"
           c:type="NMSettingVPN"
           parent="Setting"
           glib:type-name="NMSettingVPN"
           glib:get-type="nm_setting_vpn_get_type"
           glib:type-struct="SettingVPNClass">
      <constructor name="new" c:identifier="nm_setting_vpn_new">
        <doc xml:space="preserve">Creates a new #NMSettingVPN object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingVPN object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_data_item" c:identifier="nm_setting_vpn_add_data_item">
        <doc xml:space="preserve">Establishes a relationship between @key and @item internally in the
setting which may be retrieved later.  Should not be used to store passwords
or other secrets, which is what nm_setting_vpn_add_secret() is for.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a name that uniquely identifies the given value @item</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">the value to be referenced by @key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_secret" c:identifier="nm_setting_vpn_add_secret">
        <doc xml:space="preserve">Establishes a relationship between @key and @secret internally in the
setting which may be retrieved later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">a name that uniquely identifies the given secret @secret</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="secret" transfer-ownership="none">
            <doc xml:space="preserve">the secret to be referenced by @key</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_data_item"
              c:identifier="nm_setting_vpn_foreach_data_item">
        <doc xml:space="preserve">Iterates all data items stored in this setting.  It is safe to add, remove,
and modify data items inside @func, though any additions or removals made
during iteration will not be part of the iteration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">an user provided function</doc>
            <type name="VPNIterFunc" c:type="NMVPNIterFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to be passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_secret"
              c:identifier="nm_setting_vpn_foreach_secret">
        <doc xml:space="preserve">Iterates all secrets stored in this setting.  It is safe to add, remove,
and modify secrets inside @func, though any additions or removals made during
iteration will not be part of the iteration.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">an user provided function</doc>
            <type name="VPNIterFunc" c:type="NMVPNIterFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">data to be passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_data_item" c:identifier="nm_setting_vpn_get_data_item">
        <doc xml:space="preserve">Retrieves the data item of a key/value relationship previously established
by nm_setting_vpn_add_data_item().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data item, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the data item to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_num_data_items"
              c:identifier="nm_setting_vpn_get_num_data_items">
        <doc xml:space="preserve">Gets number of key/value pairs of VPN configuration data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of VPN plugin specific configuration data items</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_secrets"
              c:identifier="nm_setting_vpn_get_num_secrets">
        <doc xml:space="preserve">Gets number of VPN plugin specific secrets in the setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of VPN plugin specific secrets</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_persistent"
              c:identifier="nm_setting_vpn_get_persistent">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVPN:persistent property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secret" c:identifier="nm_setting_vpn_get_secret">
        <doc xml:space="preserve">Retrieves the secret of a key/value relationship previously established
by nm_setting_vpn_add_secret().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the secret, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret to retrieve</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_service_type"
              c:identifier="nm_setting_vpn_get_service_type">
        <doc xml:space="preserve">Returns the service name of the VPN, which identifies the specific VPN
plugin that should be used to connect to this VPN.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the VPN plugin's service name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_user_name" c:identifier="nm_setting_vpn_get_user_name">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVPN:user-name property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_data_item"
              c:identifier="nm_setting_vpn_remove_data_item">
        <doc xml:space="preserve">Deletes a key/value relationship previously established by
nm_setting_vpn_add_data_item().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the data item was found and removed from the internal list,
%FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the data item to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_secret" c:identifier="nm_setting_vpn_remove_secret">
        <doc xml:space="preserve">Deletes a key/value relationship previously established by
nm_setting_vpn_add_secret().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the secret was found and removed from the internal list,
%FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVPN</doc>
            <type name="SettingVPN" c:type="NMSettingVPN*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the name of the secret to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="data"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of VPN plugin specific data.  Both keys and
values must be strings.</doc>
        <type/>
      </property>
      <property name="persistent" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the VPN service supports persistence, and this property is %TRUE,
the VPN will attempt to stay connected across link changes and outages,
until explicitly disconnected.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="secrets"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of VPN plugin specific secrets like
passwords or private keys.  Both keys and values must be strings.</doc>
        <type/>
      </property>
      <property name="service-type" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">D-Bus service name of the VPN plugin that this setting uses to connect to
its network.  i.e. org.freedesktop.NetworkManager.vpnc for the vpnc
plugin.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="user-name" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If the VPN connection requires a user name for authentication, that name
should be provided here.  If the connection is available to more than one
user, and the VPN requires each user to supply a different name, then
leave this property empty.  If this property is empty, NetworkManager
will automatically supply the username of the user which requested the
VPN connection.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingVPNClass"
            c:type="NMSettingVPNClass"
            glib:is-gtype-struct-for="SettingVPN">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <callback name="SettingValueIterFn" c:type="NMSettingValueIterFn">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve">The setting for which properties are being iterated, given to
nm_setting_enumerate_values()</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">The value/property name</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The property's value</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">The property's flags, like %NM_SETTING_PARAM_SECRET</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="4">
          <doc xml:space="preserve">User data passed to nm_setting_enumerate_values()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SettingVlan"
           c:symbol-prefix="setting_vlan"
           c:type="NMSettingVlan"
           parent="Setting"
           glib:type-name="NMSettingVlan"
           glib:get-type="nm_setting_vlan_get_type"
           glib:type-struct="SettingVlanClass">
      <constructor name="new" c:identifier="nm_setting_vlan_new">
        <doc xml:space="preserve">Creates a new #NMSettingVlan object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingVlan object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_priority" c:identifier="nm_setting_vlan_add_priority">
        <doc xml:space="preserve">Adds a priority mapping to the #NMSettingVlan:ingress_priority_map or
#NMSettingVlan:egress_priority_map properties of the setting. If @from is
already in the given priority map, this function will overwrite the
existing entry with the new @to.

If @map is #NM_VLAN_INGRESS_MAP then @from is the incoming 802.1q VLAN
Priority Code Point (PCP) value, and @to is the Linux SKB priority value.

If @map is #NM_VLAN_EGRESS_MAP then @from is the Linux SKB priority value and
@to is the outgoing 802.1q VLAN Priority Code Point (PCP) value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the new priority mapping was successfully added to the
list, %FALSE if error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map to @to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map @from to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_priority_str"
              c:identifier="nm_setting_vlan_add_priority_str">
        <doc xml:space="preserve">Adds a priority map entry into either the #NMSettingVlan:ingress_priority_map
or the #NMSettingVlan:egress_priority_map properties.  The priority map maps
the Linux SKB priorities to 802.1p priorities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the entry was successfully added to the list, or it
overwrote the old value, %FALSE if error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">the string which contains a priority map, like "3:7"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_priorities"
              c:identifier="nm_setting_vlan_clear_priorities">
        <doc xml:space="preserve">Clear all the entries from #NMSettingVlan:ingress_priority_map or
#NMSettingVlan:egress_priority_map properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="nm_setting_vlan_get_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVlan:flags property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="nm_setting_vlan_get_id">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVlan:id property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_interface_name"
              c:identifier="nm_setting_vlan_get_interface_name">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVlan:interface_name property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_priorities"
              c:identifier="nm_setting_vlan_get_num_priorities">
        <doc xml:space="preserve">Returns the number of entries in the
#NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
properties of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">return the number of ingress/egress priority entries, -1 if error</doc>
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="nm_setting_vlan_get_parent">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingVlan:parent property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_priority" c:identifier="nm_setting_vlan_get_priority">
        <doc xml:space="preserve">Retrieve one of the entries of the #NMSettingVlan:ingress_priority_map
or #NMSettingVlan:egress_priority_map properties of this setting.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a priority map was returned, %FALSE if error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the ingress/egress priority map entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_from"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return the value of the priority map's 'from' item</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="out_to"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return the value of priority map's 'to' item</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_priority"
              c:identifier="nm_setting_vlan_remove_priority">
        <doc xml:space="preserve">Removes the priority map at index @idx from the
#NMSettingVlan:ingress_priority_map or #NMSettingVlan:egress_priority_map
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the priority map to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_priority_by_value"
              c:identifier="nm_setting_vlan_remove_priority_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the priority map @form:@to from the #NMSettingVlan:ingress_priority_map
or #NMSettingVlan:egress_priority_map (according to @map argument)
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the priority mapping was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map to @to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">the priority to map @from to</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_priority_str_by_value"
              c:identifier="nm_setting_vlan_remove_priority_str_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the priority map @str from the #NMSettingVlan:ingress_priority_map
or #NMSettingVlan:egress_priority_map (according to @map argument)
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the priority mapping was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingVlan</doc>
            <type name="SettingVlan" c:type="NMSettingVlan*"/>
          </instance-parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve">the type of priority map</doc>
            <type name="VlanPriorityMap" c:type="NMVlanPriorityMap"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">the string which contains a priority map, like "3:7"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="egress-priority-map"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">For outgoing packets, a list of mappings from Linux SKB priorities to
802.1p priorities.  The mapping is given in the format "from:to" where
both "from" and "to" are unsigned integers, ie "7:3".</doc>
        <type/>
      </property>
      <property name="flags"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">One or more flags which control the behavior and features of the VLAN
interface.  Flags include %NM_VLAN_FLAG_REORDER_HEADERS (reordering of
output packet headers), %NM_VLAN_FLAG_GVRP (use of the GVRP protocol),
and %NM_VLAN_FLAG_LOOSE_BINDING (loose binding of the interface to its
master device's operating state), %NM_VLAN_FLAG_MVRP (use of the MVRP
protocol).</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="id" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The VLAN identifier that the interface created by this connection should
be assigned.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="ingress-priority-map"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">For incoming packets, a list of mappings from 802.1p priorities to Linux
SKB priorities.  The mapping is given in the format "from:to" where both
"from" and "to" are unsigned integers, ie "7:3".</doc>
        <type/>
      </property>
      <property name="interface-name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the kernel name of the VLAN interface. If not given,
a default name will be constructed from the interface described by the
parent interface and the #NMSettingVlan:id property, eg "eth2.1". The
parent interface may be given by the #NMSettingVlan:parent property or by
the #NMSettingWired:mac-address property of an #NMSettingWired setting.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parent"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If given, specifies the parent interface name or parent connection UUID
from which this VLAN interface should be created.  If this property is
not specified, the connection must contain an #NMSettingWired setting
with a #NMSettingWired:mac-address property.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingVlanClass"
            c:type="NMSettingVlanClass"
            glib:is-gtype-struct-for="SettingVlan">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingVlanError"
                 glib:type-name="NMSettingVlanError"
                 glib:get-type="nm_setting_vlan_error_get_type"
                 c:type="NMSettingVlanError"
                 glib:error-domain="nm-setting-vlan-error-quark">
      <member name="Unknown"
              value="0"
              c:identifier="NM_SETTING_VLAN_ERROR_UNKNOWN"
              glib:nick="Unknown">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_VLAN_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_VLAN_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
  required</doc>
      </member>
      <member name="InvalidParent"
              value="3"
              c:identifier="NM_SETTING_VLAN_ERROR_INVALID_PARENT"
              glib:nick="InvalidParent">
        <doc xml:space="preserve">the VLAN parent was specified
  inconsistently</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_vlan_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingVlan if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingVlan errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="SettingVpnError"
                 glib:type-name="NMSettingVpnError"
                 glib:get-type="nm_setting_vpn_error_get_type"
                 c:type="NMSettingVpnError"
                 glib:error-domain="nm-setting-vpn-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_VPN_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_VPN_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_VPN_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_vpn_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingVPN if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingVPN errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWimax"
           c:symbol-prefix="setting_wimax"
           c:type="NMSettingWimax"
           parent="Setting"
           glib:type-name="NMSettingWimax"
           glib:get-type="nm_setting_wimax_get_type"
           glib:type-struct="SettingWimaxClass">
      <constructor name="new"
                   c:identifier="nm_setting_wimax_new"
                   deprecated="1"
                   deprecated-version="1.2">
        <doc xml:space="preserve">Creates a new #NMSettingWimax object with default values.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWimax object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="get_mac_address"
              c:identifier="nm_setting_wimax_get_mac_address"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Returns the MAC address of a WiMAX device which this connection is locked
to.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MAC address</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWimax</doc>
            <type name="SettingWimax" c:type="NMSettingWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_network_name"
              c:identifier="nm_setting_wimax_get_network_name"
              deprecated="1"
              deprecated-version="1.2">
        <doc xml:space="preserve">Returns the WiMAX NSP name (ex "Sprint" or "CLEAR") which identifies the
specific WiMAX network this setting describes a connection to.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WiMAX NSP name</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWimax</doc>
            <type name="SettingWimax" c:type="NMSettingWimax*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="mac-address"
                introspectable="0"
                deprecated="1"
                deprecated-version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the WiMAX device whose
MAC address matches. This property does not change the MAC address of the
device (known as MAC spoofing).</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type/>
      </property>
      <property name="network-name"
                deprecated="1"
                deprecated-version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Network Service Provider (NSP) name of the WiMAX network this connection
should use.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWimaxClass"
            c:type="NMSettingWimaxClass"
            glib:is-gtype-struct-for="SettingWimax">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
    </record>
    <enumeration name="SettingWimaxError"
                 glib:type-name="NMSettingWimaxError"
                 glib:get-type="nm_setting_wimax_error_get_type"
                 c:type="NMSettingWimaxError"
                 glib:error-domain="nm-setting-wimax-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIMAX_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIMAX_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIMAX_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_wimax_error_quark"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Registers an error quark for #NMSettingWimax if necessary.</doc>
        <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingWimax errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWired"
           c:symbol-prefix="setting_wired"
           c:type="NMSettingWired"
           parent="Setting"
           glib:type-name="NMSettingWired"
           glib:get-type="nm_setting_wired_get_type"
           glib:type-struct="SettingWiredClass">
      <constructor name="new" c:identifier="nm_setting_wired_new">
        <doc xml:space="preserve">Creates a new #NMSettingWired object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWired object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_mac_blacklist_item"
              c:identifier="nm_setting_wired_add_mac_blacklist_item"
              version="0.9.10">
        <doc xml:space="preserve">Adds a new MAC address to the #NMSettingWired:mac-address-blacklist property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was added; %FALSE if the MAC address
is invalid or was already present</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_s390_option"
              c:identifier="nm_setting_wired_add_s390_option">
        <doc xml:space="preserve">Add an option to the table.  The option is compared to an internal list
of allowed options.  Key names may contain only alphanumeric characters
(ie [a-zA-Z0-9]).  Adding a new key replaces any existing key/value pair that
may already exist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was valid and was added to the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">key name for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">value for the option</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_mac_blacklist_items"
              c:identifier="nm_setting_wired_clear_mac_blacklist_items"
              version="0.9.10">
        <doc xml:space="preserve">Removes all blacklisted MAC addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auto_negotiate"
              c:identifier="nm_setting_wired_get_auto_negotiate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:auto-negotiate property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cloned_mac_address"
              c:identifier="nm_setting_wired_get_cloned_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:cloned-mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_duplex" c:identifier="nm_setting_wired_get_duplex">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:duplex property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_wired_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address_blacklist"
              c:identifier="nm_setting_wired_get_mac_address_blacklist">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:mac-address-blacklist
property of the setting</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <array name="GLib.ByteArray">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_blacklist_item"
              c:identifier="nm_setting_wired_get_mac_blacklist_item"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blacklisted MAC address string (hex-digits-and-colons notation)
at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the MAC address entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_wired_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_mac_blacklist_items"
              c:identifier="nm_setting_wired_get_num_mac_blacklist_items"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of blacklisted MAC addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_s390_options"
              c:identifier="nm_setting_wired_get_num_s390_options">
        <doc xml:space="preserve">Returns the number of s390-specific options that should be set for this
device when it is activated.  This can be used to retrieve each s390
option individually using nm_setting_wired_get_s390_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of s390-specific device options</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="nm_setting_wired_get_port">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:port property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_s390_nettype"
              c:identifier="nm_setting_wired_get_s390_nettype">
        <doc xml:space="preserve">Returns the s390 device type this connection should apply to.  Will be one
of 'qeth', 'lcs', or 'ctc'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the s390 device type</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_s390_option"
              c:identifier="nm_setting_wired_get_s390_option">
        <doc xml:space="preserve">Given an index, return the value of the s390 option at that index.  indexes
are *not* guaranteed to be static across modifications to options done by
nm_setting_wired_add_s390_option() and nm_setting_wired_remove_s390_option(),
and should not be used to refer to options except for short periods of time
such as during option iteration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success if the index was valid and an option was found,
%FALSE if the index was invalid (ie, greater than the number of options
currently held by the setting)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index of the desired option, from 0 to
nm_setting_wired_get_num_s390_options() - 1</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="out_key"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, the key name of the s390 specific option; this
value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
          <parameter name="out_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">on return, the value of the key of the s390 specific
option; this value is owned by the setting and should not be modified</doc>
            <type name="utf8" c:type="const char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_s390_option_by_key"
              c:identifier="nm_setting_wired_get_s390_option_by_key">
        <doc xml:space="preserve">Returns the value associated with the s390-specific option specified by
@key, if it exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the value, or %NULL if the key/value pair was never added to the
setting; the value is owned by the setting and must not be modified</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the key for which to retrieve the value</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_s390_subchannels"
              c:identifier="nm_setting_wired_get_s390_subchannels">
        <doc xml:space="preserve">Return the list of s390 subchannels that identify the device that this
connection is applicable to.  The connection should only be used in
conjunction with that device.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GPtrArray of strings, each specifying one
subchannel the s390 device uses to communicate to the host.</doc>
          <array name="GLib.PtrArray" c:type="const GPtrArray*">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_speed" c:identifier="nm_setting_wired_get_speed">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWired:speed property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_valid_s390_options"
              c:identifier="nm_setting_wired_get_valid_s390_options"
              version="0.9.10">
        <doc xml:space="preserve">Returns a list of valid s390 options.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a %NULL-terminated array of strings of valid s390 options.</doc>
          <array c:type="const char**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item"
              c:identifier="nm_setting_wired_remove_mac_blacklist_item"
              version="0.9.10">
        <doc xml:space="preserve">Removes the MAC address at index @idx from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the MAC address</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item_by_value"
              c:identifier="nm_setting_wired_remove_mac_blacklist_item_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the MAC address @mac from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to remove from
the blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_s390_option"
              c:identifier="nm_setting_wired_remove_s390_option">
        <doc xml:space="preserve">Remove the s390-specific option referenced by @key from the internal option
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the option was found and removed from the internal option
list, %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWired</doc>
            <type name="SettingWired" c:type="NMSettingWired*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">key name for the option to remove</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-negotiate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, allow auto-negotiation of port speed and duplex mode.  If
%FALSE, do not allow auto-negotiation, in which case the "speed" and
"duplex" properties should be set.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="cloned-mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, request that the device use this MAC address instead of its
permanent MAC address.  This is known as MAC cloning or spoofing.</doc>
        <type/>
      </property>
      <property name="duplex" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If specified, request that the device only use the specified duplex mode.
Either "half" or "full".</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the Ethernet device
whose permanent MAC address matches. This property does not change the
MAC address of the device (i.e. MAC spoofing).</doc>
        <type/>
      </property>
      <property name="mac-address-blacklist"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will never apply to the Ethernet device
whose permanent MAC address matches an address in the list.  Each MAC
address is in the standard hex-digits-and-colons notation
(00:11:22:33:44:55).</doc>
        <type/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple Ethernet frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="port" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Specific port type to use if the device supports multiple
attachment methods.  One of "tp" (Twisted Pair), "aui" (Attachment Unit
Interface), "bnc" (Thin Ethernet) or "mii" (Media Independent Interface).
If the device supports only one port type, this setting is ignored.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="s390-nettype" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">s390 network device type; one of "qeth", "lcs", or "ctc", representing
the different types of virtual network devices available on s390 systems.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="s390-options"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Dictionary of key/value pairs of s390-specific device options.  Both keys
and values must be strings.  Allowed keys include "portno", "layer2",
"portname", "protocol", among others.  Key names must contain only
alphanumeric characters (ie, [a-zA-Z0-9]).</doc>
        <type/>
      </property>
      <property name="s390-subchannels"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Identifies specific subchannels that this network device uses for
communication with z/VM or s390 host.  Like the
#NMSettingWired:mac-address property for non-z/VM devices, this property
can be used to ensure this connection only applies to the network device
that uses these subchannels.  The list should contain exactly 3 strings,
and each string may only be composed of hexadecimal characters and the
period (.) character.</doc>
        <type/>
      </property>
      <property name="speed"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, request that the device use only the specified speed.  In
Mbit/s, ie 100 == 100Mbit/s.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWiredClass"
            c:type="NMSettingWiredClass"
            glib:is-gtype-struct-for="SettingWired">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingWiredError"
                 glib:type-name="NMSettingWiredError"
                 glib:get-type="nm_setting_wired_error_get_type"
                 c:type="NMSettingWiredError"
                 glib:error-domain="nm-setting-wired-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIRED_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIRED_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIRED_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_wired_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingWired if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingWired errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWireless"
           c:symbol-prefix="setting_wireless"
           c:type="NMSettingWireless"
           parent="Setting"
           glib:type-name="NMSettingWireless"
           glib:get-type="nm_setting_wireless_get_type"
           glib:type-struct="SettingWirelessClass">
      <constructor name="new" c:identifier="nm_setting_wireless_new">
        <doc xml:space="preserve">Creates a new #NMSettingWireless object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWireless object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_mac_blacklist_item"
              c:identifier="nm_setting_wireless_add_mac_blacklist_item"
              version="0.9.10">
        <doc xml:space="preserve">Adds a new MAC address to the #NMSettingWireless:mac-address-blacklist property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was added; %FALSE if the MAC address
is invalid or was already present</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_seen_bssid"
              c:identifier="nm_setting_wireless_add_seen_bssid">
        <doc xml:space="preserve">Adds a new Wi-Fi AP's BSSID to the previously seen BSSID list of the setting.
NetworkManager now tracks previously seen BSSIDs internally so this function
no longer has much use. Actually, changes you make using this function will
not be preserved.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @bssid was already known, %FALSE if not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="bssid" transfer-ownership="none">
            <doc xml:space="preserve">the new BSSID to add to the list</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ap_security_compatible"
              c:identifier="nm_setting_wireless_ap_security_compatible">
        <doc xml:space="preserve">Given a #NMSettingWireless and an optional #NMSettingWirelessSecurity,
determine if the configuration given by the settings is compatible with
the security of an access point using that access point's capability flags
and mode.  Useful for clients that wish to filter a set of connections
against a set of access points and determine which connections are
compatible with which access points.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the given settings are compatible with the access point's
security flags and mode, %FALSE if they are not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="s_wireless" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="s_wireless_sec" transfer-ownership="none">
            <doc xml:space="preserve">a #NMSettingWirelessSecurity or %NULL</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </parameter>
          <parameter name="ap_flags" transfer-ownership="none">
            <doc xml:space="preserve">the %NM80211ApFlags of the given access point</doc>
            <type name="80211ApFlags" c:type="NM80211ApFlags"/>
          </parameter>
          <parameter name="ap_wpa" transfer-ownership="none">
            <doc xml:space="preserve">the %NM80211ApSecurityFlags of the given access point's WPA
capabilities</doc>
            <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
          </parameter>
          <parameter name="ap_rsn" transfer-ownership="none">
            <doc xml:space="preserve">the %NM80211ApSecurityFlags of the given access point's WPA2/RSN
capabilities</doc>
            <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
          </parameter>
          <parameter name="ap_mode" transfer-ownership="none">
            <doc xml:space="preserve">the 802.11 mode of the AP, either Ad-Hoc or Infrastructure</doc>
            <type name="80211Mode" c:type="NM80211Mode"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_mac_blacklist_items"
              c:identifier="nm_setting_wireless_clear_mac_blacklist_items"
              version="0.9.10">
        <doc xml:space="preserve">Removes all blacklisted MAC addresses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_band" c:identifier="nm_setting_wireless_get_band">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:band property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bssid" c:identifier="nm_setting_wireless_get_bssid">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:bssid property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channel"
              c:identifier="nm_setting_wireless_get_channel">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:channel property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cloned_mac_address"
              c:identifier="nm_setting_wireless_get_cloned_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:cloned-mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hidden" c:identifier="nm_setting_wireless_get_hidden">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:hidden property of the setting</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address"
              c:identifier="nm_setting_wireless_get_mac_address">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mac-address property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_address_blacklist"
              c:identifier="nm_setting_wireless_get_mac_address_blacklist">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the
#NMSettingWireless:mac-address-blacklist property of the setting</doc>
          <type name="GLib.SList" c:type="const GSList*">
            <array name="GLib.ByteArray">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mac_blacklist_item"
              c:identifier="nm_setting_wireless_get_mac_blacklist_item"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blacklisted MAC address string (hex-digits-and-colons notation)
at index @idx</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the zero-based index of the MAC address entry</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="nm_setting_wireless_get_mode">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mode property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtu" c:identifier="nm_setting_wireless_get_mtu">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:mtu property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_mac_blacklist_items"
              c:identifier="nm_setting_wireless_get_num_mac_blacklist_items"
              version="0.9.10">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of blacklisted MAC addresses</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_seen_bssids"
              c:identifier="nm_setting_wireless_get_num_seen_bssids">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of BSSIDs in the previously seen BSSID list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_powersave"
              c:identifier="nm_setting_wireless_get_powersave"
              version="1.2">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:powersave property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rate" c:identifier="nm_setting_wireless_get_rate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:rate property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_security"
              c:identifier="nm_setting_wireless_get_security"
              deprecated="1"
              deprecated-version="0.9.10">
        <doc-deprecated xml:space="preserve">No longer used. Security rescrictions are recognized by
the presence of NM_SETTING_WIRELESS_SECURITY_SETTING_NAME in the connection.</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:security property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_seen_bssid"
              c:identifier="nm_setting_wireless_get_seen_bssid">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the BSSID at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of a BSSID in the previously seen BSSID list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_ssid" c:identifier="nm_setting_wireless_get_ssid">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:ssid property of the setting</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tx_power"
              c:identifier="nm_setting_wireless_get_tx_power">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWireless:tx-power property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item"
              c:identifier="nm_setting_wireless_remove_mac_blacklist_item"
              version="0.9.10">
        <doc xml:space="preserve">Removes the MAC address at index @idx from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">index number of the MAC address</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_mac_blacklist_item_by_value"
              c:identifier="nm_setting_wireless_remove_mac_blacklist_item_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes the MAC address @mac from the blacklist.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the MAC address was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWireless</doc>
            <type name="SettingWireless" c:type="NMSettingWireless*"/>
          </instance-parameter>
          <parameter name="mac" transfer-ownership="none">
            <doc xml:space="preserve">the MAC address string (hex-digits-and-colons notation) to remove from
the blacklist</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="band" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">802.11 frequency band of the network.  One of "a" for 5GHz 802.11a or
"bg" for 2.4GHz 802.11.  This will lock associations to the Wi-Fi network
to the specific band, i.e. if "a" is specified, the device will not
associate with the same network in the 2.4GHz band even if the network's
settings are compatible.  This setting depends on specific driver
capability and may not work with all drivers.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="bssid"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, directs the device to only associate with the given access
point.  This capability is highly driver dependent and not supported by
all devices.  Note: this property does not control the BSSID used when
creating an Ad-Hoc network and is unlikely to in the future.</doc>
        <type/>
      </property>
      <property name="channel"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Wireless channel to use for the Wi-Fi connection.  The device will only
join (or create for Ad-Hoc networks) a Wi-Fi network on the specified
channel.  Because channel numbers overlap between bands, this property
also requires the "band" property to be set.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="cloned-mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, request that the Wi-Fi device use this MAC address instead
of its permanent MAC address.  This is known as MAC cloning or spoofing.</doc>
        <type/>
      </property>
      <property name="hidden" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">If %TRUE, indicates this network is a non-broadcasting network that hides
its SSID.  In this case various workarounds may take place, such as
probe-scanning the SSID for more reliable network discovery.  However,
these workarounds expose inherent insecurities with hidden SSID networks,
and thus hidden SSID networks should be used with caution.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mac-address"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If specified, this connection will only apply to the Wi-Fi device whose
permanent MAC address matches. This property does not change the MAC
address of the device (i.e. MAC spoofing).</doc>
        <type/>
      </property>
      <property name="mac-address-blacklist"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A list of permanent MAC addresses of Wi-Fi devices to which this
connection should never apply.  Each MAC address should be given in the
standard hex-digits-and-colons notation (eg "00:11:22:33:44:55").</doc>
        <type/>
      </property>
      <property name="mode" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Wi-Fi network mode; one of "infrastructure", "adhoc" or "ap".  If blank,
infrastructure is assumed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mtu"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, only transmit packets of the specified size or smaller,
breaking larger packets up into multiple Ethernet frames.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="powersave"
                version="1.2"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If set to %FALSE, Wi-Fi power saving behavior is disabled.  If set to
%TRUE, Wi-Fi power saving behavior is enabled.  All other values are
reserved.  Note that even though only boolean values are allowed, the
property type is an unsigned integer to allow for future expansion.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="rate"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, directs the device to only use the specified bitrate for
communication with the access point.  Units are in Kb/s, ie 5500 = 5.5
Mbit/s.  This property is highly driver dependent and not all devices
support setting a static bitrate.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="security"
                deprecated="1"
                deprecated-version="0.9.10"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If the wireless connection has any security restrictions, like 802.1x,
WEP, or WPA, set this property to
%NM_SETTING_WIRELESS_SECURITY_SETTING_NAME and ensure the connection
contains a valid #NMSettingWirelessSecurity setting.</doc>
        <doc-deprecated xml:space="preserve">No longer used. Security restrictions are recognized
by the presence of a #NMSettingWirelessSecurity setting in the
connection.</doc-deprecated>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="seen-bssids"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A list of BSSIDs (each BSSID formatted as a MAC address like
"00:11:22:33:44:55") that have been detected as part of the Wi-Fi
network.  NetworkManager internally tracks previously seen BSSIDs. The
property is only meant for reading and reflects the BSSID list of
NetworkManager. The changes you make to this property will not be
preserved.</doc>
        <type/>
      </property>
      <property name="ssid"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">SSID of the Wi-Fi network. Must be specified.</doc>
        <type/>
      </property>
      <property name="tx-power"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-zero, directs the device to use the specified transmit power.
Units are dBm.  This property is highly driver dependent and not all
devices support setting a static transmit power.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWirelessClass"
            c:type="NMSettingWirelessClass"
            glib:is-gtype-struct-for="SettingWireless">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingWirelessError"
                 glib:type-name="NMSettingWirelessError"
                 glib:get-type="nm_setting_wireless_error_get_type"
                 c:type="NMSettingWirelessError"
                 glib:error-domain="nm-setting-wireless-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIRELESS_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIRELESS_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIRELESS_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was missing and is
required</doc>
      </member>
      <member name="MissingSecuritySetting"
              value="3"
              c:identifier="NM_SETTING_WIRELESS_ERROR_MISSING_SECURITY_SETTING"
              glib:nick="MissingSecuritySetting">
        <doc xml:space="preserve">property values require
the presence of an #NMSettingWirelessSecurity object in the connection</doc>
      </member>
      <member name="ChannelRequiresBand"
              value="4"
              c:identifier="NM_SETTING_WIRELESS_ERROR_CHANNEL_REQUIRES_BAND"
              glib:nick="ChannelRequiresBand">
        <doc xml:space="preserve">the property channel was
set to a value that requires the #NMSettingWireless:band property to be set</doc>
      </member>
      <function name="quark" c:identifier="nm_setting_wireless_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingWireless if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingWireless errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SettingWirelessSecurity"
           c:symbol-prefix="setting_wireless_security"
           c:type="NMSettingWirelessSecurity"
           parent="Setting"
           glib:type-name="NMSettingWirelessSecurity"
           glib:get-type="nm_setting_wireless_security_get_type"
           glib:type-struct="SettingWirelessSecurityClass">
      <constructor name="new" c:identifier="nm_setting_wireless_security_new">
        <doc xml:space="preserve">Creates a new #NMSettingWirelessSecurity object with default values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new empty #NMSettingWirelessSecurity object</doc>
          <type name="Setting" c:type="NMSetting*"/>
        </return-value>
      </constructor>
      <method name="add_group"
              c:identifier="nm_setting_wireless_security_add_group">
        <doc xml:space="preserve">Adds an encryption algorithm to the list of allowed groupwise encryption
algorithms.  If the list is not empty, then only access points that support
one or more of the encryption algorithms in the list will be considered
compatible with this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the algorithm was added to the list, %FALSE if it was
already in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to add, one of "wep40", "wep104",
"tkip", or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_pairwise"
              c:identifier="nm_setting_wireless_security_add_pairwise">
        <doc xml:space="preserve">Adds an encryption algorithm to the list of allowed pairwise encryption
algorithms.  If the list is not empty, then only access points that support
one or more of the encryption algorithms in the list will be considered
compatible with this connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the algorithm was added to the list, %FALSE if it was
already in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="pairwise" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to add, one of "tkip" or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_proto"
              c:identifier="nm_setting_wireless_security_add_proto">
        <doc xml:space="preserve">Adds a Wi-Fi security protocol (one of "wpa" or "rsn") to the allowed list;
only protocols in this list will be used when finding and connecting to
the Wi-Fi network specified by this connection.  For example, if the
protocol list contains only "wpa" but the access point for the SSID specified
by this connection only supports WPA2/RSN, the connection cannot be used
with the access point.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the protocol was new and was added to the allowed
protocol list, or %FALSE if it was already in the list</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="proto" transfer-ownership="none">
            <doc xml:space="preserve">the protocol to add, one of "wpa" or "rsn"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_groups"
              c:identifier="nm_setting_wireless_security_clear_groups">
        <doc xml:space="preserve">Removes all algorithms from the allowed list.  If there are no algorithms
specified then all groupwise encryption algorithms are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_pairwise"
              c:identifier="nm_setting_wireless_security_clear_pairwise">
        <doc xml:space="preserve">Removes all algorithms from the allowed list.  If there are no algorithms
specified then all pairwise encryption algorithms are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear_protos"
              c:identifier="nm_setting_wireless_security_clear_protos">
        <doc xml:space="preserve">Removes all protocols from the allowed list.  If there are no protocols
specified then all protocols are allowed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_auth_alg"
              c:identifier="nm_setting_wireless_security_get_auth_alg">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:auth-alg property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_group"
              c:identifier="nm_setting_wireless_security_get_group">
        <doc xml:space="preserve">Returns the allowed groupwise encryption algorithm from allowed algorithm
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the groupwise encryption algorithm at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of an item in the allowed groupwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_key_mgmt"
              c:identifier="nm_setting_wireless_security_get_key_mgmt">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:key-mgmt property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_leap_password"
              c:identifier="nm_setting_wireless_security_get_leap_password">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:leap-password property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_leap_password_flags"
              c:identifier="nm_setting_wireless_security_get_leap_password_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSettingWirelessSecurity:leap-password</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_leap_username"
              c:identifier="nm_setting_wireless_security_get_leap_username">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:leap-username property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_groups"
              c:identifier="nm_setting_wireless_security_get_num_groups">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of groupwise encryption algorithms in the allowed list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_pairwise"
              c:identifier="nm_setting_wireless_security_get_num_pairwise">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of pairwise encryption algorithms in the allowed list</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_num_protos"
              c:identifier="nm_setting_wireless_security_get_num_protos">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of security protocols this connection allows when
connecting to secure Wi-Fi networks</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pairwise"
              c:identifier="nm_setting_wireless_security_get_pairwise">
        <doc xml:space="preserve">Returns the allowed pairwise encryption algorithm from allowed algorithm
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the pairwise encryption algorithm at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of an item in the allowed pairwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_proto"
              c:identifier="nm_setting_wireless_security_get_proto">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the protocol at index @i</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">an index into the protocol list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_psk"
              c:identifier="nm_setting_wireless_security_get_psk">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:psk property of the setting</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_psk_flags"
              c:identifier="nm_setting_wireless_security_get_psk_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the
#NMSettingWirelessSecurity:psk</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wep_key"
              c:identifier="nm_setting_wireless_security_get_wep_key">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the WEP key at the given index</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the WEP key index (0..3 inclusive)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_wep_key_flags"
              c:identifier="nm_setting_wireless_security_get_wep_key_flags">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingSecretFlags pertaining to the all WEP keys</doc>
          <type name="SettingSecretFlags" c:type="NMSettingSecretFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wep_key_type"
              c:identifier="nm_setting_wireless_security_get_wep_key_type">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:wep-key-type property of the setting</doc>
          <type name="WepKeyType" c:type="NMWepKeyType"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wep_tx_keyidx"
              c:identifier="nm_setting_wireless_security_get_wep_tx_keyidx">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NMSettingWirelessSecurity:wep-tx-keyidx property of the setting</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_group"
              c:identifier="nm_setting_wireless_security_remove_group">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed groupwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of an item in the allowed groupwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_by_value"
              c:identifier="nm_setting_wireless_security_remove_group_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed groupwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the algorithm was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="group" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to remove, one of "wep40", "wep104",
"tkip", or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pairwise"
              c:identifier="nm_setting_wireless_security_remove_pairwise">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed pairwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">the index of an item in the allowed pairwise encryption algorithm list</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pairwise_by_value"
              c:identifier="nm_setting_wireless_security_remove_pairwise_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes an encryption algorithm from the allowed pairwise encryption
algorithm list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the encryption algorith was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="pairwise" transfer-ownership="none">
            <doc xml:space="preserve">the encryption algorithm to remove, one of "tkip" or "ccmp"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_proto"
              c:identifier="nm_setting_wireless_security_remove_proto">
        <doc xml:space="preserve">Removes a protocol from the allowed protocol list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:space="preserve">index of the protocol to remove</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_proto_by_value"
              c:identifier="nm_setting_wireless_security_remove_proto_by_value"
              version="0.9.10">
        <doc xml:space="preserve">Removes a protocol from the allowed protocol list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the protocol was found and removed; %FALSE if it was not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="proto" transfer-ownership="none">
            <doc xml:space="preserve">the protocol to remove, one of "wpa" or "rsn"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_wep_key"
              c:identifier="nm_setting_wireless_security_set_wep_key">
        <doc xml:space="preserve">Sets a WEP key in the given index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="setting" transfer-ownership="none">
            <doc xml:space="preserve">the #NMSettingWirelessSecurity</doc>
            <type name="SettingWirelessSecurity"
                  c:type="NMSettingWirelessSecurity*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve">the index of the key (0..3 inclusive)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">the WEP key as a string, in either hexadecimal, ASCII, or passphrase
form as determiend by the value of the #NMSettingWirelessSecurity:wep-key-type
property.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auth-alg" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">When WEP is used (ie, key-mgmt = "none" or "ieee8021x") indicate the
802.11 authentication algorithm required by the AP here.  One of "open"
for Open System, "shared" for Shared Key, or "leap" for Cisco LEAP.  When
using Cisco LEAP (ie, key-mgmt = "ieee8021x" and auth-alg = "leap") the
"leap-username" and "leap-password" properties must be specified.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="group"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A list of group/broadcast encryption algorithms which prevents
connections to Wi-Fi networks that do not utilize one of the algorithms
in the list.  For maximum compatibility leave this property empty.  Each
list element may be one of "wep40", "wep104", "tkip", or "ccmp".</doc>
        <type/>
      </property>
      <property name="key-mgmt" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Key management used for the connection.  One of "none" (WEP), "ieee8021x"
(Dynamic WEP), "wpa-none" (Ad-Hoc WPA-PSK), "wpa-psk" (infrastructure
WPA-PSK), or "wpa-eap" (WPA-Enterprise).  This property must be set for
any Wi-Fi connection that uses security.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="leap-password" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The login password for legacy LEAP connections (ie, key-mgmt =
"ieee8021x" and auth-alg = "leap").</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="leap-password-flags"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the
#NMSettingWirelessSecurity:leap-password property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="leap-username" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The login username for legacy LEAP connections (ie, key-mgmt =
"ieee8021x" and auth-alg = "leap").</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pairwise"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">A list of pairwise encryption algorithms which prevents connections to
Wi-Fi networks that do not utilize one of the algorithms in the list.
For maximum compatibility leave this property empty.  Each list element
may be one of "tkip" or "ccmp".</doc>
        <type/>
      </property>
      <property name="proto"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:space="preserve">List of strings specifying the allowed WPA protocol versions to use.
Each element may be one "wpa" (allow WPA) or "rsn" (allow WPA2/RSN).  If
not specified, both WPA and RSN connections are allowed.</doc>
        <type/>
      </property>
      <property name="psk" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Pre-Shared-Key for WPA networks.  If the key is 64-characters long, it
must contain only hexadecimal characters and is interpreted as a
hexadecimal WPA key.  Otherwise, the key must be between 8 and 63 ASCII
characters (as specified in the 802.11i standard) and is interpreted as a
WPA passphrase, and is hashed to derive the actual WPA-PSK used when
connecting to the Wi-Fi network.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="psk-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingWirelessSecurity:psk
property.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="wep-key-flags" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Flags indicating how to handle the #NMSettingWirelessSecurity:wep-key0,
#NMSettingWirelessSecurity:wep-key1, #NMSettingWirelessSecurity:wep-key2,
and #NMSettingWirelessSecurity:wep-key3 properties.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="wep-key-type"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">Controls the interpretation of WEP keys.  Allowed values are
%NM_WEP_KEY_TYPE_KEY, in which case the key is either a 10- or
26-character hexadecimal string, or a 5- or 13-character ASCII password;
or %NM_WEP_KEY_TYPE_PASSPHRASE, in which case the passphrase is provided
as a string and will be hashed using the de-facto MD5 method to derive
the actual WEP key.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="wep-key0" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 0 WEP key.  This is the WEP key used in most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-key1" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 1 WEP key.  This WEP index is not used by most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-key2" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 2 WEP key.  This WEP index is not used by most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-key3" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Index 3 WEP key.  This WEP index is not used by most networks.  See the
"wep-key-type" property for a description of how this key is interpreted.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="wep-tx-keyidx"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">When static WEP is used (ie, key-mgmt = "none") and a non-default WEP key
index is used by the AP, put that WEP key index here.  Valid values are 0
(default key) through 3.  Note that some consumer access points (like the
Linksys WRT54G) number the keys 1 - 4.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="Setting" c:type="NMSetting"/>
      </field>
    </class>
    <record name="SettingWirelessSecurityClass"
            c:type="NMSettingWirelessSecurityClass"
            glib:is-gtype-struct-for="SettingWirelessSecurity">
      <field name="parent">
        <type name="SettingClass" c:type="NMSettingClass"/>
      </field>
      <field name="_reserved1" introspectable="0">
        <callback name="_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved2" introspectable="0">
        <callback name="_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved3" introspectable="0">
        <callback name="_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_reserved4" introspectable="0">
        <callback name="_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="SettingWirelessSecurityError"
                 glib:type-name="NMSettingWirelessSecurityError"
                 glib:get-type="nm_setting_wireless_security_error_get_type"
                 c:type="NMSettingWirelessSecurityError"
                 glib:error-domain="nm-setting-wireless-security-error-quark">
      <member name="UnknownError"
              value="0"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_UNKNOWN"
              glib:nick="UnknownError">
        <doc xml:space="preserve">unknown or unclassified error</doc>
      </member>
      <member name="InvalidProperty"
              value="1"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_INVALID_PROPERTY"
              glib:nick="InvalidProperty">
        <doc xml:space="preserve">the property was invalid</doc>
      </member>
      <member name="MissingProperty"
              value="2"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_MISSING_PROPERTY"
              glib:nick="MissingProperty">
        <doc xml:space="preserve">the property was
missing and is required</doc>
      </member>
      <member name="Missing8021xSetting"
              value="3"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_MISSING_802_1X_SETTING"
              glib:nick="Missing8021xSetting">
        <doc xml:space="preserve">a property contained
a value that requires the connection to contain a #NMSetting8021x setting</doc>
      </member>
      <member name="LEAPRequires8021x"
              value="4"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_LEAP_REQUIRES_802_1X"
              glib:nick="LEAPRequires8021x">
        <doc xml:space="preserve">LEAP authentication
was specified but key management was not set to "8021x"</doc>
      </member>
      <member name="LEAPRequiresUsername"
              value="5"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_LEAP_REQUIRES_USERNAME"
              glib:nick="LEAPRequiresUsername">
        <doc xml:space="preserve">LEAP authentication
was specified but no LEAP username was given</doc>
      </member>
      <member name="SharedKeyRequiresWEP"
              value="6"
              c:identifier="NM_SETTING_WIRELESS_SECURITY_ERROR_SHARED_KEY_REQUIRES_WEP"
              glib:nick="SharedKeyRequiresWEP">
        <doc xml:space="preserve">Shared Key
authentication was specified but the setting did not specify WEP as the
encryption protocol</doc>
      </member>
      <function name="quark"
                c:identifier="nm_setting_wireless_security_error_quark">
        <doc xml:space="preserve">Registers an error quark for #NMSettingWired if necessary.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the error quark used for #NMSettingWired errors.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="State" c:type="NMState">
      <doc xml:space="preserve">#NMState values indicate the current overall networking state.</doc>
      <member name="unknown" value="0" c:identifier="NM_STATE_UNKNOWN">
        <doc xml:space="preserve">networking state is unknown</doc>
      </member>
      <member name="asleep" value="10" c:identifier="NM_STATE_ASLEEP">
        <doc xml:space="preserve">networking is not enabled</doc>
      </member>
      <member name="disconnected"
              value="20"
              c:identifier="NM_STATE_DISCONNECTED">
        <doc xml:space="preserve">there is no active network connection</doc>
      </member>
      <member name="disconnecting"
              value="30"
              c:identifier="NM_STATE_DISCONNECTING">
        <doc xml:space="preserve">network connections are being cleaned up</doc>
      </member>
      <member name="connecting" value="40" c:identifier="NM_STATE_CONNECTING">
        <doc xml:space="preserve">a network connection is being started</doc>
      </member>
      <member name="connected_local"
              value="50"
              c:identifier="NM_STATE_CONNECTED_LOCAL">
        <doc xml:space="preserve">there is only local IPv4 and/or IPv6 connectivity</doc>
      </member>
      <member name="connected_site"
              value="60"
              c:identifier="NM_STATE_CONNECTED_SITE">
        <doc xml:space="preserve">there is only site-wide IPv4 and/or IPv6 connectivity</doc>
      </member>
      <member name="connected_global"
              value="70"
              c:identifier="NM_STATE_CONNECTED_GLOBAL">
        <doc xml:space="preserve">there is global IPv4 and/or IPv6 Internet connectivity</doc>
      </member>
    </enumeration>
    <constant name="UTILS_HWADDR_LEN_MAX"
              value="20"
              c:type="NM_UTILS_HWADDR_LEN_MAX">
      <doc xml:space="preserve">The maximum length of hardware addresses handled by NetworkManager itself,
nm_utils_hwaddr_len(), and nm_utils_hwaddr_aton().</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="UtilsFileSearchInPathsPredicate"
              c:type="NMUtilsFileSearchInPathsPredicate">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="UtilsSecurityType"
                 glib:type-name="NMUtilsSecurityType"
                 glib:get-type="nm_utils_security_type_get_type"
                 c:type="NMUtilsSecurityType">
      <doc xml:space="preserve">Describes generic security mechanisms that 802.11 access points may offer.
Used with nm_utils_security_valid() for checking whether a given access
point is compatible with a network device.</doc>
      <member name="invalid"
              value="0"
              c:identifier="NMU_SEC_INVALID"
              glib:nick="invalid">
        <doc xml:space="preserve">unknown or invalid security, placeholder and not used</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="NMU_SEC_NONE"
              glib:nick="none">
        <doc xml:space="preserve">unencrypted and open</doc>
      </member>
      <member name="static_wep"
              value="2"
              c:identifier="NMU_SEC_STATIC_WEP"
              glib:nick="static-wep">
        <doc xml:space="preserve">static WEP keys are used for encryption</doc>
      </member>
      <member name="leap"
              value="3"
              c:identifier="NMU_SEC_LEAP"
              glib:nick="leap">
        <doc xml:space="preserve">Cisco LEAP is used for authentication and for generating the
dynamic WEP keys automatically</doc>
      </member>
      <member name="dynamic_wep"
              value="4"
              c:identifier="NMU_SEC_DYNAMIC_WEP"
              glib:nick="dynamic-wep">
        <doc xml:space="preserve">standard 802.1x is used for authentication and
generating the dynamic WEP keys automatically</doc>
      </member>
      <member name="wpa_psk"
              value="5"
              c:identifier="NMU_SEC_WPA_PSK"
              glib:nick="wpa-psk">
        <doc xml:space="preserve">WPA1 is used with Pre-Shared Keys (PSK)</doc>
      </member>
      <member name="wpa_enterprise"
              value="6"
              c:identifier="NMU_SEC_WPA_ENTERPRISE"
              glib:nick="wpa-enterprise">
        <doc xml:space="preserve">WPA1 is used with 802.1x authentication</doc>
      </member>
      <member name="wpa2_psk"
              value="7"
              c:identifier="NMU_SEC_WPA2_PSK"
              glib:nick="wpa2-psk">
        <doc xml:space="preserve">WPA2/RSN is used with Pre-Shared Keys (PSK)</doc>
      </member>
      <member name="wpa2_enterprise"
              value="8"
              c:identifier="NMU_SEC_WPA2_ENTERPRISE"
              glib:nick="wpa2-enterprise">
        <doc xml:space="preserve">WPA2 is used with 802.1x authentication</doc>
      </member>
    </enumeration>
    <constant name="VLAN_FLAGS_ALL" value="0" c:type="NM_VLAN_FLAGS_ALL">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="VPNConnectionState" c:type="NMVPNConnectionState">
      <doc xml:space="preserve">VPN connection states</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_CONNECTION_STATE_UNKNOWN">
        <doc xml:space="preserve">The state of the VPN connection is
  unknown.</doc>
      </member>
      <member name="prepare"
              value="1"
              c:identifier="NM_VPN_CONNECTION_STATE_PREPARE">
        <doc xml:space="preserve">The VPN connection is preparing to
  connect.</doc>
      </member>
      <member name="need_auth"
              value="2"
              c:identifier="NM_VPN_CONNECTION_STATE_NEED_AUTH">
        <doc xml:space="preserve">The VPN connection needs authorization
  credentials.</doc>
      </member>
      <member name="connect"
              value="3"
              c:identifier="NM_VPN_CONNECTION_STATE_CONNECT">
        <doc xml:space="preserve">The VPN connection is being established.</doc>
      </member>
      <member name="ip_config_get"
              value="4"
              c:identifier="NM_VPN_CONNECTION_STATE_IP_CONFIG_GET">
        <doc xml:space="preserve">The VPN connection is getting an IP
  address.</doc>
      </member>
      <member name="activated"
              value="5"
              c:identifier="NM_VPN_CONNECTION_STATE_ACTIVATED">
        <doc xml:space="preserve">The VPN connection is active.</doc>
      </member>
      <member name="failed"
              value="6"
              c:identifier="NM_VPN_CONNECTION_STATE_FAILED">
        <doc xml:space="preserve">The VPN connection failed.</doc>
      </member>
      <member name="disconnected"
              value="7"
              c:identifier="NM_VPN_CONNECTION_STATE_DISCONNECTED">
        <doc xml:space="preserve">The VPN connection is disconnected.</doc>
      </member>
    </enumeration>
    <enumeration name="VPNConnectionStateReason"
                 c:type="NMVPNConnectionStateReason">
      <doc xml:space="preserve">VPN connection state reasons</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_UNKNOWN">
        <doc xml:space="preserve">The reason for the VPN connection
  state change is unknown.</doc>
      </member>
      <member name="none"
              value="1"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_NONE">
        <doc xml:space="preserve">No reason was given for the VPN
  connection state change.</doc>
      </member>
      <member name="user_disconnected"
              value="2"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED">
        <doc xml:space="preserve">The VPN connection changed
  state because the user disconnected it.</doc>
      </member>
      <member name="device_disconnected"
              value="3"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED">
        <doc xml:space="preserve">The VPN connection
  changed state because the device it was using was disconnected.</doc>
      </member>
      <member name="service_stopped"
              value="4"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED">
        <doc xml:space="preserve">The service providing the
  VPN connection was stopped.</doc>
      </member>
      <member name="ip_config_invalid"
              value="5"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID">
        <doc xml:space="preserve">The IP config of the VPN
  connection was invalid.</doc>
      </member>
      <member name="connect_timeout"
              value="6"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT">
        <doc xml:space="preserve">The connection attempt to
  the VPN service timed out.</doc>
      </member>
      <member name="service_start_timeout"
              value="7"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT">
        <doc xml:space="preserve">A timeout occurred
  while starting the service providing the VPN connection.</doc>
      </member>
      <member name="service_start_failed"
              value="8"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED">
        <doc xml:space="preserve">Starting the service
  starting the service providing the VPN connection failed.</doc>
      </member>
      <member name="no_secrets"
              value="9"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS">
        <doc xml:space="preserve">Necessary secrets for the VPN
  connection were not provided.</doc>
      </member>
      <member name="login_failed"
              value="10"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED">
        <doc xml:space="preserve">Authentication to the VPN
  server failed.</doc>
      </member>
      <member name="connection_removed"
              value="11"
              c:identifier="NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED">
        <doc xml:space="preserve">The connection was
  deleted from settings.</doc>
      </member>
    </enumeration>
    <callback name="VPNIterFunc" c:type="NMVPNIterFunc">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">the name of the data or secret item</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the value of the data or secret item</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">User data passed to nm_setting_vpn_foreach_data_item() or
nm_setting_vpn_foreach_secret()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="VPNPluginFailure" c:type="NMVPNPluginFailure">
      <doc xml:space="preserve">VPN plugin failure reasons</doc>
      <member name="login_failed"
              value="0"
              c:identifier="NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED">
        <doc xml:space="preserve">Login failed.</doc>
      </member>
      <member name="connect_failed"
              value="1"
              c:identifier="NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED">
        <doc xml:space="preserve">Connect failed.</doc>
      </member>
      <member name="bad_ip_config"
              value="2"
              c:identifier="NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG">
        <doc xml:space="preserve">Invalid IP configuration returned from
  the VPN plugin.</doc>
      </member>
    </enumeration>
    <enumeration name="VPNServiceState" c:type="NMVPNServiceState">
      <doc xml:space="preserve">VPN daemon states</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_VPN_SERVICE_STATE_UNKNOWN">
        <doc xml:space="preserve">The state of the VPN plugin is unknown.</doc>
      </member>
      <member name="init" value="1" c:identifier="NM_VPN_SERVICE_STATE_INIT">
        <doc xml:space="preserve">The VPN plugin is initialized.</doc>
      </member>
      <member name="shutdown"
              value="2"
              c:identifier="NM_VPN_SERVICE_STATE_SHUTDOWN">
        <doc xml:space="preserve">Not used.</doc>
      </member>
      <member name="starting"
              value="3"
              c:identifier="NM_VPN_SERVICE_STATE_STARTING">
        <doc xml:space="preserve">The plugin is attempting to connect to a VPN server.</doc>
      </member>
      <member name="started"
              value="4"
              c:identifier="NM_VPN_SERVICE_STATE_STARTED">
        <doc xml:space="preserve">The plugin has connected to a VPN server.</doc>
      </member>
      <member name="stopping"
              value="5"
              c:identifier="NM_VPN_SERVICE_STATE_STOPPING">
        <doc xml:space="preserve">The plugin is disconnecting from the VPN server.</doc>
      </member>
      <member name="stopped"
              value="6"
              c:identifier="NM_VPN_SERVICE_STATE_STOPPED">
        <doc xml:space="preserve">The plugin has disconnected from the VPN server.</doc>
      </member>
    </enumeration>
    <constant name="VPN_DBUS_PLUGIN_INTERFACE"
              value="org.freedesktop.NetworkManager.VPN.Plugin"
              c:type="NM_VPN_DBUS_PLUGIN_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_DBUS_PLUGIN_PATH"
              value="/org/freedesktop/NetworkManager/VPN/Plugin"
              c:type="NM_VPN_DBUS_PLUGIN_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CAN_PERSIST"
              value="can-persist"
              c:type="NM_VPN_PLUGIN_CAN_PERSIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_BANNER"
              value="banner"
              c:type="NM_VPN_PLUGIN_CONFIG_BANNER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_EXT_GATEWAY"
              value="gateway"
              c:type="NM_VPN_PLUGIN_CONFIG_EXT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_HAS_IP4"
              value="has-ip4"
              c:type="NM_VPN_PLUGIN_CONFIG_HAS_IP4">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_HAS_IP6"
              value="has-ip6"
              c:type="NM_VPN_PLUGIN_CONFIG_HAS_IP6">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_MTU"
              value="mtu"
              c:type="NM_VPN_PLUGIN_CONFIG_MTU">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_CONFIG_TUNDEV"
              value="tundev"
              c:type="NM_VPN_PLUGIN_CONFIG_TUNDEV">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_ADDRESS"
              value="address"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DNS"
              value="dns"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DOMAIN"
              value="domain"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DOMAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY"
              value="internal-gateway"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_MSS"
              value="mss"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_MSS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_NBNS"
              value="nbns"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_NBNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_PREFIX"
              value="prefix"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_PTP"
              value="ptp"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_PTP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP4_CONFIG_ROUTES"
              value="routes"
              c:type="NM_VPN_PLUGIN_IP4_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_ADDRESS"
              value="address"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_DNS"
              value="dns"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_DNS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_DOMAIN"
              value="domain"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_DOMAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_DOMAINS"
              value="domains"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_DOMAINS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY"
              value="internal-gateway"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_MSS"
              value="mss"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_MSS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT"
              value="never-default"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_PREFIX"
              value="prefix"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_PTP"
              value="ptp"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_PTP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="VPN_PLUGIN_IP6_CONFIG_ROUTES"
              value="routes"
              c:type="NM_VPN_PLUGIN_IP6_CONFIG_ROUTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="VlanFlags"
                 glib:type-name="NMVlanFlags"
                 glib:get-type="nm_vlan_flags_get_type"
                 c:type="NMVlanFlags">
      <doc xml:space="preserve">#NMVlanFlags values control the behavior of the VLAN interface.</doc>
      <member name="reorder_headers"
              value="1"
              c:identifier="NM_VLAN_FLAG_REORDER_HEADERS"
              glib:nick="reorder-headers">
        <doc xml:space="preserve">indicates that this interface should reorder
 outgoing packet headers to look more like a non-VLAN Ethernet interface</doc>
      </member>
      <member name="gvrp"
              value="2"
              c:identifier="NM_VLAN_FLAG_GVRP"
              glib:nick="gvrp">
        <doc xml:space="preserve">indicates that this interface should use GVRP to register
 itself with it's switch</doc>
      </member>
      <member name="loose_binding"
              value="4"
              c:identifier="NM_VLAN_FLAG_LOOSE_BINDING"
              glib:nick="loose-binding">
        <doc xml:space="preserve">indicates that this interface's operating
 state is tied to the underlying network interface but other details
 (like routing) are not.</doc>
      </member>
      <member name="mvrp"
              value="8"
              c:identifier="NM_VLAN_FLAG_MVRP"
              glib:nick="mvrp">
        <doc xml:space="preserve">indicates that this interface should use MVRP to register
 itself with it's switch</doc>
      </member>
    </enumeration>
    <enumeration name="VlanPriorityMap"
                 glib:type-name="NMVlanPriorityMap"
                 glib:get-type="nm_vlan_priority_map_get_type"
                 c:type="NMVlanPriorityMap">
      <doc xml:space="preserve">A selector for traffic priority maps; these map Linux SKB priorities
to 802.1p priorities used in VLANs.</doc>
      <member name="ingress_map"
              value="0"
              c:identifier="NM_VLAN_INGRESS_MAP"
              glib:nick="ingress-map">
        <doc xml:space="preserve">map for incoming data</doc>
      </member>
      <member name="egress_map"
              value="1"
              c:identifier="NM_VLAN_EGRESS_MAP"
              glib:nick="egress-map">
        <doc xml:space="preserve">map for outgoing data</doc>
      </member>
    </enumeration>
    <enumeration name="WepKeyType"
                 glib:type-name="NMWepKeyType"
                 glib:get-type="nm_wep_key_type_get_type"
                 c:type="NMWepKeyType">
      <doc xml:space="preserve">The #NMWepKeyType values specify how any WEP keys present in the setting
are intepreted.  There are no standards governing how to hash the various WEP
key/passphrase formats into the actual WEP key.  Unfortunately some WEP keys
can be interpreted in multiple ways, requring the setting to specify how to
interpret the any WEP keys.  For example, the key "732f2d712e4a394a375d366931"
is both a valid Hexadecimal WEP key and a WEP passphrase.  Further, many
ASCII keys are also valid WEP passphrases, but since passphrases and ASCII
keys are hashed differently to determine the actual WEP key the type must be
specified.</doc>
      <member name="unknown"
              value="0"
              c:identifier="NM_WEP_KEY_TYPE_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown WEP key type</doc>
      </member>
      <member name="key"
              value="1"
              c:identifier="NM_WEP_KEY_TYPE_KEY"
              glib:nick="key">
        <doc xml:space="preserve">indicates a hexadecimal or ASCII formatted WEP key.
Hex keys are either 10 or 26 hexadecimal characters (ie "5f782f2f5f" or
"732f2d712e4a394a375d366931"), while ASCII keys are either 5 or 13 ASCII
characters (ie "abcde" or "blahblah99$*1").</doc>
      </member>
      <member name="passphrase"
              value="2"
              c:identifier="NM_WEP_KEY_TYPE_PASSPHRASE"
              glib:nick="passphrase">
        <doc xml:space="preserve">indicates a WEP passphrase (ex "I bought a duck
on my way back from the market 235Q&amp;^%^*%") instead of a hexadecimal or ASCII
key.  Passphrases are between 8 and 64 characters inclusive and are hashed
the actual WEP key using the MD5 hash algorithm.</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="NM_WEP_KEY_TYPE_LAST"
              glib:nick="last">
        <doc xml:space="preserve">placeholder value for bounds-checking</doc>
      </member>
    </enumeration>
    <function name="connection_error_quark"
              c:identifier="nm_connection_error_quark"
              moved-to="ConnectionError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMConnection if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMConnection errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_802_1x_error_quark"
              c:identifier="nm_setting_802_1x_error_quark"
              moved-to="Setting8021xError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSetting8021x if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSetting8021x errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_adsl_error_quark"
              c:identifier="nm_setting_adsl_error_quark"
              moved-to="SettingAdslError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingAdsl if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingAdsl errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_bluetooth_error_quark"
              c:identifier="nm_setting_bluetooth_error_quark"
              moved-to="SettingBluetoothError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingBluetooth if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingBluetooth errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_bond_error_quark"
              c:identifier="nm_setting_bond_error_quark"
              moved-to="SettingBondError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingBond if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingBond errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_bridge_error_quark"
              c:identifier="nm_setting_bridge_error_quark"
              moved-to="SettingBridgeError.quark"
              version="0.9.8">
      <doc xml:space="preserve">Registers an error quark for #NMSettingBridge if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingBridge errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_bridge_port_error_quark"
              c:identifier="nm_setting_bridge_port_error_quark"
              moved-to="SettingBridgePortError.quark"
              version="0.9.8">
      <doc xml:space="preserve">Registers an error quark for #NMSettingBridgePort if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingBridgePort errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_cdma_error_quark"
              c:identifier="nm_setting_cdma_error_quark"
              moved-to="SettingCdmaError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingCdma if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingCdma errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_connection_error_quark"
              c:identifier="nm_setting_connection_error_quark"
              moved-to="SettingConnectionError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingConnection if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingConnection errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_dcb_error_quark"
              c:identifier="nm_setting_dcb_error_quark"
              moved-to="SettingDcbError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMSettingDcb if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingDcb errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_error_quark"
              c:identifier="nm_setting_error_quark"
              moved-to="SettingError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSetting if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for NMSetting errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_generic_error_quark"
              c:identifier="nm_setting_generic_error_quark"
              moved-to="SettingGenericError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMSettingGeneric if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingGeneric errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_gsm_error_quark"
              c:identifier="nm_setting_gsm_error_quark"
              moved-to="SettingGsmError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingGsm if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingGsm errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_infiniband_error_quark"
              c:identifier="nm_setting_infiniband_error_quark"
              moved-to="SettingInfinibandError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingInfiniband if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingInfiniband errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_ip4_config_error_quark"
              c:identifier="nm_setting_ip4_config_error_quark"
              moved-to="SettingIP4ConfigError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingIP4Config if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingIP4Config errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_ip6_config_error_quark"
              c:identifier="nm_setting_ip6_config_error_quark"
              moved-to="SettingIP6ConfigError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingIP6Config if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingIP6Config errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_olpc_mesh_error_quark"
              c:identifier="nm_setting_olpc_mesh_error_quark"
              moved-to="SettingOlpcMeshError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_ppp_error_quark"
              c:identifier="nm_setting_ppp_error_quark"
              moved-to="SettingPPPError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingPPP if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingPPP errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_pppoe_error_quark"
              c:identifier="nm_setting_pppoe_error_quark"
              moved-to="SettingPPPOEError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingPPPOE if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingPPPOE errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_serial_error_quark"
              c:identifier="nm_setting_serial_error_quark"
              moved-to="SettingSerialError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingSerial if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingSerial errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_team_error_quark"
              c:identifier="nm_setting_team_error_quark"
              moved-to="SettingTeamError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMSettingTeam if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingTeam errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_team_port_error_quark"
              c:identifier="nm_setting_team_port_error_quark"
              moved-to="SettingTeamPortError.quark"
              version="0.9.10">
      <doc xml:space="preserve">Registers an error quark for #NMSettingTeamPort if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingTeamPort errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_vlan_error_quark"
              c:identifier="nm_setting_vlan_error_quark"
              moved-to="SettingVlanError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingVlan if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingVlan errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_vpn_error_quark"
              c:identifier="nm_setting_vpn_error_quark"
              moved-to="SettingVpnError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingVPN if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingVPN errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wimax_error_quark"
              c:identifier="nm_setting_wimax_error_quark"
              moved-to="SettingWimaxError.quark"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Registers an error quark for #NMSettingWimax if necessary.</doc>
      <doc-deprecated xml:space="preserve">WiMAX is no longer supported.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingWimax errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wired_error_quark"
              c:identifier="nm_setting_wired_error_quark"
              moved-to="SettingWiredError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingWired if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingWired errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wireless_error_quark"
              c:identifier="nm_setting_wireless_error_quark"
              moved-to="SettingWirelessError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingWireless if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingWireless errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="setting_wireless_security_error_quark"
              c:identifier="nm_setting_wireless_security_error_quark"
              moved-to="SettingWirelessSecurityError.quark">
      <doc xml:space="preserve">Registers an error quark for #NMSettingWired if necessary.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the error quark used for #NMSettingWired errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="utils_ap_mode_security_valid"
              c:identifier="nm_utils_ap_mode_security_valid"
              version="0.9.8">
      <doc xml:space="preserve">Given a set of device capabilities, and a desired security type to check
against, determines whether the combination of device capabilities and
desired security type are valid for AP/Hotspot connections.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the device capabilities are compatible with the desired
@type, %FALSE if they are not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the security type to check device capabilties against,
e.g. #NMU_SEC_STATIC_WEP</doc>
          <type name="UtilsSecurityType" c:type="NMUtilsSecurityType"/>
        </parameter>
        <parameter name="wifi_caps" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of the capabilities of the specific Wi-Fi device, e.g.
#NM_WIFI_DEVICE_CAP_CIPHER_WEP40</doc>
          <type name="DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_bin2hexstr"
              c:identifier="nm_utils_bin2hexstr"
              version="0.9.10">
      <doc xml:space="preserve">Converts a byte-array @bytes into a hexadecimal string.
If @final_len is greater than -1, the returned string is terminated at
that index (returned_string[final_len] == '\0'),</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the textual form of @bytes</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:space="preserve">an array of bytes</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @bytes array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="final_len" transfer-ownership="none">
          <doc xml:space="preserve">an index where to cut off the returned string, or -1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_check_virtual_device_compatibility"
              c:identifier="nm_utils_check_virtual_device_compatibility"
              version="0.9.10">
      <doc xml:space="preserve">Determines if a connection of type @virtual_type can (in the
general case) work with connections of type @other_type.

If @virtual_type is %NM_TYPE_SETTING_VLAN, then this checks if
@other_type is a valid type for the parent of a VLAN.

If @virtual_type is a "master" type (eg, %NM_TYPE_SETTING_BRIDGE),
then this checks if @other_type is a valid type for a slave of that
master.

Note that even if this returns %TRUE it is not guaranteed that
&lt;emphasis&gt;every&lt;/emphasis&gt; connection of type @other_type is
compatible with @virtual_type; it may depend on the exact
configuration of the two connections, or on the capabilities of an
underlying device driver.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE or %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="virtual_type" transfer-ownership="none">
          <doc xml:space="preserve">a virtual connection type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="other_type" transfer-ownership="none">
          <doc xml:space="preserve">a connection type to test against @virtual_type</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_deinit" c:identifier="nm_utils_deinit">
      <doc xml:space="preserve">No-op. Although this function still exists for ABI compatibility reasons, it
does not have any effect, and does not ever need to be called.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="utils_escape_ssid" c:identifier="nm_utils_escape_ssid">
      <doc xml:space="preserve">This function does a quick printable character conversion of the SSID, simply
replacing embedded NULLs and non-printable characters with the hexadecimal
representation of that character.  Intended for debugging only, should not
be used for display of SSIDs.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">pointer to the escaped SSID, which uses an internal static buffer
and will be overwritten by subsequent calls to this function</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a buffer containing the SSID data</doc>
          <type name="guint8" c:type="const guint8*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the SSID data in @ssid</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_file_is_pkcs12"
              c:identifier="nm_utils_file_is_pkcs12">
      <doc xml:space="preserve">Utility function to find out if the @filename is in PKCS#&lt;!-- --&gt;12 format.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the file is PKCS#&lt;!-- --&gt;12, %FALSE if it is not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">name of the file to test</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_file_search_in_paths"
              c:identifier="nm_utils_file_search_in_paths"
              throws="1">
      <doc xml:space="preserve">Searches for a @progname file in a list of search @paths.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the full path to the helper, if found, or %NULL if not found.
  The returned string is not owned by the caller, but later
  invocations of the function might overwrite it.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="progname" transfer-ownership="none">
          <doc xml:space="preserve">the helper program name, like "iptables"
  Must be a non-empty string, without path separator (/).</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="try_first"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a custom path to try first before searching.
  It is silently ignored if it is empty or not an absolute path.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="paths"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a %NULL terminated list of search paths.
  Can be empty or %NULL, in which case only @try_first is checked.</doc>
          <type name="utf8" c:type="const char* const*"/>
        </parameter>
        <parameter name="file_test_flags" transfer-ownership="none">
          <doc xml:space="preserve">the flags passed to g_file_test() when searching
  for @progname. Set it to 0 to skip the g_file_test().</doc>
          <type name="GLib.FileTest" c:type="GFileTest"/>
        </parameter>
        <parameter name="predicate"
                   transfer-ownership="none"
                   scope="call"
                   closure="5">
          <doc xml:space="preserve">if given, pass the file name to this function
  for additional checks. This check is performed after the check for
  @file_test_flags. You cannot omit both @file_test_flags and @predicate.</doc>
          <type name="UtilsFileSearchInPathsPredicate"
                c:type="NMUtilsFileSearchInPathsPredicate"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">(allow-none): user data for @predicate function.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_gvalue_hash_dup"
              c:identifier="nm_utils_gvalue_hash_dup">
      <doc xml:space="preserve">Utility function to duplicate a hash table of #GValues.</doc>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">a newly allocated duplicated #GHashTable, caller must free the
returned hash with g_hash_table_unref() or g_hash_table_destroy()</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="GObject.Value"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="hash" transfer-ownership="none">
          <doc xml:space="preserve">a #GHashTable mapping string:GValue</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hex2byte"
              c:identifier="nm_utils_hex2byte"
              version="0.9.10">
      <doc xml:space="preserve">Converts a hex string (2 characters) into its byte representation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a byte, or -1 if @hex doesn't represent a hex byte</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="hex" transfer-ownership="none">
          <doc xml:space="preserve">a string representing a hex byte</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hexstr2bin"
              c:identifier="nm_utils_hexstr2bin"
              version="0.9.10">
      <doc xml:space="preserve">Converts a hexadecimal string @hex into a byte-array. The returned array
length is @len/2.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a array of bytes, or %NULL on error</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="hex" transfer-ownership="none">
          <doc xml:space="preserve">an hex string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @hex string (it has to be even)</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_atoba" c:identifier="nm_utils_hwaddr_atoba">
      <doc xml:space="preserve">Parses @asc and converts it to binary form in a #GByteArray. See
nm_utils_hwaddr_aton() if you don't want a #GByteArray.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new #GByteArray, or %NULL if @asc couldn't
be parsed</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of address; either &lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or
  &lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_aton" c:identifier="nm_utils_hwaddr_aton">
      <doc xml:space="preserve">Parses @asc and converts it to binary form in @buffer. See
nm_utils_hwaddr_atoba() if you'd rather have the result in a
#GByteArray.

See also nm_utils_hwaddr_aton_len(), which takes an output length
instead of a type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@buffer, or %NULL if @asc couldn't be parsed</doc>
        <type name="guint8" c:type="guint8*"/>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of address; either &lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or
  &lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="buffer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">buffer to store the result into</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_aton_len"
              c:identifier="nm_utils_hwaddr_aton_len"
              version="0.9.10">
      <doc xml:space="preserve">Parses @asc and converts it to binary form in @buffer.
Bytes in @asc can be sepatared by colons (:), or hyphens (-), but not mixed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@buffer, or %NULL if @asc couldn't be parsed
  or would be shorter or longer than @length.</doc>
        <type name="guint8" c:type="guint8*"/>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="buffer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">buffer to store the result into</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the expected length in bytes of the result and
the size of the buffer in bytes.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_len" c:identifier="nm_utils_hwaddr_len">
      <doc xml:space="preserve">Returns the length in octets of a hardware address of type @type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the positive length, or -1 if the type is unknown/unsupported.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of address; either &lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or
  &lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_ntoa" c:identifier="nm_utils_hwaddr_ntoa">
      <doc xml:space="preserve">Converts @addr to textual form.

See also nm_utils_hwaddr_ntoa_len(), which takes a length instead of
a type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the textual form of @addr</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="addr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a binary hardware address</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type of address; either &lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or
  &lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_ntoa_len"
              c:identifier="nm_utils_hwaddr_ntoa_len"
              version="0.9.10">
      <doc xml:space="preserve">Converts @addr to textual form.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the textual form of @addr</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="addr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a binary hardware address</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length of @addr</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_type"
              c:identifier="nm_utils_hwaddr_type"
              deprecated="1">
      <doc xml:space="preserve">Returns the type (either &lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or
&lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;) of the raw address given its length.</doc>
      <doc-deprecated xml:space="preserve">This could not be extended to cover other types, since
there is not a one-to-one mapping between types and lengths. This
was mostly only used to get a type to pass to
nm_utils_hwaddr_ntoa() or nm_utils_hwaddr_aton() when you only had
a length; but you can just use nm_utils_hwaddr_ntoa_len() or
nm_utils_hwaddr_aton_len() now instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the type, either &lt;literal&gt;ARPHRD_ETHER&lt;/literal&gt; or
&lt;literal&gt;ARPHRD_INFINIBAND&lt;/literal&gt;.  If the length is unexpected, return -1
(unsupported type/length).</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">the length of hardware address in bytes</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_hwaddr_valid"
              c:identifier="nm_utils_hwaddr_valid"
              version="0.9.10">
      <doc xml:space="preserve">Parses @asc to see if it is a valid hardware address of some type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @asc appears to be a valid hardware address
  of some type, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="asc" transfer-ownership="none">
          <doc xml:space="preserve">the ASCII representation of a hardware address</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_iface_valid_name"
              c:identifier="nm_utils_iface_valid_name"
              version="0.9.8">
      <doc xml:space="preserve">This function is a 1:1 copy of the kernel's interface validation
function in net/core/dev.c.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if interface name is valid, otherwise %FALSE is returned.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">Name of interface</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_inet4_ntop"
              c:identifier="nm_utils_inet4_ntop"
              version="0.9.10"
              introspectable="0">
      <doc xml:space="preserve">Wrapper for inet_ntop.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the input buffer @dst, or a pointer to an
 internal, static buffer. This function cannot fail.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="inaddr" transfer-ownership="none">
          <doc xml:space="preserve">the address that should be converted to string.</doc>
          <type c:type="in_addr_t"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:space="preserve">the destination buffer, it must contain at least
 &lt;literal&gt;INET_ADDRSTRLEN&lt;/literal&gt; or %NM_UTILS_INET_ADDRSTRLEN
 characters. If set to %NULL, it will return a pointer to an internal, static
 buffer (shared with nm_utils_inet6_ntop()).  Beware, that the internal
 buffer will be overwritten with ever new call of nm_utils_inet4_ntop() or
 nm_utils_inet6_ntop() that does not provied it's own @dst buffer. Also,
 using the internal buffer is not thread safe. When in doubt, pass your own
 @dst buffer to avoid these issues.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_inet6_ntop"
              c:identifier="nm_utils_inet6_ntop"
              version="0.9.10"
              introspectable="0">
      <doc xml:space="preserve">Wrapper for inet_ntop.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the input buffer @dst, or a pointer to an
 internal, static buffer. %NULL is not allowed as @in6addr,
 otherwise, this function cannot fail.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="in6addr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the address that should be converted to string.</doc>
          <type name="gpointer" c:type="const in6_addr*"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:space="preserve">the destination buffer, it must contain at least
 &lt;literal&gt;INET6_ADDRSTRLEN&lt;/literal&gt; or %NM_UTILS_INET_ADDRSTRLEN
 characters. If set to %NULL, it will return a pointer to an internal, static
 buffer (shared with nm_utils_inet4_ntop()).  Beware, that the internal
 buffer will be overwritten with ever new call of nm_utils_inet4_ntop() or
 nm_utils_inet6_ntop() that does not provied it's own @dst buffer. Also,
 using the internal buffer is not thread safe. When in doubt, pass your own
 @dst buffer to avoid these issues.</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_init" c:identifier="nm_utils_init" throws="1">
      <doc xml:space="preserve">Initializes libnm-util; should be called when starting any program that
uses libnm-util.  This function can be called more than once.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the initialization was successful, %FALSE on failure.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="utils_ip4_addresses_from_gvalue"
              c:identifier="nm_utils_ip4_addresses_from_gvalue">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #GArrays of #guint32s representing
a list of NetworkManager IPv4 addresses (which is a tuple of address, gateway,
and prefix) into a #GSList of #NMIP4Address objects.  The specific format of
this serialization is not guaranteed to be stable and the #GArray may be
extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GSList of #NMIP4Address objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP4Address"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">#GValue containing a #GPtrArray of #GArrays of #guint32s</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_addresses_to_gvalue"
              c:identifier="nm_utils_ip4_addresses_to_gvalue">
      <doc xml:space="preserve">Utility function to convert a #GSList of #NMIP4Address objects into a
#GPtrArray of #GArrays of #guint32s representing a list of NetworkManager IPv4
addresses (which is a tuple of address, gateway, and prefix).   The specific
format of this serialization is not guaranteed to be stable and may be
extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a list of #NMIP4Address objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP4Address"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GValue into which to place the converted addresses,
which should be unset by the caller (when no longer needed) with
g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_get_default_prefix"
              c:identifier="nm_utils_ip4_get_default_prefix">
      <doc xml:space="preserve">When the Internet was originally set up, various ranges of IP addresses were
segmented into three network classes: A, B, and C.  This function will return
a prefix that is associated with the IP address specified defining where it
falls in the predefined classes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the default class prefix for the given IP</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="ip" transfer-ownership="none">
          <doc xml:space="preserve">an IPv4 address (in network byte order)</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_netmask_to_prefix"
              c:identifier="nm_utils_ip4_netmask_to_prefix">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the CIDR prefix represented by the netmask</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="netmask" transfer-ownership="none">
          <doc xml:space="preserve">an IPv4 netmask in network byte order</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_prefix_to_netmask"
              c:identifier="nm_utils_ip4_prefix_to_netmask">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the netmask represented by the prefix, in network byte order</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="prefix" transfer-ownership="none">
          <doc xml:space="preserve">a CIDR prefix</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_routes_from_gvalue"
              c:identifier="nm_utils_ip4_routes_from_gvalue">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #GArrays of #guint32s representing
a list of NetworkManager IPv4 routes (which is a tuple of route, next hop,
prefix, and metric) into a #GSList of #NMIP4Route objects.  The specific
format of this serialization is not guaranteed to be stable and may be
extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GSList of #NMIP4Route objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP4Route"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">#GValue containing a #GPtrArray of #GArrays of #guint32s</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip4_routes_to_gvalue"
              c:identifier="nm_utils_ip4_routes_to_gvalue">
      <doc xml:space="preserve">Utility function to convert a #GSList of #NMIP4Route objects into a
#GPtrArray of #GArrays of #guint32s representing a list of NetworkManager IPv4
routes (which is a tuple of route, next hop, prefix, and metric).   The
specific format of this serialization is not guaranteed to be stable and may
be extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a list of #NMIP4Route objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP4Route"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GValue into which to place the converted routes,
which should be unset by the caller (when no longer needed) with
g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_addresses_from_gvalue"
              c:identifier="nm_utils_ip6_addresses_from_gvalue">
      <doc xml:space="preserve">Utility function to convert a #GPtrArray of #GValueArrays of (#GArray of guchars) and #guint32
representing a list of NetworkManager IPv6 addresses (which is a tuple of address,
prefix, and gateway), into a #GSList of #NMIP6Address objects.  The specific format of
this serialization is not guaranteed to be stable and the #GValueArray may be
extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GSList of #NMIP6Address objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP6Address"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">gvalue containing a GPtrArray of GValueArrays of (GArray of guchars) and #guint32</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_addresses_to_gvalue"
              c:identifier="nm_utils_ip6_addresses_to_gvalue">
      <doc xml:space="preserve">Utility function to convert a #GSList of #NMIP6Address objects into a
#GPtrArray of #GValueArrays representing a list of NetworkManager IPv6 addresses
(which is a tuple of address, prefix, and gateway). The specific format of
this serialization is not guaranteed to be stable and may be extended in the
future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a list of #NMIP6Address objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP6Address"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GValue into which to place the converted addresses,
which should be unset by the caller (when no longer needed) with
g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_dns_from_gvalue"
              c:identifier="nm_utils_ip6_dns_from_gvalue"
              introspectable="0">
      <doc xml:space="preserve">Converts a #GValue containing a #GPtrArray of IP6 DNS, represented as
#GByteArrays into a #GSList of &lt;literal&gt;&lt;type&gt;struct in6_addr&lt;/type&gt;&lt;/literal&gt;s.</doc>
      <return-value>
        <doc xml:space="preserve">a #GSList of IP6 addresses.</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_dns_to_gvalue"
              c:identifier="nm_utils_ip6_dns_to_gvalue"
              introspectable="0">
      <doc xml:space="preserve">Utility function to convert a #GSList of &lt;literal&gt;&lt;type&gt;struct
in6_addr&lt;/type&gt;&lt;/literal&gt; structs into a #GPtrArray of #GByteArrays
representing each server's IPv6 addresses in network byte order.
The specific format of this serialization is not guaranteed to be
stable and may be extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a list of #NMIP6Route objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GValue into which to place the converted DNS server
addresses, which should be unset by the caller (when no longer needed) with
g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_routes_from_gvalue"
              c:identifier="nm_utils_ip6_routes_from_gvalue">
      <doc xml:space="preserve">Utility function #GPtrArray of #GValueArrays of (#GArray of #guchars), #guint32,
(#GArray of #guchars), and #guint32 representing a list of NetworkManager IPv6
routes (which is a tuple of destination, prefix, next hop, and metric)
into a #GSList of #NMIP6Route objects.  The specific format of this serialization
is not guaranteed to be stable and may be extended in the future.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated #GSList of #NMIP6Route objects</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="IP6Route"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">#GValue containing a #GPtrArray of #GValueArrays of (#GArray of #guchars), #guint32,
(#GArray of #guchars), and #guint32</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ip6_routes_to_gvalue"
              c:identifier="nm_utils_ip6_routes_to_gvalue">
      <doc xml:space="preserve">Utility function to convert a #GSList of #NMIP6Route objects into a #GPtrArray of
#GValueArrays of (#GArray of #guchars), #guint32, (#GArray of #guchars), and #guint32
representing a list of NetworkManager IPv6 routes (which is a tuple of destination,
prefix, next hop, and metric).  The specific format of this serialization is not
guaranteed to be stable and may be extended in the future.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a list of #NMIP6Route objects</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="IP6Route"/>
          </type>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a #GValue into which to place the converted routes,
which should be unset by the caller (when no longer needed) with
g_value_unset().</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_is_empty_ssid" c:identifier="nm_utils_is_empty_ssid">
      <doc xml:space="preserve">Different manufacturers use different mechanisms for not broadcasting the
AP's SSID.  This function attempts to detect blank/empty SSIDs using a
number of known SSID-cloaking methods.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the SSID is "empty", %FALSE if it is not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:space="preserve">pointer to a buffer containing the SSID data</doc>
          <type name="guint8" c:type="const guint8*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">length of the SSID data in @ssid</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_is_uuid"
              c:identifier="nm_utils_is_uuid"
              version="0.9.8">
      <doc xml:space="preserve">Checks if @str is a UUID</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @str is a UUID, %FALSE if not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve">a string that might be a UUID</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_rsa_key_encrypt"
              c:identifier="nm_utils_rsa_key_encrypt"
              throws="1">
      <doc xml:space="preserve">Encrypts the given RSA private key data with the given password (or generates
a password if no password was given) and converts the data to PEM format
suitable for writing to a file. It uses Triple DES cipher for the encryption.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">on success, PEM-formatted data suitable for writing to a PEM-formatted
certificate/private key file.</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">RSA private key data to be encrypted</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="in_password"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">existing password to use, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out_password"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if @in_password was %NULL, a random password will be generated
 and returned in this argument</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_rsa_key_encrypt_aes"
              c:identifier="nm_utils_rsa_key_encrypt_aes"
              throws="1">
      <doc xml:space="preserve">Encrypts the given RSA private key data with the given password (or generates
a password if no password was given) and converts the data to PEM format
suitable for writing to a file.  It uses AES cipher for the encryption.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">on success, PEM-formatted data suitable for writing to a PEM-formatted
certificate/private key file.</doc>
        <array name="GLib.ByteArray" c:type="GByteArray*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">RSA private key data to be encrypted</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="in_password"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">existing password to use, if any</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="out_password"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve">if @in_password was %NULL, a random password will be generated
 and returned in this argument</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_same_ssid" c:identifier="nm_utils_same_ssid">
      <doc xml:space="preserve">Earlier versions of the Linux kernel added a NULL byte to the end of the
SSID to enable easy printing of the SSID on the console or in a terminal,
but this behavior was problematic (SSIDs are simply byte arrays, not strings)
and thus was changed.  This function compensates for that behavior at the
cost of some compatibility with odd SSIDs that may legitimately have trailing
NULLs, even though that is functionally pointless.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the SSIDs are the same, %FALSE if they are not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ssid1" transfer-ownership="none">
          <doc xml:space="preserve">first SSID data to compare</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="ssid2" transfer-ownership="none">
          <doc xml:space="preserve">second SSID data to compare</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="ignore_trailing_null" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to ignore one trailing NULL byte</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_security_valid"
              c:identifier="nm_utils_security_valid">
      <doc xml:space="preserve">Given a set of device capabilities, and a desired security type to check
against, determines whether the combination of device, desired security
type, and AP capabilities intersect.

NOTE: this function cannot handle checking security for AP/Hotspot mode;
use nm_utils_ap_mode_security_valid() instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the device capabilities and AP capabilties intersect and are
compatible with the desired @type, %FALSE if they are not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the security type to check AP flags and device capabilties against,
e.g. #NMU_SEC_STATIC_WEP</doc>
          <type name="UtilsSecurityType" c:type="NMUtilsSecurityType"/>
        </parameter>
        <parameter name="wifi_caps" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of the capabilities of the specific Wi-Fi device, e.g.
#NM_WIFI_DEVICE_CAP_CIPHER_WEP40</doc>
          <type name="DeviceWifiCapabilities"
                c:type="NMDeviceWifiCapabilities"/>
        </parameter>
        <parameter name="have_ap" transfer-ownership="none">
          <doc xml:space="preserve">whether the @ap_flags, @ap_wpa, and @ap_rsn arguments are valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="adhoc" transfer-ownership="none">
          <doc xml:space="preserve">whether the capabilities being tested are from an Ad-Hoc AP (IBSS)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="ap_flags" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of AP capabilities, e.g. #NM_802_11_AP_FLAGS_PRIVACY</doc>
          <type name="80211ApFlags" c:type="NM80211ApFlags"/>
        </parameter>
        <parameter name="ap_wpa" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of AP capabilties derived from the AP's WPA beacon,
e.g. (#NM_802_11_AP_SEC_PAIR_TKIP | #NM_802_11_AP_SEC_KEY_MGMT_PSK)</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </parameter>
        <parameter name="ap_rsn" transfer-ownership="none">
          <doc xml:space="preserve">bitfield of AP capabilties derived from the AP's RSN/WPA2 beacon,
e.g. (#NM_802_11_AP_SEC_PAIR_CCMP | #NM_802_11_AP_SEC_PAIR_TKIP)</doc>
          <type name="80211ApSecurityFlags" c:type="NM80211ApSecurityFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_slist_free"
              c:identifier="nm_utils_slist_free"
              introspectable="0"
              deprecated="1">
      <doc xml:space="preserve">Utility function to free a #GSList.</doc>
      <doc-deprecated xml:space="preserve">use g_slist_free_full().</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:space="preserve">a #GSList</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="elem_destroy_fn"
                   transfer-ownership="none"
                   scope="async">
          <doc xml:space="preserve">user function called for each element in @list</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_ssid_to_utf8" c:identifier="nm_utils_ssid_to_utf8">
      <doc xml:space="preserve">Wi-Fi SSIDs are byte arrays, they are _not_ strings.  Thus, an SSID may
contain embedded NULLs and other unprintable characters.  Often it is
useful to print the SSID out for debugging purposes, but that should be the
_only_ use of this function.  Do not use this function for any persistent
storage of the SSID, since the printable SSID returned from this function
cannot be converted back into the real SSID of the access point.

This function does almost everything humanly possible to convert the input
into a printable UTF-8 string, using roughly the following procedure:

1) if the input data is already UTF-8 safe, no conversion is performed
2) attempts to get the current system language from the LANG environment
   variable, and depending on the language, uses a table of alternative
   encodings to try.  For example, if LANG=hu_HU, the table may first try
   the ISO-8859-2 encoding, and if that fails, try the Windows-1250 encoding.
   If all fallback encodings fail, replaces non-UTF-8 characters with '?'.
3) If the system language was unable to be determined, falls back to the
   ISO-8859-1 encoding, then to the Windows-1251 encoding.
4) If step 3 fails, replaces non-UTF-8 characters with '?'.

Again, this function should be used for debugging and display purposes
_only_.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">an allocated string containing a UTF-8
representation of the SSID, which must be freed by the caller using g_free().
Returns %NULL on errors.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="ssid" transfer-ownership="none">
          <doc xml:space="preserve">a byte array containing the SSID data</doc>
          <array name="GLib.ByteArray" c:type="const GByteArray*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="utils_uuid_generate" c:identifier="nm_utils_uuid_generate">
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated UUID suitable for use as the #NMSettingConnection
object's #NMSettingConnection:id: property.  Should be freed with g_free()</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
    </function>
    <function name="utils_uuid_generate_from_string"
              c:identifier="nm_utils_uuid_generate_from_string">
      <doc xml:space="preserve">For a given @s, this function will always return the same UUID.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated UUID suitable for use as the #NMSettingConnection
object's #NMSettingConnection:id: property</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="s" transfer-ownership="none">
          <doc xml:space="preserve">a string to use as the seed for the UUID</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wep_key_valid"
              c:identifier="nm_utils_wep_key_valid"
              version="0.9.8">
      <doc xml:space="preserve">Checks if @key is a valid WEP key</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @key is a WEP key, %FALSE if not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <doc xml:space="preserve">a string that might be a WEP key</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="wep_type" transfer-ownership="none">
          <doc xml:space="preserve">the #NMWepKeyType type of the WEP key</doc>
          <type name="WepKeyType" c:type="NMWepKeyType"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_channel_to_freq"
              c:identifier="nm_utils_wifi_channel_to_freq">
      <doc xml:space="preserve">Utility function to translate a Wi-Fi channel to its corresponding frequency.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the frequency represented by the channel of the band,
         or -1 when the freq is invalid, or 0 when the band
         is invalid</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:space="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_find_next_channel"
              c:identifier="nm_utils_wifi_find_next_channel">
      <doc xml:space="preserve">Utility function to find out next/previous Wi-Fi channel for a channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the next channel in the specified direction or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">current channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="direction" transfer-ownership="none">
          <doc xml:space="preserve">whether going downward (0 or less) or upward (1 or more)</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:space="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_freq_to_channel"
              c:identifier="nm_utils_wifi_freq_to_channel">
      <doc xml:space="preserve">Utility function to translate a Wi-Fi frequency to its corresponding channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the channel represented by the frequency or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="freq" transfer-ownership="none">
          <doc xml:space="preserve">frequency</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wifi_is_channel_valid"
              c:identifier="nm_utils_wifi_is_channel_valid">
      <doc xml:space="preserve">Utility function to verify Wi-Fi channel validity.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE or %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:space="preserve">channel</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="band" transfer-ownership="none">
          <doc xml:space="preserve">frequency band for wireless ("a" or "bg")</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_wpa_psk_valid"
              c:identifier="nm_utils_wpa_psk_valid"
              version="0.9.8">
      <doc xml:space="preserve">Checks if @psk is a valid WPA PSK</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @psk is a WPA PSK, %FALSE if not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="psk" transfer-ownership="none">
          <doc xml:space="preserve">a string that might be a WPA PSK</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
