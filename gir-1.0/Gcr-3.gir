<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gck" version="1"/>
  <package name="gcr-base-3"/>
  <c:include name="gcr/gcr-base.h"/>
  <namespace name="Gcr" version="3.broken" shared-library="libgcr-base-3.so.1" c:identifier-prefixes="Gcr" c:symbol-prefixes="gcr">
    <interface name="Certificate" c:symbol-prefix="certificate" c:type="GcrCertificate" glib:type-name="GcrCertificate" glib:get-type="gcr_certificate_get_type" glib:type-struct="CertificateIface">
      <doc xml:space="preserve">An object which holds a certificate.</doc>
      <prerequisite name="Comparable"/>
      <function name="compare" c:identifier="gcr_certificate_compare">
        <doc xml:space="preserve">Compare one certificate against another. If the certificates are equal
then zero is returned. If one certificate is %NULL or not a certificate,
then a non-zero value is returned.

The return value is useful in a stable sort, but has no user logical
meaning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">zero if the certificates match, non-zero otherwise.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="first" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the certificate to compare</doc>
            <type name="Comparable" c:type="GcrComparable*"/>
          </parameter>
          <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the certificate to compare against</doc>
            <type name="Comparable" c:type="GcrComparable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_columns" c:identifier="gcr_certificate_get_columns" introspectable="0">
        <doc xml:space="preserve">Get the columns appropriate for a certificate</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the columns</doc>
          <type name="Column" c:type="const GcrColumn*"/>
        </return-value>
      </function>
      <function name="mixin_class_init" c:identifier="gcr_certificate_mixin_class_init" introspectable="0">
        <doc xml:space="preserve">Initialize the certificate mixin for the class. This mixin implements the
various required properties for the certificate.

Call this function near the end of your derived class_init function. The
derived class must implement the #GcrCertificate interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_class" transfer-ownership="none">
            <doc xml:space="preserve">The GObjectClass for this class</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="mixin_comparable_init" c:identifier="gcr_certificate_mixin_comparable_init" introspectable="0">
        <doc xml:space="preserve">Initialize a #GcrComparableIface to compare the current certificate.
In general it's easier to use the GCR_CERTIFICATE_MIXIN_IMPLEMENT_COMPARABLE()
macro instead of this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:space="preserve">The interface</doc>
            <type name="ComparableIface" c:type="GcrComparableIface*"/>
          </parameter>
        </parameters>
      </function>
      <function name="mixin_get_property" c:identifier="gcr_certificate_mixin_get_property" introspectable="0">
        <doc xml:space="preserve">Implementation to get various required certificate properties. This should
be called from your derived class get_property function, or used as a
get_property virtual function.

Example of use as called from derived class get_property function:

&lt;informalexample&gt;&lt;programlisting&gt;
static void
my_get_property (GObject *obj, guint prop_id, GValue *value, GParamSpec *pspec)
{
	switch (prop_id) {

	...

	default:
		gcr_certificate_mixin_get_property (obj, prop_id, value, pspec);
		break;
	}
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

Example of use as get_property function:

&lt;informalexample&gt;&lt;programlisting&gt;
static void
my_class_init (MyClass *klass)
{
	GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
	gobject_class-&gt;get_property = gcr_certificate_mixin_get_property;

	...
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve">The object</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="prop_id" transfer-ownership="none">
            <doc xml:space="preserve">The property id</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The value to fill in.</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve">The param specification.</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method invoker="get_der_data" name="get_der_data"><doc xml:space="preserve">Gets the raw DER data for an X.509 certificate.</doc><return-value transfer-ownership="none">
          <doc xml:space="preserve">raw DER data of the X.509 certificate</doc>
          <array length="0" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value><parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a pointer to a location to store the size of the resulting DER data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters></virtual-method>
      <method name="get_basic_constraints" c:identifier="gcr_certificate_get_basic_constraints">
        <doc xml:space="preserve">Get the basic constraints for the certificate if present. If %FALSE is
returned then no basic constraints are present and the @is_ca and
@path_len arguments are not changed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether basic constraints are present or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the certificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="is_ca" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to place a %TRUE if is an authority</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="path_len" direction="out" caller-allocates="0" transfer-ownership="full" optional="1" allow-none="1">
            <doc xml:space="preserve">location to place the max path length</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_der_data" c:identifier="gcr_certificate_get_der_data">
        <doc xml:space="preserve">Gets the raw DER data for an X.509 certificate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">raw DER data of the X.509 certificate</doc>
          <array length="0" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a pointer to a location to store the size of the resulting DER data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_expiry_date" c:identifier="gcr_certificate_get_expiry_date">
        <doc xml:space="preserve">Get the expiry date of this certificate.

The #GDate returned should be freed by the caller using
g_date_free() when no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An allocated expiry date of this certificate.</doc>
          <type name="GLib.Date" c:type="GDate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fingerprint" c:identifier="gcr_certificate_get_fingerprint">
        <doc xml:space="preserve">Calculate the fingerprint for this certificate.

You can pass G_CHECKSUM_SHA1 or G_CHECKSUM_MD5 as the @type
parameter.

The caller should free the returned data using g_free() when
it is no longer required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw binary fingerprint</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of algorithm for the fingerprint.</doc>
            <type name="GLib.ChecksumType" c:type="GChecksumType"/>
          </parameter>
          <parameter name="n_length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The length of the resulting fingerprint.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fingerprint_hex" c:identifier="gcr_certificate_get_fingerprint_hex">
        <doc xml:space="preserve">Calculate the fingerprint for this certificate, and return it
as a hex string.

You can pass G_CHECKSUM_SHA1 or G_CHECKSUM_MD5 as the @type
parameter.

The caller should free the returned data using g_free() when
it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an allocated hex string which contains the fingerprint.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">the type of algorithm for the fingerprint.</doc>
            <type name="GLib.ChecksumType" c:type="GChecksumType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_icon" c:identifier="gcr_certificate_get_icon" introspectable="0">
        <doc xml:space="preserve">Get the icon for a certificate.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the icon for this certificate, which should be
         released with g_object_unref()</doc>
          <type name="Gio.Icon" c:type="GIcon*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The certificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_issued_date" c:identifier="gcr_certificate_get_issued_date">
        <doc xml:space="preserve">Get the issued date of this certificate.

The #GDate returned should be freed by the caller using
g_date_free() when no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">An allocated issued date of this certificate.</doc>
          <type name="GLib.Date" c:type="GDate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_issuer_cn" c:identifier="gcr_certificate_get_issuer_cn">
        <doc xml:space="preserve">Get the common name of the issuer of this certificate.

The string returned should be freed by the caller when no longer
required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The allocated issuer CN, or NULL if no issuer CN present.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_issuer_dn" c:identifier="gcr_certificate_get_issuer_dn">
        <doc xml:space="preserve">Get the full issuer DN of the certificate as a (mostly)
readable string.

The string returned should be freed by the caller when no longer
required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The allocated issuer DN of the certificate.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_issuer_name" c:identifier="gcr_certificate_get_issuer_name">
        <doc xml:space="preserve">Get a name to represent the issuer of this certificate.

This will try to lookup the common name, orianizational unit,
organization in that order.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the allocated issuer name, or NULL if no issuer name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_issuer_part" c:identifier="gcr_certificate_get_issuer_part">
        <doc xml:space="preserve">Get a part of the DN of the issuer of this certificate.

Examples of a @part might be the 'OU' (organizational unit)
or the 'CN' (common name). Only the value of that part
of the DN is returned.

The string returned should be freed by the caller when no longer
required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the allocated part of the issuer DN, or %NULL if no
         such part is present</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a DN type string or OID.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_issuer_raw" c:identifier="gcr_certificate_get_issuer_raw">
        <doc xml:space="preserve">Get the raw DER data for the issuer DN of the certificate.

The data should be freed by using g_free() when no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">allocated memory containing
         the raw issuer</doc>
          <array length="0" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The length of the returned data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_key_size" c:identifier="gcr_certificate_get_key_size">
        <doc xml:space="preserve">Get the key size in bits of the public key represented
by this certificate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The key size of the certificate.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_markup_text" c:identifier="gcr_certificate_get_markup_text">
        <doc xml:space="preserve">Calculate a GMarkup string for displaying this certificate.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the markup string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a certificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_serial_number" c:identifier="gcr_certificate_get_serial_number">
        <doc xml:space="preserve">Get the raw binary serial number of the certificate.

The caller should free the returned data using g_free() when
it is no longer required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw binary serial number.</doc>
          <array length="0" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="n_length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">the length of the returned data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_serial_number_hex" c:identifier="gcr_certificate_get_serial_number_hex">
        <doc xml:space="preserve">Get the serial number of the certificate as a hex string.

The caller should free the returned data using g_free() when
it is no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">an allocated string containing the serial number as hex.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject_cn" c:identifier="gcr_certificate_get_subject_cn">
        <doc xml:space="preserve">Get the common name of the subject of this certificate.

The string returned should be freed by the caller when no longer
required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The allocated subject CN, or NULL if no subject CN present.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject_dn" c:identifier="gcr_certificate_get_subject_dn">
        <doc xml:space="preserve">Get the full subject DN of the certificate as a (mostly)
readable string.

The string returned should be freed by the caller when no longer
required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The allocated subject DN of the certificate.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject_name" c:identifier="gcr_certificate_get_subject_name">
        <doc xml:space="preserve">Get a name to represent the subject of this certificate.

This will try to lookup the common name, orianizational unit,
organization in that order.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the allocated subject name, or NULL if no subject name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subject_part" c:identifier="gcr_certificate_get_subject_part">
        <doc xml:space="preserve">Get a part of the DN of the subject of this certificate.

Examples of a @part might be the 'OU' (organizational unit)
or the 'CN' (common name). Only the value of that part
of the DN is returned.

The string returned should be freed by the caller when no longer
required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the allocated part of the subject DN, or %NULL if no
         such part is present.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="part" transfer-ownership="none">
            <doc xml:space="preserve">a DN type string or OID.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_subject_raw" c:identifier="gcr_certificate_get_subject_raw">
        <doc xml:space="preserve">Get the raw DER data for the subject DN of the certificate.

The data should be freed by using g_free() when no longer required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">allocated memory containing
         the raw subject</doc>
          <array length="0" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">The length of the returned data.</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_issuer" c:identifier="gcr_certificate_is_issuer">
        <doc xml:space="preserve">Check if @issuer could be the issuer of this certificate. This is done by
comparing the relevant subject and issuer fields. No signature check is
done. Proper verification of certificates must be done via a crypto
library.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether @issuer could be the issuer of the certificate.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
          <parameter name="issuer" transfer-ownership="none">
            <doc xml:space="preserve">a possible issuer #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="mixin_emit_notify" c:identifier="gcr_certificate_mixin_emit_notify">
        <doc xml:space="preserve">Implementers of the #GcrCertificate mixin should call this function to notify
when the certificate has changed to emit notifications on the various
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="description" transfer-ownership="none">
        <doc xml:space="preserve">A readable description for this certificate</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="expiry" transfer-ownership="none">
        <doc xml:space="preserve">The expiry date of the certificate</doc>
        <type name="GLib.Date"/>
      </property>
      <property name="icon" transfer-ownership="none">
        <doc xml:space="preserve">An icon representing the certificate</doc>
        <type name="Gio.Icon"/>
      </property>
      <property name="issuer" transfer-ownership="none">
        <doc xml:space="preserve">Common name part of the certificate issuer</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="label" transfer-ownership="none">
        <doc xml:space="preserve">A readable label for this certificate.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="markup" transfer-ownership="none">
        <doc xml:space="preserve">GLib markup to describe the certificate</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="subject" transfer-ownership="none">
        <doc xml:space="preserve">Common name part of the certificate subject</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </interface>
    <class name="CertificateChain" c:symbol-prefix="certificate_chain" c:type="GcrCertificateChain" parent="GObject.Object" glib:type-name="GcrCertificateChain" glib:get-type="gcr_certificate_chain_get_type" glib:type-struct="CertificateChainClass">
      <doc xml:space="preserve">A chain of certificates.</doc>
      <constructor name="new" c:identifier="gcr_certificate_chain_new">
        <doc xml:space="preserve">Create a new #GcrCertificateChain.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated certificate chain</doc>
          <type name="CertificateChain" c:type="GcrCertificateChain*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="gcr_certificate_chain_add">
        <doc xml:space="preserve">Add @certificate to the chain. The order of certificates in the chain are
important. The first certificate should be the endpoint certificate, and
then come the signers (certificate authorities) each in turn. If a root
certificate authority is present, it should come last.

Adding a certificate an already built chain (see
gcr_certificate_chain_build()) resets the type of the certificate chain
to %GCR_CERTIFICATE_CHAIN_UNKNOWN</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate to add to the chain</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="build" c:identifier="gcr_certificate_chain_build" throws="1">
        <doc xml:space="preserve">Complete a certificate chain. Once a certificate chain has been built
its status can be examined.

This operation will lookup missing certificates in PKCS\#11
modules and also that each certificate in the chain is the signer of the
previous one. If a trust anchor, pinned certificate, or self-signed certificate
is found, then the chain is considered built. Any extra certificates are
removed from the chain.

It's important to understand that building of a certificate chain does not
constitute verifying that chain. This is merely the first step towards
trust verification.

The @purpose is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
for which the certificate chain will be used. Trust anchors are looked up
for this purpose. This argument is required.

The @peer is usually the host name of the peer whith which this certificate
chain is being used. It is used to look up pinned certificates that have
been stored for this peer. If %NULL then no pinned certificates will
be considered.

If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
lookups for anchors or pinned certificates are done, and the resulting chain
will be neither anchored or pinned. Additionally no missing certificate
authorities are looked up in PKCS\#11

This call will block, see gcr_certificate_chain_build_async() for the
asynchronous version.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the operation completed successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
          <parameter name="purpose" transfer-ownership="none">
            <doc xml:space="preserve">the purpose the certificate chain will be used for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="peer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the peer the certificate chain will be used with, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">chain completion flags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="build_async" c:identifier="gcr_certificate_chain_build_async">
        <doc xml:space="preserve">Complete a certificate chain. Once a certificate chain has been built
its status can be examined.

This will lookup missing certificates in PKCS\#11
modules and also that each certificate in the chain is the signer of the
previous one. If a trust anchor, pinned certificate, or self-signed certificate
is found, then the chain is considered built. Any extra certificates are
removed from the chain.

It's important to understand that building of a certificate chain does not
constitute verifying that chain. This is merely the first step towards
trust verification.

The @purpose is a string like %GCR_PURPOSE_CLIENT_AUTH and is the purpose
for which the certificate chain will be used. Trust anchors are looked up
for this purpose. This argument is required.

The @peer is usually the host name of the peer whith which this certificate
chain is being used. It is used to look up pinned certificates that have
been stored for this peer. If %NULL then no pinned certificates will
be considered.

If the %GCR_CERTIFICATE_CHAIN_NO_LOOKUPS flag is specified then no
lookups for anchors or pinned certificates are done, and the resulting chain
will be neither anchored or pinned. Additionally no missing certificate
authorities are looked up in PKCS\#11

When the operation is finished, @callback will be called. You can then call
gcr_certificate_chain_build_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
          <parameter name="purpose" transfer-ownership="none">
            <doc xml:space="preserve">the purpose the certificate chain will be used for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="peer" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the peer the certificate chain will be used with, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">chain completion flags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="5">
            <doc xml:space="preserve">this will be called when the operation completes.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="build_finish" c:identifier="gcr_certificate_chain_build_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous operation started by
gcr_certificate_chain_build_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the operation succeeded</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_anchor" c:identifier="gcr_certificate_chain_get_anchor">
        <doc xml:space="preserve">If the certificate chain has been built and is of status
%GCR_CERTIFICATE_CHAIN_ANCHORED, then this will return the anchor
certificate that was found. This is not necessarily a root certificate
authority. If an intermediate certificate authority in the chain was
found to be anchored, then that certificate will be returned.

If an anchor is returned it does not mean that the certificate chain has
been verified, but merely that an anchor has been found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the anchor certificate, or NULL if not anchored.</doc>
          <type name="Certificate" c:type="GcrCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_certificate" c:identifier="gcr_certificate_chain_get_certificate">
        <doc xml:space="preserve">Get a certificate in the chain. It is an error to call this function
with an invalid index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the certificate</doc>
          <type name="Certificate" c:type="GcrCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">index of the certificate to get</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_endpoint" c:identifier="gcr_certificate_chain_get_endpoint">
        <doc xml:space="preserve">Get the endpoint certificate in the chain. This is always the first
certificate in the chain. The endpoint certificate cannot be anchored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the endpoint certificate, or %NULL if the chain
         is empty</doc>
          <type name="Certificate" c:type="GcrCertificate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="gcr_certificate_chain_get_length">
        <doc xml:space="preserve">Get the length of the certificate chain.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the certificate chain</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_status" c:identifier="gcr_certificate_chain_get_status">
        <doc xml:space="preserve">Get the status of a certificate chain. If the certificate chain has not
been built, then the status will be %GCR_CERTIFICATE_CHAIN_UNKNOWN.

A status of %GCR_CERTIFICATE_CHAIN_ANCHORED does not mean that the
certificate chain has been verified, but merely that an anchor has been
found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the status of the certificate chain.</doc>
          <type name="CertificateChainStatus" c:type="GcrCertificateChainStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GcrCertificateChain</doc>
            <type name="CertificateChain" c:type="GcrCertificateChain*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="length" transfer-ownership="none">
        <doc xml:space="preserve">The length of the certificate chain.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="status" introspectable="0" transfer-ownership="none">
        <doc xml:space="preserve">The certificate chain status. See #GcrCertificateChainStatus</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="CertificateChainPrivate" c:type="GcrCertificateChainPrivate*"/>
      </field>
    </class>
    <record name="CertificateChainClass" c:type="GcrCertificateChainClass" glib:is-gtype-struct-for="CertificateChain">
      <doc xml:space="preserve">The class for #GcrCertificateChain.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <bitfield name="CertificateChainFlags" c:type="GcrCertificateChainFlags">
      <doc xml:space="preserve">Flags to be used with the gcr_certificate_chain_build() operation.</doc>
      <member name="none" value="0" c:identifier="GCR_CERTIFICATE_CHAIN_NONE">
        <doc xml:space="preserve">no flags</doc>
      </member>
      <member name="no_lookups" value="1" c:identifier="GCR_CERTIFICATE_CHAIN_NO_LOOKUPS">
        <doc xml:space="preserve">If this flag is specified then no
lookups for anchors or pinned certificates are done, and the resulting chain
will be neither anchored or pinned. Additionally no missing certificate
authorities are looked up in PKCS\#11.</doc>
      </member>
    </bitfield>
    <record name="CertificateChainPrivate" c:type="GcrCertificateChainPrivate" disguised="1">
    </record>
    <enumeration name="CertificateChainStatus" c:type="GcrCertificateChainStatus">
      <doc xml:space="preserve">The status of a built certificate chain. Will be set to
%GCR_CERTIFICATE_CHAIN_UNKNOWN for certificate chains that have not been
built.</doc>
      <member name="unknown" value="0" c:identifier="GCR_CERTIFICATE_CHAIN_UNKNOWN">
        <doc xml:space="preserve">The certificate chain's status is unknown.
When a chain is not yet built it has this status. If a chain is modified after
being built, it has this status.</doc>
      </member>
      <member name="incomplete" value="1" c:identifier="GCR_CERTIFICATE_CHAIN_INCOMPLETE">
        <doc xml:space="preserve">A full chain could not be loaded. The
chain does not end with a self-signed certificate, a trusted anchor, or a
pinned certificate.</doc>
      </member>
      <member name="distrusted" value="2" c:identifier="GCR_CERTIFICATE_CHAIN_DISTRUSTED">
        <doc xml:space="preserve">The certificate chain contains a revoked
or otherwise explicitly distrusted certificate. The entire chain should
be distrusted.</doc>
      </member>
      <member name="selfsigned" value="3" c:identifier="GCR_CERTIFICATE_CHAIN_SELFSIGNED">
        <doc xml:space="preserve">The chain ends with a self-signed
certificate. No trust anchor was found.</doc>
      </member>
      <member name="pinned" value="4" c:identifier="GCR_CERTIFICATE_CHAIN_PINNED">
        <doc xml:space="preserve">The chain represents a pinned certificate. A
pinned certificate is an exception which trusts a given certificate
explicitly for a purpose and communication with a certain peer.</doc>
      </member>
      <member name="anchored" value="5" c:identifier="GCR_CERTIFICATE_CHAIN_ANCHORED">
        <doc xml:space="preserve">The chain ends with an anchored
certificate. The anchored certificate is not necessarily self-signed.</doc>
      </member>
    </enumeration>
    <record name="CertificateIface" c:type="GcrCertificateIface" glib:is-gtype-struct-for="Certificate">
      <doc xml:space="preserve">The interface that implementors of #GcrCertificate must implement.</doc>
      <field name="parent">
        <doc xml:space="preserve">the parent interface type</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_der_data">
        <callback name="get_der_data">
          <return-value transfer-ownership="none">
            <type name="guint8" c:type="const guint8*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Certificate" c:type="GcrCertificate*"/>
            </parameter>
            <parameter name="n_data" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dummy1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy7" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy8" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <class name="CertificateRequest" c:symbol-prefix="certificate_request" c:type="GcrCertificateRequest" parent="GObject.Object" glib:type-name="GcrCertificateRequest" glib:get-type="gcr_certificate_request_get_type">
      <doc xml:space="preserve">Represents a certificate request.</doc>
      <function name="capable" c:identifier="gcr_certificate_request_capable" throws="1">
        <doc xml:space="preserve">Check whether #GcrCertificateRequest is capable of creating a request
for the given @private_key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a request can be created</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="private_key" transfer-ownership="none">
            <doc xml:space="preserve">a private key</doc>
            <type name="Gck.Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="capable_async" c:identifier="gcr_certificate_request_capable_async">
        <doc xml:space="preserve">Asynchronously check whether #GcrCertificateRequest is capable of creating
a request for the given @private_key.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="private_key" transfer-ownership="none">
            <doc xml:space="preserve">a private key</doc>
            <type name="Gck.Object" c:type="GckObject*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">will be called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="capable_finish" c:identifier="gcr_certificate_request_capable_finish" throws="1">
        <doc xml:space="preserve">Get the result for asynchronously check whether #GcrCertificateRequest is
capable of creating a request for the given @private_key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether a request can be created</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="prepare" c:identifier="gcr_certificate_request_prepare">
        <doc xml:space="preserve">Create a new certificate request, in the given format for the private key.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GcrCertificate request</doc>
          <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format for the certificate request</doc>
            <type name="CertificateRequestFormat" c:type="GcrCertificateRequestFormat"/>
          </parameter>
          <parameter name="private_key" transfer-ownership="none">
            <doc xml:space="preserve">the private key the the certificate is being requested for</doc>
            <type name="Gck.Object" c:type="GckObject*"/>
          </parameter>
        </parameters>
      </function>
      <method name="complete" c:identifier="gcr_certificate_request_complete" throws="1">
        <doc xml:space="preserve">Complete and sign a certificate request, so that it can be encoded
and sent to a certificate authority.

This call may block as it signs the request using the private key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether certificate request was successfully completed or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a certificate request</doc>
            <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete_async" c:identifier="gcr_certificate_request_complete_async">
        <doc xml:space="preserve">Asynchronously complete and sign a certificate request, so that it can
be encoded and sent to a certificate authority.

This call will return immediately and complete later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a certificate request</doc>
            <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="complete_finish" c:identifier="gcr_certificate_request_complete_finish" throws="1">
        <doc xml:space="preserve">Finish an asynchronous operation to complete and sign a certificate
request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether certificate request was successfully completed or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a certificate request</doc>
            <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">result of the asynchronous operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encode" c:identifier="gcr_certificate_request_encode">
        <doc xml:space="preserve">Encode the certificate request. It must have been completed with
gcr_certificate_request_complete() or gcr_certificate_request_complete_async()

If @textual is %FALSE, the output is a DER encoded certificate request.

If @textual is %TRUE, the output is encoded as text. For PKCS\#10 requests this
is done using the OpenSSL style PEM encoding.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the encoded certificate request</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a certificate request</doc>
            <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
          </instance-parameter>
          <parameter name="textual" transfer-ownership="none">
            <doc xml:space="preserve">whether to encode output as text</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="length" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to place length of returned data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="gcr_certificate_request_get_format">
        <doc xml:space="preserve">Get the format of this certificate request.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the format</doc>
          <type name="CertificateRequestFormat" c:type="GcrCertificateRequestFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the certificate request</doc>
            <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_private_key" c:identifier="gcr_certificate_request_get_private_key">
        <doc xml:space="preserve">Get the private key this certificate request is for.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the private key,</doc>
          <type name="Gck.Object" c:type="GckObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the certificate request</doc>
            <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_cn" c:identifier="gcr_certificate_request_set_cn">
        <doc xml:space="preserve">Set the common name encoded in the certificate request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the certificate request</doc>
            <type name="CertificateRequest" c:type="GcrCertificateRequest*"/>
          </instance-parameter>
          <parameter name="cn" transfer-ownership="none">
            <doc xml:space="preserve">common name to set on the request</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="format" introspectable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The format of the certificate request.</doc>
        <type/>
      </property>
      <property name="private-key" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The private key that this certificate request is for.</doc>
        <type name="Gck.Object"/>
      </property>
    </class>
    <enumeration name="CertificateRequestFormat" c:type="GcrCertificateRequestFormat">
      <doc xml:space="preserve">The format of a certificate request. Currently only PKCS\#10 is supported.</doc>
      <member name="certificate_request_pkcs10" value="1" c:identifier="GCR_CERTIFICATE_REQUEST_PKCS10">
        <doc xml:space="preserve">certificate request is in PKCS\#10 format</doc>
      </member>
    </enumeration>
    <interface name="Collection" c:symbol-prefix="collection" c:type="GcrCollection" glib:type-name="GcrCollection" glib:get-type="gcr_collection_get_type" glib:type-struct="CollectionIface">
      <doc xml:space="preserve">A #GcrCollection is used to group a set of objects.</doc>
      <virtual-method name="added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="contains" invoker="contains">
        <doc xml:space="preserve">Check whether the collection contains an object or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the collection contains this object</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to check</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_length" invoker="get_length">
        <doc xml:space="preserve">Get the number of objects in this collection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of objects.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_objects" invoker="get_objects">
        <doc xml:space="preserve">Get a list of the objects in this collection.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a list of the objects
         in this collection, which should be freed with g_list_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GObject.Object"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="contains" c:identifier="gcr_collection_contains">
        <doc xml:space="preserve">Check whether the collection contains an object or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the collection contains this object</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object to check</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="emit_added" c:identifier="gcr_collection_emit_added">
        <doc xml:space="preserve">Emit the #GcrCollection::added signal for the given object. This function
is used by implementors of this interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The object that was added</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="emit_removed" c:identifier="gcr_collection_emit_removed">
        <doc xml:space="preserve">Emit the #GcrCollection::removed signal for the given object. This function
is used by implementors of this interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The object that was removed</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="gcr_collection_get_length">
        <doc xml:space="preserve">Get the number of objects in this collection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of objects.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_objects" c:identifier="gcr_collection_get_objects">
        <doc xml:space="preserve">Get a list of the objects in this collection.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a list of the objects
         in this collection, which should be freed with g_list_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GObject.Object"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <glib:signal name="added" when="last">
        <doc xml:space="preserve">This signal is emitted when an object is added to the collection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object that was added</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="removed" when="last">
        <doc xml:space="preserve">This signal is emitted when an object is removed from the collection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">object that was removed</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="CollectionIface" c:type="GcrCollectionIface" glib:is-gtype-struct-for="Collection">
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="added">
        <callback name="added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Collection" c:type="GcrCollection*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="removed">
        <callback name="removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Collection" c:type="GcrCollection*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_length">
        <callback name="get_length">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of objects.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The collection</doc>
              <type name="Collection" c:type="GcrCollection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_objects">
        <callback name="get_objects">
          <return-value transfer-ownership="container">
            <doc xml:space="preserve">a list of the objects
         in this collection, which should be freed with g_list_free()</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="GObject.Object"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The collection</doc>
              <type name="Collection" c:type="GcrCollection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="contains">
        <callback name="contains">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether the collection contains this object</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">the collection</doc>
              <type name="Collection" c:type="GcrCollection*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <doc xml:space="preserve">object to check</doc>
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dummy1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy7" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy8" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="Column" c:type="GcrColumn">
      <field name="property_name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="property_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="column_type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="label" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="ColumnFlags" c:type="GcrColumnFlags"/>
      </field>
      <field name="transformer" writable="1">
        <type name="GObject.ValueTransform" c:type="GValueTransform"/>
      </field>
      <field name="user_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <bitfield name="ColumnFlags" c:type="GcrColumnFlags">
      <member name="none" value="0" c:identifier="GCR_COLUMN_NONE">
      </member>
      <member name="hidden" value="2" c:identifier="GCR_COLUMN_HIDDEN">
      </member>
      <member name="sortable" value="4" c:identifier="GCR_COLUMN_SORTABLE">
      </member>
    </bitfield>
    <interface name="Comparable" c:symbol-prefix="comparable" c:type="GcrComparable" glib:type-name="GcrComparable" glib:get-type="gcr_comparable_get_type" glib:type-struct="ComparableIface">
      <doc xml:space="preserve">The #GcrComparable interface is implemented by comparable objects.</doc>
      <function name="memcmp" c:identifier="gcr_comparable_memcmp" introspectable="0">
        <doc xml:space="preserve">Compare two blocks of memory. The return value can be used to sort
the blocks of memory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Zero if the blocks are identical, negative if first
         less than secend, possitive otherwise.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="mem1" transfer-ownership="none">
            <doc xml:space="preserve">First block of memory</doc>
            <array length="1" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size1" transfer-ownership="none">
            <doc xml:space="preserve">Length of first block</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mem2" transfer-ownership="none">
            <doc xml:space="preserve">Second block of memory</doc>
            <array length="3" zero-terminated="0" c:type="gconstpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size2" transfer-ownership="none">
            <doc xml:space="preserve">Length of second block</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="compare" invoker="compare">
        <doc xml:space="preserve">Compare whether two objects represent the same thing. The return value can
also be used to sort the objects.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Zero if the two objects represent the same thing, non-zero if not.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The comparable object</doc>
            <type name="Comparable" c:type="GcrComparable*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Another comparable object</doc>
            <type name="Comparable" c:type="GcrComparable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="compare" c:identifier="gcr_comparable_compare">
        <doc xml:space="preserve">Compare whether two objects represent the same thing. The return value can
also be used to sort the objects.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Zero if the two objects represent the same thing, non-zero if not.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The comparable object</doc>
            <type name="Comparable" c:type="GcrComparable*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">Another comparable object</doc>
            <type name="Comparable" c:type="GcrComparable*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ComparableIface" c:type="GcrComparableIface" glib:is-gtype-struct-for="Comparable">
      <doc xml:space="preserve">The interface to implement for #GcrComparable</doc>
      <field name="parent">
        <doc xml:space="preserve">type interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="compare">
        <callback name="compare">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">Zero if the two objects represent the same thing, non-zero if not.</doc>
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve">The comparable object</doc>
              <type name="Comparable" c:type="GcrComparable*"/>
            </parameter>
            <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">Another comparable object</doc>
              <type name="Comparable" c:type="GcrComparable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="DataError" c:type="GcrDataError">
      <doc xml:space="preserve">Values responding to error codes for parsing and serializing data.</doc>
      <member name="failure" value="-1" c:identifier="GCR_ERROR_FAILURE">
        <doc xml:space="preserve">Failed to parse or serialize the data</doc>
      </member>
      <member name="unrecognized" value="1" c:identifier="GCR_ERROR_UNRECOGNIZED">
        <doc xml:space="preserve">The data was unrecognized or unsupported</doc>
      </member>
      <member name="cancelled" value="2" c:identifier="GCR_ERROR_CANCELLED">
        <doc xml:space="preserve">The operation was cancelled</doc>
      </member>
      <member name="locked" value="3" c:identifier="GCR_ERROR_LOCKED">
        <doc xml:space="preserve">The data was encrypted or locked and could not be unlocked.</doc>
      </member>
    </enumeration>
    <enumeration name="DataFormat" c:type="GcrDataFormat">
      <doc xml:space="preserve">The various format identifiers.</doc>
      <member name="all" value="-1" c:identifier="GCR_FORMAT_ALL">
        <doc xml:space="preserve">Represents all the formats, when enabling or disabling</doc>
      </member>
      <member name="invalid" value="0" c:identifier="GCR_FORMAT_INVALID">
        <doc xml:space="preserve">Not a valid format</doc>
      </member>
      <member name="der_private_key" value="100" c:identifier="GCR_FORMAT_DER_PRIVATE_KEY">
        <doc xml:space="preserve">DER encoded private key</doc>
      </member>
      <member name="der_private_key_rsa" value="101" c:identifier="GCR_FORMAT_DER_PRIVATE_KEY_RSA">
        <doc xml:space="preserve">DER encoded RSA private key</doc>
      </member>
      <member name="der_private_key_dsa" value="102" c:identifier="GCR_FORMAT_DER_PRIVATE_KEY_DSA">
        <doc xml:space="preserve">DER encoded DSA private key</doc>
      </member>
      <member name="der_private_key_ec" value="103" c:identifier="GCR_FORMAT_DER_PRIVATE_KEY_EC">
        <doc xml:space="preserve">DER encoded EC private key</doc>
      </member>
      <member name="der_subject_public_key" value="150" c:identifier="GCR_FORMAT_DER_SUBJECT_PUBLIC_KEY">
        <doc xml:space="preserve">DER encoded SubjectPublicKeyInfo</doc>
      </member>
      <member name="der_certificate_x509" value="200" c:identifier="GCR_FORMAT_DER_CERTIFICATE_X509">
        <doc xml:space="preserve">DER encoded X.509 certificate</doc>
      </member>
      <member name="der_pkcs7" value="300" c:identifier="GCR_FORMAT_DER_PKCS7">
        <doc xml:space="preserve">DER encoded PKCS\#7 container file which can contain certificates</doc>
      </member>
      <member name="der_pkcs8" value="400" c:identifier="GCR_FORMAT_DER_PKCS8">
        <doc xml:space="preserve">DER encoded PKCS\#8 file which can contain a key</doc>
      </member>
      <member name="der_pkcs8_plain" value="401" c:identifier="GCR_FORMAT_DER_PKCS8_PLAIN">
        <doc xml:space="preserve">Unencrypted DER encoded PKCS\#8 file which can contain a key</doc>
      </member>
      <member name="der_pkcs8_encrypted" value="402" c:identifier="GCR_FORMAT_DER_PKCS8_ENCRYPTED">
        <doc xml:space="preserve">Encrypted DER encoded PKCS\#8 file which can contain a key</doc>
      </member>
      <member name="der_pkcs10" value="450" c:identifier="GCR_FORMAT_DER_PKCS10">
        <doc xml:space="preserve">DER encoded PKCS\#10 certificate request file</doc>
      </member>
      <member name="der_spkac" value="455" c:identifier="GCR_FORMAT_DER_SPKAC">
        <doc xml:space="preserve">DER encoded SPKAC as generated by HTML5 keygen element</doc>
      </member>
      <member name="base64_spkac" value="456" c:identifier="GCR_FORMAT_BASE64_SPKAC">
        <doc xml:space="preserve">OpenSSL style SPKAC data</doc>
      </member>
      <member name="der_pkcs12" value="500" c:identifier="GCR_FORMAT_DER_PKCS12">
        <doc xml:space="preserve">DER encoded PKCS\#12 file which can contain certificates and/or keys</doc>
      </member>
      <member name="openssh_public" value="600" c:identifier="GCR_FORMAT_OPENSSH_PUBLIC">
        <doc xml:space="preserve">OpenSSH v1 or v2 public key</doc>
      </member>
      <member name="openpgp_packet" value="700" c:identifier="GCR_FORMAT_OPENPGP_PACKET">
        <doc xml:space="preserve">OpenPGP key packet(s)</doc>
      </member>
      <member name="openpgp_armor" value="701" c:identifier="GCR_FORMAT_OPENPGP_ARMOR">
        <doc xml:space="preserve">OpenPGP public or private key armor encoded data</doc>
      </member>
      <member name="pem" value="1000" c:identifier="GCR_FORMAT_PEM">
        <doc xml:space="preserve">An OpenSSL style PEM file with unspecified contents</doc>
      </member>
      <member name="pem_private_key_rsa" value="1001" c:identifier="GCR_FORMAT_PEM_PRIVATE_KEY_RSA">
        <doc xml:space="preserve">An OpenSSL style PEM file with a private RSA key</doc>
      </member>
      <member name="pem_private_key_dsa" value="1002" c:identifier="GCR_FORMAT_PEM_PRIVATE_KEY_DSA">
        <doc xml:space="preserve">An OpenSSL style PEM file with a private DSA key</doc>
      </member>
      <member name="pem_certificate_x509" value="1003" c:identifier="GCR_FORMAT_PEM_CERTIFICATE_X509">
        <doc xml:space="preserve">An OpenSSL style PEM file with an X.509 certificate</doc>
      </member>
      <member name="pem_pkcs7" value="1004" c:identifier="GCR_FORMAT_PEM_PKCS7">
        <doc xml:space="preserve">An OpenSSL style PEM file containing PKCS\#7</doc>
      </member>
      <member name="pem_pkcs8_plain" value="1005" c:identifier="GCR_FORMAT_PEM_PKCS8_PLAIN">
        <doc xml:space="preserve">Unencrypted OpenSSL style PEM file containing PKCS\#8</doc>
      </member>
      <member name="pem_pkcs8_encrypted" value="1006" c:identifier="GCR_FORMAT_PEM_PKCS8_ENCRYPTED">
        <doc xml:space="preserve">Encrypted OpenSSL style PEM file containing PKCS\#8</doc>
      </member>
      <member name="pem_pkcs12" value="1007" c:identifier="GCR_FORMAT_PEM_PKCS12">
        <doc xml:space="preserve">An OpenSSL style PEM file containing PKCS\#12</doc>
      </member>
      <member name="pem_private_key" value="1008" c:identifier="GCR_FORMAT_PEM_PRIVATE_KEY">
        <doc xml:space="preserve">An OpenSSL style PEM file with a private key</doc>
      </member>
      <member name="pem_pkcs10" value="1009" c:identifier="GCR_FORMAT_PEM_PKCS10">
        <doc xml:space="preserve">An OpenSSL style PEM file containing PKCS\#10</doc>
      </member>
      <member name="pem_private_key_ec" value="1010" c:identifier="GCR_FORMAT_PEM_PRIVATE_KEY_EC">
        <doc xml:space="preserve">An OpenSSL style PEM file with a private EC key</doc>
      </member>
      <member name="pem_public_key" value="1011" c:identifier="GCR_FORMAT_PEM_PUBLIC_KEY">
        <doc xml:space="preserve">An OpenSSL style PEM file containing a SubjectPublicKeyInfo</doc>
      </member>
    </enumeration>
    <class name="FilterCollection" c:symbol-prefix="filter_collection" c:type="GcrFilterCollection" parent="GObject.Object" glib:type-name="GcrFilterCollection" glib:get-type="gcr_filter_collection_get_type" glib:type-struct="FilterCollectionClass">
      <doc xml:space="preserve">A filter implementation of #GcrCollection.</doc>
      <implements name="Collection"/>
      <constructor name="new_with_callback" c:identifier="gcr_filter_collection_new_with_callback">
        <doc xml:space="preserve">Create a new #GcrFilterCollection.

The callback should return %TRUE if an object should appear in the
filtered collection.

If a %NULL callback is set, then all underlynig objects will appear in the
filtered collection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
         filtered collection, which should be freed with g_object_unref()</doc>
          <type name="FilterCollection" c:type="GcrCollection*"/>
        </return-value>
        <parameters>
          <parameter name="underlying" transfer-ownership="none">
            <doc xml:space="preserve">the underlying collection</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="2" destroy="3">
            <doc xml:space="preserve">function to call for each object</doc>
            <type name="FilterCollectionFunc" c:type="GcrFilterCollectionFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called for user_data when it is no longer needed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_underlying" c:identifier="gcr_filter_collection_get_underlying">
        <doc xml:space="preserve">Get the collection that is being filtered by this filter collection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the underlying collection</doc>
          <type name="Collection" c:type="GcrCollection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a filter collection</doc>
            <type name="FilterCollection" c:type="GcrFilterCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="refilter" c:identifier="gcr_filter_collection_refilter">
        <doc xml:space="preserve">Refilter all objects in the underlying collection. Call this function if
the filter callback function changes its filtering criteria.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a filter collection</doc>
            <type name="FilterCollection" c:type="GcrFilterCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_callback" c:identifier="gcr_filter_collection_set_callback">
        <doc xml:space="preserve">Set the callback used to filter the objects in the underlying collection.
The callback should return %TRUE if an object should appear in the
filtered collection.

If a %NULL callback is set, then all underlynig objects will appear in the
filtered collection.

This will refilter the collection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a filter collection</doc>
            <type name="FilterCollection" c:type="GcrFilterCollection*"/>
          </instance-parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="notified" closure="1" destroy="2">
            <doc xml:space="preserve">function to call for each object</doc>
            <type name="FilterCollectionFunc" c:type="GcrFilterCollectionFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called for user_data when it is no longer needed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <property name="underlying" writable="1" construct-only="1" transfer-ownership="none">
        <type name="Collection"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="FilterCollectionPrivate" c:type="GcrFilterCollectionPrivate*"/>
      </field>
    </class>
    <record name="FilterCollectionClass" c:type="GcrFilterCollectionClass" glib:is-gtype-struct-for="FilterCollection">
      <doc xml:space="preserve">The class for #GcrFilterCollection.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <callback name="FilterCollectionFunc" c:type="GcrFilterCollectionFunc">
      <doc xml:space="preserve">A function which is called by #GcrFilterCollection in order to determine
whether an object should show through the filter or not.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if an object should be included in the filtered collection</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">object to filter</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">user data passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="FilterCollectionPrivate" c:type="GcrFilterCollectionPrivate" disguised="1">
    </record>
    <constant name="ICON_CERTIFICATE" value="application-certificate" c:type="GCR_ICON_CERTIFICATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ICON_GNUPG" value="gcr-gnupg" c:type="GCR_ICON_GNUPG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ICON_HOME_DIRECTORY" value="user-home" c:type="GCR_ICON_HOME_DIRECTORY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ICON_KEY" value="gcr-key" c:type="GCR_ICON_KEY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ICON_KEY_PAIR" value="gcr-key-pair" c:type="GCR_ICON_KEY_PAIR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ICON_PASSWORD" value="gcr-password" c:type="GCR_ICON_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ICON_SMART_CARD" value="gcr-smart-card" c:type="GCR_ICON_SMART_CARD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="ImportInteraction" c:symbol-prefix="import_interaction" c:type="GcrImportInteraction" glib:type-name="GcrImportInteraction" glib:get-type="gcr_import_interaction_get_type" glib:type-struct="ImportInteractionIface">
      <doc xml:space="preserve">Interface implemented by the caller performing an import.</doc>
      <prerequisite name="Gio.TlsInteraction"/>
      <virtual-method name="supplement" invoker="supplement" throws="1">
        <doc xml:space="preserve">Supplement attributes before import. This means prompting the user for
things like labels and the like. The needed attributes will have been passed
to gcr_import_interaction_supplement_prep().

This method prompts the user and fills in the attributes. If the user or
cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED</doc>
          <type name="Gio.TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">supplemented attributes</doc>
            <type name="Gck.Builder" c:type="GckBuilder*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supplement_async" invoker="supplement_async">
        <doc xml:space="preserve">Asynchronously supplement attributes before import. This means prompting the
user for things like labels and the like. The needed attributes will have
been passed to gcr_import_interaction_supplement_prep().

This method prompts the user and fills in the attributes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">supplemented attributes</doc>
            <type name="Gck.Builder" c:type="GckBuilder*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="3">
            <doc xml:space="preserve">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supplement_finish" invoker="supplement_finish" throws="1">
        <doc xml:space="preserve">Complete operation to asynchronously supplement attributes before import.

If the user or cancellable cancels the operation the error should be set
with %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED</doc>
          <type name="Gio.TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="supplement_prep" invoker="supplement_prep">
        <doc xml:space="preserve">Prepare for supplementing the given attributes before import. This means
prompting the user for things like labels and the like. The attributes
will contain attributes for values that the importer needs, either empty
or prefilled with suggested values.

This method does not prompt the user, but rather just prepares the
interaction that these are the attributes that are needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">attributes to supplement</doc>
            <type name="Gck.Builder" c:type="GckBuilder*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="supplement" c:identifier="gcr_import_interaction_supplement" throws="1">
        <doc xml:space="preserve">Supplement attributes before import. This means prompting the user for
things like labels and the like. The needed attributes will have been passed
to gcr_import_interaction_supplement_prep().

This method prompts the user and fills in the attributes. If the user or
cancellable cancels the operation the error should be set with %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED</doc>
          <type name="Gio.TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">supplemented attributes</doc>
            <type name="Gck.Builder" c:type="GckBuilder*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supplement_async" c:identifier="gcr_import_interaction_supplement_async">
        <doc xml:space="preserve">Asynchronously supplement attributes before import. This means prompting the
user for things like labels and the like. The needed attributes will have
been passed to gcr_import_interaction_supplement_prep().

This method prompts the user and fills in the attributes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">supplemented attributes</doc>
            <type name="Gck.Builder" c:type="GckBuilder*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellable object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="supplement_finish" c:identifier="gcr_import_interaction_supplement_finish" throws="1">
        <doc xml:space="preserve">Complete operation to asynchronously supplement attributes before import.

If the user or cancellable cancels the operation the error should be set
with %G_IO_ERROR_CANCELLED.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED</doc>
          <type name="Gio.TlsInteractionResult" c:type="GTlsInteractionResult"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supplement_prep" c:identifier="gcr_import_interaction_supplement_prep">
        <doc xml:space="preserve">Prepare for supplementing the given attributes before import. This means
prompting the user for things like labels and the like. The attributes
will contain attributes for values that the importer needs, either empty
or prefilled with suggested values.

This method does not prompt the user, but rather just prepares the
interaction that these are the attributes that are needed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction</doc>
            <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
          </instance-parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">attributes to supplement</doc>
            <type name="Gck.Builder" c:type="GckBuilder*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ImportInteractionIface" c:type="GcrImportInteractionIface" glib:is-gtype-struct-for="ImportInteraction">
      <doc xml:space="preserve">Interface implemented by implementations of #GcrImportInteraction.</doc>
      <field name="parent">
        <doc xml:space="preserve">parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="supplement_prep">
        <callback name="supplement_prep">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">the interaction</doc>
              <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <doc xml:space="preserve">attributes to supplement</doc>
              <type name="Gck.Builder" c:type="GckBuilder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supplement">
        <callback name="supplement" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED</doc>
            <type name="Gio.TlsInteractionResult" c:type="GTlsInteractionResult"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">the interaction</doc>
              <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <doc xml:space="preserve">supplemented attributes</doc>
              <type name="Gck.Builder" c:type="GckBuilder*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional cancellable object</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supplement_async">
        <callback name="supplement_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">the interaction</doc>
              <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <doc xml:space="preserve">supplemented attributes</doc>
              <type name="Gck.Builder" c:type="GckBuilder*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">optional cancellable object</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
              <doc xml:space="preserve">called when the operation completes</doc>
              <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="4">
              <doc xml:space="preserve">data to be passed to the callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="supplement_finish">
        <callback name="supplement_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%G_TLS_INTERACTION_HANDLED if successful or %G_TLS_INTERACTION_FAILED</doc>
            <type name="Gio.TlsInteractionResult" c:type="GTlsInteractionResult"/>
          </return-value>
          <parameters>
            <parameter name="interaction" transfer-ownership="none">
              <doc xml:space="preserve">the interaction</doc>
              <type name="ImportInteraction" c:type="GcrImportInteraction*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">the asynchronous result</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <interface name="Importer" c:symbol-prefix="importer" c:type="GcrImporter" glib:type-name="GcrImporter" glib:get-type="gcr_importer_get_type" glib:type-struct="ImporterIface">
      <doc xml:space="preserve">Imports certificates and keys</doc>
      <function name="create_for_parsed" c:identifier="gcr_importer_create_for_parsed">
        <doc xml:space="preserve">Create a set of importers which can import this parsed item.
The parsed item is represented by the state of the GcrParser at the
time of calling this method.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a list of importers
         which can import the parsed item, which should be freed with
         g_object_unref(), or %NULL if no types of importers can be created</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Importer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parser with a parsed item to import</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </parameter>
        </parameters>
      </function>
      <function name="queue_and_filter_for_parsed" c:identifier="gcr_importer_queue_and_filter_for_parsed">
        <doc xml:space="preserve">Queues an additional item to be imported in all compattible importers
in the set. The parsed item is represented by the state of the #GcrParser
at the time of calling this method.

If the parsed item is incompatible with an importer, then that the item
will not be queued on that importer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new set of importers
         that queued the item, which should be freed with gck_list_unref_free()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Importer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="importers" transfer-ownership="none">
            <doc xml:space="preserve">a set of importers</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Importer"/>
            </type>
          </parameter>
          <parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register" c:identifier="gcr_importer_register">
        <doc xml:space="preserve">Register an importer to handle parsed items that match the given attributes.

If @attrs are a floating reference, then it is consumed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="importer_type" transfer-ownership="none">
            <doc xml:space="preserve">the GType of the importer being registered</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:space="preserve">the attributes that this importer is compatible with</doc>
            <type name="Gck.Attributes" c:type="GckAttributes*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_well_known" c:identifier="gcr_importer_register_well_known">
        <doc xml:space="preserve">Register built-in PKCS\#11 and GnuPG importers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <virtual-method name="import_async" invoker="import_async">
        <doc xml:space="preserve">Import the queued items in the importer. This function returns immediately
and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">the importer</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <doc xml:space="preserve">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="import_finish" invoker="import_finish" throws="1">
        <doc xml:space="preserve">Complete an asynchronous operation to import queued items.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the import succeeded or failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">the importer</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">an asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="import_sync" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="queue_for_parsed" invoker="queue_for_parsed">
        <doc xml:space="preserve">Queues an additional item to be imported. The parsed item is represented
by the state of the #GcrParser at the time of calling this method.

If the parsed item is incompatible with the importer, then this will
fail and the item will not be queued.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the item was queued or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">an importer to add additional items to</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item to import</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_interaction" c:identifier="gcr_importer_get_interaction">
        <doc xml:space="preserve">Get the interaction used to prompt the user when needed by this
importer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the interaction or %NULL</doc>
          <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">the importer</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="import" c:identifier="gcr_importer_import" throws="1">
        <doc xml:space="preserve">Import the queued items in the importer. This call will block
until the operation completes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the items were imported successfully or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">the importer</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="import_async" c:identifier="gcr_importer_import_async">
        <doc xml:space="preserve">Import the queued items in the importer. This function returns immediately
and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">the importer</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="import_finish" c:identifier="gcr_importer_import_finish" throws="1">
        <doc xml:space="preserve">Complete an asynchronous operation to import queued items.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the import succeeded or failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">the importer</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">an asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="queue_for_parsed" c:identifier="gcr_importer_queue_for_parsed">
        <doc xml:space="preserve">Queues an additional item to be imported. The parsed item is represented
by the state of the #GcrParser at the time of calling this method.

If the parsed item is incompatible with the importer, then this will
fail and the item will not be queued.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the item was queued or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">an importer to add additional items to</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item to import</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_interaction" c:identifier="gcr_importer_set_interaction">
        <doc xml:space="preserve">Set the interaction used to prompt the user when needed by this
importer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="importer" transfer-ownership="none">
            <doc xml:space="preserve">the importer</doc>
            <type name="Importer" c:type="GcrImporter*"/>
          </instance-parameter>
          <parameter name="interaction" transfer-ownership="none">
            <doc xml:space="preserve">the interaction used by the importer</doc>
            <type name="Gio.TlsInteraction" c:type="GTlsInteraction*"/>
          </parameter>
        </parameters>
      </method>
      <property name="icon" transfer-ownership="none">
        <doc xml:space="preserve">The icon for the importer.</doc>
        <type name="Gio.Icon"/>
      </property>
      <property name="interaction" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The interaction for the importer.</doc>
        <type name="Gio.TlsInteraction"/>
      </property>
      <property name="label" transfer-ownership="none">
        <doc xml:space="preserve">The label for the importer.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="uri" transfer-ownership="none">
        <doc xml:space="preserve">The URI of the location imported to.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
    </interface>
    <record name="ImporterIface" c:type="GcrImporterIface" glib:is-gtype-struct-for="Importer">
      <doc xml:space="preserve">Interface implemented for a #GcrImporter.</doc>
      <field name="parent">
        <doc xml:space="preserve">parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="create_for_parsed" introspectable="0">
        <callback name="create_for_parsed" introspectable="0">
          <return-value>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="parsed" transfer-ownership="none">
              <type name="Parsed" c:type="GcrParsed*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="queue_for_parsed">
        <callback name="queue_for_parsed">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether the item was queued or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="importer" transfer-ownership="none">
              <doc xml:space="preserve">an importer to add additional items to</doc>
              <type name="Importer" c:type="GcrImporter*"/>
            </parameter>
            <parameter name="parsed" transfer-ownership="none">
              <doc xml:space="preserve">a parsed item to import</doc>
              <type name="Parsed" c:type="GcrParsed*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="import_sync">
        <callback name="import_sync" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="importer" transfer-ownership="none">
              <type name="Importer" c:type="GcrImporter*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="import_async">
        <callback name="import_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="importer" transfer-ownership="none">
              <doc xml:space="preserve">the importer</doc>
              <type name="Importer" c:type="GcrImporter*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <doc xml:space="preserve">a #GCancellable, or %NULL</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <doc xml:space="preserve">called when the operation completes</doc>
              <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <doc xml:space="preserve">data to be passed to the callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="import_finish">
        <callback name="import_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">whether the import succeeded or failed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="importer" transfer-ownership="none">
              <doc xml:space="preserve">the importer</doc>
              <type name="Importer" c:type="GcrImporter*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">an asynchronous result</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="14">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <constant name="MAJOR_VERSION" value="3" c:type="GCR_MAJOR_VERSION">
      <doc xml:space="preserve">The major version number of the Gcr library.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="0" c:type="GCR_MICRO_VERSION">
      <doc xml:space="preserve">The micro version number of the Gcr library.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="16" c:type="GCR_MINOR_VERSION">
      <doc xml:space="preserve">The minor version number of the Gcr library.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Parsed" c:type="GcrParsed" glib:type-name="GcrParsed" glib:get-type="gcr_parsed_get_type" c:symbol-prefix="parsed">
      <doc xml:space="preserve">A parsed item parsed by a #GcrParser.</doc>
      <method name="get_attributes" c:identifier="gcr_parsed_get_attributes">
        <doc xml:space="preserve">Get the attributes which make up the parsed item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the attributes for the item; these
         are owned by the parsed item and should not be freed</doc>
          <type name="Gck.Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bytes" c:identifier="gcr_parsed_get_bytes">
        <doc xml:space="preserve">Get the raw data block for the parsed item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw data of the parsed item, or %NULL</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="gcr_parsed_get_data">
        <doc xml:space="preserve">Get the raw data block for the parsed item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw data of
         the parsed item, or %NULL</doc>
          <array length="0" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
          <parameter name="n_data" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">location to store size of returned data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="gcr_parsed_get_description">
        <doc xml:space="preserve">Get the descirption for a parsed item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the description</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_filename" c:identifier="gcr_parsed_get_filename">
        <doc xml:space="preserve">Get the filename of the parsed item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the filename of
         the parsed item, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="gcr_parsed_get_format">
        <doc xml:space="preserve">Get the format of the parsed item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data format of the item</doc>
          <type name="DataFormat" c:type="GcrDataFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_label" c:identifier="gcr_parsed_get_label">
        <doc xml:space="preserve">Get the label for the parsed item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the label for the item</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gcr_parsed_ref">
        <doc xml:space="preserve">Add a reference to a parsed item. An item may not be shared across threads
until it has been referenced at least once.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the parsed item</doc>
          <type name="Parsed" c:type="GcrParsed*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="Parsed" c:type="GcrParsed*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="unref" c:identifier="gcr_parsed_unref">
        <doc xml:space="preserve">Unreferences a parsed item which was referenced with gcr_parsed_ref()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parsed" transfer-ownership="none">
            <doc xml:space="preserve">a parsed item</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="Parser" c:symbol-prefix="parser" c:type="GcrParser" parent="GObject.Object" glib:type-name="GcrParser" glib:get-type="gcr_parser_get_type" glib:type-struct="ParserClass">
      <doc xml:space="preserve">A parser for parsing various types of files or data.</doc>
      <constructor name="new" c:identifier="gcr_parser_new">
        <doc xml:space="preserve">Create a new #GcrParser</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #GcrParser</doc>
          <type name="Parser" c:type="GcrParser*"/>
        </return-value>
      </constructor>
      <virtual-method name="authenticate">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="count" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parsed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_password" c:identifier="gcr_parser_add_password">
        <doc xml:space="preserve">Add a password to the set of passwords to try when parsing locked or encrypted
items. This is usually called from the #GcrParser::authenticate signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="password" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a password to try</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="format_disable" c:identifier="gcr_parser_format_disable">
        <doc xml:space="preserve">Disable parsing of the given format. Use %GCR_FORMAT_ALL to disable all the formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">The format identifier</doc>
            <type name="DataFormat" c:type="GcrDataFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="format_enable" c:identifier="gcr_parser_format_enable">
        <doc xml:space="preserve">Enable parsing of the given format. Use %GCR_FORMAT_ALL to enable all the formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">The format identifier</doc>
            <type name="DataFormat" c:type="GcrDataFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="format_supported" c:identifier="gcr_parser_format_supported">
        <doc xml:space="preserve">Check whether the given format is supported by the parser.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the format is supported.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">The format identifier</doc>
            <type name="DataFormat" c:type="GcrDataFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_filename" c:identifier="gcr_parser_get_filename">
        <doc xml:space="preserve">Get the filename of the parser item.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the filename set on the parser, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a parser item</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parsed" c:identifier="gcr_parser_get_parsed">
        <doc xml:space="preserve">Get the currently parsed item</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the currently parsed item</doc>
          <type name="Parsed" c:type="GcrParsed*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parsed_attributes" c:identifier="gcr_parser_get_parsed_attributes">
        <doc xml:space="preserve">Get the attributes which make up the currently parsed item. This is generally
only valid during the #GcrParser::parsed signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the attributes for the current item,
         which are owned by the parser and should not be freed</doc>
          <type name="Gck.Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parsed_block" c:identifier="gcr_parser_get_parsed_block">
        <doc xml:space="preserve">Get the raw data block that represents this parsed object. This is only
valid during the #GcrParser::parsed signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw data
         block of the currently parsed item; the value is owned by the parser
         and should not be freed</doc>
          <array length="0" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="n_block" direction="out" caller-allocates="0" transfer-ownership="full">
            <doc xml:space="preserve">a location to place the size of the block</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parsed_bytes" c:identifier="gcr_parser_get_parsed_bytes">
        <doc xml:space="preserve">Get the raw data block that represents this parsed object. This is only
valid during the #GcrParser::parsed signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the raw data block of the currently parsed item</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parsed_description" c:identifier="gcr_parser_get_parsed_description">
        <doc xml:space="preserve">Get a description for the type of the currently parsed item. This is generally
only valid during the #GcrParser::parsed signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the description for the current item; this is owned by
         the parser and should not be freed</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parsed_format" c:identifier="gcr_parser_get_parsed_format">
        <doc xml:space="preserve">Get the format of the raw data block that represents this parsed object.
This corresponds with the data returned from gcr_parser_get_parsed_block().

This is only valid during the #GcrParser::parsed signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the data format of the currently parsed item</doc>
          <type name="DataFormat" c:type="GcrDataFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parsed_label" c:identifier="gcr_parser_get_parsed_label">
        <doc xml:space="preserve">Get the label of the currently parsed item. This is generally only valid
during the #GcrParser::parsed signal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the label of the currently parsed item. The value is
         owned by the parser and should not be freed.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_bytes" c:identifier="gcr_parser_parse_bytes" throws="1">
        <doc xml:space="preserve">Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
may fire during the parsing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the data was parsed successfully or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the data to parse</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_data" c:identifier="gcr_parser_parse_data" throws="1">
        <doc xml:space="preserve">Parse the data. The #GcrParser::parsed and #GcrParser::authenticate signals
may fire during the parsing.

A copy of the data will be made. Use gcr_parser_parse_bytes() to avoid this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the data was parsed successfully or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the data to parse</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_data" transfer-ownership="none">
            <doc xml:space="preserve">The length of the data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_stream" c:identifier="gcr_parser_parse_stream" throws="1">
        <doc xml:space="preserve">Parse items from the data in a #GInputStream. This function may block while
reading from the input stream. Use gcr_parser_parse_stream_async() for
a non-blocking variant.

The #GcrParser::parsed and #GcrParser::authenticate signals
may fire during the parsing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the parsing completed successfully or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">The input stream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">An optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_stream_async" c:identifier="gcr_parser_parse_stream_async">
        <doc xml:space="preserve">Parse items from the data in a #GInputStream. This function completes
asyncronously and doesn't block.

The #GcrParser::parsed and #GcrParser::authenticate signals
may fire during the parsing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <doc xml:space="preserve">The input stream</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">An optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">Called when the operation result is ready.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">Data to pass to callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_stream_finish" c:identifier="gcr_parser_parse_stream_finish" throws="1">
        <doc xml:space="preserve">Complete an operation to parse a stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the parsing completed successfully or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The parser</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The operation result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filename" c:identifier="gcr_parser_set_filename">
        <doc xml:space="preserve">Sets the filename of the parser item.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a parser item</doc>
            <type name="Parser" c:type="GcrParser*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a string of the filename of the parser item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="parsed-attributes" transfer-ownership="none">
        <doc xml:space="preserve">Get the attributes that make up the currently parsed item. This is
generally only valid during a #GcrParser::parsed signal.</doc>
        <type name="Gck.Attributes"/>
      </property>
      <property name="parsed-description" transfer-ownership="none">
        <doc xml:space="preserve">The description of the type of the currently parsed item. This is generally
only valid during a #GcrParser::parsed signal.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="parsed-label" transfer-ownership="none">
        <doc xml:space="preserve">The label of the currently parsed item. This is generally
only valid during a #GcrParser::parsed signal.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="ParserPrivate" c:type="GcrParserPrivate*"/>
      </field>
      <glib:signal name="authenticate" when="last">
        <doc xml:space="preserve">This signal is emitted when an item needs to be unlocked or decrypted before
it can be parsed. The @count argument specifies the number of times
the signal has been emitted for a given item. This can be used to
display a message saying the previous password was incorrect.

Typically the gcr_parser_add_password() function is called in
response to this signal.

If %FALSE is returned, then the authentication was not handled. If
no handlers return %TRUE then the item is not parsed and an error
with the code %GCR_ERROR_CANCELLED will be raised.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Whether the authentication was handled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve">the number of times this item has been authenticated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="parsed" when="first">
        <doc xml:space="preserve">This signal is emitted when an item is sucessfully parsed. To access
the information about the item use the gcr_parser_get_parsed_label(),
gcr_parser_get_parsed_attributes() and gcr_parser_get_parsed_description()
functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="ParserClass" c:type="GcrParserClass" glib:is-gtype-struct-for="Parser">
      <doc xml:space="preserve">The class for #GcrParser</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="authenticate">
        <callback name="authenticate">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Parser" c:type="GcrParser*"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parsed">
        <callback name="parsed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Parser" c:type="GcrParser*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ParserPrivate" c:type="GcrParserPrivate" disguised="1">
    </record>
    <class name="Pkcs11Certificate" c:symbol-prefix="pkcs11_certificate" c:type="GcrPkcs11Certificate" parent="Gck.Object" glib:type-name="GcrPkcs11Certificate" glib:get-type="gcr_pkcs11_certificate_get_type" glib:type-struct="Pkcs11CertificateClass">
      <doc xml:space="preserve">A certificate loaded from PKCS\#11 storage.</doc>
      <implements name="Certificate"/>
      <implements name="Comparable"/>
      <function name="lookup_issuer" c:identifier="gcr_pkcs11_certificate_lookup_issuer" throws="1">
        <doc xml:space="preserve">Lookup a the issuer of a @certificate in the PKCS\#11 storage. The
lookup is done using the issuer DN of the certificate. No certificate chain
verification is done. Use a crypto library to make trust decisions.

This call may block, see gcr_pkcs11_certificate_lookup_issuer() for the
non-blocking version.

Will return %NULL if no issuer certificate is found. Use @error to determine
if an error occurred.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GcrPkcs11Certificate, or %NULL</doc>
          <type name="Certificate" c:type="GcrCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_issuer_async" c:identifier="gcr_pkcs11_certificate_lookup_issuer_async">
        <doc xml:space="preserve">Lookup a the issuer of a @certificate in the PKCS\#11 storage. The
lookup is done using the issuer DN of the certificate. No certificate chain
verification is done. Use a crypto library to make trust decisions.

When the operation is finished, callback will be called. You can then call
gcr_pkcs11_certificate_lookup_issuer_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="certificate" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrCertificate</doc>
            <type name="Certificate" c:type="GcrCertificate*"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="lookup_issuer_finish" c:identifier="gcr_pkcs11_certificate_lookup_issuer_finish" throws="1">
        <doc xml:space="preserve">Finishes an asynchronous operation started by
gcr_pkcs11_certificate_lookup_issuer_async().

Will return %NULL if no issuer certificate is found. Use @error to determine
if an error occurred.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GcrPkcs11Certificate, or %NULL</doc>
          <type name="Certificate" c:type="GcrCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the #GAsyncResult passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_attributes" c:identifier="gcr_pkcs11_certificate_get_attributes">
        <doc xml:space="preserve">Access the automatically loaded attributes for this certificate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the certificate attributes</doc>
          <type name="Gck.Attributes" c:type="GckAttributes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A #GcrPkcs11Certificate</doc>
            <type name="Pkcs11Certificate" c:type="GcrPkcs11Certificate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="attributes" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">Automatically loaded attributes for this certificate.</doc>
        <type name="Gck.Attributes"/>
      </property>
      <field name="parent">
        <type name="Gck.Object" c:type="GckObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="Pkcs11CertificatePrivate" c:type="GcrPkcs11CertificatePrivate*"/>
      </field>
    </class>
    <record name="Pkcs11CertificateClass" c:type="GcrPkcs11CertificateClass" glib:is-gtype-struct-for="Pkcs11Certificate">
      <doc xml:space="preserve">The class for #GcrPkcs11Certificate.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="Gck.ObjectClass" c:type="GckObjectClass"/>
      </field>
    </record>
    <record name="Pkcs11CertificatePrivate" c:type="GcrPkcs11CertificatePrivate" disguised="1">
    </record>
    <interface name="Prompt" c:symbol-prefix="prompt" c:type="GcrPrompt" glib:type-name="GcrPrompt" glib:get-type="gcr_prompt_get_type" glib:type-struct="PromptIface">
      <doc xml:space="preserve">Represents a #GcrPrompt displayed to the user.</doc>
      <virtual-method name="prompt_close">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prompt_confirm_async">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prompt_confirm_finish" throws="1">
        <return-value transfer-ownership="none">
          <type name="PromptReply" c:type="GcrPromptReply"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prompt_password_async">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prompt_password_finish" throws="1">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="close" c:identifier="gcr_prompt_close">
        <doc xml:space="preserve">Closes the prompt so that in can no longer be used to prompt. The various
prompt methods will return results as if the user dismissed the prompt.

The prompt may also be closed by the implementor of the #GcrPrompt object.

This emits the GcrPrompt::prompt-close signal on the prompt object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="confirm" c:identifier="gcr_prompt_confirm" throws="1">
        <doc xml:space="preserve">Prompts for confirmation asking a cancel/continue style question.
Set the various properties on the prompt before calling this function to
represent the question correctly.

This method will block until the a response is returned from the prompter.

%GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
an error occurs. Check the @error argument to tell the difference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the reply from the prompt</doc>
          <type name="PromptReply" c:type="GcrPromptReply"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="confirm_async" c:identifier="gcr_prompt_confirm_async">
        <doc xml:space="preserve">Prompts for confirmation asking a cancel/continue style question.
Set the various properties on the prompt before calling this method to
represent the question correctly.

This method will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="confirm_finish" c:identifier="gcr_prompt_confirm_finish" throws="1">
        <doc xml:space="preserve">Complete an operation to prompt for confirmation.

%GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
an error occurs. Check the @error argument to tell the difference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the reply from the prompt</doc>
          <type name="PromptReply" c:type="GcrPromptReply"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="confirm_run" c:identifier="gcr_prompt_confirm_run" throws="1">
        <doc xml:space="preserve">Prompts for confirmation asking a cancel/continue style question.
Set the various properties on the prompt before calling this function to
represent the question correctly.

This method will block until the a response is returned from the prompter
and will run a main loop similar to a gtk_dialog_run(). The application
will remain responsive but care must be taken to handle reentrancy issues.

%GCR_PROMPT_REPLY_CONTINUE will be returned if the user confirms the prompt. The
return value will also be %GCR_PROMPT_REPLY_CANCEL if the user cancels or if
an error occurs. Check the @error argument to tell the difference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the reply from the prompt</doc>
          <type name="PromptReply" c:type="GcrPromptReply"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_caller_window" c:identifier="gcr_prompt_get_caller_window">
        <doc xml:space="preserve">Get the string handle of the caller's window.

The caller window indicates to the prompt which window is prompting the
user. The prompt may choose to ignore this information or use it in whatever
way it sees fit.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the string
         handle of the window.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cancel_label" c:identifier="gcr_prompt_get_cancel_label">
        <doc xml:space="preserve">Get the label for the cancel button.

This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
from the prompt.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the label</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_choice_chosen" c:identifier="gcr_prompt_get_choice_chosen">
        <doc xml:space="preserve">Get whether the additional choice was chosen or not.

The additional choice would have been setup using
gcr_prompt_set_choice_label().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether chosen</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_choice_label" c:identifier="gcr_prompt_get_choice_label">
        <doc xml:space="preserve">Get the label for the additional choice.

This will be %NULL if no additional choice is being displayed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the additional
         choice or %NULL</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_continue_label" c:identifier="gcr_prompt_get_continue_label">
        <doc xml:space="preserve">Get the label for the continue button.

This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
from the prompt.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the label</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description" c:identifier="gcr_prompt_get_description">
        <doc xml:space="preserve">Get the detailed description of the prompt.

A prompt implementation may choose not to display this detailed description.
The prompt message should contain relevant information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the detailed
         description of the prompt</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_message" c:identifier="gcr_prompt_get_message">
        <doc xml:space="preserve">Gets the prompt message for the user.

A prompt implementation should always display this message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the detailed
         description of the prompt</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_new" c:identifier="gcr_prompt_get_password_new">
        <doc xml:space="preserve">Get whether the prompt will prompt for a new password.

This will cause the prompt implementation to ask the user to confirm the
password and/or display other relevant user interface for creating a new
password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether in new password mode or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_password_strength" c:identifier="gcr_prompt_get_password_strength">
        <doc xml:space="preserve">Get indication of the password strength.

Prompts will return a zero value if the password is empty, and a value
greater than zero if the password has any characters.

This is only valid after a successful prompt for a password.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">zero if the password is empty, greater than zero if not</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_title" c:identifier="gcr_prompt_get_title">
        <doc xml:space="preserve">Gets the title of the prompt.

A prompt implementation may choose not to display the prompt title. The
prompt message should contain relevant information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the prompt
         title.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_warning" c:identifier="gcr_prompt_get_warning">
        <doc xml:space="preserve">Get a prompt warning displayed on the prompt.

This is a warning like "The password is incorrect." usually displayed to the
user about a previous 'unsuccessful' prompt.

If this string is %NULL then no warning is displayed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string containing the prompt
         warning, or %NULL if no warning</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="password" c:identifier="gcr_prompt_password" throws="1">
        <doc xml:space="preserve">Prompts for password. Set the various properties on the prompt before calling
this method to explain which password should be entered.

This method will block until the a response is returned from the prompter.

A password will be returned if the user enters a password successfully.
The returned password is valid until the next time a method is called
to display another prompt.

%NULL will be returned if the user cancels or if an error occurs. Check the
@error argument to tell the difference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password owned by the prompt, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="password_async" c:identifier="gcr_prompt_password_async">
        <doc xml:space="preserve">Prompts for password. Set the various properties on the prompt before calling
this method to explain which password should be entered.

This method will return immediately and complete asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="password_finish" c:identifier="gcr_prompt_password_finish" throws="1">
        <doc xml:space="preserve">Complete an operation to prompt for a password.

A password will be returned if the user enters a password successfully.
The returned password is valid until the next time a method is called
to display another prompt.

%NULL will be returned if the user cancels or if an error occurs. Check the
@error argument to tell the difference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password owned by the prompt, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="password_run" c:identifier="gcr_prompt_password_run" throws="1">
        <doc xml:space="preserve">Prompts for password. Set the various properties on the prompt before calling
this method to explain which password should be entered.

This method will block until the a response is returned from the prompter
and will run a main loop similar to a gtk_dialog_run(). The application
will remain responsive but care must be taken to handle reentrancy issues.

A password will be returned if the user enters a password successfully.
The returned password is valid until the next time a method is called
to display another prompt.

%NULL will be returned if the user cancels or if an error occurs. Check the
@error argument to tell the difference.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the password owned by the prompt, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">a prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gcr_prompt_reset">
        <doc xml:space="preserve">Reset the contents and properties of the prompt.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_caller_window" c:identifier="gcr_prompt_set_caller_window">
        <doc xml:space="preserve">Set the string handle of the caller's window.

The caller window indicates to the prompt which window is prompting the
user. The prompt may choose to ignore this information or use it in whatever
way it sees fit.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="window_id" transfer-ownership="none">
            <doc xml:space="preserve">the window id</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cancel_label" c:identifier="gcr_prompt_set_cancel_label">
        <doc xml:space="preserve">Set the label for the continue button.

This is the button that results in a %GCR_PROMPT_REPLY_CANCEL reply
from the prompt.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="cancel_label" transfer-ownership="none">
            <doc xml:space="preserve">the label</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_choice_chosen" c:identifier="gcr_prompt_set_choice_chosen">
        <doc xml:space="preserve">Set whether the additional choice is chosen or not.

The additional choice should be set up using gcr_prompt_set_choice_label().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="chosen" transfer-ownership="none">
            <doc xml:space="preserve">whether chosen</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_choice_label" c:identifier="gcr_prompt_set_choice_label">
        <doc xml:space="preserve">Set the label for the additional choice.

If this is a non-%NULL value then an additional boolean choice will be
displayed by the prompt allowing the user to select or deselect it.

The initial value of the choice can be set with the
gcr_prompt_set_choice_label() method.

If this is %NULL, then no additional choice is being displayed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="choice_label" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the additional choice or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_continue_label" c:identifier="gcr_prompt_set_continue_label">
        <doc xml:space="preserve">Set the label for the continue button.

This is the button that results in a %GCR_PROMPT_REPLY_CONTINUE reply
from the prompt.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="continue_label" transfer-ownership="none">
            <doc xml:space="preserve">the label</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_description" c:identifier="gcr_prompt_set_description">
        <doc xml:space="preserve">Set the detailed description of the prompt.

A prompt implementation may choose not to display this detailed description.
Use gcr_prompt_set_message() to set a general message containing relevant
information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">the detailed description</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_message" c:identifier="gcr_prompt_set_message">
        <doc xml:space="preserve">Sets the prompt message for the user.

A prompt implementation should always display this message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">the prompt message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_password_new" c:identifier="gcr_prompt_set_password_new">
        <doc xml:space="preserve">Set whether the prompt will prompt for a new password.

This will cause the prompt implementation to ask the user to confirm the
password and/or display other relevant user interface for creating a new
password.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="new_password" transfer-ownership="none">
            <doc xml:space="preserve">whether in new password mode or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_title" c:identifier="gcr_prompt_set_title">
        <doc xml:space="preserve">Sets the title of the prompt.

A prompt implementation may choose not to display the prompt title. The
prompt message should contain relevant information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve">the prompt title</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_warning" c:identifier="gcr_prompt_set_warning">
        <doc xml:space="preserve">Set a prompt warning displayed on the prompt.

This is a warning like "The password is incorrect." usually displayed to the
user about a previous 'unsuccessful' prompt.

If this string is %NULL then no warning is displayed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </instance-parameter>
          <parameter name="warning" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the warning or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="caller-window" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The string handle of the caller's window.

The caller window indicates to the prompt which window is prompting the
user. The prompt may choose to ignore this information or use it in whatever
way it sees fit.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="cancel-label" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The label for the cancel button in the prompt.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="choice-chosen" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the additional choice is chosen or not.

The additional choice would have been setup using #GcrPrompt:choice-label.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="choice-label" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The label for the additional choice.

If this is a non-%NULL value then an additional boolean choice will be
displayed by the prompt allowing the user to select or deselect it.

If %NULL, then no additional choice is displayed.

The initial value of the choice can be set with #GcrPrompt:choice-chosen.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="continue-label" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The label for the continue button in the prompt.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="description" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The detailed description of the prompt.

A prompt implementation may choose not to display this detailed description.
The prompt message should contain relevant information.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="message" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The prompt message for the user.

A prompt implementation should always display this message.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="password-new" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Whether the prompt will prompt for a new password.

This will cause the prompt implementation to ask the user to confirm the
password and/or display other relevant user interface for creating a new
password.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="password-strength" transfer-ownership="none">
        <doc xml:space="preserve">Indication of the password strength.

Prompts will return a zero value if the password is empty, and a value
greater than zero if the password has any characters.

This is only valid after a successful prompt for a password.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <property name="title" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">The title of the prompt.

A prompt implementation may choose not to display the prompt title. The
#GcrPrompt:message should contain relevant information.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="warning" writable="1" construct="1" transfer-ownership="none">
        <doc xml:space="preserve">A prompt warning displayed on the prompt, or %NULL for no warning.

This is a warning like "The password is incorrect." usually displayed to the
user about a previous 'unsuccessful' prompt.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <glib:signal name="prompt-close" when="first">
        <doc xml:space="preserve">Action signal fired when the prompt is to be closed. After the default
handler has run, the prompt is closed. The various prompting methods
will return results as if the user dismissed the prompt.

You can use the gcr_prompt_close() method to emit this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </interface>
    <record name="PromptIface" c:type="GcrPromptIface" glib:is-gtype-struct-for="Prompt">
      <doc xml:space="preserve">The interface for implementing #GcrPrompt.</doc>
      <field name="parent_iface">
        <doc xml:space="preserve">parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="prompt_password_async">
        <callback name="prompt_password_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="prompt" transfer-ownership="none">
              <type name="Prompt" c:type="GcrPrompt*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prompt_password_finish">
        <callback name="prompt_password_finish" throws="1">
          <return-value transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="prompt" transfer-ownership="none">
              <type name="Prompt" c:type="GcrPrompt*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prompt_confirm_async">
        <callback name="prompt_confirm_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="prompt" transfer-ownership="none">
              <type name="Prompt" c:type="GcrPrompt*"/>
            </parameter>
            <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
              <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prompt_confirm_finish">
        <callback name="prompt_confirm_finish" throws="1">
          <return-value transfer-ownership="none">
            <type name="PromptReply" c:type="GcrPromptReply"/>
          </return-value>
          <parameters>
            <parameter name="prompt" transfer-ownership="none">
              <type name="Prompt" c:type="GcrPrompt*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prompt_close">
        <callback name="prompt_close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="prompt" transfer-ownership="none">
              <type name="Prompt" c:type="GcrPrompt*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="PromptReply" c:type="GcrPromptReply">
      <doc xml:space="preserve">Various replies returned by gcr_prompt_confirm() and friends.</doc>
      <member name="cancel" value="0" c:identifier="GCR_PROMPT_REPLY_CANCEL">
        <doc xml:space="preserve">the prompt was cancelled</doc>
      </member>
      <member name="continue" value="1" c:identifier="GCR_PROMPT_REPLY_CONTINUE">
        <doc xml:space="preserve">the user replied with 'ok'</doc>
      </member>
    </enumeration>
    <constant name="SECRET_EXCHANGE_PROTOCOL_1" value="sx-aes-1" c:type="GCR_SECRET_EXCHANGE_PROTOCOL_1">
      <doc xml:space="preserve">The current secret exchange protocol. Key agreement is done using DH with the
1536 bit IKE parameter group. Keys are derived using SHA256 with HKDF. The
transport encryption is done with 128 bit AES.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="SecretExchange" c:symbol-prefix="secret_exchange" c:type="GcrSecretExchange" parent="GObject.Object" glib:type-name="GcrSecretExchange" glib:get-type="gcr_secret_exchange_get_type" glib:type-struct="SecretExchangeClass">
      <doc xml:space="preserve">An object representing one side of a secret exchange.</doc>
      <constructor name="new" c:identifier="gcr_secret_exchange_new">
        <doc xml:space="preserve">Create a new secret exchange object.

Specify a protocol of %NULL to allow any protocol. This is especially
relevant on the side of the exchange that does not call
gcr_secret_exchange_begin(), that is the originator. Currently the only
protocol supported is %GCR_SECRET_EXCHANGE_PROTOCOL_1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GcrSecretExchange object</doc>
          <type name="SecretExchange" c:type="GcrSecretExchange*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the exchange protocol to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="decrypt_transport_data" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="exchange" transfer-ownership="none">
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
          <parameter name="allocator" transfer-ownership="none">
            <type name="Gck.Allocator" c:type="GckAllocator"/>
          </parameter>
          <parameter name="cipher_text" transfer-ownership="none">
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
          <parameter name="n_cipher_text" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none">
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
          <parameter name="n_parameter" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="plain_text" transfer-ownership="none">
            <type name="guint8" c:type="guchar**"/>
          </parameter>
          <parameter name="n_plain_text" transfer-ownership="none">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="derive_transport_key">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="exchange" transfer-ownership="none">
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
          <parameter name="peer" transfer-ownership="none">
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
          <parameter name="n_peer" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="encrypt_transport_data" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="exchange" transfer-ownership="none">
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
          <parameter name="allocator" transfer-ownership="none">
            <type name="Gck.Allocator" c:type="GckAllocator"/>
          </parameter>
          <parameter name="plain_text" transfer-ownership="none">
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
          <parameter name="n_plain_text" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="parameter" transfer-ownership="none">
            <type name="guint8" c:type="guchar**"/>
          </parameter>
          <parameter name="n_parameter" transfer-ownership="none">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="cipher_text" transfer-ownership="none">
            <type name="guint8" c:type="guchar**"/>
          </parameter>
          <parameter name="n_cipher_text" transfer-ownership="none">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="generate_exchange_key">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="exchange" transfer-ownership="none">
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
          <parameter name="scheme" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="public_key" transfer-ownership="none">
            <type name="guint8" c:type="guchar**"/>
          </parameter>
          <parameter name="n_public_key" transfer-ownership="none">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="begin" c:identifier="gcr_secret_exchange_begin">
        <doc xml:space="preserve">Begin the secret exchange. The resulting string should be sent to the other
side of the exchange. The other side should use gcr_secret_exchange_receive()
to process the string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string to be sent to the other
    side of the secret exchange</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrSecretExchange object</doc>
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_protocol" c:identifier="gcr_secret_exchange_get_protocol">
        <doc xml:space="preserve">Will return %NULL if no protocol was specified, and either
gcr_secret_exchange_begin() or gcr_secret_exchange_receive() have not been
called successfully.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the protocol or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrSecretExchange object
Get the secret exchange protocol.</doc>
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secret" c:identifier="gcr_secret_exchange_get_secret">
        <doc xml:space="preserve">Returns the last secret received. If no secret has yet been received this
will return %NULL. The string is owned by the #GcrSecretExchange object
and will be valid until the next time that gcr_secret_exchange_receive()
is called on this object, or the object is destroyed.

Depending on the secret passed into the other side of the secret exchange,
the result may be a binary string. It does however have a null terminator,
so if you're certain that it is does not contain arbitrary binary data,
it can be used as a string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the last secret received</doc>
          <array length="0" zero-terminated="0" c:type="gchar*">
            <type name="utf8" c:type="gchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrSecretExchange object</doc>
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
          <parameter name="secret_len" direction="out" caller-allocates="0" transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">optionally, a location to store the length of returned secret</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="receive" c:identifier="gcr_secret_exchange_receive">
        <doc xml:space="preserve">Receive a string from the other side of secret exchange. This string will
have been created by gcr_secret_exchange_begin() or gcr_secret_exchange_send().

After this call completes successfully the value returned from
gcr_secret_exchange_get_secret() will have changed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the string was successfully parsed and received</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrSecretExchange object</doc>
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
          <parameter name="exchange" transfer-ownership="none">
            <doc xml:space="preserve">the string received</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="gcr_secret_exchange_send">
        <doc xml:space="preserve">Send a reply to the other side of the secret exchange, optionally sending a
secret.

gcr_secret_exchange_receive() must have been successfully called at least
once on this object. In other words this object must have received data
from the other side of the secret exchange, before we can send a secret.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated string to be sent to the other
    side of the secret exchange</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GcrSecretExchange object</doc>
            <type name="SecretExchange" c:type="GcrSecretExchange*"/>
          </instance-parameter>
          <parameter name="secret" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optionally, a secret to send to the other side</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="secret_len" transfer-ownership="none">
            <doc xml:space="preserve">length of @secret, or -1 if null terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <property name="protocol" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The protocol being used for the exchange.

Will be %NULL if no protocol was specified when creating this object,
and either gcr_secret_exchange_begin() or gcr_secret_exchange_receive()
have not been called successfully.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="SecretExchangePrivate" c:type="GcrSecretExchangePrivate*"/>
      </field>
    </class>
    <record name="SecretExchangeClass" c:type="GcrSecretExchangeClass" glib:is-gtype-struct-for="SecretExchange">
      <doc xml:space="preserve">The class for #GcrSecretExchange</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="generate_exchange_key">
        <callback name="generate_exchange_key">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="exchange" transfer-ownership="none">
              <type name="SecretExchange" c:type="GcrSecretExchange*"/>
            </parameter>
            <parameter name="scheme" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="public_key" transfer-ownership="none">
              <type name="guint8" c:type="guchar**"/>
            </parameter>
            <parameter name="n_public_key" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="derive_transport_key">
        <callback name="derive_transport_key">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="exchange" transfer-ownership="none">
              <type name="SecretExchange" c:type="GcrSecretExchange*"/>
            </parameter>
            <parameter name="peer" transfer-ownership="none">
              <type name="guint8" c:type="const guchar*"/>
            </parameter>
            <parameter name="n_peer" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="encrypt_transport_data" introspectable="0">
        <callback name="encrypt_transport_data" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="exchange" transfer-ownership="none">
              <type name="SecretExchange" c:type="GcrSecretExchange*"/>
            </parameter>
            <parameter name="allocator" transfer-ownership="none">
              <type name="Gck.Allocator" c:type="GckAllocator"/>
            </parameter>
            <parameter name="plain_text" transfer-ownership="none">
              <type name="guint8" c:type="const guchar*"/>
            </parameter>
            <parameter name="n_plain_text" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none">
              <type name="guint8" c:type="guchar**"/>
            </parameter>
            <parameter name="n_parameter" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
            <parameter name="cipher_text" transfer-ownership="none">
              <type name="guint8" c:type="guchar**"/>
            </parameter>
            <parameter name="n_cipher_text" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decrypt_transport_data" introspectable="0">
        <callback name="decrypt_transport_data" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="exchange" transfer-ownership="none">
              <type name="SecretExchange" c:type="GcrSecretExchange*"/>
            </parameter>
            <parameter name="allocator" transfer-ownership="none">
              <type name="Gck.Allocator" c:type="GckAllocator"/>
            </parameter>
            <parameter name="cipher_text" transfer-ownership="none">
              <type name="guint8" c:type="const guchar*"/>
            </parameter>
            <parameter name="n_cipher_text" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="parameter" transfer-ownership="none">
              <type name="guint8" c:type="const guchar*"/>
            </parameter>
            <parameter name="n_parameter" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="plain_text" transfer-ownership="none">
              <type name="guint8" c:type="guchar**"/>
            </parameter>
            <parameter name="n_plain_text" transfer-ownership="none">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SecretExchangePrivate" c:type="GcrSecretExchangePrivate" disguised="1">
    </record>
    <class name="SimpleCertificate" c:symbol-prefix="simple_certificate" c:type="GcrSimpleCertificate" parent="GObject.Object" glib:type-name="GcrSimpleCertificate" glib:get-type="gcr_simple_certificate_get_type" glib:type-struct="SimpleCertificateClass">
      <doc xml:space="preserve">A #GcrCertificate which represents a certificate already in memory.</doc>
      <implements name="Certificate"/>
      <implements name="Comparable"/>
      <constructor name="new" c:identifier="gcr_simple_certificate_new">
        <doc xml:space="preserve">Create a new #GcrSimpleCertificate for the raw DER data. The @data memory is
copied so you can dispose of it after this function returns.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GcrSimpleCertificate</doc>
          <type name="SimpleCertificate" c:type="GcrCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the raw DER certificate data</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_data" transfer-ownership="none">
            <doc xml:space="preserve">The length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_static" c:identifier="gcr_simple_certificate_new_static" introspectable="0">
        <doc xml:space="preserve">Create a new #GcrSimpleCertificate for the raw DER data. The @data memory is
not copied and must persist until the #GcrSimpleCertificate object is
destroyed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GcrSimpleCertificate</doc>
          <type name="SimpleCertificate" c:type="GcrCertificate*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">The raw DER certificate data</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="n_data" transfer-ownership="none">
            <doc xml:space="preserve">The length of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="SimpleCertificatePrivate" c:type="GcrSimpleCertificatePrivate*"/>
      </field>
    </class>
    <record name="SimpleCertificateClass" c:type="GcrSimpleCertificateClass" glib:is-gtype-struct-for="SimpleCertificate">
      <doc xml:space="preserve">The class for #GcrSimpleCertificate.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="SimpleCertificatePrivate" c:type="GcrSimpleCertificatePrivate" disguised="1">
    </record>
    <class name="SimpleCollection" c:symbol-prefix="simple_collection" c:type="GcrSimpleCollection" parent="GObject.Object" glib:type-name="GcrSimpleCollection" glib:get-type="gcr_simple_collection_get_type" glib:type-struct="SimpleCollectionClass">
      <doc xml:space="preserve">A simple implementation of #GcrCollection.</doc>
      <implements name="Collection"/>
      <constructor name="new" c:identifier="gcr_simple_collection_new">
        <doc xml:space="preserve">Create a new #GcrSimpleCollection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
    collection, which should be freed with g_object_unref()</doc>
          <type name="SimpleCollection" c:type="GcrCollection*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="gcr_simple_collection_add">
        <doc xml:space="preserve">Add an object to this collection</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="SimpleCollection" c:type="GcrSimpleCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The object to add</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="gcr_simple_collection_remove">
        <doc xml:space="preserve">Remove an object from the collection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="SimpleCollection" c:type="GcrSimpleCollection*"/>
          </instance-parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The object to remove from the collection</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="SimpleCollectionPrivate" c:type="GcrSimpleCollectionPrivate*"/>
      </field>
    </class>
    <record name="SimpleCollectionClass" c:type="GcrSimpleCollectionClass" glib:is-gtype-struct-for="SimpleCollection">
      <doc xml:space="preserve">The class for #GcrSimpleCollection.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="SimpleCollectionPrivate" c:type="GcrSimpleCollectionPrivate" disguised="1">
    </record>
    <class name="SystemPrompt" c:symbol-prefix="system_prompt" c:type="GcrSystemPrompt" parent="GObject.Object" glib:type-name="GcrSystemPrompt" glib:get-type="gcr_system_prompt_get_type" glib:type-struct="SystemPromptClass">
      <doc xml:space="preserve">A #GcrPrompt which shows a system prompt. This is usually a system modal
dialog.</doc>
      <implements name="Prompt"/>
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.Initable"/>
      <function name="error_get_domain" c:identifier="gcr_system_prompt_error_get_domain">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="open" c:identifier="gcr_system_prompt_open" throws="1">
        <doc xml:space="preserve">Opens a system prompt with the default prompter.

Most system prompters only allow showing one prompt at a time, and if
another prompt is shown then this method will block for up to
@timeout_seconds seconds. If @timeout_seconds is equal to -1, then this
will block indefinitely until the prompt can be opened. If @timeout_seconds
expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the prompt, or %NULL if
         prompt could not be opened</doc>
          <type name="SystemPrompt" c:type="GcrPrompt*"/>
        </return-value>
        <parameters>
          <parameter name="timeout_seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds to wait to access the prompt, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_async" c:identifier="gcr_system_prompt_open_async">
        <doc xml:space="preserve">Asynchronously open a system prompt with the default system prompter.

Most system prompters only allow showing one prompt at a time, and if
another prompt is shown then this method will block for up to
@timeout_seconds seconds. If @timeout_seconds is equal to -1, then this
will block indefinitely until the prompt can be opened. If @timeout_seconds
expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds to wait to access the prompt, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="3">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_finish" c:identifier="gcr_system_prompt_open_finish" throws="1">
        <doc xml:space="preserve">Complete an operation to asynchronously open a system prompt.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the prompt, or %NULL if
         prompt could not be opened</doc>
          <type name="SystemPrompt" c:type="GcrPrompt*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">the asynchronous result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_for_prompter" c:identifier="gcr_system_prompt_open_for_prompter" throws="1">
        <doc xml:space="preserve">Opens a system prompt. If prompter_name is %NULL, then the default
system prompter is used.

Most system prompters only allow showing one prompt at a time, and if
another prompt is shown then this method will block for up to
@timeout_seconds seconds. If @timeout_seconds is equal to -1, then this
will block indefinitely until the prompt can be opened. If @timeout_seconds
expires, then this function will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the prompt, or %NULL if
         prompt could not be opened</doc>
          <type name="SystemPrompt" c:type="GcrPrompt*"/>
        </return-value>
        <parameters>
          <parameter name="prompter_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the prompter dbus name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="timeout_seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds to wait to access the prompt, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_for_prompter_async" c:identifier="gcr_system_prompt_open_for_prompter_async">
        <doc xml:space="preserve">Opens a system prompt asynchronously. If prompter_name is %NULL, then the
default system prompter is used.

Most system prompters only allow showing one prompt at a time, and if
another prompt is shown then this method will block for up to
@timeout_seconds seconds. If @timeout_seconds is equal to -1, then this
will block indefinitely until the prompt can be opened. If @timeout_seconds
expires, then this operation will fail with a %GCR_SYSTEM_PROMPT_IN_PROGRESS
error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="prompter_name" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">the prompter dbus name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="timeout_seconds" transfer-ownership="none">
            <doc xml:space="preserve">the number of seconds to wait to access the prompt, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="4">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="close" c:identifier="gcr_system_prompt_close" throws="1">
        <doc xml:space="preserve">Close this prompt. After calling this function, no further prompts will
succeed on this object. The prompt object is not unreferenced by this
function, and you must unreference it once done.

This call may block, use the gcr_system_prompt_close_async() to perform
this action indefinitely.

Whether or not this function returns %TRUE, the system prompt object is
still closed and may not be further used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether close was cleanly completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="SystemPrompt" c:type="GcrSystemPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async" c:identifier="gcr_system_prompt_close_async">
        <doc xml:space="preserve">Close this prompt asynchronously. After calling this function, no further
methods may be called on this object. The prompt object is not unreferenced
by this function, and you must unreference it once done.

This call returns immediately and completes asynchronously.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="SystemPrompt" c:type="GcrSystemPrompt*"/>
          </instance-parameter>
          <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
            <doc xml:space="preserve">an optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
            <doc xml:space="preserve">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:space="preserve">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish" c:identifier="gcr_system_prompt_close_finish" throws="1">
        <doc xml:space="preserve">Complete operation to close this prompt.

Whether or not this function returns %TRUE, the system prompt object is
still closed and may not be further used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether close was cleanly completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the prompt</doc>
            <type name="SystemPrompt" c:type="GcrSystemPrompt*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">asynchronous operation result</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secret_exchange" c:identifier="gcr_system_prompt_get_secret_exchange">
        <doc xml:space="preserve">Get the current #GcrSecretExchange used to transfer secrets in this prompt.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the secret exchange</doc>
          <type name="SecretExchange" c:type="GcrSecretExchange*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a prompter</doc>
            <type name="SystemPrompt" c:type="GcrSystemPrompt*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="bus-name" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The DBus bus name of the prompter to use for prompting, or %NULL
for the default prompter.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="secret-exchange" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GcrSecretExchange to use when transferring passwords. A default
secret exchange will be used if this is not set.</doc>
        <type name="SecretExchange"/>
      </property>
      <property name="timeout-seconds" readable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The timeout in seconds to wait when opening the prompt.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="SystemPromptPrivate" c:type="GcrSystemPromptPrivate*"/>
      </field>
    </class>
    <record name="SystemPromptClass" c:type="GcrSystemPromptClass" glib:is-gtype-struct-for="SystemPrompt">
      <doc xml:space="preserve">The class for #GcrSystemPrompt.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="SystemPromptError" c:type="GcrSystemPromptError">
      <doc xml:space="preserve">No error returned by the #GcrSystemPrompt is suitable for display or
to the user.

If the system prompter can only show one prompt at a time, and there is
already a prompt being displayed, and the timeout waiting to open the
prompt expires, then %GCR_SYSTEM_PROMPT_IN_PROGRESS is returned.</doc>
      <member name="system_prompt_in_progress" value="1" c:identifier="GCR_SYSTEM_PROMPT_IN_PROGRESS">
        <doc xml:space="preserve">another prompt is already in progress</doc>
      </member>
    </enumeration>
    <record name="SystemPromptPrivate" c:type="GcrSystemPromptPrivate" disguised="1">
    </record>
    <class name="SystemPrompter" c:symbol-prefix="system_prompter" c:type="GcrSystemPrompter" parent="GObject.Object" glib:type-name="GcrSystemPrompter" glib:get-type="gcr_system_prompter_get_type" glib:type-struct="SystemPrompterClass">
      <doc xml:space="preserve">A prompter used by implementations of system prompts.</doc>
      <constructor name="new" c:identifier="gcr_system_prompter_new">
        <doc xml:space="preserve">Create a new system prompter service. This prompter won't do anything unless
you connect to its signals and show appropriate prompts.

If @prompt_type is zero, then the new-prompt signal must be handled and
return a valid prompt object implementing the #GcrPrompt interface.

If @prompt_type is non-zero then the #GType must implement the #GcrPrompt
interface.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new prompter service</doc>
          <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the mode for the prompt</doc>
            <type name="SystemPrompterMode" c:type="GcrSystemPrompterMode"/>
          </parameter>
          <parameter name="prompt_type" transfer-ownership="none">
            <doc xml:space="preserve">the gobject type for prompts created by this prompter</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="new_prompt" introspectable="0">
        <return-value>
          <type name="Prompt" c:type="GcrPrompt*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_mode" c:identifier="gcr_system_prompter_get_mode">
        <doc xml:space="preserve">Get the mode for this prompter.

Most system prompters only display one prompt at a time and therefore
return %GCR_SYSTEM_PROMPTER_SINGLE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the prompter mode</doc>
          <type name="SystemPrompterMode" c:type="GcrSystemPrompterMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the prompter</doc>
            <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prompt_type" c:identifier="gcr_system_prompter_get_prompt_type">
        <doc xml:space="preserve">Get the #GType for prompts created by this prompter.

The returned #GType will be a #GcrPrompt implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the prompt #GType</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the prompter</doc>
            <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_prompting" c:identifier="gcr_system_prompter_get_prompting">
        <doc xml:space="preserve">Get whether prompting or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether prompting or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the prompter</doc>
            <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="gcr_system_prompter_register">
        <doc xml:space="preserve">Register this system prompter on the DBus @connection.

This makes the prompter available for clients to call. The prompter will
remain registered until gcr_system_prompter_unregister() is called, or the
prompter is unreferenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the system prompter</doc>
            <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve">a DBus connection</doc>
            <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister" c:identifier="gcr_system_prompter_unregister">
        <doc xml:space="preserve">Unregister this system prompter on the DBus @connection.

The prompter must have previously been registered with gcr_system_prompter_register().

If @wait is set then this function will wait until all prompts have been closed
or cancelled. This is usually only used by tests.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the system prompter</doc>
            <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
          </instance-parameter>
          <parameter name="wait" transfer-ownership="none">
            <doc xml:space="preserve">whether to wait for closing prompts</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="mode" introspectable="0" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The mode for this prompter.

Most system prompters only display one prompt at a time and therefore
return %GCR_SYSTEM_PROMPTER_SINGLE.</doc>
        <type/>
      </property>
      <property name="prompt-type" writable="1" construct-only="1" transfer-ownership="none">
        <doc xml:space="preserve">The #GType for prompts created by this prompter. This must be a
#GcrPrompt implementation.</doc>
        <type name="GType" c:type="GType"/>
      </property>
      <property name="prompting" transfer-ownership="none">
        <doc xml:space="preserve">Whether the prompter is prompting or not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="SystemPrompterPrivate" c:type="GcrSystemPrompterPrivate*"/>
      </field>
      <glib:signal name="new-prompt" when="last">
        <doc xml:space="preserve">Signal emitted to create a new prompt when needed.

The default implementation of this signal creates a prompt of the type
gcr_system_prompter_get_prompt_type().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new prompt</doc>
          <type name="Prompt"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="SystemPrompterClass" c:type="GcrSystemPrompterClass" glib:is-gtype-struct-for="SystemPrompter">
      <doc xml:space="preserve">The class for #GcrSystemPrompter.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="new_prompt" introspectable="0">
        <callback name="new_prompt" introspectable="0">
          <return-value>
            <type name="Prompt" c:type="GcrPrompt*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SystemPrompter" c:type="GcrSystemPrompter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="7">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="SystemPrompterMode" c:type="GcrSystemPrompterMode">
      <doc xml:space="preserve">The mode for the system prompter. Most system prompters can only show
one prompt at a time and would use the %GCR_SYSTEM_PROMPTER_SINGLE mode.</doc>
      <member name="single" value="0" c:identifier="GCR_SYSTEM_PROMPTER_SINGLE">
        <doc xml:space="preserve">only one prompt shown at a time</doc>
      </member>
      <member name="multiple" value="1" c:identifier="GCR_SYSTEM_PROMPTER_MULTIPLE">
        <doc xml:space="preserve">more than one prompt shown at a time</doc>
      </member>
    </enumeration>
    <record name="SystemPrompterPrivate" c:type="GcrSystemPrompterPrivate" disguised="1">
    </record>
    <constant name="UNLOCK_OPTION_ALWAYS" value="always" c:type="GCR_UNLOCK_OPTION_ALWAYS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="UNLOCK_OPTION_IDLE" value="idle" c:type="GCR_UNLOCK_OPTION_IDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="UNLOCK_OPTION_SESSION" value="session" c:type="GCR_UNLOCK_OPTION_SESSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="UNLOCK_OPTION_TIMEOUT" value="timeout" c:type="GCR_UNLOCK_OPTION_TIMEOUT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="UnionCollection" c:symbol-prefix="union_collection" c:type="GcrUnionCollection" parent="GObject.Object" glib:type-name="GcrUnionCollection" glib:get-type="gcr_union_collection_get_type" glib:type-struct="UnionCollectionClass">
      <doc xml:space="preserve">A union implementation of #GcrCollection.</doc>
      <implements name="Collection"/>
      <constructor name="new" c:identifier="gcr_union_collection_new">
        <doc xml:space="preserve">Create a new #GcrUnionCollection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated
         collection, which should be freed with g_object_unref()</doc>
          <type name="UnionCollection" c:type="GcrCollection*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="gcr_union_collection_add">
        <doc xml:space="preserve">Add objects from this collection to the union</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The union collection</doc>
            <type name="UnionCollection" c:type="GcrUnionCollection*"/>
          </instance-parameter>
          <parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve">The collection whose objects to add</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="elements" c:identifier="gcr_union_collection_elements">
        <doc xml:space="preserve">Get the collections that have been added to this union.</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">collections
         added to the union</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Collection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the union collection</doc>
            <type name="UnionCollection" c:type="GcrUnionCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="have" c:identifier="gcr_union_collection_have">
        <doc xml:space="preserve">Check whether the collection is present in the union.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether present or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the union collection</doc>
            <type name="UnionCollection" c:type="GcrUnionCollection*"/>
          </instance-parameter>
          <parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve">the collection to check</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="gcr_union_collection_remove">
        <doc xml:space="preserve">Remove an object from the collection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The collection</doc>
            <type name="UnionCollection" c:type="GcrUnionCollection*"/>
          </instance-parameter>
          <parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve">The collection whose objects to remove</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="gcr_union_collection_size">
        <doc xml:space="preserve">Return the number of collections in this union. This does not reflect
the number of objects in the combined collection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of collections inlcuded</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the union collection</doc>
            <type name="UnionCollection" c:type="GcrUnionCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="take" c:identifier="gcr_union_collection_take">
        <doc xml:space="preserve">Add objects from this collection to the union. Do not add an additional
reference to the collection.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The union collection</doc>
            <type name="UnionCollection" c:type="GcrUnionCollection*"/>
          </instance-parameter>
          <parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve">The collection whose objects to add</doc>
            <type name="Collection" c:type="GcrCollection*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="UnionCollectionPrivate" c:type="GcrUnionCollectionPrivate*"/>
      </field>
    </class>
    <record name="UnionCollectionClass" c:type="GcrUnionCollectionClass" glib:is-gtype-struct-for="UnionCollection">
      <doc xml:space="preserve">The class for #GcrUnionCollection.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="UnionCollectionPrivate" c:type="GcrUnionCollectionPrivate" disguised="1">
    </record>
    <function name="certificate_compare" c:identifier="gcr_certificate_compare" moved-to="Certificate.compare">
      <doc xml:space="preserve">Compare one certificate against another. If the certificates are equal
then zero is returned. If one certificate is %NULL or not a certificate,
then a non-zero value is returned.

The return value is useful in a stable sort, but has no user logical
meaning.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">zero if the certificates match, non-zero otherwise.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="first" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the certificate to compare</doc>
          <type name="Comparable" c:type="GcrComparable*"/>
        </parameter>
        <parameter name="other" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the certificate to compare against</doc>
          <type name="Comparable" c:type="GcrComparable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="certificate_get_columns" c:identifier="gcr_certificate_get_columns" moved-to="Certificate.get_columns" introspectable="0">
      <doc xml:space="preserve">Get the columns appropriate for a certificate</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the columns</doc>
        <type name="Column" c:type="const GcrColumn*"/>
      </return-value>
    </function>
    <function name="certificate_mixin_class_init" c:identifier="gcr_certificate_mixin_class_init" moved-to="Certificate.mixin_class_init" introspectable="0">
      <doc xml:space="preserve">Initialize the certificate mixin for the class. This mixin implements the
various required properties for the certificate.

Call this function near the end of your derived class_init function. The
derived class must implement the #GcrCertificate interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object_class" transfer-ownership="none">
          <doc xml:space="preserve">The GObjectClass for this class</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="certificate_mixin_comparable_init" c:identifier="gcr_certificate_mixin_comparable_init" moved-to="Certificate.mixin_comparable_init" introspectable="0">
      <doc xml:space="preserve">Initialize a #GcrComparableIface to compare the current certificate.
In general it's easier to use the GCR_CERTIFICATE_MIXIN_IMPLEMENT_COMPARABLE()
macro instead of this function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:space="preserve">The interface</doc>
          <type name="ComparableIface" c:type="GcrComparableIface*"/>
        </parameter>
      </parameters>
    </function>
    <function name="certificate_mixin_get_property" c:identifier="gcr_certificate_mixin_get_property" moved-to="Certificate.mixin_get_property" introspectable="0">
      <doc xml:space="preserve">Implementation to get various required certificate properties. This should
be called from your derived class get_property function, or used as a
get_property virtual function.

Example of use as called from derived class get_property function:

&lt;informalexample&gt;&lt;programlisting&gt;
static void
my_get_property (GObject *obj, guint prop_id, GValue *value, GParamSpec *pspec)
{
	switch (prop_id) {

	...

	default:
		gcr_certificate_mixin_get_property (obj, prop_id, value, pspec);
		break;
	}
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

Example of use as get_property function:

&lt;informalexample&gt;&lt;programlisting&gt;
static void
my_class_init (MyClass *klass)
{
	GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
	gobject_class-&gt;get_property = gcr_certificate_mixin_get_property;

	...
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve">The object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="prop_id" transfer-ownership="none">
          <doc xml:space="preserve">The property id</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">The value to fill in.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="pspec" transfer-ownership="none">
          <doc xml:space="preserve">The param specification.</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="comparable_memcmp" c:identifier="gcr_comparable_memcmp" moved-to="Comparable.memcmp" introspectable="0">
      <doc xml:space="preserve">Compare two blocks of memory. The return value can be used to sort
the blocks of memory.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">Zero if the blocks are identical, negative if first
         less than secend, possitive otherwise.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="mem1" transfer-ownership="none">
          <doc xml:space="preserve">First block of memory</doc>
          <array length="1" zero-terminated="0" c:type="gconstpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="size1" transfer-ownership="none">
          <doc xml:space="preserve">Length of first block</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="mem2" transfer-ownership="none">
          <doc xml:space="preserve">Second block of memory</doc>
          <array length="3" zero-terminated="0" c:type="gconstpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="size2" transfer-ownership="none">
          <doc xml:space="preserve">Length of second block</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="data_error_get_domain" c:identifier="gcr_data_error_get_domain">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="fingerprint_from_attributes" c:identifier="gcr_fingerprint_from_attributes">
      <doc xml:space="preserve">Create a key fingerprint for a certificate, public key or private key.
Note that this is not a fingerprint of certificate data, which you would
use gcr_certificate_get_fingerprint() for.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the
         fingerprint or %NULL if the input was invalid.</doc>
        <array length="2" zero-terminated="0" c:type="guchar*">
          <type name="guint8" c:type="guchar"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="attrs" transfer-ownership="none">
          <doc xml:space="preserve">attributes for key or certificate</doc>
          <type name="Gck.Attributes" c:type="GckAttributes*"/>
        </parameter>
        <parameter name="checksum_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of fingerprint to create</doc>
          <type name="GLib.ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="n_fingerprint" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the length of fingerprint returned</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="fingerprint_from_subject_public_key_info" c:identifier="gcr_fingerprint_from_subject_public_key_info">
      <doc xml:space="preserve">Create a key fingerprint for a DER encoded subjectPublicKeyInfo.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the
         fingerprint or %NULL if the input was invalid.</doc>
        <array length="3" zero-terminated="0" c:type="guchar*">
          <type name="guint8" c:type="guchar"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="key_info" transfer-ownership="none">
          <doc xml:space="preserve">DER encoded subjectPublicKeyInfo structure</doc>
          <array length="1" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </parameter>
        <parameter name="n_key_info" transfer-ownership="none">
          <doc xml:space="preserve">length of DER encoded structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="checksum_type" transfer-ownership="none">
          <doc xml:space="preserve">the type of fingerprint to create</doc>
          <type name="GLib.ChecksumType" c:type="GChecksumType"/>
        </parameter>
        <parameter name="n_fingerprint" direction="out" caller-allocates="0" transfer-ownership="full">
          <doc xml:space="preserve">the length of fingerprint returned</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </function>
    <function name="icon_for_token" c:identifier="gcr_icon_for_token">
      <doc xml:space="preserve">Get an appropriate icon for the token</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the icon</doc>
        <type name="Gio.Icon" c:type="GIcon*"/>
      </return-value>
      <parameters>
        <parameter name="token_info" transfer-ownership="none">
          <doc xml:space="preserve">the token info</doc>
          <type name="Gck.TokenInfo" c:type="GckTokenInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="importer_create_for_parsed" c:identifier="gcr_importer_create_for_parsed" moved-to="Importer.create_for_parsed">
      <doc xml:space="preserve">Create a set of importers which can import this parsed item.
The parsed item is represented by the state of the GcrParser at the
time of calling this method.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a list of importers
         which can import the parsed item, which should be freed with
         g_object_unref(), or %NULL if no types of importers can be created</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Importer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="parsed" transfer-ownership="none">
          <doc xml:space="preserve">a parser with a parsed item to import</doc>
          <type name="Parsed" c:type="GcrParsed*"/>
        </parameter>
      </parameters>
    </function>
    <function name="importer_queue_and_filter_for_parsed" c:identifier="gcr_importer_queue_and_filter_for_parsed" moved-to="Importer.queue_and_filter_for_parsed">
      <doc xml:space="preserve">Queues an additional item to be imported in all compattible importers
in the set. The parsed item is represented by the state of the #GcrParser
at the time of calling this method.

If the parsed item is incompatible with an importer, then that the item
will not be queued on that importer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new set of importers
         that queued the item, which should be freed with gck_list_unref_free()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Importer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="importers" transfer-ownership="none">
          <doc xml:space="preserve">a set of importers</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Importer"/>
          </type>
        </parameter>
        <parameter name="parsed" transfer-ownership="none">
          <doc xml:space="preserve">a parsed item</doc>
          <type name="Parsed" c:type="GcrParsed*"/>
        </parameter>
      </parameters>
    </function>
    <function name="importer_register" c:identifier="gcr_importer_register" moved-to="Importer.register">
      <doc xml:space="preserve">Register an importer to handle parsed items that match the given attributes.

If @attrs are a floating reference, then it is consumed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="importer_type" transfer-ownership="none">
          <doc xml:space="preserve">the GType of the importer being registered</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="attrs" transfer-ownership="none">
          <doc xml:space="preserve">the attributes that this importer is compatible with</doc>
          <type name="Gck.Attributes" c:type="GckAttributes*"/>
        </parameter>
      </parameters>
    </function>
    <function name="importer_register_well_known" c:identifier="gcr_importer_register_well_known" moved-to="Importer.register_well_known">
      <doc xml:space="preserve">Register built-in PKCS\#11 and GnuPG importers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="mock_prompter_disconnect" c:identifier="gcr_mock_prompter_disconnect">
      <doc xml:space="preserve">Disconnect the mock prompter</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="mock_prompter_expect_close" c:identifier="gcr_mock_prompter_expect_close">
      <doc xml:space="preserve">Queue an expected response on the mock prompter.

Expects any prompt, and closes the prompt when it gets it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="mock_prompter_expect_confirm_cancel" c:identifier="gcr_mock_prompter_expect_confirm_cancel">
      <doc xml:space="preserve">Queue an expected response on the mock prompter.

Expects a confirmation prompt, and then cancels that prompt.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="mock_prompter_expect_confirm_ok" c:identifier="gcr_mock_prompter_expect_confirm_ok" introspectable="0">
      <doc xml:space="preserve">Queue an expected response on the mock prompter.

Expects a confirmation prompt, and then confirms that prompt by
simulating a click on the ok button.

Additional property pairs for the prompt can be added in the argument
list, in the same way that you would with g_object_new().

If the "choice-chosen" property is specified then that value will be
set on the prompt as if the user had changed the value.

All other properties will be checked against the prompt, and an error
will occur if they do not match the value set on the prompt.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:space="preserve">the first property name in the argument list or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">properties to expect</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mock_prompter_expect_password_cancel" c:identifier="gcr_mock_prompter_expect_password_cancel">
      <doc xml:space="preserve">Queue an expected response on the mock prompter.

Expects a password prompt, and then cancels that prompt.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="mock_prompter_expect_password_ok" c:identifier="gcr_mock_prompter_expect_password_ok" introspectable="0">
      <doc xml:space="preserve">Queue an expected response on the mock prompter.

Expects a password prompt, and returns @password as if the user had entered
it and clicked the ok button.

Additional property pairs for the prompt can be added in the argument
list, in the same way that you would with g_object_new().

If the "choice-chosen" property is specified then that value will be
set on the prompt as if the user had changed the value.

All other properties will be checked against the prompt, and an error
will occur if they do not match the value set on the prompt.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve">the password to return from the prompt</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="first_property_name" transfer-ownership="none">
          <doc xml:space="preserve">the first property name in the argument list or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">properties to expect</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="mock_prompter_get_delay_msec" c:identifier="gcr_mock_prompter_get_delay_msec">
      <doc xml:space="preserve">Get the delay in milliseconds before the mock prompter completes
an expected prompt.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the delay</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
    </function>
    <function name="mock_prompter_is_expecting" c:identifier="gcr_mock_prompter_is_expecting">
      <doc xml:space="preserve">Check if the mock prompter is expecting a response. This will be %TRUE
when one of the &lt;literal&gt;gcr_mock_prompter_expect_xxx&lt;!-- --&gt;()&lt;/literal&gt;
functions have been used to queue an expected prompt, but that prompt
response has not be 'used' yet.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether expecting a prompt</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="mock_prompter_is_prompting" c:identifier="gcr_mock_prompter_is_prompting">
      <doc xml:space="preserve">Check if the mock prompter is showing any prompts.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether prompting</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="mock_prompter_set_delay_msec" c:identifier="gcr_mock_prompter_set_delay_msec">
      <doc xml:space="preserve">Set the delay in milliseconds before the mock prompter completes
an expected prompt.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="delay_msec" transfer-ownership="none">
          <doc xml:space="preserve">prompt response delay in milliseconds</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="mock_prompter_start" c:identifier="gcr_mock_prompter_start">
      <doc xml:space="preserve">Start the mock prompter. This is often used from the
&lt;literal&gt;setup&lt;!-- --&gt;()&lt;/literal&gt; function of tests.

Starts the mock prompter in an additional thread. Use the returned DBus bus
name with gcr_system_prompt_open_for_prompter() to connect to this prompter.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the bus name that the mock prompter is listening on</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="mock_prompter_stop" c:identifier="gcr_mock_prompter_stop">
      <doc xml:space="preserve">Stop the mock prompter. This is often used from the
&lt;literal&gt;teardown&lt;!-- --&gt;()&lt;/literal&gt; function of tests.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="parsed_unref" c:identifier="gcr_parsed_unref" moved-to="Parsed.unref">
      <doc xml:space="preserve">Unreferences a parsed item which was referenced with gcr_parsed_ref()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="parsed" transfer-ownership="none">
          <doc xml:space="preserve">a parsed item</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_add_module" c:identifier="gcr_pkcs11_add_module">
      <doc xml:space="preserve">Add a #GckModule to the list of PKCS\#11 modules that are used by the
GCR library.

It is not normally necessary to call this function. The available
PKCS\#11 modules installed on the system are automatically loaded
by the GCR library.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="module" transfer-ownership="none">
          <doc xml:space="preserve">a #GckModule</doc>
          <type name="Gck.Module" c:type="GckModule*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_add_module_from_file" c:identifier="gcr_pkcs11_add_module_from_file" throws="1">
      <doc xml:space="preserve">Initialize a PKCS\#11 module and add it to the modules that are
used by the GCR library. Note that is an error to initialize the same
PKCS\#11 module twice.

It is not normally necessary to call this function. The available
PKCS\#11 modules installed on the system are automatically loaded
by the GCR library.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the module was sucessfully added.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="module_path" transfer-ownership="none">
          <doc xml:space="preserve">the full file path of the PKCS\#11 module</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:space="preserve">unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_get_modules" c:identifier="gcr_pkcs11_get_modules">
      <doc xml:space="preserve">List all the PKCS\#11 modules that are used by the GCR library.
Each module is a #GckModule object.

An empty list of modules will be returned if gcr_pkcs11_set_modules(),
or gcr_pkcs11_initialize() has not yet run.

When done with the list, free it with gck_list_unref_free().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated list
         of #GckModule objects</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Gck.Module"/>
        </type>
      </return-value>
    </function>
    <function name="pkcs11_get_trust_lookup_slots" c:identifier="gcr_pkcs11_get_trust_lookup_slots">
      <doc xml:space="preserve">List all the PKCS\#11 slots that are used by the GCR library for lookup
of trust assertions. Each slot is a #GckSlot object.

This will return an empty list if the gcr_pkcs11_initialize() function has
not yet been called.

When done with the list, free it with gck_list_unref_free().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a list of #GckSlot objects
         to use for lookup of trust.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Gck.Slot"/>
        </type>
      </return-value>
    </function>
    <function name="pkcs11_get_trust_lookup_uris" c:identifier="gcr_pkcs11_get_trust_lookup_uris">
      <doc xml:space="preserve">Get the PKCS\#11 URIs that are used to identify which slots to use for
lookup trust assertions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the uri which identifies trust storage slot</doc>
        <array c:type="const gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
    </function>
    <function name="pkcs11_get_trust_store_slot" c:identifier="gcr_pkcs11_get_trust_store_slot">
      <doc xml:space="preserve">Selects an appropriate PKCS\#11 slot to store trust assertions. The slot
to use is normally configured automatically by the system.

This will only return a valid result after the gcr_pkcs11_initialize()
method has been called.

When done with the #GckSlot, use g_object_unref() to release it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GckSlot to use for trust assertions.</doc>
        <type name="Gck.Slot" c:type="GckSlot*"/>
      </return-value>
    </function>
    <function name="pkcs11_get_trust_store_uri" c:identifier="gcr_pkcs11_get_trust_store_uri">
      <doc xml:space="preserve">Get the PKCS\#11 URI that is used to identify which slot to use for
storing trust storage.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the uri which identifies trust storage slot</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="pkcs11_initialize" c:identifier="gcr_pkcs11_initialize" throws="1">
      <doc xml:space="preserve">Asynchronously initialize the registered PKCS\#11 modules.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the operation was successful or not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional cancellable used to cancel the operation</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_initialize_async" c:identifier="gcr_pkcs11_initialize_async">
      <doc xml:space="preserve">Asynchronously initialize the registered PKCS\#11 modules.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cancellable" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">optional cancellable used to cancel the operation</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" nullable="1" allow-none="1" scope="async" closure="2">
          <doc xml:space="preserve">callback which will be called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:space="preserve">data passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_initialize_finish" c:identifier="gcr_pkcs11_initialize_finish" throws="1">
      <doc xml:space="preserve">Complete the asynchronous operation to initialize the registered PKCS\#11
modules.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the operation was successful or not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve">the asynchronous result</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_set_modules" c:identifier="gcr_pkcs11_set_modules">
      <doc xml:space="preserve">Set the list of PKCS\#11 modules that are used by the GCR library.
Each module in the list is a #GckModule object.

It is not normally necessary to call this function. The available
PKCS\#11 modules installed on the system are automatically loaded
by the GCR library.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="modules" transfer-ownership="none">
          <doc xml:space="preserve">a list of #GckModule</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Gck.Module"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_set_trust_lookup_uris" c:identifier="gcr_pkcs11_set_trust_lookup_uris">
      <doc xml:space="preserve">Set the PKCS\#11 URIs that are used to identify which slots to use for
lookup of trust assertions.

It is not normally necessary to call this function. The relevant
PKCS\#11 slots are automatically configured by the GCR library.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pkcs11_uris" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the uris which identifies trust lookup slots</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="pkcs11_set_trust_store_uri" c:identifier="gcr_pkcs11_set_trust_store_uri">
      <doc xml:space="preserve">Set the PKCS\#11 URI that is used to identify which slot to use for
storing trust assertions.

It is not normally necessary to call this function. The relevant
PKCS\#11 slot is automatically configured by the GCR library.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pkcs11_uri" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">the uri which identifies trust storage slot</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_alloc" c:identifier="gcr_secure_memory_alloc" introspectable="0">
      <doc xml:space="preserve">Allocate a block of non-pageable memory.

If non-pageable memory cannot be allocated then normal memory will be
returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">new memory block which should be freed
with gcr_secure_memory_free()</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">The new desired size of the memory block.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_free" c:identifier="gcr_secure_memory_free" introspectable="0">
      <doc xml:space="preserve">Free a block of non-pageable memory.

Glib memory is also freed correctly when passed to this function. If called
with a %NULL pointer then no action is taken.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="memory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">pointer to the beginning of the block of memory to free</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_is_secure" c:identifier="gcr_secure_memory_is_secure" introspectable="0">
      <doc xml:space="preserve">Check if a pointer is in non-pageable memory allocated by.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">whether the memory is secure non-pageable memory allocated by the
         Gcr library or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="memory" transfer-ownership="none">
          <doc xml:space="preserve">pointer to check</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_realloc" c:identifier="gcr_secure_memory_realloc" introspectable="0">
      <doc xml:space="preserve">Reallocate a block of non-pageable memory.

Glib memory is also reallocated correctly. If called with a null pointer,
then a new block of memory is allocated. If called with a zero size,
then the block of memory is freed.

If non-pageable memory cannot be allocated then normal memory will be
returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">new block, or %NULL if the block was
freed; memory block should be freed with gcr_secure_memory_free()</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="memory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">pointer to reallocate or %NULL to allocate a new block</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">new desired size of the memory block, or 0 to free the memory</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_strdup" c:identifier="gcr_secure_memory_strdup" introspectable="0">
      <doc xml:space="preserve">Copy a string into non-pageable memory. If the input string is %NULL, then
%NULL will be returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">copied string, should be freed with gcr_secure_memory_free()</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">null terminated string to copy</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_strfree" c:identifier="gcr_secure_memory_strfree" introspectable="0">
      <doc xml:space="preserve">Free a string, whether securely allocated using these functions or not.
This will also clear out the contents of the string so they do not
remain in memory.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">null terminated string to fere</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_try_alloc" c:identifier="gcr_secure_memory_try_alloc" introspectable="0">
      <doc xml:space="preserve">Allocate a block of non-pageable memory.

If non-pageable memory cannot be allocated, then %NULL is returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">new block, or %NULL if memory cannot be
allocated; memory block should be freed with gcr_secure_memory_free()</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">new desired size of the memory block</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="secure_memory_try_realloc" c:identifier="gcr_secure_memory_try_realloc" introspectable="0">
      <doc xml:space="preserve">Reallocate a block of non-pageable memory.

Glib memory is also reallocated correctly when passed to this function.
If called with a null pointer, then a new block of memory is allocated.
If called with a zero size, then the block of memory is freed.

If memory cannot be allocated, %NULL is returned and the original block
of memory remains intact.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new block, or %NULL if memory cannot be
allocated; the memory block should be freed with gcr_secure_memory_free()</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="memory" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">pointer to reallocate or %NULL to allocate a new block</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">new desired size of the memory block</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
