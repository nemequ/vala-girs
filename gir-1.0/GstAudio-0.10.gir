<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gst" version="0.10"/>
  <include name="GstBase" version="0.10"/>
  <include name="GstInterfaces" version="0.10"/>
  <include name="libxml2" version="2.0"/>
  <package name="gstreamer-audio-0.10"/>
  <c:include name="gst/audio/audio-enumtypes.h"/>
  <c:include name="gst/audio/audio.h"/>
  <c:include name="gst/audio/gstaudioclock.h"/>
  <c:include name="gst/audio/gstaudiodecoder.h"/>
  <c:include name="gst/audio/gstaudioencoder.h"/>
  <c:include name="gst/audio/gstaudiofilter.h"/>
  <c:include name="gst/audio/gstaudioiec61937.h"/>
  <c:include name="gst/audio/gstaudiosink.h"/>
  <c:include name="gst/audio/gstaudiosrc.h"/>
  <c:include name="gst/audio/gstbaseaudiosink.h"/>
  <c:include name="gst/audio/gstbaseaudiosrc.h"/>
  <c:include name="gst/audio/gstringbuffer.h"/>
  <c:include name="gst/audio/mixerutils.h"/>
  <c:include name="gst/audio/multichannel.h"/>
  <namespace name="GstAudio"
             version="0.10"
             shared-library="libgstaudio-0.10.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <constant name="AUDIO_DECODER_MAX_ERRORS"
              value="10"
              c:type="GST_AUDIO_DECODER_MAX_ERRORS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_DECODER_SINK_NAME"
              value="sink"
              c:type="GST_AUDIO_DECODER_SINK_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DECODER_SRC_NAME"
              value="src"
              c:type="GST_AUDIO_DECODER_SRC_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DEF_RATE" value="44100" c:type="GST_AUDIO_DEF_RATE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_ENCODER_SINK_NAME"
              value="sink"
              c:type="GST_AUDIO_ENCODER_SINK_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_ENCODER_SRC_NAME"
              value="src"
              c:type="GST_AUDIO_ENCODER_SRC_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_FLOAT_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-float, rate = (int) [ 1, MAX ], channels = (int) [ 1, MAX ], endianness = (int) { LITTLE_ENDIAN , BIG_ENDIAN }, width = (int) { 32, 64 }"
              c:type="GST_AUDIO_FLOAT_PAD_TEMPLATE_CAPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_FLOAT_STANDARD_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-float, width = (int) 32, rate = (int) [ 1, MAX ], channels = (int) 1, endianness = (int) BYTE_ORDER"
              c:type="GST_AUDIO_FLOAT_STANDARD_PAD_TEMPLATE_CAPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_INT_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-int, rate = (int) [ 1, MAX ], channels = (int) [ 1, MAX ], endianness = (int) { LITTLE_ENDIAN, BIG_ENDIAN }, width = (int) { 8, 16, 24, 32 }, depth = (int) [ 1, 32 ], signed = (boolean) { true, false }"
              c:type="GST_AUDIO_INT_PAD_TEMPLATE_CAPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_INT_STANDARD_PAD_TEMPLATE_CAPS"
              value="audio/x-raw-int, rate = (int) [ 1, MAX ], channels = (int) 2, endianness = (int) BYTE_ORDER, width = (int) 16, depth = (int) 16, signed = (boolean) true"
              c:type="GST_AUDIO_INT_STANDARD_PAD_TEMPLATE_CAPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="AudioChannelPosition"
                 glib:type-name="GstAudioChannelPosition"
                 glib:get-type="gst_audio_channel_position_get_type"
                 c:type="GstAudioChannelPosition">
      <doc xml:whitespace="preserve">Audio channel positions.</doc>
      <member name="invalid"
              value="-1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_INVALID"
              glib:nick="invalid"/>
      <member name="front_mono"
              value="0"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_MONO"
              glib:nick="front-mono"/>
      <member name="front_left"
              value="1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT"
              glib:nick="front-left"/>
      <member name="front_right"
              value="2"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT"
              glib:nick="front-right"/>
      <member name="rear_center"
              value="3"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_CENTER"
              glib:nick="rear-center"/>
      <member name="rear_left"
              value="4"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_LEFT"
              glib:nick="rear-left"/>
      <member name="rear_right"
              value="5"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT"
              glib:nick="rear-right"/>
      <member name="lfe"
              value="6"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_LFE"
              glib:nick="lfe"/>
      <member name="front_center"
              value="7"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER"
              glib:nick="front-center"/>
      <member name="front_left_of_center"
              value="8"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER"
              glib:nick="front-left-of-center"/>
      <member name="front_right_of_center"
              value="9"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER"
              glib:nick="front-right-of-center"/>
      <member name="side_left"
              value="10"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT"
              glib:nick="side-left"/>
      <member name="side_right"
              value="11"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT"
              glib:nick="side-right"/>
      <member name="none"
              value="12"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_NONE"
              glib:nick="none"/>
      <member name="num"
              value="13"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_NUM"
              glib:nick="num"/>
    </enumeration>
    <class name="AudioClock"
           c:symbol-prefix="audio_clock"
           c:type="GstAudioClock"
           parent="Gst.SystemClock"
           glib:type-name="GstAudioClock"
           glib:get-type="gst_audio_clock_get_type"
           glib:type-struct="AudioClockClass">
      <doc xml:whitespace="preserve">#GstAudioClock makes it easy for elements to implement a #GstClock, they
simply need to provide a function that returns the current clock time.

This object is internally used to implement the clock in #GstBaseAudioSink.

Last reviewed on 2006-09-27 (0.10.12)</doc>
      <constructor name="new"
                   c:identifier="gst_audio_clock_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Create a new #GstAudioClock instance. Whenever the clock time should be
calculated it will call @func with @user_data. When @func returns
#GST_CLOCK_TIME_NONE, the clock will return the last reported time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstAudioClock casted to a #GstClock.</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the clock</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">a function</doc>
            <type name="AudioClockGetTimeFunc"
                  c:type="GstAudioClockGetTimeFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="gst_audio_clock_new_full"
                   version="0.10.31">
        <doc xml:whitespace="preserve">Create a new #GstAudioClock instance. Whenever the clock time should be
calculated it will call @func with @user_data. When @func returns
#GST_CLOCK_TIME_NONE, the clock will return the last reported time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstAudioClock casted to a #GstClock.</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the clock</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">a function</doc>
            <type name="AudioClockGetTimeFunc"
                  c:type="GstAudioClockGetTimeFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">#GDestroyNotify for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="adjust"
                c:identifier="gst_audio_clock_adjust"
                version="0.10.23">
        <doc xml:whitespace="preserve">Adjust @time with the internal offset of the audio clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@time adjusted with the internal offset.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_time"
                c:identifier="gst_audio_clock_get_time"
                version="0.10.23">
        <doc xml:whitespace="preserve">Report the time as returned by the #GstAudioClockGetTimeFunc without applying
any offsets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the time as reported by the time function of the audio clock</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </function>
      <function name="invalidate"
                c:identifier="gst_audio_clock_invalidate"
                version="0.10.31">
        <doc xml:whitespace="preserve">Invalidate the clock function. Call this function when the provided
#GstAudioClockGetTimeFunc cannot be called anymore, for example, when the
user_data becomes invalid.

After calling this function, @clock will return the last returned time for
the rest of its lifetime.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAudioClock</doc>
            <type name="Gst.Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </function>
      <method name="reset" c:identifier="gst_audio_clock_reset">
        <doc xml:whitespace="preserve">Inform @clock that future calls to #GstAudioClockGetTimeFunc will return values
starting from @time. The clock will update an internal offset to make sure that
future calls to internal_time will return an increasing result as required by
the #GstClock object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <field name="clock">
        <type name="Gst.SystemClock" c:type="GstSystemClock"/>
      </field>
      <field name="func">
        <type name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc"/>
      </field>
      <field name="user_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="last_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="time_offset" writable="1">
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </field>
          <field name="destroy_notify" writable="1">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <record name="AudioClockClass"
            c:type="GstAudioClockClass"
            glib:is-gtype-struct-for="AudioClock">
      <field name="parent_class">
        <type name="Gst.SystemClockClass" c:type="GstSystemClockClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc">
      <doc xml:whitespace="preserve">This function will be called whenever the current clock time needs to be
calculated. If this function returns #GST_CLOCK_TIME_NONE, the last reported
time will be returned by the clock.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the current time or #GST_CLOCK_TIME_NONE if the previous time should be used.</doc>
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </return-value>
      <parameters>
        <parameter name="clock" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstAudioClock</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AudioDecoder"
           c:symbol-prefix="audio_decoder"
           c:type="GstAudioDecoder"
           version="0.10.36"
           parent="Gst.Element"
           glib:type-name="GstAudioDecoder"
           glib:get-type="gst_audio_decoder_get_type"
           glib:type-struct="AudioDecoderClass">
      <doc xml:whitespace="preserve">This base class is for audio decoders turning encoded data into
raw audio samples.

GstAudioDecoder and subclass should cooperate as follows.
&lt;orderedlist&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Configuration&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    Initially, GstAudioDecoder calls @start when the decoder element
    is activated, which allows subclass to perform any global setup.
    Base class (context) parameters can already be set according to subclass
    capabilities (or possibly upon receive more information in subsequent
    @set_format).
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioDecoder calls @set_format to inform subclass of the format
    of input audio data that it is about to receive.
    While unlikely, it might be called more than once, if changing input
    parameters require reconfiguration.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioDecoder calls @stop at end of all processing.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
As of configuration stage, and throughout processing, GstAudioDecoder
provides various (context) parameters, e.g. describing the format of
output audio data (valid when output caps have been set) or current parsing state.
Conversely, subclass can and should configure context to inform
base class of its expectation w.r.t. buffer handling.
&lt;listitem&gt;
  &lt;itemizedlist&gt;
  &lt;title&gt;Data processing&lt;/title&gt;
    &lt;listitem&gt;&lt;para&gt;
      Base class gathers input data, and optionally allows subclass
      to parse this into subsequently manageable (as defined by subclass)
      chunks.  Such chunks are subsequently referred to as 'frames',
      though they may or may not correspond to 1 (or more) audio format frame.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      Input frame is provided to subclass' @handle_frame.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      If codec processing results in decoded data, subclass should call
      @gst_audio_decoder_finish_frame to have decoded data pushed
      downstream.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      Just prior to actually pushing a buffer downstream,
      it is passed to @pre_push.  Subclass should either use this callback
      to arrange for additional downstream pushing or otherwise ensure such
      custom pushing occurs after at least a method call has finished since
      setting src pad caps.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      During the parsing process GstAudioDecoderClass will handle both
      srcpad and sinkpad events. Sink events will be passed to subclass
      if @event callback has been provided.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Shutdown phase&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioDecoder class calls @stop to inform the subclass that data
    parsing will be stopped.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;/orderedlist&gt;

Subclass is responsible for providing pad template caps for
source and sink pads. The pads need to be named "sink" and "src". It also
needs to set the fixed caps on srcpad, when the format is ensured.  This
is typically when base class calls subclass' @set_format function, though
it might be delayed until calling @gst_audio_decoder_finish_frame.

In summary, above process should have subclass concentrating on
codec data processing while leaving other matters to base class,
such as most notably timestamp handling.  While it may exert more control
in this area (see e.g. @pre_push), it is very much not recommended.

In particular, base class will try to arrange for perfect output timestamps
as much as possible while tracking upstream timestamps.
To this end, if deviation between the next ideal expected perfect timestamp
and upstream exceeds #GstAudioDecoder:tolerance, then resync to upstream
occurs (which would happen always if the tolerance mechanism is disabled).

In non-live pipelines, baseclass can also (configurably) arrange for
output buffer aggregation which may help to redue large(r) numbers of
small(er) buffers being pushed and processed downstream.

On the other hand, it should be noted that baseclass only provides limited
seeking support (upon explicit subclass request), as full-fledged support
should rather be left to upstream demuxer, parser or alike.  This simple
approach caters for seeking and duration reporting using estimated input
bitrates.

Things that subclass need to take care of:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;Provide pad templates&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set source pad caps when appropriate
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set user-configurable properties to sane defaults for format and
     implementing codec at hand, and convey some subclass capabilities and
     expectations in context.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Accept data in @handle_frame and provide encoded results to
     @gst_audio_decoder_finish_frame.  If it is prepared to perform
     PLC, it should also accept NULL data in @handle_frame and provide for
     data for indicated duration.
  &lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hard" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="parse">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="adapter" transfer-ownership="none">
            <type name="GstBase.Adapter" c:type="GstAdapter*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_push">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_format">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="finish_frame"
              c:identifier="gst_audio_decoder_finish_frame"
              version="0.10.36">
        <doc xml:whitespace="preserve">Collects decoded data and pushes it downstream.

@buf may be NULL in which case the indicated number of frames
are discarded and considered to have produced no output
(e.g. lead-in or setup frames).
Otherwise, source pad caps must be set when it is called with valid
data in @buf.

Note that a frame received in gst_audio_decoder_handle_frame() may be
invalidated by a call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn that should be escalated to caller (of caller)</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:whitespace="preserve">decoded data</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="frames" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of decoded frames represented by decoded data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_audio_info"
              c:identifier="gst_audio_decoder_get_audio_info"
              version="0.10.36"
              introspectable="0">
        <return-value>
          <doc xml:whitespace="preserve">a #GstAudioInfo describing the input audio format</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
      </method>
      <method name="get_byte_time"
              c:identifier="gst_audio_decoder_get_byte_time"
              version="0.10.36">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">currently configured byte to time conversion setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_delay"
              c:identifier="gst_audio_decoder_get_delay"
              version="0.10.36">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">currently configured decoder delay</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_drainable"
              c:identifier="gst_audio_decoder_get_drainable"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries decoder drain handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if drainable handling is enabled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_latency"
              c:identifier="gst_audio_decoder_get_latency"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets the variables pointed to by @min and @max to the currently configured
latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="min"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to storage to hold minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to storage to hold maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_errors"
              c:identifier="gst_audio_decoder_get_max_errors"
              version="0.10.36">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">currently configured decoder tolerated error count.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_min_latency"
              c:identifier="gst_audio_decoder_get_min_latency"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries decoder's latency aggregation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">aggregation latency.  MT safe.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_needs_format"
              c:identifier="gst_audio_decoder_get_needs_format"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries decoder required format handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if required format handling is enabled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_parse_state"
              c:identifier="gst_audio_decoder_get_parse_state"
              version="0.10.36">
        <doc xml:whitespace="preserve">Return current parsing (sync and eos) state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sync" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a variable to hold the current sync state</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="eos" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a variable to hold the current eos state</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_plc"
              c:identifier="gst_audio_decoder_get_plc"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries decoder packet loss concealment handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if packet loss concealment is enabled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_plc_aware"
              c:identifier="gst_audio_decoder_get_plc_aware"
              version="0.10.36">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">currently configured plc handling</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_tolerance"
              c:identifier="gst_audio_decoder_get_tolerance"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries current audio jitter tolerance threshold.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">decoder audio jitter tolerance threshold.  MT safe.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="merge_tags"
              c:identifier="gst_audio_decoder_merge_tags"
              version="0.10.37">
        <doc xml:whitespace="preserve">Adds tags to so-called pending tags, which will be processed
before pushing out data downstream.

Note that this is provided for convenience, and the subclass is
not required to use this and can still do tag handling on its own,
although it should be aware that baseclass already takes care
of the usual CODEC/AUDIO_CODEC tags.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstTagList to merge</doc>
            <type name="Gst.TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstTagMergeMode to use</doc>
            <type name="Gst.TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_byte_time"
              c:identifier="gst_audio_decoder_set_byte_time"
              version="0.10.36">
        <doc xml:whitespace="preserve">Allows baseclass to perform byte to time estimated conversion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to enable byte to time conversion</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drainable"
              c:identifier="gst_audio_decoder_set_drainable"
              version="0.10.36">
        <doc xml:whitespace="preserve">Configures decoder drain handling.  If drainable, subclass might
be handed a NULL buffer to have it return any leftover decoded data.
Otherwise, it is not considered so capable and will only ever be passed
real data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency"
              c:identifier="gst_audio_decoder_set_latency"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets decoder latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="min" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:whitespace="preserve">maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_errors"
              c:identifier="gst_audio_decoder_set_max_errors"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets numbers of tolerated decoder errors, where a tolerated one is then only
warned about, but more than tolerated will lead to fatal error.  Default
is set to GST_AUDIO_DECODER_MAX_ERRORS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num" transfer-ownership="none">
            <doc xml:whitespace="preserve">max tolerated errors</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_min_latency"
              c:identifier="gst_audio_decoder_set_min_latency"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets decoder minimum aggregation latency.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num" transfer-ownership="none">
            <doc xml:whitespace="preserve">new minimum latency</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_needs_format"
              c:identifier="gst_audio_decoder_set_needs_format"
              version="0.10.36">
        <doc xml:whitespace="preserve">Configures decoder format needs.  If enabled, subclass needs to be
negotiated with format caps before it can process any data.  It will then
never be handed any data before it has been configured.
Otherwise, it might be handed data without having been configured and
is then expected being able to do so either by default
or based on the input data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_plc"
              c:identifier="gst_audio_decoder_set_plc"
              version="0.10.36">
        <doc xml:whitespace="preserve">Enable or disable decoder packet loss concealment, provided subclass
and codec are capable and allow handling plc.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_plc_aware"
              c:identifier="gst_audio_decoder_set_plc_aware"
              version="0.10.36">
        <doc xml:whitespace="preserve">Indicates whether or not subclass handles packet loss concealment (plc).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="plc" transfer-ownership="none">
            <doc xml:whitespace="preserve">new plc state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tolerance"
              c:identifier="gst_audio_decoder_set_tolerance"
              version="0.10.36">
        <doc xml:whitespace="preserve">Configures decoder audio jitter tolerance threshold.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:whitespace="preserve">new tolerance</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <property name="min-latency" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="plc" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="tolerance" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="stream_lock" introspectable="0">
        <type c:type="GStaticRecMutex"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioDecoderPrivate" c:type="GstAudioDecoderPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioDecoderClass"
            c:type="GstAudioDecoderClass"
            glib:is-gtype-struct-for="AudioDecoder"
            version="0.10.36">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @handle_frame (and likely @set_format) needs to be
overridden.</doc>
      <field name="element_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_format">
        <callback name="set_format">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse">
        <callback name="parse">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="adapter" transfer-ownership="none">
              <type name="GstBase.Adapter" c:type="GstAdapter*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_frame">
        <callback name="handle_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="hard" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push">
        <callback name="pre_push">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="18">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioDecoderPrivate"
            c:type="GstAudioDecoderPrivate"
            disguised="1">
    </record>
    <class name="AudioEncoder"
           c:symbol-prefix="audio_encoder"
           c:type="GstAudioEncoder"
           version="0.10.36"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstAudioEncoder"
           glib:get-type="gst_audio_encoder_get_type"
           glib:type-struct="AudioEncoderClass">
      <doc xml:whitespace="preserve">This base class is for audio encoders turning raw audio samples into
encoded audio data.

GstAudioEncoder and subclass should cooperate as follows.
&lt;orderedlist&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Configuration&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    Initially, GstAudioEncoder calls @start when the encoder element
    is activated, which allows subclass to perform any global setup.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioEncoder calls @set_format to inform subclass of the format
    of input audio data that it is about to receive.  Subclass should
    setup for encoding and configure various base class parameters
    appropriately, notably those directing desired input data handling.
    While unlikely, it might be called more than once, if changing input
    parameters require reconfiguration.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioEncoder calls @stop at end of all processing.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
As of configuration stage, and throughout processing, GstAudioEncoder
maintains various parameters that provide required context,
e.g. describing the format of input audio data.
Conversely, subclass can and should configure these context parameters
to inform base class of its expectation w.r.t. buffer handling.
&lt;listitem&gt;
  &lt;itemizedlist&gt;
  &lt;title&gt;Data processing&lt;/title&gt;
    &lt;listitem&gt;&lt;para&gt;
      Base class gathers input sample data (as directed by the context's
      frame_samples and frame_max) and provides this to subclass' @handle_frame.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      If codec processing results in encoded data, subclass should call
      @gst_audio_encoder_finish_frame to have encoded data pushed
      downstream.  Alternatively, it might also call to indicate dropped
      (non-encoded) samples.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      Just prior to actually pushing a buffer downstream,
      it is passed to @pre_push.
    &lt;/para&gt;&lt;/listitem&gt;
    &lt;listitem&gt;&lt;para&gt;
      During the parsing process GstAudioEncoderClass will handle both
      srcpad and sinkpad events. Sink events will be passed to subclass
      if @event callback has been provided.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
  &lt;itemizedlist&gt;&lt;title&gt;Shutdown phase&lt;/title&gt;
  &lt;listitem&gt;&lt;para&gt;
    GstAudioEncoder class calls @stop to inform the subclass that data
    parsing will be stopped.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
&lt;/listitem&gt;
&lt;/orderedlist&gt;

Subclass is responsible for providing pad template caps for
source and sink pads. The pads need to be named "sink" and "src". It also 
needs to set the fixed caps on srcpad, when the format is ensured.  This
is typically when base class calls subclass' @set_format function, though
it might be delayed until calling @gst_audio_encoder_finish_frame.

In summary, above process should have subclass concentrating on
codec data processing while leaving other matters to base class,
such as most notably timestamp handling.  While it may exert more control
in this area (see e.g. @pre_push), it is very much not recommended.

In particular, base class will either favor tracking upstream timestamps
(at the possible expense of jitter) or aim to arrange for a perfect stream of
output timestamps, depending on #GstAudioEncoder:perfect-timestamp.
However, in the latter case, the input may not be so perfect or ideal, which
is handled as follows.  An input timestamp is compared with the expected
timestamp as dictated by input sample stream and if the deviation is less
than #GstAudioEncoder:tolerance, the deviation is discarded.
Otherwise, it is considered a discontuinity and subsequent output timestamp
is resynced to the new position after performing configured discontinuity
processing.  In the non-perfect-timestamp case, an upstream variation
exceeding tolerance only leads to marking DISCONT on subsequent outgoing
(while timestamps are adjusted to upstream regardless of variation).
While DISCONT is also marked in the perfect-timestamp case, this one
optionally (see #GstAudioEncoder:hard-resync)
performs some additional steps, such as clipping of (early) input samples
or draining all currently remaining input data, depending on the direction
of the discontuinity.

If perfect timestamps are arranged, it is also possible to request baseclass
(usually set by subclass) to provide additional buffer metadata (in OFFSET
and OFFSET_END) fields according to granule defined semantics currently
needed by oggmux.  Specifically, OFFSET is set to granulepos (= sample count
including buffer) and OFFSET_END to corresponding timestamp (as determined
by same sample count and sample rate).

Things that subclass need to take care of:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;Provide pad templates&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set source pad caps when appropriate
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Inform base class of buffer processing needs using context's
     frame_samples and frame_bytes.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Set user-configurable properties to sane defaults for format and
     implementing codec at hand, e.g. those controlling timestamp behaviour
     and discontinuity processing.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
     Accept data in @handle_frame and provide encoded results to
     @gst_audio_encoder_finish_frame.
  &lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
      <implements name="Gst.Preset"/>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="getcaps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="handle_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="pre_push">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_format">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="finish_frame"
              c:identifier="gst_audio_encoder_finish_frame"
              version="0.10.36">
        <doc xml:whitespace="preserve">Collects encoded data and pushes encoded data downstream.
Source pad caps must be set when this is called.

If @samples &lt; 0, then best estimate is all samples provided to encoder
(subclass) so far.  @buf may be NULL, in which case next number of @samples
are considered discarded, e.g. as a result of discontinuous transmission,
and a discontinuity is marked.

Note that samples received in gst_audio_encoder_handle_frame()
may be invalidated by a call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn that should be escalated to caller (of caller)</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">encoded data</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="samples" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of samples (per channel) represented by encoded data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_audio_info"
              c:identifier="gst_audio_encoder_get_audio_info"
              version="0.10.36"
              introspectable="0">
        <return-value>
          <doc xml:whitespace="preserve">a #GstAudioInfo describing the input audio format</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
      </method>
      <method name="get_drainable"
              c:identifier="gst_audio_encoder_get_drainable"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries encoder drain handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if drainable handling is enabled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_frame_max"
              c:identifier="gst_audio_encoder_get_frame_max"
              version="0.10.36">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">currently configured maximum handled frames</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_frame_samples_max"
              c:identifier="gst_audio_encoder_get_frame_samples_max">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_frame_samples_min"
              c:identifier="gst_audio_encoder_get_frame_samples_min"
              version="0.10.36">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">currently maximum requested samples per frame</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_hard_min"
              c:identifier="gst_audio_encoder_get_hard_min"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries encoder hard minimum handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if hard minimum handling is enabled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_hard_resync"
              c:identifier="gst_audio_encoder_get_hard_resync">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_latency"
              c:identifier="gst_audio_encoder_get_latency"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets the variables pointed to by @min and @max to the currently configured
latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="min"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to storage to hold minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to storage to hold maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_lookahead"
              c:identifier="gst_audio_encoder_get_lookahead">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">currently configured encoder lookahead</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_mark_granule"
              c:identifier="gst_audio_encoder_get_mark_granule"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries if the encoder will handle granule marking.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if granule marking is enabled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_perfect_timestamp"
              c:identifier="gst_audio_encoder_get_perfect_timestamp"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries encoder perfect timestamp behaviour.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if perfect timestamp setting enabled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_tolerance"
              c:identifier="gst_audio_encoder_get_tolerance"
              version="0.10.36">
        <doc xml:whitespace="preserve">Queries current audio jitter tolerance threshold.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">encoder audio jitter tolerance threshold.  MT safe.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="merge_tags"
              c:identifier="gst_audio_encoder_merge_tags"
              version="0.10.36">
        <doc xml:whitespace="preserve">Adds tags to so-called pending tags, which will be processed
before pushing out data downstream.

Note that this is provided for convenience, and the subclass is
not required to use this and can still do tag handling on its own,
although it should be aware that baseclass already takes care
of the usual CODEC/AUDIO_CODEC tags.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tags" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstTagList to merge</doc>
            <type name="Gst.TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstTagMergeMode to use</doc>
            <type name="Gst.TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="proxy_getcaps"
              c:identifier="gst_audio_encoder_proxy_getcaps"
              version="0.10.36">
        <doc xml:whitespace="preserve">Returns caps that express @caps (or sink template caps if @caps == NULL)
restricted to channel/rate combinations supported by downstream elements
(e.g. muxers).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstCaps owned by caller</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">initial caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drainable"
              c:identifier="gst_audio_encoder_set_drainable"
              version="0.10.36">
        <doc xml:whitespace="preserve">Configures encoder drain handling.  If drainable, subclass might
be handed a NULL buffer to have it return any leftover encoded data.
Otherwise, it is not considered so capable and will only ever be passed
real data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_max"
              c:identifier="gst_audio_encoder_set_frame_max"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets max number of frames accepted at once (assumed minimally 1).
Requires @frame_samples_min and @frame_samples_max to be the equal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of frames</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_samples_max"
              c:identifier="gst_audio_encoder_set_frame_samples_max"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets number of samples (per channel) subclass needs to be handed,
at most or will be handed all available if 0.

If an exact number of samples is required, gst_audio_encoder_set_frame_samples_min()
must be called with the same number.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of samples per frame</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_samples_min"
              c:identifier="gst_audio_encoder_set_frame_samples_min"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets number of samples (per channel) subclass needs to be handed,
at least or will be handed all available if 0.

If an exact number of samples is required, gst_audio_encoder_set_frame_samples_max()
must be called with the same number.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of samples per frame</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hard_min"
              c:identifier="gst_audio_encoder_set_hard_min"
              version="0.10.36">
        <doc xml:whitespace="preserve">Configures encoder hard minimum handling.  If enabled, subclass
will never be handed less samples than it configured, which otherwise
might occur near end-of-data handling.  Instead, the leftover samples
will simply be discarded.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hard_resync"
              c:identifier="gst_audio_encoder_set_hard_resync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency"
              c:identifier="gst_audio_encoder_set_latency"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets encoder latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="min" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:whitespace="preserve">maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_lookahead"
              c:identifier="gst_audio_encoder_set_lookahead"
              version="0.10.36">
        <doc xml:whitespace="preserve">Sets encoder lookahead (in units of input rate samples)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="num" transfer-ownership="none">
            <doc xml:whitespace="preserve">lookahead</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mark_granule"
              c:identifier="gst_audio_encoder_set_mark_granule"
              version="0.10.36">
        <doc xml:whitespace="preserve">Enable or disable encoder granule handling.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_perfect_timestamp"
              c:identifier="gst_audio_encoder_set_perfect_timestamp"
              version="0.10.36">
        <doc xml:whitespace="preserve">Enable or disable encoder perfect output timestamp preference.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tolerance"
              c:identifier="gst_audio_encoder_set_tolerance"
              version="0.10.36">
        <doc xml:whitespace="preserve">Configures encoder audio jitter tolerance threshold.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:whitespace="preserve">new tolerance</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <property name="hard-resync" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="mark-granule" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="perfect-timestamp"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="tolerance" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="stream_lock" introspectable="0">
        <type c:type="GStaticRecMutex"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioEncoderPrivate" c:type="GstAudioEncoderPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioEncoderClass"
            c:type="GstAudioEncoderClass"
            glib:is-gtype-struct-for="AudioEncoder"
            version="0.10.36">
      <doc xml:whitespace="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @set_format and @handle_frame needs to be overridden.</doc>
      <field name="element_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_format">
        <callback name="set_format">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AudioInfo" c:type="GstAudioInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_frame">
        <callback name="handle_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push">
        <callback name="pre_push">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="getcaps">
        <callback name="getcaps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="18">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioEncoderPrivate"
            c:type="GstAudioEncoderPrivate"
            disguised="1">
    </record>
    <bitfield name="AudioFieldFlag"
              deprecated="use gst_structure_set() directly"
              c:type="GstAudioFieldFlag">
      <doc xml:whitespace="preserve">Do not use anymore.</doc>
      <member name="rate" value="1" c:identifier="GST_AUDIO_FIELD_RATE"/>
      <member name="channels"
              value="2"
              c:identifier="GST_AUDIO_FIELD_CHANNELS"/>
      <member name="endianness"
              value="4"
              c:identifier="GST_AUDIO_FIELD_ENDIANNESS"/>
      <member name="width" value="8" c:identifier="GST_AUDIO_FIELD_WIDTH"/>
      <member name="depth" value="16" c:identifier="GST_AUDIO_FIELD_DEPTH"/>
      <member name="signed" value="32" c:identifier="GST_AUDIO_FIELD_SIGNED"/>
    </bitfield>
    <class name="AudioFilter"
           c:symbol-prefix="audio_filter"
           c:type="GstAudioFilter"
           version="0.10.12"
           parent="GstBase.BaseTransform"
           abstract="1"
           glib:type-name="GstAudioFilter"
           glib:get-type="gst_audio_filter_get_type"
           glib:type-struct="AudioFilterClass">
      <doc xml:whitespace="preserve">#GstAudioFilter is a #GstBaseTransform&lt;!-- --&gt;-derived base class for simple audio
filters, ie. those that output the same format that they get as input.

#GstAudioFilter will parse the input format for you (with error checking)
before calling your setup function. Also, elements deriving from
#GstAudioFilter may use gst_audio_filter_class_add_pad_templates() from
their base_init function to easily configure the set of caps/formats that
the element is able to handle.

Derived classes should override the #GstAudioFilterClass.setup() and
#GstBaseTransformClass.transform_ip() and/or
#GstBaseTransformClass.transform()
virtual functions in their class_init function.

Last reviewed on 2007-02-03 (0.10.11.1)</doc>
      <virtual-method name="setup">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="basetransform">
        <type name="GstBase.BaseTransform" c:type="GstBaseTransform"/>
      </field>
      <field name="format">
        <type name="RingBufferSpec" c:type="GstRingBufferSpec"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioFilterClass"
            c:type="GstAudioFilterClass"
            glib:is-gtype-struct-for="AudioFilter"
            version="0.10.12">
      <doc xml:whitespace="preserve">In addition to the @setup virtual function, you should also override the
GstBaseTransform::transform and/or GstBaseTransform::transform_ip virtual
function.</doc>
      <field name="basetransformclass">
        <type name="GstBase.BaseTransformClass"
              c:type="GstBaseTransformClass"/>
      </field>
      <field name="setup">
        <callback name="setup">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="AudioFilter" c:type="GstAudioFilter*"/>
            </parameter>
            <parameter name="format" transfer-ownership="none">
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="add_pad_templates"
              c:identifier="gst_audio_filter_class_add_pad_templates"
              version="0.10.12">
        <doc xml:whitespace="preserve">Convenience function to add pad templates to this element class, with
@allowed_caps as the caps that can be handled.

This function is usually used from within a GObject base_init function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allowed_caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">what formats the filter can handle, as #GstCaps</doc>
            <type name="Gst.Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="AudioFlags" version="0.10.36" c:type="GstAudioFlags">
      <doc xml:whitespace="preserve">Extra audio flags</doc>
      <member name="none" value="0" c:identifier="GST_AUDIO_FLAG_NONE"/>
      <member name="default_positions"
              value="1"
              c:identifier="GST_AUDIO_FLAG_DEFAULT_POSITIONS"/>
    </bitfield>
    <enumeration name="AudioFormat" version="0.10.36" c:type="GstAudioFormat">
      <doc xml:whitespace="preserve">Enum value describing the most common audio formats.</doc>
      <member name="unknown"
              value="0"
              c:identifier="GST_AUDIO_FORMAT_UNKNOWN"/>
      <member name="s8" value="1" c:identifier="GST_AUDIO_FORMAT_S8"/>
      <member name="u8" value="2" c:identifier="GST_AUDIO_FORMAT_U8"/>
      <member name="s16le" value="3" c:identifier="GST_AUDIO_FORMAT_S16LE"/>
      <member name="s16be" value="4" c:identifier="GST_AUDIO_FORMAT_S16BE"/>
      <member name="u16le" value="5" c:identifier="GST_AUDIO_FORMAT_U16LE"/>
      <member name="u16be" value="6" c:identifier="GST_AUDIO_FORMAT_U16BE"/>
      <member name="s24_32le"
              value="7"
              c:identifier="GST_AUDIO_FORMAT_S24_32LE"/>
      <member name="s24_32be"
              value="8"
              c:identifier="GST_AUDIO_FORMAT_S24_32BE"/>
      <member name="u24_32le"
              value="9"
              c:identifier="GST_AUDIO_FORMAT_U24_32LE"/>
      <member name="u24_32be"
              value="10"
              c:identifier="GST_AUDIO_FORMAT_U24_32BE"/>
      <member name="s32le" value="11" c:identifier="GST_AUDIO_FORMAT_S32LE"/>
      <member name="s32be" value="12" c:identifier="GST_AUDIO_FORMAT_S32BE"/>
      <member name="u32le" value="13" c:identifier="GST_AUDIO_FORMAT_U32LE"/>
      <member name="u32be" value="14" c:identifier="GST_AUDIO_FORMAT_U32BE"/>
      <member name="s24le" value="15" c:identifier="GST_AUDIO_FORMAT_S24LE"/>
      <member name="s24be" value="16" c:identifier="GST_AUDIO_FORMAT_S24BE"/>
      <member name="u24le" value="17" c:identifier="GST_AUDIO_FORMAT_U24LE"/>
      <member name="u24be" value="18" c:identifier="GST_AUDIO_FORMAT_U24BE"/>
      <member name="s20le" value="19" c:identifier="GST_AUDIO_FORMAT_S20LE"/>
      <member name="s20be" value="20" c:identifier="GST_AUDIO_FORMAT_S20BE"/>
      <member name="u20le" value="21" c:identifier="GST_AUDIO_FORMAT_U20LE"/>
      <member name="u20be" value="22" c:identifier="GST_AUDIO_FORMAT_U20BE"/>
      <member name="s18le" value="23" c:identifier="GST_AUDIO_FORMAT_S18LE"/>
      <member name="s18be" value="24" c:identifier="GST_AUDIO_FORMAT_S18BE"/>
      <member name="u18le" value="25" c:identifier="GST_AUDIO_FORMAT_U18LE"/>
      <member name="u18be" value="26" c:identifier="GST_AUDIO_FORMAT_U18BE"/>
      <member name="f32le" value="27" c:identifier="GST_AUDIO_FORMAT_F32LE"/>
      <member name="f32be" value="28" c:identifier="GST_AUDIO_FORMAT_F32BE"/>
      <member name="f64le" value="29" c:identifier="GST_AUDIO_FORMAT_F64LE"/>
      <member name="f64be" value="30" c:identifier="GST_AUDIO_FORMAT_F64BE"/>
      <member name="s16" value="3" c:identifier="GST_AUDIO_FORMAT_S16"/>
      <member name="u16" value="5" c:identifier="GST_AUDIO_FORMAT_U16"/>
      <member name="s24_32" value="7" c:identifier="GST_AUDIO_FORMAT_S24_32"/>
      <member name="u24_32" value="9" c:identifier="GST_AUDIO_FORMAT_U24_32"/>
      <member name="s32" value="11" c:identifier="GST_AUDIO_FORMAT_S32"/>
      <member name="u32" value="13" c:identifier="GST_AUDIO_FORMAT_U32"/>
      <member name="s24" value="15" c:identifier="GST_AUDIO_FORMAT_S24"/>
      <member name="u24" value="17" c:identifier="GST_AUDIO_FORMAT_U24"/>
      <member name="s20" value="19" c:identifier="GST_AUDIO_FORMAT_S20"/>
      <member name="u20" value="21" c:identifier="GST_AUDIO_FORMAT_U20"/>
      <member name="s18" value="23" c:identifier="GST_AUDIO_FORMAT_S18"/>
      <member name="u18" value="25" c:identifier="GST_AUDIO_FORMAT_U18"/>
      <member name="f32" value="27" c:identifier="GST_AUDIO_FORMAT_F32"/>
      <member name="f64" value="29" c:identifier="GST_AUDIO_FORMAT_F64"/>
    </enumeration>
    <bitfield name="AudioFormatFlags"
              version="0.10.36"
              c:type="GstAudioFormatFlags">
      <doc xml:whitespace="preserve">The different audio flags that a format info can have.</doc>
      <member name="integer"
              value="1"
              c:identifier="GST_AUDIO_FORMAT_FLAG_INTEGER"/>
      <member name="float"
              value="2"
              c:identifier="GST_AUDIO_FORMAT_FLAG_FLOAT"/>
      <member name="signed"
              value="4"
              c:identifier="GST_AUDIO_FORMAT_FLAG_SIGNED"/>
      <member name="complex"
              value="16"
              c:identifier="GST_AUDIO_FORMAT_FLAG_COMPLEX"/>
    </bitfield>
    <record name="AudioFormatInfo"
            c:type="GstAudioFormatInfo"
            version="0.10.36">
      <doc xml:whitespace="preserve">Information for an audio format.</doc>
      <field name="format" writable="1">
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags" writable="1">
        <type name="AudioFormatFlags" c:type="GstAudioFormatFlags"/>
      </field>
      <field name="endianness" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="width" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="depth" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="silence" writable="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="8">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="padding_i" readable="0" private="1">
        <array zero-terminated="0" c:type="guint" fixed-size="4">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="padding_p" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioInfo" c:type="GstAudioInfo" version="0.10.36">
      <doc xml:whitespace="preserve">Information describing audio properties. This information can be filled
in from GstCaps with gst_audio_info_from_caps().

Use the provided macros to access the info in this structure.</doc>
      <field name="finfo" writable="1">
        <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
      </field>
      <field name="flags" writable="1">
        <type name="AudioFlags" c:type="GstAudioFlags"/>
      </field>
      <field name="rate" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="channels" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="bpf" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="position" writable="1">
        <array zero-terminated="0"
               c:type="GstAudioChannelPosition"
               fixed-size="64">
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition"/>
        </array>
      </field>
      <method name="clear" c:identifier="gst_audio_info_clear">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="convert" c:identifier="gst_audio_info_convert">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_fmt" transfer-ownership="none">
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_fmt" transfer-ownership="none">
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val" transfer-ownership="none">
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="gst_audio_info_copy"
              introspectable="0">
        <return-value>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="gst_audio_info_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="from_caps"
              c:identifier="gst_audio_info_from_caps"
              version="0.10.36">
        <doc xml:whitespace="preserve">Parse @caps and update @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps could be parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_audio_info_init">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="to_caps"
              c:identifier="gst_audio_info_to_caps"
              version="0.10.36">
        <doc xml:whitespace="preserve">Convert the values of @info into a #GstCaps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps containing the info of @info.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
    </record>
    <callback name="AudioMixerFilterFunc" c:type="GstAudioMixerFilterFunc">
      <doc xml:whitespace="preserve">Function that will be called by gst_audio_default_registry_mixer_filter()
so the caller can decide which mixer elements should be kept and returned.
When the mixer element is passed to the callback function, it is opened
and in READY state. If you decide to keep the element, you need to set it
back to NULL state yourself (unless you want to keep it opened of course).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the element should be kept, FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mixer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstElement implementing the #GstMixer interface</doc>
          <type name="GstInterfaces.Mixer" c:type="GstMixer*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="AudioSink"
           c:symbol-prefix="audio_sink"
           c:type="GstAudioSink"
           parent="BaseAudioSink"
           glib:type-name="GstAudioSink"
           glib:get-type="gst_audio_sink_get_type"
           glib:type-struct="AudioSinkClass">
      <doc xml:whitespace="preserve">This is the most simple base class for audio sinks that only requires
subclasses to implement a set of simple functions:

&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;open()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Open the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;prepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Configure the device with the specified format.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;write()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Write samples to the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;reset()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Unblock writes and flush the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;delay()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Get the number of samples written but not yet played 
    by the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;unprepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Undo operations done by prepare.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;close()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Close the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

All scheduling of samples and timestamps is done in this base class
together with #GstBaseAudioSink using a default implementation of a
#GstRingBuffer that uses threads.

Last reviewed on 2006-09-27 (0.10.12)</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="write">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="element">
        <type name="BaseAudioSink" c:type="GstBaseAudioSink"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSinkClass"
            c:type="GstAudioSinkClass"
            glib:is-gtype-struct-for="AudioSink">
      <doc xml:whitespace="preserve">#GstAudioSink class. Override the vmethods to implement functionality.</doc>
      <field name="parent_class">
        <type name="BaseAudioSinkClass" c:type="GstBaseAudioSinkClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AudioSrc"
           c:symbol-prefix="audio_src"
           c:type="GstAudioSrc"
           parent="BaseAudioSrc"
           glib:type-name="GstAudioSrc"
           glib:get-type="gst_audio_src_get_type"
           glib:type-struct="AudioSrcClass">
      <doc xml:whitespace="preserve">This is the most simple base class for audio sources that only requires
subclasses to implement a set of simple functions:

&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;open()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Open the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;prepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Configure the device with the specified format.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;read()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Read samples from the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;reset()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Unblock reads and flush the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;delay()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Get the number of samples in the device but not yet read.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;unprepare()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Undo operations done by prepare.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;close()&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;Close the device.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

All scheduling of samples and timestamps is done in this base class
together with #GstBaseAudioSrc using a default implementation of a
#GstRingBuffer that uses threads.

Last reviewed on 2006-09-27 (0.10.12)</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <field name="element">
        <type name="BaseAudioSrc" c:type="GstBaseAudioSrc"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSrcClass"
            c:type="GstAudioSrcClass"
            glib:is-gtype-struct-for="AudioSrc">
      <doc xml:whitespace="preserve">#GstAudioSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <type name="BaseAudioSrcClass" c:type="GstBaseAudioSrcClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="BaseAudioSink"
           c:symbol-prefix="base_audio_sink"
           c:type="GstBaseAudioSink"
           parent="GstBase.BaseSink"
           glib:type-name="GstBaseAudioSink"
           glib:get-type="gst_base_audio_sink_get_type"
           glib:type-struct="BaseAudioSinkClass">
      <doc xml:whitespace="preserve">This is the base class for audio sinks. Subclasses need to implement the
::create_ringbuffer vmethod. This base class will then take care of
writing samples to the ringbuffer, synchronisation, clipping and flushing.

Last reviewed on 2006-09-27 (0.10.12)</doc>
      <virtual-method name="create_ringbuffer"
                      invoker="create_ringbuffer"
                      introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @sink. This function will call the
::create_ringbuffer vmethod and will set @sink as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @sink.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="payload" introspectable="0">
        <return-value>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_base_audio_sink_create_ringbuffer"
              introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @sink. This function will call the
::create_ringbuffer vmethod and will set @sink as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @sink.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </method>
      <method name="get_alignment_threshold"
              c:identifier="gst_base_audio_sink_get_alignment_threshold"
              version="0.10.36">
        <doc xml:whitespace="preserve">Get the current alignment threshold, in nanoseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current alignment threshold used by @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_discont_wait"
              c:identifier="gst_base_audio_sink_get_discont_wait"
              version="0.10.36">
        <doc xml:whitespace="preserve">Get the current discont wait, in nanoseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current discont wait used by @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_drift_tolerance"
              c:identifier="gst_base_audio_sink_get_drift_tolerance"
              version="0.10.31">
        <doc xml:whitespace="preserve">Get the current drift tolerance, in microseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current drift tolerance used by @sink.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_base_audio_sink_get_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Queries whether @sink will provide a clock or not. See also
gst_base_audio_sink_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @sink will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_base_audio_sink_get_slave_method"
              version="0.10.16">
        <doc xml:whitespace="preserve">Get the current slave method used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current slave method used by @sink.</doc>
          <type name="BaseAudioSinkSlaveMethod"
                c:type="GstBaseAudioSinkSlaveMethod"/>
        </return-value>
      </method>
      <method name="set_alignment_threshold"
              c:identifier="gst_base_audio_sink_set_alignment_threshold"
              version="0.10.36">
        <doc xml:whitespace="preserve">Controls the sink's alignment threshold.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="alignment_threshold" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new alignment threshold in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_discont_wait"
              c:identifier="gst_base_audio_sink_set_discont_wait"
              version="0.10.36">
        <doc xml:whitespace="preserve">Controls how long the sink will wait before creating a discontinuity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="discont_wait" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new discont wait in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drift_tolerance"
              c:identifier="gst_base_audio_sink_set_drift_tolerance"
              version="0.10.31">
        <doc xml:whitespace="preserve">Controls the sink's drift tolerance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="drift_tolerance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new drift tolerance in microseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_base_audio_sink_set_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Controls whether @sink will provide a clock or not. If @provide is %TRUE,
gst_element_provide_clock() will return a clock that reflects the datarate
of @sink. If @provide is %FALSE, gst_element_provide_clock() will return NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_base_audio_sink_set_slave_method"
              version="0.10.16">
        <doc xml:whitespace="preserve">Controls how clock slaving will be performed in @sink.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new slave method</doc>
            <type name="BaseAudioSinkSlaveMethod"
                  c:type="GstBaseAudioSinkSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="alignment-threshold"
                writable="1"
                transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="can-activate-pull"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="discont-wait"
                version="0.10.36"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A window of time in nanoseconds to wait before creating a discontinuity as
a result of breaching the drift-tolerance.</doc>
        <type name="guint64"/>
      </property>
      <property name="drift-tolerance"
                version="0.10.26"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Controls the amount of time in microseconds that clocks are allowed
to drift before resynchronisation happens.</doc>
        <type name="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="BaseAudioSinkSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.BaseSink" c:type="GstBaseSink"/>
      </field>
      <field name="ringbuffer">
        <type name="RingBuffer" c:type="GstRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="latency_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="provide_clock">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="provided_clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseAudioSinkPrivate" c:type="GstBaseAudioSinkPrivate*"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="eos_rendering" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="3">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <record name="BaseAudioSinkClass"
            c:type="GstBaseAudioSinkClass"
            glib:is-gtype-struct-for="BaseAudioSink">
      <doc xml:whitespace="preserve">#GstBaseAudioSink class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <type name="GstBase.BaseSinkClass" c:type="GstBaseSinkClass"/>
      </field>
      <field name="create_ringbuffer" introspectable="0">
        <callback name="create_ringbuffer" introspectable="0">
          <return-value>
            <doc xml:whitespace="preserve">The new ringbuffer of @sink.</doc>
            <type name="RingBuffer" c:type="GstRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseAudioSink" c:type="GstBaseAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="payload" introspectable="0">
        <callback name="payload" introspectable="0">
          <return-value>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseAudioSink" c:type="GstBaseAudioSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseAudioSinkPrivate"
            c:type="GstBaseAudioSinkPrivate"
            disguised="1">
    </record>
    <enumeration name="BaseAudioSinkSlaveMethod"
                 glib:type-name="GstBaseAudioSinkSlaveMethod"
                 glib:get-type="gst_base_audio_sink_slave_method_get_type"
                 c:type="GstBaseAudioSinkSlaveMethod">
      <doc xml:whitespace="preserve">Different possible clock slaving algorithms used when the internal audio
clock is not selected as the pipeline master clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_BASE_AUDIO_SINK_SLAVE_RESAMPLE"
              glib:nick="resample"/>
      <member name="skew"
              value="1"
              c:identifier="GST_BASE_AUDIO_SINK_SLAVE_SKEW"
              glib:nick="skew"/>
      <member name="none"
              value="2"
              c:identifier="GST_BASE_AUDIO_SINK_SLAVE_NONE"
              glib:nick="none"/>
    </enumeration>
    <class name="BaseAudioSrc"
           c:symbol-prefix="base_audio_src"
           c:type="GstBaseAudioSrc"
           parent="GstBase.PushSrc"
           glib:type-name="GstBaseAudioSrc"
           glib:get-type="gst_base_audio_src_get_type"
           glib:type-struct="BaseAudioSrcClass">
      <doc xml:whitespace="preserve">This is the base class for audio sources. Subclasses need to implement the
::create_ringbuffer vmethod. This base class will then take care of
reading samples from the ringbuffer, synchronisation and flushing.

Last reviewed on 2006-09-27 (0.10.12)</doc>
      <virtual-method name="create_ringbuffer"
                      invoker="create_ringbuffer"
                      introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @src. This function will call the
::create_ringbuffer vmethod and will set @src as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @src.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_base_audio_src_create_ringbuffer"
              introspectable="0">
        <doc xml:whitespace="preserve">Create and return the #GstRingBuffer for @src. This function will call the
::create_ringbuffer vmethod and will set @src as the parent of the returned
buffer (see gst_object_set_parent()).</doc>
        <return-value>
          <doc xml:whitespace="preserve">The new ringbuffer of @src.</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </return-value>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_base_audio_src_get_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Queries whether @src will provide a clock or not. See also
gst_base_audio_src_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @src will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_base_audio_src_get_slave_method"
              version="0.10.20">
        <doc xml:whitespace="preserve">Get the current slave method used by @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The current slave method used by @src.</doc>
          <type name="BaseAudioSrcSlaveMethod"
                c:type="GstBaseAudioSrcSlaveMethod"/>
        </return-value>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_base_audio_src_set_provide_clock"
              version="0.10.16">
        <doc xml:whitespace="preserve">Controls whether @src will provide a clock or not. If @provide is %TRUE, 
gst_element_provide_clock() will return a clock that reflects the datarate
of @src. If @provide is %FALSE, gst_element_provide_clock() will return NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:whitespace="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_base_audio_src_set_slave_method"
              version="0.10.20">
        <doc xml:whitespace="preserve">Controls how clock slaving will be performed in @src.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new slave method</doc>
            <type name="BaseAudioSrcSlaveMethod"
                  c:type="GstBaseAudioSrcSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="actual-buffer-time"
                version="0.10.20"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Actual configured size of audio buffer in microseconds.</doc>
        <type name="gint64"/>
      </property>
      <property name="actual-latency-time"
                version="0.10.20"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Actual configured audio latency in microseconds.</doc>
        <type name="gint64"/>
      </property>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="BaseAudioSrcSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.PushSrc" c:type="GstPushSrc"/>
      </field>
      <field name="ringbuffer">
        <type name="RingBuffer" c:type="GstRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="latency_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseAudioSrcPrivate" c:type="GstBaseAudioSrcPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseAudioSrcClass"
            c:type="GstBaseAudioSrcClass"
            glib:is-gtype-struct-for="BaseAudioSrc">
      <doc xml:whitespace="preserve">#GstBaseAudioSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <type name="GstBase.PushSrcClass" c:type="GstPushSrcClass"/>
      </field>
      <field name="create_ringbuffer" introspectable="0">
        <callback name="create_ringbuffer" introspectable="0">
          <return-value>
            <doc xml:whitespace="preserve">The new ringbuffer of @src.</doc>
            <type name="RingBuffer" c:type="GstRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseAudioSrc" c:type="GstBaseAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseAudioSrcPrivate"
            c:type="GstBaseAudioSrcPrivate"
            disguised="1">
    </record>
    <enumeration name="BaseAudioSrcSlaveMethod"
                 glib:type-name="GstBaseAudioSrcSlaveMethod"
                 glib:get-type="gst_base_audio_src_slave_method_get_type"
                 c:type="GstBaseAudioSrcSlaveMethod">
      <doc xml:whitespace="preserve">Different possible clock slaving algorithms when the internal audio clock was
not selected as the pipeline clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_RESAMPLE"
              glib:nick="resample"/>
      <member name="re_timestamp"
              value="1"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_RETIMESTAMP"
              glib:nick="re-timestamp"/>
      <member name="skew"
              value="2"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_SKEW"
              glib:nick="skew"/>
      <member name="none"
              value="3"
              c:identifier="GST_BASE_AUDIO_SRC_SLAVE_NONE"
              glib:nick="none"/>
    </enumeration>
    <enumeration name="BufferFormat"
                 glib:type-name="GstBufferFormat"
                 glib:get-type="gst_buffer_format_get_type"
                 c:type="GstBufferFormat">
      <doc xml:whitespace="preserve">The detailed format of the samples in the ringbuffer.</doc>
      <member name="unknown"
              value="0"
              c:identifier="GST_UNKNOWN"
              glib:nick="unknown"/>
      <member name="s8" value="1" c:identifier="GST_S8" glib:nick="s8"/>
      <member name="u8" value="2" c:identifier="GST_U8" glib:nick="u8"/>
      <member name="s16_le"
              value="3"
              c:identifier="GST_S16_LE"
              glib:nick="s16-le"/>
      <member name="s16_be"
              value="4"
              c:identifier="GST_S16_BE"
              glib:nick="s16-be"/>
      <member name="u16_le"
              value="5"
              c:identifier="GST_U16_LE"
              glib:nick="u16-le"/>
      <member name="u16_be"
              value="6"
              c:identifier="GST_U16_BE"
              glib:nick="u16-be"/>
      <member name="s24_le"
              value="7"
              c:identifier="GST_S24_LE"
              glib:nick="s24-le"/>
      <member name="s24_be"
              value="8"
              c:identifier="GST_S24_BE"
              glib:nick="s24-be"/>
      <member name="u24_le"
              value="9"
              c:identifier="GST_U24_LE"
              glib:nick="u24-le"/>
      <member name="u24_be"
              value="10"
              c:identifier="GST_U24_BE"
              glib:nick="u24-be"/>
      <member name="s32_le"
              value="11"
              c:identifier="GST_S32_LE"
              glib:nick="s32-le"/>
      <member name="s32_be"
              value="12"
              c:identifier="GST_S32_BE"
              glib:nick="s32-be"/>
      <member name="u32_le"
              value="13"
              c:identifier="GST_U32_LE"
              glib:nick="u32-le"/>
      <member name="u32_be"
              value="14"
              c:identifier="GST_U32_BE"
              glib:nick="u32-be"/>
      <member name="s24_3le"
              value="15"
              c:identifier="GST_S24_3LE"
              glib:nick="s24-3le"/>
      <member name="s24_3be"
              value="16"
              c:identifier="GST_S24_3BE"
              glib:nick="s24-3be"/>
      <member name="u24_3le"
              value="17"
              c:identifier="GST_U24_3LE"
              glib:nick="u24-3le"/>
      <member name="u24_3be"
              value="18"
              c:identifier="GST_U24_3BE"
              glib:nick="u24-3be"/>
      <member name="s20_3le"
              value="19"
              c:identifier="GST_S20_3LE"
              glib:nick="s20-3le"/>
      <member name="s20_3be"
              value="20"
              c:identifier="GST_S20_3BE"
              glib:nick="s20-3be"/>
      <member name="u20_3le"
              value="21"
              c:identifier="GST_U20_3LE"
              glib:nick="u20-3le"/>
      <member name="u20_3be"
              value="22"
              c:identifier="GST_U20_3BE"
              glib:nick="u20-3be"/>
      <member name="s18_3le"
              value="23"
              c:identifier="GST_S18_3LE"
              glib:nick="s18-3le"/>
      <member name="s18_3be"
              value="24"
              c:identifier="GST_S18_3BE"
              glib:nick="s18-3be"/>
      <member name="u18_3le"
              value="25"
              c:identifier="GST_U18_3LE"
              glib:nick="u18-3le"/>
      <member name="u18_3be"
              value="26"
              c:identifier="GST_U18_3BE"
              glib:nick="u18-3be"/>
      <member name="float32_le"
              value="27"
              c:identifier="GST_FLOAT32_LE"
              glib:nick="float32-le"/>
      <member name="float32_be"
              value="28"
              c:identifier="GST_FLOAT32_BE"
              glib:nick="float32-be"/>
      <member name="float64_le"
              value="29"
              c:identifier="GST_FLOAT64_LE"
              glib:nick="float64-le"/>
      <member name="float64_be"
              value="30"
              c:identifier="GST_FLOAT64_BE"
              glib:nick="float64-be"/>
      <member name="mu_law"
              value="31"
              c:identifier="GST_MU_LAW"
              glib:nick="mu-law"/>
      <member name="a_law"
              value="32"
              c:identifier="GST_A_LAW"
              glib:nick="a-law"/>
      <member name="ima_adpcm"
              value="33"
              c:identifier="GST_IMA_ADPCM"
              glib:nick="ima-adpcm"/>
      <member name="mpeg" value="34" c:identifier="GST_MPEG" glib:nick="mpeg"/>
      <member name="gsm" value="35" c:identifier="GST_GSM" glib:nick="gsm"/>
      <member name="iec958"
              value="36"
              c:identifier="GST_IEC958"
              glib:nick="iec958"/>
      <member name="ac3" value="37" c:identifier="GST_AC3" glib:nick="ac3"/>
      <member name="eac3" value="38" c:identifier="GST_EAC3" glib:nick="eac3"/>
      <member name="dts" value="39" c:identifier="GST_DTS" glib:nick="dts"/>
      <member name="mpeg2_aac"
              value="40"
              c:identifier="GST_MPEG2_AAC"
              glib:nick="mpeg2-aac"/>
      <member name="mpeg4_aac"
              value="41"
              c:identifier="GST_MPEG4_AAC"
              glib:nick="mpeg4-aac"/>
    </enumeration>
    <enumeration name="BufferFormatType"
                 glib:type-name="GstBufferFormatType"
                 glib:get-type="gst_buffer_format_type_get_type"
                 c:type="GstBufferFormatType">
      <doc xml:whitespace="preserve">The format of the samples in the ringbuffer.</doc>
      <member name="linear"
              value="0"
              c:identifier="GST_BUFTYPE_LINEAR"
              glib:nick="linear"/>
      <member name="float"
              value="1"
              c:identifier="GST_BUFTYPE_FLOAT"
              glib:nick="float"/>
      <member name="mu_law"
              value="2"
              c:identifier="GST_BUFTYPE_MU_LAW"
              glib:nick="mu-law"/>
      <member name="a_law"
              value="3"
              c:identifier="GST_BUFTYPE_A_LAW"
              glib:nick="a-law"/>
      <member name="ima_adpcm"
              value="4"
              c:identifier="GST_BUFTYPE_IMA_ADPCM"
              glib:nick="ima-adpcm"/>
      <member name="mpeg"
              value="5"
              c:identifier="GST_BUFTYPE_MPEG"
              glib:nick="mpeg"/>
      <member name="gsm"
              value="6"
              c:identifier="GST_BUFTYPE_GSM"
              glib:nick="gsm"/>
      <member name="iec958"
              value="7"
              c:identifier="GST_BUFTYPE_IEC958"
              glib:nick="iec958"/>
      <member name="ac3"
              value="8"
              c:identifier="GST_BUFTYPE_AC3"
              glib:nick="ac3"/>
      <member name="eac3"
              value="9"
              c:identifier="GST_BUFTYPE_EAC3"
              glib:nick="eac3"/>
      <member name="dts"
              value="10"
              c:identifier="GST_BUFTYPE_DTS"
              glib:nick="dts"/>
      <member name="mpeg2_aac"
              value="11"
              c:identifier="GST_BUFTYPE_MPEG2_AAC"
              glib:nick="mpeg2-aac"/>
      <member name="mpeg4_aac"
              value="12"
              c:identifier="GST_BUFTYPE_MPEG4_AAC"
              glib:nick="mpeg4-aac"/>
    </enumeration>
    <class name="RingBuffer"
           c:symbol-prefix="ring_buffer"
           c:type="GstRingBuffer"
           parent="Gst.Object"
           abstract="1"
           glib:type-name="GstRingBuffer"
           glib:get-type="gst_ring_buffer_get_type"
           glib:type-struct="RingBufferClass">
      <doc xml:whitespace="preserve">&lt;refsect2&gt;
&lt;para&gt;
This object is the base class for audio ringbuffers used by the base
audio source and sink classes.
&lt;/para&gt;
&lt;para&gt;
The ringbuffer abstracts a circular buffer of data. One reader and
one writer can operate on the data from different threads in a lockfree
manner. The base class is sufficiently flexible to be used as an
abstraction for DMA based ringbuffers as well as a pure software
implementations.
&lt;/para&gt;
&lt;/refsect2&gt;

Last reviewed on 2006-02-02 (0.10.4)</doc>
      <function name="debug_spec_buff"
                c:identifier="gst_ring_buffer_debug_spec_buff">
        <doc xml:whitespace="preserve">Print debug info about the buffer sized in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the spec to debug</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="debug_spec_caps"
                c:identifier="gst_ring_buffer_debug_spec_caps">
        <doc xml:whitespace="preserve">Print debug info about the parsed caps in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the spec to debug</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_caps" c:identifier="gst_ring_buffer_parse_caps">
        <doc xml:whitespace="preserve">Parse @caps into @spec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the caps could be parsed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">a spec</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="acquire" invoker="acquire">
        <doc xml:whitespace="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be acquired, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the specs of the buffer</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="activate" invoker="activate" version="0.10.22.">
        <doc xml:whitespace="preserve">Activate @buf to start or stop pulling data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be activated in the requested mode, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear_all" invoker="clear_all">
        <doc xml:whitespace="preserve">Fill the ringbuffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="close_device" invoker="close_device">
        <doc xml:whitespace="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_ring_buffer_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be closed, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="commit">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay" invoker="delay">
        <doc xml:whitespace="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.

For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.

For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples queued in the audio device.  MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <virtual-method name="open_device" invoker="open_device">
        <doc xml:whitespace="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be opened, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="pause" invoker="pause">
        <doc xml:whitespace="preserve">Pause processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be paused, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="release" invoker="release">
        <doc xml:whitespace="preserve">Free the resources of the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be released, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="resume">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="start" invoker="start">
        <doc xml:whitespace="preserve">Start processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be started, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop" invoker="stop">
        <doc xml:whitespace="preserve">Stop processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be stopped, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="acquire" c:identifier="gst_ring_buffer_acquire">
        <doc xml:whitespace="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be acquired, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:whitespace="preserve">the specs of the buffer</doc>
            <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate"
              c:identifier="gst_ring_buffer_activate"
              version="0.10.22.">
        <doc xml:whitespace="preserve">Activate @buf to start or stop pulling data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be activated in the requested mode, FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="advance" c:identifier="gst_ring_buffer_advance">
        <doc xml:whitespace="preserve">Subclasses should call this function to notify the fact that 
@advance segments are now processed by the device.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="advance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of segments written</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gst_ring_buffer_clear">
        <doc xml:whitespace="preserve">Clear the given segment of the buffer with silence samples.
This function is used by subclasses.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment to clear</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_all" c:identifier="gst_ring_buffer_clear_all">
        <doc xml:whitespace="preserve">Fill the ringbuffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="close_device" c:identifier="gst_ring_buffer_close_device">
        <doc xml:whitespace="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_ring_buffer_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be closed, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="commit" c:identifier="gst_ring_buffer_commit">
        <doc xml:whitespace="preserve">Same as gst_ring_buffer_commit_full() but with a in_samples and out_samples
equal to @len, ignoring accum.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples written to the ringbuffer or -1 on error.  MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to commit</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples in the data to commit</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="commit_full"
              c:identifier="gst_ring_buffer_commit_full"
              version="0.10.11.">
        <doc xml:whitespace="preserve">Commit @in_samples samples pointed to by @data to the ringbuffer @buf. 

@in_samples and @out_samples define the rate conversion to perform on the
samples in @data. For negative rates, @out_samples must be negative and
@in_samples positive.

When @out_samples is positive, the first sample will be written at position @sample
in the ringbuffer. When @out_samples is negative, the last sample will be written to
@sample in reverse order.

@out_samples does not need to be a multiple of the segment size of the ringbuffer
although it is recommended for optimal performance. 

@accum will hold a temporary accumulator used in rate conversion and should be
set to 0 when this function is first called. In case the commit operation is
interrupted, one can resume the processing by passing the previously returned
@accum value back to this function.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples written to the ringbuffer or -1 on error. The number of samples written can be less than @out_samples when @buf was interrupted with a flush or stop.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data to commit</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples in the data to commit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples to write to the ringbuffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum" transfer-ownership="none">
            <doc xml:whitespace="preserve">accumulator for rate conversion.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="convert"
              c:identifier="gst_ring_buffer_convert"
              version="0.10.22.">
        <doc xml:whitespace="preserve">Convert @src_val in @src_fmt to the equivalent value in @dest_fmt. The result
will be put in @dest_val.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the conversion succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_fmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_fmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the converted value</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="gst_ring_buffer_delay">
        <doc xml:whitespace="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.

For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.

For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples queued in the audio device.  MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="device_is_open"
              c:identifier="gst_ring_buffer_device_is_open">
        <doc xml:whitespace="preserve">Checks the status of the device associated with the ring buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device was open, FALSE if it was closed.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_acquired" c:identifier="gst_ring_buffer_is_acquired">
        <doc xml:whitespace="preserve">Check if the ringbuffer is acquired and ready to use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the ringbuffer is acquired, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_active"
              c:identifier="gst_ring_buffer_is_active"
              version="0.10.22.">
        <doc xml:whitespace="preserve">Check if @buf is activated.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="may_start"
              c:identifier="gst_ring_buffer_may_start"
              version="0.10.6">
        <doc xml:whitespace="preserve">Tell the ringbuffer that it is allowed to start playback when
the ringbuffer is filled with samples. 

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_device" c:identifier="gst_ring_buffer_open_device">
        <doc xml:whitespace="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be opened, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="pause" c:identifier="gst_ring_buffer_pause">
        <doc xml:whitespace="preserve">Pause processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be paused, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="prepare_read" c:identifier="gst_ring_buffer_prepare_read">
        <doc xml:whitespace="preserve">Returns a pointer to memory where the data from segment @segment
can be found. This function is mostly used by subclasses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if the buffer is not started.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="readptr" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pointer to the memory where samples can be read</doc>
            <type name="guint8" c:type="guint8**"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of bytes to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="gst_ring_buffer_read">
        <doc xml:whitespace="preserve">Read @len samples from the ringbuffer into the memory pointed 
to by @data.
The first sample should be read from position @sample in
the ringbuffer.

@len should not be a multiple of the segment size of the ringbuffer
although it is recommended.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples read from the ringbuffer or -1 on error.  MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">where the data should be read</doc>
            <type name="guint8" c:type="guchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of samples in data to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="gst_ring_buffer_release">
        <doc xml:whitespace="preserve">Free the resources of the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be released, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="samples_done" c:identifier="gst_ring_buffer_samples_done">
        <doc xml:whitespace="preserve">Get the number of samples that were processed by the ringbuffer
since it was last started. This does not include the number of samples not
yet processed (see gst_ring_buffer_delay()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of samples processed by the ringbuffer.  MT safe.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="set_callback"
              c:identifier="gst_ring_buffer_set_callback"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the given callback function on the buffer. This function
will be called every time a segment has been written to a device.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cb" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">the callback to set</doc>
            <type name="RingBufferCallback" c:type="GstRingBufferCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing" c:identifier="gst_ring_buffer_set_flushing">
        <doc xml:whitespace="preserve">Set the ringbuffer to flushing mode or normal mode.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample" c:identifier="gst_ring_buffer_set_sample">
        <doc xml:whitespace="preserve">Make sure that the next sample written to the device is
accounted for as being the @sample sample written to the
device. This value will be used in reporting the current
sample position of the ringbuffer.

This function will also clear the buffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sample number to set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_ring_buffer_start">
        <doc xml:whitespace="preserve">Start processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be started, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="gst_ring_buffer_stop">
        <doc xml:whitespace="preserve">Stop processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the device could be stopped, FALSE on error.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="cond">
        <type name="GLib.Cond" c:type="GCond*"/>
      </field>
      <field name="open">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="acquired">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="data">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="spec">
        <type name="RingBufferSpec" c:type="GstRingBufferSpec"/>
      </field>
      <field name="segstate">
        <type name="RingBufferSegState" c:type="GstRingBufferSegState*"/>
      </field>
      <field name="samples_per_seg">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="empty_seg">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="state">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segdone">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segbase">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="waiting">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="callback" readable="0" private="1">
        <type name="RingBufferCallback" c:type="GstRingBufferCallback"/>
      </field>
      <field name="cb_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <union name="abidata" c:type="abidata">
        <record name="ABI" c:type="ABI">
          <field name="flushing" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
          <field name="may_start" writable="1">
            <type name="gint" c:type="gint"/>
          </field>
          <field name="active" writable="1">
            <type name="gboolean" c:type="gboolean"/>
          </field>
        </record>
        <field name="_gst_reserved" writable="1">
          <array zero-terminated="0" c:type="gpointer" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </class>
    <callback name="RingBufferCallback" c:type="GstRingBufferCallback">
      <doc xml:whitespace="preserve">This function is set with gst_ring_buffer_set_callback() and is
called to fill the memory at @data with @len bytes of samples.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="rbuf" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstRingBuffer</doc>
          <type name="RingBuffer" c:type="GstRingBuffer*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">target to fill</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:whitespace="preserve">amount to fill</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="RingBufferClass"
            c:type="GstRingBufferClass"
            glib:is-gtype-struct-for="RingBuffer">
      <doc xml:whitespace="preserve">The vmethods that subclasses can override to implement the ringbuffer.</doc>
      <field name="parent_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="open_device">
        <callback name="open_device">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be opened, FALSE on error.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire">
        <callback name="acquire">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be acquired, FALSE on error.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <doc xml:whitespace="preserve">the specs of the buffer</doc>
              <type name="RingBufferSpec" c:type="GstRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release">
        <callback name="release">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be released, FALSE on error.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_device">
        <callback name="close_device">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be closed, FALSE on error.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be started, FALSE on error.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pause">
        <callback name="pause">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be paused, FALSE on error.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resume">
        <callback name="resume">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be stopped, FALSE on error.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of samples queued in the audio device.  MT safe.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the device could be activated in the requested mode, FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <doc xml:whitespace="preserve">the new mode</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="commit">
        <callback name="commit">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
            <parameter name="sample" transfer-ownership="none">
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="guint8" c:type="guchar*"/>
            </parameter>
            <parameter name="in_samples" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="out_samples" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="accum" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_all">
        <callback name="clear_all">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="RingBuffer" c:type="GstRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="1">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="RingBufferSegState"
                 glib:type-name="GstRingBufferSegState"
                 glib:get-type="gst_ring_buffer_seg_state_get_type"
                 c:type="GstRingBufferSegState">
      <doc xml:whitespace="preserve">The state of a segment in the ringbuffer.</doc>
      <member name="invalid"
              value="0"
              c:identifier="GST_SEGSTATE_INVALID"
              glib:nick="invalid"/>
      <member name="empty"
              value="1"
              c:identifier="GST_SEGSTATE_EMPTY"
              glib:nick="empty"/>
      <member name="filled"
              value="2"
              c:identifier="GST_SEGSTATE_FILLED"
              glib:nick="filled"/>
      <member name="partial"
              value="3"
              c:identifier="GST_SEGSTATE_PARTIAL"
              glib:nick="partial"/>
    </enumeration>
    <record name="RingBufferSpec" c:type="GstRingBufferSpec">
      <doc xml:whitespace="preserve">The structure containing the format specification of the ringbuffer.</doc>
      <field name="caps" writable="1">
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="type" writable="1">
        <type name="BufferFormatType" c:type="GstBufferFormatType"/>
      </field>
      <field name="format" writable="1">
        <type name="BufferFormat" c:type="GstBufferFormat"/>
      </field>
      <field name="sign" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="bigend" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="width" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="depth" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="rate" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="channels" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="latency_time" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="buffer_time" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="segsize" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segtotal" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="bytes_per_sample" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="silence_sample" writable="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="32">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="seglatency" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="guint8" fixed-size="0">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
    </record>
    <enumeration name="RingBufferState"
                 glib:type-name="GstRingBufferState"
                 glib:get-type="gst_ring_buffer_state_get_type"
                 c:type="GstRingBufferState">
      <doc xml:whitespace="preserve">The state of the ringbuffer.</doc>
      <member name="stopped"
              value="0"
              c:identifier="GST_RING_BUFFER_STATE_STOPPED"
              glib:nick="stopped"/>
      <member name="paused"
              value="1"
              c:identifier="GST_RING_BUFFER_STATE_PAUSED"
              glib:nick="paused"/>
      <member name="started"
              value="2"
              c:identifier="GST_RING_BUFFER_STATE_STARTED"
              glib:nick="started"/>
    </enumeration>
    <function name="audio_buffer_clip"
              c:identifier="gst_audio_buffer_clip"
              version="0.10.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Clip the buffer to the given %GstSegment.

After calling this function the caller does not own a reference to 
@buffer anymore.</doc>
      <return-value>
        <doc xml:whitespace="preserve">%NULL if the buffer is completely outside the configured segment, otherwise the clipped buffer is returned.  If the buffer has no timestamp, it is assumed to be inside the segment and is not clipped</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">The buffer to clip.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="segment" transfer-ownership="none">
          <doc xml:whitespace="preserve">Segment in %GST_FORMAT_TIME or %GST_FORMAT_DEFAULT to which the buffer should be clipped.</doc>
          <type name="Gst.Segment" c:type="GstSegment*"/>
        </parameter>
        <parameter name="rate" transfer-ownership="none">
          <doc xml:whitespace="preserve">sample rate.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="frame_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of one audio frame in bytes.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_check_channel_positions"
              c:identifier="gst_audio_check_channel_positions"
              version="0.10.20">
      <doc xml:whitespace="preserve">This functions checks if the given channel positions are valid. Channel
positions are valid if:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;No channel positions appears twice or all positions are %GST_AUDIO_CHANNEL_POSITION_NONE.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;Either all or none of the channel positions are %GST_AUDIO_CHANNEL_POSITION_NONE.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;%GST_AUDIO_CHANNEL_POSITION_FRONT_MONO and %GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT or %GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT don't appear together in the given positions.
  &lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the given channel positions are valid and %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #GstAudioChannelPosition.</doc>
          <type name="AudioChannelPosition"
                c:type="const GstAudioChannelPosition*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of elements in @pos.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_default_registry_mixer_filter"
              c:identifier="gst_audio_default_registry_mixer_filter"
              version="0.10.2"
              introspectable="0">
      <doc xml:whitespace="preserve">Utility function to find audio mixer elements.

Will traverse the default plugin registry in order of plugin rank and
find usable audio mixer elements. The caller may optionally fine-tune
the selection by specifying a filter function.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a #GList of audio mixer #GstElement&lt;!-- --&gt;s. You must free each element in the list by setting it to NULL state and calling gst_object_unref(). After that the list itself should be freed using g_list_free().</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="filter_func" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">filter function, or #NULL</doc>
          <type name="AudioMixerFilterFunc" c:type="GstAudioMixerFilterFunc"/>
        </parameter>
        <parameter name="first" transfer-ownership="none">
          <doc xml:whitespace="preserve">set to #TRUE if you only want the first suitable mixer element</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data to pass to the filter function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_duration_from_pad_buffer"
              c:identifier="gst_audio_duration_from_pad_buffer">
      <doc xml:whitespace="preserve">Calculate length in nanoseconds of audio buffer @buf based on capabilities of
@pad.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the length.</doc>
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_fixate_channel_positions"
              c:identifier="gst_audio_fixate_channel_positions">
      <doc xml:whitespace="preserve">Custom fixate function. Elements that implement some sort of
channel conversion algorithm should use this function for
fixating on GstAudioChannelPosition properties. It will take
care of equal channel positioning (left/right). Caller g_free()s
the return value. The input properties may be (and are supposed
to be) unfixed.
Note that this function is mostly a hack because we currently
have no way to add default fixation functions for new GTypes.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">fixed values that the caller could use as a fixed set of #GstAudioChannelPosition values.</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstStructure containing a (possibly unfixed) "channel-positions" field.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_get_info"
              c:identifier="gst_audio_format_get_info">
      <return-value transfer-ownership="none">
        <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_frame_byte_size"
              c:identifier="gst_audio_frame_byte_size">
      <doc xml:whitespace="preserve">Calculate byte size of an audio frame.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the byte size, or 0 if there was an error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_frame_length" c:identifier="gst_audio_frame_length">
      <doc xml:whitespace="preserve">Calculate length of buffer in frames.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">0 if there's an error, or the number of frames if everything's ok</doc>
        <type name="glong" c:type="long"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_get_channel_positions"
              c:identifier="gst_audio_get_channel_positions">
      <doc xml:whitespace="preserve">Retrieves a number of (fixed!) audio channel positions from
the provided #GstStructure and returns it as a newly allocated
array. The caller should g_free () this array. The caller
should also check that the members in this #GstStructure are
indeed "fixed" before calling this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a newly allocated array containing the channel positions as provided in the given #GstStructure. Returns NULL on error.</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstStructure to retrieve channel positions from.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_iec61937_frame_size"
              c:identifier="gst_audio_iec61937_frame_size"
              version="0.10.36">
      <doc xml:whitespace="preserve">Calculated the size of the buffer expected by gst_audio_iec61937_payload() for
payloading type from @spec.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the size or 0 if the given @type is not supported or cannot be payloaded.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="spec" transfer-ownership="none">
          <doc xml:whitespace="preserve">the ringbufer spec</doc>
          <type name="RingBufferSpec" c:type="const GstRingBufferSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_iec61937_payload"
              c:identifier="gst_audio_iec61937_payload"
              version="0.10.36">
      <doc xml:whitespace="preserve">Payloads @src in the form specified by IEC 61937 for the type from @spec and
stores the result in @dst. @src must contain exactly one frame of data and
the frame is not checked for errors.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">transfer-full: %TRUE if the payloading was successful, %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">a buffer containing the data to payload</doc>
          <type name="guint8" c:type="const guint8*"/>
        </parameter>
        <parameter name="src_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of @src in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:whitespace="preserve">the destination buffer to store the payloaded contents in. Should not overlap with @src</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="dst_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of @dst in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="spec" transfer-ownership="none">
          <doc xml:whitespace="preserve">the ringbufer spec for @src</doc>
          <type name="RingBufferSpec" c:type="const GstRingBufferSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_is_buffer_framed"
              c:identifier="gst_audio_is_buffer_framed">
      <doc xml:whitespace="preserve">Check if the buffer size is a whole multiple of the frame size.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if buffer size is multiple.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to get the caps from</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_set_caps_channel_positions_list"
              c:identifier="gst_audio_set_caps_channel_positions_list">
      <doc xml:whitespace="preserve">Sets a (possibly non-fixed) list of possible audio channel
positions (given in pos) on the given caps. Each of the
structures of the caps, after this function has been called,
will contain a "channel-positions" field with an array.
Each value in the array will contain each of the values given
in the pos array. Note that the size of the caps might be
increased by this, since each structure with a "channel-
positions" field needs to have a fixed "channels" field.
The input caps is not required to have this.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstCaps to set the list of channel positions on.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">the array containing one or more possible audio channel positions that we should add in each value of the array in the given structure.</doc>
          <type name="AudioChannelPosition"
                c:type="const GstAudioChannelPosition*"/>
        </parameter>
        <parameter name="num_positions" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of values in pos.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_set_channel_positions"
              c:identifier="gst_audio_set_channel_positions">
      <doc xml:whitespace="preserve">Adds a "channel-positions" field to the given #GstStructure,
which will represent the channel positions as given in the
provided #GstAudioChannelPosition array.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstStructure to set channel positions on.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of channel positions. The number of members in this array should be equal to the (fixed!) number of the "channels" field in the given #GstStructure.</doc>
          <type name="AudioChannelPosition"
                c:type="const GstAudioChannelPosition*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_set_structure_channel_positions_list"
              c:identifier="gst_audio_set_structure_channel_positions_list">
      <doc xml:whitespace="preserve">Sets a (possibly non-fixed) list of possible audio channel
positions (given in pos) on the given structure. The
structure, after this function has been called, will contain
a "channel-positions" field with an array of the size of
the "channels" field value in the given structure (note
that this means that the channels field in the provided
structure should be fixed!). Each value in the array will
contain each of the values given in the pos array.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="str" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstStructure to set the list of channel positions on.</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
        <parameter name="pos" transfer-ownership="none">
          <doc xml:whitespace="preserve">the array containing one or more possible audio channel positions that we should add in each value of the array in the given structure.</doc>
          <type name="AudioChannelPosition"
                c:type="const GstAudioChannelPosition*"/>
        </parameter>
        <parameter name="num_positions" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of values in pos.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_structure_set_int"
              c:identifier="gst_audio_structure_set_int"
              deprecated="use gst_structure_set()">
      <doc xml:whitespace="preserve">Do not use anymore.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="structure" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstStructure</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
        <parameter name="flag" transfer-ownership="none">
          <doc xml:whitespace="preserve">a set of #GstAudioFieldFlag</doc>
          <type name="AudioFieldFlag" c:type="GstAudioFieldFlag"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
