<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="telepathy-glib"/>
  <c:include name="telepathy-glib/telepathy-glib.h"/>
  <namespace name="TelepathyGLib"
             version="0.12"
             shared-library="libtelepathy-glib.so.0"
             c:identifier-prefixes="Tp"
             c:symbol-prefixes="tp">
    <alias name="Handle" c:type="TpHandle">
      <doc xml:whitespace="preserve">Type representing Telepathy handles within telepathy-glib.

This is guint despite the wire protocol having 32-bit integers, because
dbus-glib expects GArrays of guint and so on. If the dbus-glib ABI changes
in future, telepathy-glib is likely to have a matching ABI change.</doc>
      <type name="guint" c:type="guint"/>
    </alias>
    <alias name="IntSet" c:type="TpIntSet" introspectable="0">
      <doc xml:whitespace="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntset&lt;/type&gt;, but it's
now just a backwards compatibility typedef.</doc>
      <type name="Intset" c:type="TpIntset"/>
    </alias>
    <alias name="IntSetFastIter" c:type="TpIntSetFastIter" introspectable="0">
      <doc xml:whitespace="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntsetFastIter&lt;/type&gt;,
but it's now just a backwards compatibility typedef.</doc>
      <type name="IntsetFastIter" c:type="TpIntsetFastIter"/>
    </alias>
    <alias name="IntSetIter" c:type="TpIntSetIter" introspectable="0">
      <doc xml:whitespace="preserve">Before 0.11.16, this was the name for &lt;type&gt;TpIntsetIter&lt;/type&gt;, but
it's now just a backwards compatibility typedef.</doc>
      <type name="IntsetIter" c:type="TpIntsetIter"/>
    </alias>
    <constant name="ACCOUNT_MANAGER_BUS_NAME"
              value="org.freedesktop.Telepathy.AccountManager"
              c:type="TP_ACCOUNT_MANAGER_BUS_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCOUNT_MANAGER_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/AccountManager"
              c:type="TP_ACCOUNT_MANAGER_OBJECT_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ACCOUNT_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Account/"
              c:type="TP_ACCOUNT_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="AccessControlType" c:type="TpAccessControlType">
      <member name="whitelist"
              value="0"
              c:identifier="TP_ACCESS_CONTROL_TYPE_WHITELIST"/>
      <member name="publish_list"
              value="1"
              c:identifier="TP_ACCESS_CONTROL_TYPE_PUBLISH_LIST"/>
      <member name="group"
              value="2"
              c:identifier="TP_ACCESS_CONTROL_TYPE_GROUP"/>
      <member name="open"
              value="3"
              c:identifier="TP_ACCESS_CONTROL_TYPE_OPEN"/>
      <member name="subscribe_or_publish_list"
              value="4"
              c:identifier="TP_ACCESS_CONTROL_TYPE_SUBSCRIBE_OR_PUBLISH_LIST"/>
      <member name="closed"
              value="5"
              c:identifier="TP_ACCESS_CONTROL_TYPE_CLOSED"/>
      <member name="not_understood"
              value="6"
              c:identifier="TP_ACCESS_CONTROL_TYPE_NOT_UNDERSTOOD"/>
    </enumeration>
    <class name="Account"
           c:symbol-prefix="account"
           c:type="TpAccount"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpAccount"
           glib:get-type="tp_account_get_type"
           glib:type-struct="AccountClass">
      <doc xml:whitespace="preserve">The Telepathy Account Manager stores the user's configured real-time
communication accounts. This object represents a stored account.

If this account is deleted from the account manager, the
#TpProxy::invalidated signal will be emitted
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

One can connect to the #GObject::notify signal to get change notifications
for many of the properties on this object. Refer to each property's
documentation for whether it can be used in this way.</doc>
      <constructor name="new" c:identifier="tp_account_new" throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new account proxy. The returned #TpAccount
is not guaranteed to be ready at the point of return.

not valid</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account proxy, or %NULL if @object_path is</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this account</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_addressing"
                c:identifier="tp_account_get_feature_quark_addressing">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_connection"
                c:identifier="tp_account_get_feature_quark_connection"
                version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpAccount</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the connection feature of a</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_account_get_feature_quark_core"
                version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpAccount</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the core feature of a</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_storage"
                c:identifier="tp_account_get_feature_quark_storage"
                version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpAccount</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the storage interface of a</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_account_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpAccount have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="parse_object_path"
                c:identifier="tp_account_parse_object_path"
                version="0.9.0"
                throws="1">
        <doc xml:whitespace="preserve">Validates and parses a Telepathy Account's object path, extracting the
connection manager's name, the protocol, and the account's unique identifier
from the path. This includes replacing underscores with hyphens in the
protocol name, as defined in the Account specification.

Any of the out parameters may be %NULL if not needed. If %TRUE is returned,
the caller is responsible for freeing the strings stored in any non-%NULL
out parameters, using g_free().

@error otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @object_path was successfully parsed; %FALSE and sets</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">a Telepathy Account's object path</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cm"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's connection manager's name</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="protocol"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's protocol</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="account_id"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location at which to store the account's unique identifier</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
      <method name="associated_with_uri_scheme"
              c:identifier="tp_account_associated_with_uri_scheme"
              version="0.13.8">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

@scheme</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the result of tp_account_get_uri_schemes() would include</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a URI scheme such as "tel", "sip" or "xmpp"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_connection_status_to_property"
              c:identifier="tp_account_bind_connection_status_to_property"
              version="0.13.16">
        <doc xml:whitespace="preserve">Binds the :connection-status of @self to the boolean property of another
object using a #GBinding such that the @target_property will be set to
%TRUE when @self is connected (and @invert is %FALSE).

@target_property will be synchronised immediately (%G_BINDING_SYNC_CREATE).
@invert can be interpreted as analogous to %G_BINDING_INVERT_BOOLEAN.

For instance, this function can be used to bind the GtkWidget:sensitive
property to only make a widget sensitive when the account is connected.

See g_object_bind_property() for more information.

between the @self and the @target. The binding is released whenever the
#GBinding reference count reaches zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBinding instance representing the binding</doc>
          <type name="GObject.Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @target to bind (must be %G_TYPE_BOOLEAN)</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="invert" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if you wish to invert the value of @target_property (i.e. %FALSE if connected)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_connection"
              c:identifier="tp_account_ensure_connection"
              version="0.9.0">
        <doc xml:whitespace="preserve">Set the connection of the account by specifying the connection object path.
This function does not return a new ref and it is not guaranteed that the
returned #TpConnection object is ready.

The use-case for this function is in a HandleChannels callback and you
already know the object path for the connection, so you can let @account
create its #TpConnection and return it for use.

the object path @path is invalid or it is the null-value "/"</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection of the account, or %NULL if either</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to connection object for #TpAccount</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_automatic_presence"
              c:identifier="tp_account_get_automatic_presence"
              version="0.13.8">
        <doc xml:whitespace="preserve">Gets the automatic presence, status and status message of @account. These
values are the same as the #TpAccount:automatic-presence-type,
#TpAccount:automatic-status and #TpAccount:automatic-status-message
properties, and are the values that will be used if the account should
be put online automatically.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:automatic-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the presence status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the user-defined message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_async"
              c:identifier="tp_account_get_avatar_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous get of @account's avatar. When
the operation is finished, @callback will be called. You can then call
tp_account_get_avatar_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_avatar_finish"
              c:identifier="tp_account_get_avatar_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async get operation of @account's avatar.

containing the bytes of the account's avatar, or %NULL on failure</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GArray of #guchar</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_changing_presence"
              c:identifier="tp_account_get_changing_presence"
              version="0.11.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:changing-presence property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_connect_automatically"
              c:identifier="tp_account_get_connect_automatically"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connect-automatically property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_connection"
              c:identifier="tp_account_get_connection"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection property</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="get_connection_manager"
              c:identifier="tp_account_get_connection_manager"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection-manager property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_connection_status"
              c:identifier="tp_account_get_connection_status"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the connection status and reason from @account. The two values
are the same as the #TpAccount:connection-status and
#TpAccount:connection-status-reason properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:connection-status property</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #TpConnectionStatusReason to fill, or %NULL</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_current_presence"
              c:identifier="tp_account_get_current_presence"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the current presence, status and status message of @account. These
values are the same as the #TpAccount:current-presence-type,
#TpAccount:current-status and #TpAccount:current-status-message properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:current-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the current status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the current status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error"
              c:identifier="tp_account_get_detailed_error"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">If the account's connection is not connected, return the D-Bus error name
with which it last disconnected or failed to connect (in particular, this
is %TP_ERROR_STR_CANCELLED if it was disconnected by a user request).
This is the same as #TpAccount:connection-error.

If @details is not %NULL, it will be used to return additional details about
the error (the same as #TpAccount:connection-error-details).

Otherwise, return %NULL, without altering @details.

The returned string and @details may become invalid when the main loop is
re-entered or the account is destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve"> optionally used to return a map from string to #GValue, which must not be modified, destroyed or unreffed by the caller</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_display_name"
              c:identifier="tp_account_get_display_name"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:display-name property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_has_been_online"
              c:identifier="tp_account_get_has_been_online"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:has-been-online property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_icon_name"
              c:identifier="tp_account_get_icon_name"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:icon-name property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_nickname"
              c:identifier="tp_account_get_nickname"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:nickname property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_normalized_name"
              c:identifier="tp_account_get_normalized_name"
              version="0.13.8">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:normalized-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_parameters"
              c:identifier="tp_account_get_parameters"
              version="0.9.0">
        <doc xml:whitespace="preserve">Returns the parameters of the account, in a hash table where each string
is the parameter name (account, password, require-encryption etc.), and
each value is a #GValue. Using the tp_asv_get family of functions
(tp_asv_get_uint32(), tp_asv_get_string() etc.) to access the parameters is
recommended.

The allowed parameters depend on the connection manager, and can be found
via tp_connection_manager_get_protocol() and
tp_connection_manager_protocol_get_param(). Well-known parameters are
listed
&lt;ulink url="http://telepathy.freedesktop.org/spec/org.freedesktop.Telepathy.ConnectionManager.html#org.freedesktop.Telepathy.ConnectionManager.RequestConnection"&gt;in
the Telepathy D-Bus Interface Specification&lt;/ulink&gt;.

parameters on @account</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hash table of</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_path_suffix"
              c:identifier="tp_account_get_path_suffix"
              version="0.13.9">
        <doc xml:whitespace="preserve">Returns the portion of @account's object path after the standard
#TP_ACCOUNT_OBJECT_PATH_BASE prefix, of the form "cm/protocol/acct". This
string uniquely identifies the account.

This function is only intended to be used when printing debug messages or in
tools for developer. For a string suitable for displaying to the user, see
tp_account_get_display_name(). To retrieve the connection manager and
protocol name parts of the object path, see
tp_account_get_connection_manager() and tp_account_get_protocol(). For
persistent identification of the account, use tp_proxy_get_object_path().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a suffix of @account's object path, for debugging purposes.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="tp_account_get_protocol"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:protocol property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_requested_presence"
              c:identifier="tp_account_get_requested_presence"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the requested presence, status and status message of @account. These
values are the same as the #TpAccount:requested-presence-type,
#TpAccount:requested-status and #TpAccount:requested-status-message
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:requested-presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the requested status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="status_message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the requested status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="tp_account_get_service"
              version="0.11.9">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:service property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_storage_identifier"
              c:identifier="tp_account_get_storage_identifier"
              version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:storage-identifier property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
      </method>
      <method name="get_storage_provider"
              c:identifier="tp_account_get_storage_provider"
              version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:storage-provider property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_storage_restrictions"
              c:identifier="tp_account_get_storage_restrictions"
              version="0.13.2">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:storage-restrictions property</doc>
          <type name="StorageRestrictionFlags"
                c:type="TpStorageRestrictionFlags"/>
        </return-value>
      </method>
      <method name="get_storage_specific_information_async"
              c:identifier="tp_account_get_storage_specific_information_async"
              version="0.13.2">
        <doc xml:whitespace="preserve">Makes an asynchronous request of @self's StorageSpecificInformation
property (part of the Account.Interface.Storage interface).

When the operation is finished, @callback will be called. You must then
call tp_account_get_storage_specific_information_finish() to get the
result of the request.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_storage_specific_information_finish"
              c:identifier="tp_account_get_storage_specific_information_finish"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Retrieve the value of the request begun with
tp_account_get_storage_specific_information_async().

of strings to GValues representing the D-Bus type a{sv}.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uri_schemes"
              c:identifier="tp_account_get_uri_schemes"
              version="0.13.8">
        <doc xml:whitespace="preserve">If the %TP_ACCOUNT_FEATURE_ADDRESSING feature has been prepared
successfully, return a list of additional URI schemes for which this
account should be used if possible. Otherwise return %NULL.

For instance, a SIP or Skype account might have "tel" in this list if the
user would like to use that account to call phone numbers.

This list should not contain the primary URI scheme(s) for the account's
protocol (for instance, "xmpp" for XMPP, or "sip" or "sips" for SIP),
since it should be assumed to be useful for those schemes in any case.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a list of URI schemes, or %NULL</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="is_enabled"
              c:identifier="tp_account_is_enabled"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:enabled property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_prepared"
              c:identifier="tp_account_is_prepared"
              version="0.9.0"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_valid"
              c:identifier="tp_account_is_valid"
              version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same as the #TpAccount:valid property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="prepare_async"
              c:identifier="tp_account_prepare_async"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_async() instead.">
        <doc xml:whitespace="preserve">Requests an asynchronous preparation of @account with the features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_prepare_finish() to get the result of the
operation.

If @features is %NULL, then @callback will be called when the implied
%TP_ACCOUNT_FEATURE_CORE feature is ready.

If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.

Since 0.11.3, this is equivalent to calling the new function
tp_proxy_prepare_async() with the same arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="GQuark*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_account_prepare_finish"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_finish() instead."
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async preparation of the account @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_async"
              c:identifier="tp_account_reconnect_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous reconnect of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_reconnect_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reconnect_finish"
              c:identifier="tp_account_reconnect_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async reconnect of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the reconnect call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_async"
              c:identifier="tp_account_remove_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous removal of @account. When the operation is
finished, @callback will be called. You can then call
tp_account_remove_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_account_remove_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async removal of @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_async"
              c:identifier="tp_account_request_presence_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous change of presence on @account. When the
operation is finished, @callback will be called. You can then call
tp_account_request_presence_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to set, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message for the change, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_presence_finish"
              c:identifier="tp_account_request_presence_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async presence change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence_async"
              c:identifier="tp_account_set_automatic_presence_async"
              version="0.13.8">
        <doc xml:whitespace="preserve">Requests an asynchronous change of @account's automatic presence. When the
operation is finished, @callback will be called. You can then call
tp_account_set_automatic_presence_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested presence</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to set, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message for the change, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_presence_finish"
              c:identifier="tp_account_set_automatic_presence_finish"
              version="0.13.8"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an asynchronous request to change the automatic presence of
@account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_async"
              c:identifier="tp_account_set_avatar_async"
              version="0.11.1">
        <doc xml:whitespace="preserve">Requests an asynchronous change of the Avatar parameter on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_avatar_finish() to get the result of the operation.

If @len equals 0, the avatar is cleared.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="avatar" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a new avatar to set; can be %NULL only if @len equals 0</doc>
            <array length="1" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the new avatar</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mime_type" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the MIME type of the new avatar; can be %NULL only if @len equals 0</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_avatar_finish"
              c:identifier="tp_account_set_avatar_finish"
              version="0.11.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async avatar change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_async"
              c:identifier="tp_account_set_connect_automatically_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the ConnectAutomatically property of
@account. When the operation is finished, @callback will be called. You can
then call tp_account_set_display_name_finish() to get the result of the
operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connect_automatically" transfer-ownership="none">
            <doc xml:whitespace="preserve">new value for the parameter</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_connect_automatically_finish"
              c:identifier="tp_account_set_connect_automatically_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the ConnectAutomatically property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_async"
              c:identifier="tp_account_set_display_name_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the DisplayName property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_display_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new display name, or %NULL to unset the display name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_display_name_finish"
              c:identifier="tp_account_set_display_name_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the DisplayName property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_async"
              c:identifier="tp_account_set_enabled_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Enabled property of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_set_enabled_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new enabled value of @account</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enabled_finish"
              c:identifier="tp_account_set_enabled_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Enabled property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the set was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_async"
              c:identifier="tp_account_set_icon_name_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Icon property of @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_icon_name_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="icon_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new icon name, or %NULL to unset the icon name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_icon_name_finish"
              c:identifier="tp_account_set_icon_name_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Icon parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_async"
              c:identifier="tp_account_set_nickname_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous change of the Nickname parameter on @account. When
the operation is finished, @callback will be called. You can then call
tp_account_set_nickname_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nickname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new nickname to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nickname_finish"
              c:identifier="tp_account_set_nickname_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async nickname change request on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_async"
              c:identifier="tp_account_set_service_async"
              version="0.11.9">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the Service property on @self. When
the operation is finished, @callback will be called. You can then call
tp_account_set_service_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new service name, or %NULL or the empty string to unset the service name (which will result in the #TpAccount:service property becoming the same as #TpAccount:protocol)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_service_finish"
              c:identifier="tp_account_set_service_finish"
              version="0.11.9"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of the Service parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri_scheme_association_async"
              c:identifier="tp_account_set_uri_scheme_association_async"
              version="0.13.8">
        <doc xml:whitespace="preserve">Add @scheme to the list of additional URI schemes that would be returned
by tp_account_get_uri_schemes(), or remove it from that list.

@scheme should not be the primary URI scheme for the account's
protocol (for instance, "xmpp" for XMPP, or "sip" or "sips" for SIP),
since the account should be assumed to be useful for those schemes
regardless of the contents of the list.

Calling this method does not require the %TP_ACCOUNT_FEATURE_ADDRESSING
feature to be enabled, but the change will not be reflected in the result
of tp_account_get_uri_schemes() or tp_account_associated_with_uri_scheme()
unless that feature has been enabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="scheme" transfer-ownership="none">
            <doc xml:whitespace="preserve">a non-%NULL URI scheme such as "tel"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="associate" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to use this account for @scheme, or %FALSE to not use it</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri_scheme_association_finish"
              c:identifier="tp_account_set_uri_scheme_association_finish"
              version="0.13.8"
              throws="1">
        <doc xml:whitespace="preserve">Interpret the result of tp_account_set_uri_scheme_association_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_async"
              c:identifier="tp_account_update_parameters_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous update of parameters of @account. When the
operation is finished, @callback will be called. You can then call
tp_account_update_parameters_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">new parameters to set on @account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="unset_parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">list of parameters to unset on @account</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_parameters_finish"
              c:identifier="tp_account_update_parameters_finish"
              version="0.9.0"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async update of the parameters on @account.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request succeeded, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="reconnect_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GStrv to fill with properties that need a reconnect to take effect</doc>
            <type name="GObject.Strv" c:type="gchar***"/>
          </parameter>
        </parameters>
      </method>
      <property name="automatic-presence-type"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's automatic presence type (a #TpConnectionPresenceType).

When the account is put online automatically, for instance to make a
channel request or because network connectivity becomes available,
the automatic presence type, status and message will be copied to
their "requested" counterparts.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <type name="guint"/>
      </property>
      <property name="automatic-status"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The string status name to use in conjunction with the
#TpAccount:automatic-presence-type.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="automatic-status-message"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-defined message to use in conjunction with the
#TpAccount:automatic-presence-type.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for automatic-presence-type,
automatic-status and automatic-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="changing-presence"
                version="0.11.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if an attempt is currently being made to change the account's
presence (#TpAccount:current-presence-type, #TpAccount:current-status
and #TpAccount:current-status-message) to match its requested presence
(#TpAccount:requested-presence-type, #TpAccount:requested-status
and #TpAccount:requested-status-message).

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="connect-automatically"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether the account should connect automatically or not. To change this
property, use tp_account_set_connect_automatically_async().

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="connection" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The connection of the account, or %NULL if account is offline.
Note that the returned #TpConnection is not guaranteed to have any
features pre-prepared (not even %TP_CONNECTION_FEATURE_CORE) unless
%TP_ACCOUNT_FEATURE_CONNECTION has been prepared on the account

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. If %TP_ACCOUNT_FEATURE_CONNECTION has been prepared, this signal
will be delayed until the connection is ready.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="connection-error"
                version="0.11.7"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus error name for the last disconnection or connection failure,
(in particular, %TP_ERROR_STR_CANCELLED if it was disconnected by user
request), or %NULL if the account is connected.

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-error-details"
                version="0.11.7"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A map from string to #GValue containing extensible error details
related to #TpAccount:connection-error. Functions like tp_asv_get_string()
can be used to read from this map.

The keys for this map are defined by
&lt;ulink url="http://telepathy.freedesktop.org/spec/"&gt;the Telepathy D-Bus
Interface Specification&lt;/ulink&gt;. They will typically include
&lt;literal&gt;debug-message&lt;/literal&gt;, which is a debugging message in the C
locale, analogous to #GError&lt;!-- --&gt;.message.

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
an empty map.</doc>
        <type name="GLib.HashTable">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </property>
      <property name="connection-manager"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection manager name.</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection status type (a %TpConnectionStatus).

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_DISCONNECTED.</doc>
        <type name="guint"/>
      </property>
      <property name="connection-status-reason"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's connection status reason (a %TpConnectionStatusReason).

One can receive change notifications on this property by connecting
to the #TpAccount::status-changed signal, or by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED.</doc>
        <type name="guint"/>
      </property>
      <property name="current-presence-type"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account connection's current presence type
(a %TpConnectionPresenceType).

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <type name="guint"/>
      </property>
      <property name="current-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The current Status string of the account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="current-status-message"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The current status message message of the account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for current-presence-type,
current-status and current-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="display-name" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's display name, from the DisplayName property.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="enabled" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account is enabled or not.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="has-been-online"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account has been online or not.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="icon-name" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's icon name. To change this propery, use
tp_account_set_icon_name_async().

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="nickname" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The nickname that should be set for the user on this account.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="normalized-name"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The normalized form of the user's own unique identifier on this
protocol. For example, on XMPP accounts this is the user's JID; on
ICQ this is the user's UIN; and so on.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="protocol" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's machine-readable protocol name, such as "jabber", "msn" or
"local-xmpp". Recommended names for most protocols can be found in the
Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8"/>
      </property>
      <property name="requested-presence-type"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The account's requested presence type (a #TpConnectionPresenceType).

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="guint"/>
      </property>
      <property name="requested-status"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested Status string of the account.

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="requested-status-message"
                version="0.9.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The requested status message message of the account.

Since 0.13.8,
one can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail. Change notifications for requested-presence-type,
requested-status and requested-status-message are always emitted together,
so it is sufficient to connect to one of the notification signals.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="service" version="0.11.9" transfer-ownership="none">
        <doc xml:whitespace="preserve">A machine-readable name identifying a specific service to which this
account connects, or a copy of #TpAccount:protocol if there is no more
specific service.

Well-known names for various services can be found in the Telepathy D-Bus
Interface Specification.

For instance, accounts for the "jabber" protocol should have the service
names "google-talk", "ovi-chat", "facebook" and "lj-talk" for accounts
that connect to Google Talk, Ovi Chat, Facebook and Livejournal,
respectively, and this property will be "jabber" for accounts that
connect to a generic Jabber server.

To change this property, use
tp_account_set_service_async().</doc>
        <type name="utf8"/>
      </property>
      <property name="storage-identifier"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The storage identifier for this account.

A provider-specific variant type used to identify this account with the
provider. This value will be %NULL if #TpAccount:storage-provider is
an empty string.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="GObject.Value"/>
      </property>
      <property name="storage-provider"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The storage provider for this account.

The name of the account storage implementation. When this
is the empty string the account is internally stored.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="storage-restrictions"
                version="0.13.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The storage restrictions for this account.

A bitfield of #TpStorageRestrictionFlags that give the limitations of
this account imposed by the storage provider. This value will be 0
if #TpAccount:storage-provider is an empty string.

This property cannot change once an Account has been created.

This is not guaranteed to have been retrieved until the
%TP_ACCOUNT_FEATURE_STORAGE feature has been prepared; until then,
the value is 0.</doc>
        <type name="guint"/>
      </property>
      <property name="valid" version="0.9.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this account is valid.

One can receive change notifications on this property by connecting
to the #GObject::notify signal and using this property as the signal
detail.

This is not guaranteed to have been retrieved until
tp_proxy_prepare_async() has finished; until then, the value is
%FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountPrivate" c:type="TpAccountPrivate*"/>
      </field>
      <glib:signal name="presence-changed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the presence of the account changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence status</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="status_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new presence status message</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="status-changed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the connection status on the account changes.

The @dbus_error_name and @details parameters were present, but
non-functional (always %NULL), in older versions. They have been
available with their current behaviour since version 0.11.7.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="old_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">old #TpAccount:connection-status</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="new_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">new #TpAccount:connection-status</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount:connection-status-reason</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="dbus_error_name"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the #TpAccount:connection-error</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount:connection-error-details</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="AccountChannelRequest"
           c:symbol-prefix="account_channel_request"
           c:type="TpAccountChannelRequest"
           version="0.11.12"
           parent="GObject.Object"
           glib:type-name="TpAccountChannelRequest"
           glib:get-type="tp_account_channel_request_get_type"
           glib:type-struct="AccountChannelRequestClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpAccountChannelRequest object.</doc>
      <constructor name="new"
                   c:identifier="tp_account_channel_request_new"
                   version="0.11.12">
        <doc xml:whitespace="preserve">Convenience function to create a new #TpAccountChannelRequest object.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAccountChannelRequest object</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested properties of the channel (see #TpAccountChannelRequest:request)</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time of the user action that caused this request, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time)</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="create_and_handle_channel_async"
              c:identifier="tp_account_channel_request_create_and_handle_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_create_and_handle_channel_finish() to get the
result of the operation.

(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_create_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)

The caller is responsible for closing the channel with
tp_cli_channel_call_close() when it has finished handling it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_handle_channel_finish"
              c:identifier="tp_account_channel_request_create_and_handle_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_handle_channel_async().

See tp_account_channel_request_ensure_and_handle_channel_finish()
for details of how @context can be used.

The caller is responsible for closing the channel with
tp_cli_channel_call_close() when it has finished handling it.

channel was successfully created and you are handling it, otherwise %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference on a #TpChannel if the</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer used to return a reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_observe_channel_async"
              c:identifier="tp_account_channel_request_create_and_observe_channel_async"
              version="0.13.14">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation and a #TpChannel representing the channel
which has been created. Note that you are &lt;emphasis&gt;not&lt;/emphasis&gt; handling
this channel and so should interact with the channel as an Observer.
See &lt;ulink url="http://telepathy.freedesktop.org/doc/book/sect.channel-dispatcher.clients.html"&gt;
the Telepathy book&lt;/ulink&gt; for details about how clients should interact
with channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_and_observe_channel_finish"
              c:identifier="tp_account_channel_request_create_and_observe_channel_finish"
              version="0.13.14"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_observe_channel_async().

successfully created and dispatched, otherwise %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpChannel if the channel was</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_async"
              c:identifier="tp_account_channel_request_create_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls CreateChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_channel_finish"
              c:identifier="tp_account_channel_request_create_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_channel_async().

otherwise %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel was successfully created and dispatched,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_handle_channel_async"
              c:identifier="tp_account_channel_request_ensure_and_handle_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
that you are going to handle yourself.
When the operation is finished, @callback will be called. You can then call
tp_account_channel_request_ensure_and_handle_channel_finish() to get the
result of the operation.

If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS. The other handler
will be notified that the channel was requested again (for instance
with #TpAccountChannelRequest::re-handled,
#TpBaseClientClassHandleChannelsImpl or #TpSimpleHandler:callback),
and can move its window to the foreground, if applicable.

(Behind the scenes, this works by creating a temporary #TpBaseClient, then
acting like tp_account_channel_request_ensure_channel_async() with the
temporary #TpBaseClient as the @preferred_handler.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_handle_channel_finish"
              c:identifier="tp_account_channel_request_ensure_and_handle_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_and_handle_channel_async().

If the channel already exists and is already being handled, or if a
newly created channel is sent to a different handler, this operation
will fail with the error %TP_ERROR_NOT_YOURS.

@context can be used to obtain extensible information about the channel
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the caller of this method
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().

channel was successfully created and you are handling it, otherwise %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference on a #TpChannel if the</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="context"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer used to return a reference to the context of the HandleChannels() call, or %NULL</doc>
            <type name="HandleChannelsContext"
                  c:type="TpHandleChannelsContext**"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_observe_channel_async"
              c:identifier="tp_account_channel_request_ensure_and_observe_channel_async"
              version="0.13.14">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.
@callback will be called when the channel has been created and dispatched,
or the request has failed.
You can then call tp_account_channel_request_create_channel_finish() to
get the result of the operation and a #TpChannel representing the channel
which has been created. Note that you are &lt;emphasis&gt;not&lt;/emphasis&gt; handling
this channel and so should interact with the channel as an Observer.
See &lt;ulink url="http://telepathy.freedesktop.org/doc/book/sect.channel-dispatcher.clients.html"&gt;
the Telepathy book&lt;/ulink&gt; for details about how clients should interact
with channels.

If a suitable channel already existed, its handler will be notified that
the channel was requested again (for instance with
#TpAccountChannelRequest::re-handled, #TpBaseClientClassHandleChannelsImpl
or #TpSimpleHandler:callback, if it is implemented using Telepathy-GLib),
so that it can re-present the window to the user, for example.
Otherwise, a new channel will be created and dispatched to a handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_and_observe_channel_finish"
              c:identifier="tp_account_channel_request_ensure_and_observe_channel_finish"
              version="0.13.14"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_create_and_observe_channel_async().

successfully ensure and (re-)dispatched, otherwise %NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpChannel if the channel was</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_async"
              c:identifier="tp_account_channel_request_ensure_channel_async"
              version="0.11.12">
        <doc xml:whitespace="preserve">Asynchronously calls EnsureChannel on the ChannelDispatcher to create a
channel with the properties defined in #TpAccountChannelRequest:request
and let the ChannelDispatcher dispatch it to an handler.

If a suitable channel already existed, its handler will be notified that
the channel was requested again (for instance with
#TpAccountChannelRequest::re-handled, #TpBaseClientClassHandleChannelsImpl
or #TpSimpleHandler:callback, if it is implemented using Telepathy-GLib),
so that it can re-present the window to the user, for example.
Otherwise, a new channel will be created and dispatched to a handler.

@callback will be called when an existing channel's handler has been
notified, a new channel has been created and dispatched, or the request
has failed.
You can then call tp_account_channel_request_ensure_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channel, or %NULL to indicate that any handler would be acceptable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel_finish"
              c:identifier="tp_account_channel_request_ensure_channel_finish"
              version="0.11.12"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel creation started using
tp_account_channel_request_ensure_channel_async().

otherwise %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel was successfully ensured and (re-)dispatched,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_account"
              c:identifier="tp_account_channel_request_get_account"
              version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:account construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_channel_request"
              c:identifier="tp_account_channel_request_get_channel_request"
              version="0.13.13">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:channel-request property

#TpAccountChannelRequest:channel-request</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <type name="ChannelRequest" c:type="TpChannelRequest*"/>
        </return-value>
      </method>
      <method name="get_request"
              c:identifier="tp_account_channel_request_get_request"
              version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:request construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:request</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="get_user_action_time"
              c:identifier="tp_account_channel_request_get_user_action_time"
              version="0.11.12">
        <doc xml:whitespace="preserve">Return the #TpAccountChannelRequest:user-action-time construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpAccountChannelRequest:user-action-time</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_account_channel_request_set_channel_factory"
              version="0.13.2"
              deprecated="since 0.15.5. The factory is taken from">
        <doc xml:whitespace="preserve">Set @factory as the #TpClientChannelFactory that will be used to
create the channel requested by @self.
By default #TpAutomaticProxyFactory is used.

This function can't be called once @self has been used to request a
channel.

#TpAccountChannelRequest:account.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpClientChannelFactory</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegate_to_preferred_handler"
              c:identifier="tp_account_channel_request_set_delegate_to_preferred_handler"
              version="0.15.3">
        <doc xml:whitespace="preserve">If @delegate is %TRUE, asks to the client currently handling the channels to
delegate them to the preferred handler (passed when calling
tp_account_channel_request_ensure_channel_async() for example).

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delegate" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE to request to delegate channels</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegated_channel_callback"
              c:identifier="tp_account_channel_request_set_delegated_channel_callback"
              version="0.15.3">
        <doc xml:whitespace="preserve">Turn on support for
the org.freedesktop.Telepathy.ChannelRequest.DelegateToPreferredHandler
hint.

When receiving a request containing this hint, @self will automatically
delegate the channel to the preferred handler of the request and then call
@callback to inform the client that it is no longer handling this channel.

@callback may be called any time after (and only after) requesting and
handling the channel (i.e. you have called create_and_handle or
ensure_and_handle).

This function can't be called once @self has been used to request a
channel.

See also: tp_base_client_set_delegated_channels_callback()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">function called the channel requested using @self is delegated, may not be %NULL</doc>
            <type name="AccountChannelRequestDelegatedChannelCb"
                  c:type="TpAccountChannelRequestDelegatedChannelCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the @user_data as argument, when @self is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hints"
              c:identifier="tp_account_channel_request_set_hints"
              version="0.13.14">
        <doc xml:whitespace="preserve">Set additional information about the channel request, which will be used
as the value for the resulting request's #TpChannelRequest:hints property.

This function can't be called once @self has been used to request a
channel.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TP_HASH_TYPE_STRING_VARIANT_MAP</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.12"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount used to request the channel.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channel-request" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpChannelRequest used to request the channel, or %NULL if the
channel has not be requested yet.

This can be useful for example to compare with the #TpChannelRequest
objects received from the requests_satisfied argument of
#TpSimpleHandlerHandleChannelsImpl to check if the client is asked to
handle the channel it just requested.

Note that the #TpChannelRequest objects may be different while still
representing the same ChannelRequest on D-Bus. You have to compare
them using their object paths (tp_proxy_get_object_path()).

Since 0.13.13</doc>
        <type name="ChannelRequest"/>
      </property>
      <property name="request"
                version="0.11.12"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The desired D-Bus properties for the channel, represented as a
#GHashTable where the keys are strings and the values are #GValue.

This property can't be %NULL.</doc>
        <type/>
      </property>
      <property name="user-action-time"
                version="0.11.12"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user action time that will be passed to the channel dispatcher when
requesting the channel.

This may be the time at which user action occurred, or one of the special
values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME.

If %TP_USER_ACTION_TIME_NOT_USER_ACTION, the action doesn't involve any
user action. Clients should avoid stealing focus when presenting the
channel.

If %TP_USER_ACTION_TIME_CURRENT_TIME, clients SHOULD behave as though the
user action happened at the current time, e.g. a client may
request that its window gains focus.

On X11-based systems, Gdk 2.x, Clutter 1.0 etc.,
tp_user_action_time_from_x11() can be used to convert an X11 timestamp to
a Telepathy user action time.

If the channel request succeeds, this user action time will be passed on
to the channel's handler. If the handler is a GUI, it may use
tp_user_action_time_should_present() to decide whether to bring its
window to the foreground.</doc>
        <type name="gint64"/>
      </property>
      <glib:signal name="re-handled"
                   when="last"
                   detailed="1"
                   version="0.11.12">
        <doc xml:whitespace="preserve">Emitted when the channel created using @self has been "re-handled".

This means that a Telepathy client has made another request for a
matching channel using an "ensure" API like
tp_account_channel_request_ensure_channel_async(), while the channel
still exists. Instead of creating a new channel, the channel dispatcher
notifies the existing handler of @channel, resulting in this signal.

Most GUI handlers should respond to this signal by checking
@user_action_time, and if appropriate, moving to the foreground.

@context can be used to obtain extensible information about the channel
via tp_handle_channels_context_get_handler_info(), and any similar methods
that are added in future. It is not valid for the receiver of this signal
to call tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel being re-handled</doc>
            <type name="Channel"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME; see #TpAccountChannelRequest:user-action-time</doc>
            <type name="gint64"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of the HandleChannels() call.</doc>
            <type name="HandleChannelsContext"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountChannelRequestClass"
            c:type="TpAccountChannelRequestClass"
            disguised="1"
            glib:is-gtype-struct-for="AccountChannelRequest"
            version="0.11.12">
      <doc xml:whitespace="preserve">The class of a #TpAccountChannelRequest.</doc>
    </record>
    <callback name="AccountChannelRequestDelegatedChannelCb"
              c:type="TpAccountChannelRequestDelegatedChannelCb"
              version="0.15.3">
      <doc xml:whitespace="preserve">Called when a client asked us to delegate @channel to another Handler.
When this function is called you are no longer handling @channel.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="request" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccountChannelRequest instance</doc>
          <type name="AccountChannelRequest"
                c:type="TpAccountChannelRequest*"/>
        </parameter>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpChannel</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_account_channel_request_set_delegated_channel_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AccountChannelRequestPrivate"
            c:type="TpAccountChannelRequestPrivate"
            disguised="1">
    </record>
    <record name="AccountClass"
            c:type="TpAccountClass"
            glib:is-gtype-struct-for="Account">
      <doc xml:whitespace="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountClassPrivate" c:type="TpAccountClassPrivate*"/>
      </field>
    </record>
    <record name="AccountClassPrivate"
            c:type="TpAccountClassPrivate"
            disguised="1">
    </record>
    <class name="AccountManager"
           c:symbol-prefix="account_manager"
           c:type="TpAccountManager"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpAccountManager"
           glib:get-type="tp_account_manager_get_type"
           glib:type-struct="AccountManagerClass">
      <doc xml:whitespace="preserve">The Telepathy Account Manager stores real-time communication accounts and
their configuration, places accounts online on request, and manipulates
accounts' presence, nicknames and avatars.

#TpAccountManager is the "top level" object, its #TpProxy:factory will be
propagated to all other objects like #TpAccountManager -&gt; #TpAccount -&gt;
#TpConnection -&gt; #TpContact and #TpChannel. This means that desired features
set on that factory will be prepared on all those objects.

&lt;example id="account-manager"&gt;&lt;title&gt;TpAccountManager example&lt;/title&gt;&lt;programlisting&gt;&lt;xi:include xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" href="../../../examples/client/contact-list.c"&gt;&lt;xi:fallback&gt;FIXME: MISSING XINCLUDE CONTENT&lt;/xi:fallback&gt;&lt;/xi:include&gt;&lt;/programlisting&gt;&lt;/example&gt;</doc>
      <constructor name="new" c:identifier="tp_account_manager_new">
        <doc xml:whitespace="preserve">Convenience function to create a new account manager proxy. The returned
#TpAccountManager is not guaranteed to be ready on return.

Use tp_account_manager_dup() instead if you want an account manager proxy
on the starter or session bus (which is almost always the right thing for
Telepathy).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account manager proxy</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_account_manager_new_with_factory">
        <doc xml:whitespace="preserve">Convenience function to create a new account manager proxy. The returned
#TpAccountManager is not guaranteed to be ready on return.

Should be used only by applications having their own #TpSimpleClientFactory
subclass. Usually this should be done at application startup and followed by
a call to tp_account_manager_set_default() to ensure other libraries/plugins
will use this custom factory as well.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an account manager proxy</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSimpleClientFactory</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="dup"
                c:identifier="tp_account_manager_dup"
                version="0.9.0">
        <doc xml:whitespace="preserve">Returns an account manager proxy on the D-Bus daemon on which this
process was activated (if it was launched by D-Bus service activation), or
the session bus (otherwise).

The returned #TpAccountManager is cached; the same #TpAccountManager object
will be returned by this function repeatedly, as long as at least one
reference exists. Note that the returned #TpAccountManager is not guaranteed
to be ready on return.

bus, or %NULL if it wasn't possible to get a dbus daemon proxy for
the appropriate bus</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an account manager proxy on the starter or session</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_account_manager_get_feature_quark_core"
                version="0.9.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpAccountManager</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for representing the core feature of a</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_account_manager_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpAccountManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_ACCOUNT_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="create_account_async"
              c:identifier="tp_account_manager_create_account_async"
              version="0.9.0">
        <doc xml:whitespace="preserve">Requests an asynchronous create of an account on the account manager
@manager. When the operation is finished, @callback will be called. You can
then call tp_account_manager_create_account_finish() to get the result of
the operation.

@callback will only be called when the newly created #TpAccount has the
%TP_ACCOUNT_FEATURE_CORE feature ready on it, so when calling
tp_account_manager_create_account_finish(), one can guarantee this feature
will be ready.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="connection_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a connection manager</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="display_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the display name for the account</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">parameters for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">properties for the new account</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_account_finish"
              c:identifier="tp_account_manager_create_account_finish"
              version="0.9.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async create account operation, and returns a new #TpAccount
object, with the %TP_ACCOUNT_FEATURE_CORE feature ready on it.

The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept.

success, otherwise %NULL</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #TpAccount which was just created on</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="enable_restart"
              c:identifier="tp_account_manager_enable_restart">
        <doc xml:whitespace="preserve">Enable autostarting the account manager D-Bus service. This means
that the account manager will be restarted if it disappears from
the bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="ensure_account"
              c:identifier="tp_account_manager_ensure_account"
              version="0.9.0"
              deprecated="New code should use tp_simple_client_factory_ensure_account()">
        <doc xml:whitespace="preserve">Lookup an account in the account manager @manager. If the desired account
has already been ensured then the same object will be returned, otherwise
it will create a new #TpAccount and add it to @manager. As a result, if
@manager thinks that the account doesn't exist, this will still add it to
@manager to avoid races. Note that the returned #TpAccount is not guaranteed
to be ready on return.

The caller must keep a ref to the returned object using g_object_ref() if
it is to be kept.

not a valid account path.

instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #TpAccount at @path, or %NULL if @path is</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path for an account</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_most_available_presence"
              c:identifier="tp_account_manager_get_most_available_presence"
              version="0.9.0">
        <doc xml:whitespace="preserve">Gets the most available presence over all accounts in @manager. This
function does not average presences across all accounts, but it merely
finds the "most available" presence. As a result, there is a guarantee
that there exists at least one account in @manager with the returned
presence.

If no accounts are enabled or valid the output will be
(%TP_CONNECTION_PRESENCE_TYPE_OFFLINE, "offline", "").

The return value of this function is not guaranteed to have been retrieved
until tp_proxy_prepare_async() has finished; until then, the
value will be the same as if no accounts are enabled or valid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the most available presence across all accounts</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
        <parameters>
          <parameter name="status"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a string to fill with the actual status</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a string to fill with the actual status message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valid_accounts"
              c:identifier="tp_account_manager_get_valid_accounts"
              version="0.9.0">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of valid accounts in @manager. The list
must be freed with g_list_free() after used. None of the accounts in the
returned list are guaranteed to be ready.

Note that the #TpAccount&lt;!-- --&gt;s in the returned #GList are not reffed
before returning from this function. One could ref every item in the list
like the following example:
|[
GList *accounts;
account = tp_account_manager_get_valid_accounts (manager);
g_list_foreach (accounts, (GFunc) g_object_ref, NULL);
]|

The returned #TpAccount&lt;!-- --&gt;s are guaranteed to have
%TP_ACCOUNT_FEATURE_CORE prepared, along with all features previously passed
to tp_simple_client_factory_add_account_features().

The list of valid accounts returned is not guaranteed to have been retrieved
until %TP_ACCOUNT_MANAGER_FEATURE_CORE is prepared
(tp_proxy_prepare_async() has returned). Until this feature has
been prepared, an empty list (%NULL) will be returned.</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a newly allocated #GList of valid accounts in @manager</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Account"/>
          </type>
        </return-value>
      </method>
      <method name="is_prepared"
              c:identifier="tp_account_manager_is_prepared"
              version="0.9.0"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same thing as tp_proxy_is_prepared()</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature which is required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async"
              c:identifier="tp_account_manager_prepare_async"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_async() instead.">
        <doc xml:whitespace="preserve">Requests an asynchronous preparation of @manager with
%TP_ACCOUNT_MANAGER_FEATURE_CORE, plus any features specified
by @features. When the operation is finished, @callback will be called. You
can then call tp_account_manager_prepare_finish() to get the result of the
operation.

If %NULL is given to @callback, then no callback will be called when the
operation is finished. Instead, it will simply set @features on @manager.
Note that if @callback is %NULL, then @user_data must also be %NULL.

In version 0.11.3 or later, this is equivalent to calling
tp_proxy_prepare_async() with the same arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">a 0-terminated list of features, or %NULL</doc>
            <type name="GLib.Quark" c:type="GQuark*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_account_manager_prepare_finish"
              version="0.9.0"
              introspectable="0"
              deprecated="since 0.15.6, use tp_proxy_prepare_finish() instead."
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async preparation of the account manager @manager.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the preparation was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_all_requested_presences"
              c:identifier="tp_account_manager_set_all_requested_presences"
              version="0.9.0">
        <doc xml:whitespace="preserve">Iterates through the accounts in @manager and requests the presence
(@type, @status and @message). Note that the presence requested here is
merely a request, and if might not be satisfiable.

You can find the most available presence across all accounts by calling
tp_account_manager_get_most_available_presence().

Setting a requested presence on all accounts will have no effect
until tp_proxy_prepare_async()
(or the older tp_account_manager_prepare_async()) has finished.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a presence type to request</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status to request</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a status message to request</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default"
              c:identifier="tp_account_manager_set_default"
              version="0.15.5">
        <doc xml:whitespace="preserve">Define the #TpAccountManager singleton that will be returned by
tp_account_manager_dup().

This function may only be called before the first call to
tp_account_manager_dup(), and may not be called more than once. Applications
which use a custom #TpSimpleClientFactory and want the default
#TpAccountManager to use that factory should call this after calling
tp_account_manager_new_with_factory().

Note that @manager must use the default #TpDBusDaemon as returned by
tp_dbus_daemon_dup()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountManagerPrivate" c:type="TpAccountManagerPrivate*"/>
      </field>
      <glib:signal name="account-disabled" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account from @manager is disabled.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-enabled" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account from @manager is enabled.

@account is guaranteed to have %TP_ACCOUNT_FEATURE_CORE prepared, along
with all features previously passed to
tp_simple_client_factory_add_account_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-removed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when an account is removed from @manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="account-validity-changed" when="last" version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the validity on @account changes.

@account is guaranteed to have %TP_ACCOUNT_FEATURE_CORE prepared, along
with all features previously passed to
tp_simple_client_factory_add_account_features().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account"/>
          </parameter>
          <parameter name="valid" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the account is now valid</doc>
            <type name="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="most-available-presence-changed"
                   when="last"
                   version="0.9.0">
        <doc xml:whitespace="preserve">Emitted when the most available presence on @manager changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">new presence type</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">new status</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">new status message</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AccountManagerClass"
            c:type="TpAccountManagerClass"
            glib:is-gtype-struct-for="AccountManager">
      <doc xml:whitespace="preserve">The class of a #TpAccount.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AccountManagerClassPrivate"
              c:type="TpAccountManagerClassPrivate*"/>
      </field>
    </record>
    <record name="AccountManagerClassPrivate"
            c:type="TpAccountManagerClassPrivate"
            disguised="1">
    </record>
    <record name="AccountManagerPrivate"
            c:type="TpAccountManagerPrivate"
            disguised="1">
    </record>
    <record name="AccountPrivate" c:type="TpAccountPrivate" disguised="1">
    </record>
    <class name="AddDispatchOperationContext"
           c:symbol-prefix="add_dispatch_operation_context"
           c:type="TpAddDispatchOperationContext"
           version="0.11.5"
           parent="GObject.Object"
           glib:type-name="TpAddDispatchOperationContext"
           glib:get-type="tp_add_dispatch_operation_context_get_type"
           glib:type-struct="AddDispatchOperationContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Approver.AddDispatchOperation()
call.</doc>
      <method name="accept"
              c:identifier="tp_add_dispatch_operation_context_accept"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delay"
              c:identifier="tp_add_dispatch_operation_context_delay"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpAddDispatchOperationContext before calling this function, and
is responsible for calling either
tp_add_dispatch_operation_context_accept() or
tp_add_dispatch_operation_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail"
              c:identifier="tp_add_dispatch_operation_context_fail"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.5"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
AddDispatchOperation call.
Can only be written during construction.</doc>
        <type name="gpointer"/>
      </property>
      <property name="dispatch-operation"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to AddDispatchOperation.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="ChannelDispatchOperation"/>
      </property>
    </class>
    <record name="AddDispatchOperationContextClass"
            c:type="TpAddDispatchOperationContextClass"
            disguised="1"
            glib:is-gtype-struct-for="AddDispatchOperationContext"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpAddDispatchOperationContext.</doc>
    </record>
    <record name="AddDispatchOperationContextPrivate"
            c:type="TpAddDispatchOperationContextPrivate"
            disguised="1">
    </record>
    <bitfield name="AnonymityModeFlags" c:type="TpAnonymityModeFlags">
      <member name="client_info"
              value="1"
              c:identifier="TP_ANONYMITY_MODE_CLIENT_INFO"/>
      <member name="show_client_info"
              value="2"
              c:identifier="TP_ANONYMITY_MODE_SHOW_CLIENT_INFO"/>
      <member name="network_info"
              value="4"
              c:identifier="TP_ANONYMITY_MODE_NETWORK_INFO"/>
    </bitfield>
    <class name="AutomaticClientFactory"
           c:symbol-prefix="automatic_client_factory"
           c:type="TpAutomaticClientFactory"
           version="0.15.5"
           parent="SimpleClientFactory"
           glib:type-name="TpAutomaticClientFactory"
           glib:get-type="tp_automatic_client_factory_get_type"
           glib:type-struct="AutomaticClientFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpAutomaticClientFactory</doc>
      <constructor name="new"
                   c:identifier="tp_automatic_client_factory_new"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Returns a new #TpAutomaticClientFactory instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAutomaticClientFactory</doc>
          <type name="AutomaticClientFactory"
                c:type="TpAutomaticClientFactory*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <field name="parent" readable="0" private="1">
        <type name="SimpleClientFactory" c:type="TpSimpleClientFactory"/>
      </field>
    </class>
    <record name="AutomaticClientFactoryClass"
            c:type="TpAutomaticClientFactoryClass"
            glib:is-gtype-struct-for="AutomaticClientFactory"
            version="0.15.5">
      <doc xml:whitespace="preserve">The class of a #TpAutomaticClientFactory.</doc>
      <field name="parent_class">
        <type name="SimpleClientFactoryClass"
              c:type="TpSimpleClientFactoryClass"/>
      </field>
    </record>
    <class name="AutomaticProxyFactory"
           c:symbol-prefix="automatic_proxy_factory"
           c:type="TpAutomaticProxyFactory"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpAutomaticProxyFactory"
           glib:get-type="tp_automatic_proxy_factory_get_type"
           glib:type-struct="AutomaticProxyFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpAutomaticProxyFactory</doc>
      <implements name="ClientChannelFactory"/>
      <constructor name="new"
                   c:identifier="tp_automatic_proxy_factory_new"
                   version="0.13.2"
                   deprecated="New code should use #TpAutomaticClientFactory instead">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpAutomaticProxyFactory instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpAutomaticProxyFactory</doc>
          <type name="AutomaticProxyFactory"
                c:type="TpAutomaticProxyFactory*"/>
        </return-value>
      </constructor>
      <function name="dup"
                c:identifier="tp_automatic_proxy_factory_dup"
                version="0.13.2"
                deprecated="New code should use #TpAutomaticClientFactory instead">
        <doc xml:whitespace="preserve">Returns a cached #TpAutomaticProxyFactory; the same
#TpAutomaticProxyFactory object will be returned by this function repeatedly,
as long as at least one reference exists.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #TpAutomaticProxyFactory</doc>
          <type name="AutomaticProxyFactory"
                c:type="TpAutomaticProxyFactory*"/>
        </return-value>
      </function>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="AutomaticProxyFactoryClass"
            c:type="TpAutomaticProxyFactoryClass"
            glib:is-gtype-struct-for="AutomaticProxyFactory"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpAutomaticProxyFactory.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="AvatarRequirements"
            c:type="TpAvatarRequirements"
            version="0.11.4"
            glib:type-name="TpAvatarRequirements"
            glib:get-type="tp_avatar_requirements_get_type"
            c:symbol-prefix="avatar_requirements">
      <doc xml:whitespace="preserve">The requirements for setting an avatar on a particular protocol.</doc>
      <field name="supported_mime_types" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="minimum_width" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="minimum_height" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="recommended_width" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="recommended_height" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_width" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_height" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="maximum_bytes" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="tp_avatar_requirements_new"
                   version="0.11.4">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_avatar_requirements_destroy()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpAvatarRequirements, free it with</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
        <parameters>
          <parameter name="supported_mime_types" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of supported MIME types (e.g. "image/jpeg") Clients MAY assume that the first type in this array is preferred</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="minimum_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">The minimum width in pixels of an avatar, which MAY be 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="minimum_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">The minimum height in pixels of an avatar, which MAY be 0</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">The recommended width in pixels of an avatar, or 0 if there is no preferred width.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="recommended_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">The recommended height in pixels of an avatar, or 0 if there is no preferred height</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_width" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum width in pixels of an avatar on this protocol, or 0 if there is no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_height" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum height in pixels of an avatar, or 0 if there is no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="maximum_bytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">he maximum size in bytes of an avatar, or 0 if there is no limit.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="tp_avatar_requirements_copy"
              version="0.11.4"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_avatar_requirements_destroy()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpAvatarRequirements, free it with</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="destroy"
              c:identifier="tp_avatar_requirements_destroy"
              version="0.11.4"
              introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #TpAvatarRequirements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <class name="BaseClient"
           c:symbol-prefix="base_client"
           c:type="TpBaseClient"
           version="0.11.5"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TpBaseClient"
           glib:get-type="tp_base_client_get_type"
           glib:type-struct="BaseClientClass">
      <doc xml:whitespace="preserve">Data structure representing a generic #TpSvcClient implementation.</doc>
      <function name="implement_add_dispatch_operation"
                c:identifier="tp_base_client_implement_add_dispatch_operation"
                version="0.11.5"
                introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
AddDispatchOperation() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.add_dispatch_operation function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClassAddDispatchOperationImpl function implementing AddDispatchOperation()</doc>
            <type name="BaseClientClassAddDispatchOperationImpl"
                  c:type="TpBaseClientClassAddDispatchOperationImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_handle_channels"
                c:identifier="tp_base_client_implement_handle_channels"
                version="0.11.6"
                introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
HandleChannels() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.handle_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClassHandleChannelsImpl function implementing HandleCHannels()</doc>
            <type name="BaseClientClassHandleChannelsImpl"
                  c:type="TpBaseClientClassHandleChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <function name="implement_observe_channels"
                c:identifier="tp_base_client_implement_observe_channels"
                version="0.11.5"
                introspectable="0">
        <doc xml:whitespace="preserve">Called by subclasses to define the actual implementation of the
ObserveChannels() D-Bus method.

Since 0.11.13 this is exactly equivalent to setting the
#TpBaseClientClass.observe_channels function pointer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="klass" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClass of the object</doc>
            <type name="BaseClientClass" c:type="TpBaseClientClass*"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClientClassObserveChannelsImpl function implementing ObserveChannels()</doc>
            <type name="BaseClientClassObserveChannelsImpl"
                  c:type="TpBaseClientClassObserveChannelsImpl"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_account_features"
              c:identifier="tp_base_client_add_account_features"
              version="0.11.14"
              deprecated="New code should use">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpAccount (in
addition to %TP_ACCOUNT_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels, or emitting
#TpBaseClient::request-added.

tp_simple_client_factory_add_account_features() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features_varargs"
              c:identifier="tp_base_client_add_account_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should use">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_account_features(), but with a more
convenient calling convention from C.

tp_simple_client_factory_add_account_features_varargs() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_approver_filter"
              c:identifier="tp_base_client_add_approver_filter"
              version="0.11.5">
        <doc xml:whitespace="preserve">Register a new channel class as Approver.ApproverChannelFilter.
The #TpBaseClientClass.add_dispatch_operation virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.add_dispatch_operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features"
              c:identifier="tp_base_client_add_channel_features"
              version="0.11.14"
              deprecated="New code should use">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpChannel (in
addition to %TP_CHANNEL_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels.

tp_simple_client_factory_add_channel_features() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features_varargs"
              c:identifier="tp_base_client_add_channel_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should use">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_channel_features(), but with a more
convenient calling convention from C.

tp_simple_client_factory_add_channel_features_varargs() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features"
              c:identifier="tp_base_client_add_connection_features"
              version="0.11.14"
              deprecated="New code should use">
        <doc xml:whitespace="preserve">Request that the given features are prepared on each #TpConnection (in
addition to %TP_CONNECTION_FEATURE_CORE) before calling
#TpBaseClientClass.observe_channels,
#TpBaseClientClass.add_dispatch_operation or
#TpBaseClientClass.handle_channels.

tp_simple_client_factory_add_connection_features() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">the features</doc>
            <array length="1" zero-terminated="0" c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of features, or -1 if @features is 0-terminated</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features_varargs"
              c:identifier="tp_base_client_add_connection_features_varargs"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should use">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_connection_features(), but with a more
convenient calling convention from C.

tp_simple_client_factory_add_connection_features_varargs() instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities"
              c:identifier="tp_base_client_add_handler_capabilities"
              version="0.11.6">
        <doc xml:whitespace="preserve">Add several capability tokens to this client. These are used to signal
that Telepathy connection managers should advertise certain capabilities
to other contacts, such as the ability to receive audio/video calls using
particular streaming protocols and codecs.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tokens" transfer-ownership="none">
            <doc xml:whitespace="preserve">capability tokens as defined by the Telepathy D-Bus API Specification</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capabilities_varargs"
              c:identifier="tp_base_client_add_handler_capabilities_varargs"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Convenience C API equivalent to calling
tp_base_client_add_handler_capability() for each capability token.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a capability token from the Telepathy D-Bus API Specification</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_capability"
              c:identifier="tp_base_client_add_handler_capability"
              version="0.11.6">
        <doc xml:whitespace="preserve">Add one capability token to this client, as if via
tp_base_client_add_handler_capabilities().

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a capability token as defined by the Telepathy D-Bus API Specification</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_handler_filter"
              c:identifier="tp_base_client_add_handler_filter"
              version="0.11.6">
        <doc xml:whitespace="preserve">Register a new channel class as Handler.HandlerChannelFilter.
The #TpBaseClientClass.handle_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="add_observer_filter"
              c:identifier="tp_base_client_add_observer_filter"
              version="0.11.5">
        <doc xml:whitespace="preserve">Register a new channel class as Observer.ObserverChannelFilter.
The #TpBaseClientClass.observe_channels virtual method will be called
whenever a new channel's properties match the ones in @filter.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a %TP_HASH_TYPE_CHANNEL_CLASS</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="be_a_handler"
              c:identifier="tp_base_client_be_a_handler"
              version="0.11.6">
        <doc xml:whitespace="preserve">Register @self as a Client.Handler with an empty list of filters.
This is useful if you want to create a client that only handle channels
for which it's the PreferredHandler.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delegate_channels_async"
              c:identifier="tp_base_client_delegate_channels_async"
              version="0.15.0">
        <doc xml:whitespace="preserve">Asynchronously calls DelegateChannels on the ChannelDispatcher to try
stopping handling @channels and pass them to another Handler.
You can then call tp_base_client_delegate_channels_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpChannel handled by @self</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Channel"/>
            </type>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or #TP_USER_ACTION_TIME_NOT_USER_ACTION if this delegation request is for some reason not involving user action.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="preferred_handler" transfer-ownership="none">
            <doc xml:whitespace="preserve">Either the well-known bus name (starting with %TP_CLIENT_BUS_NAME_BASE) of the preferred handler for the channels, or %NULL to indicate that any handler but @self would be acceptable.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delegate_channels_finish"
              c:identifier="tp_base_client_delegate_channels_finish"
              version="0.15.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channels delegation request started using
tp_base_client_delegate_channels_async().

can be used to know the channels that @self is not handling any more,
otherwise %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation succeed, @delegated and @not_delegated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="delegated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:whitespace="preserve"> if not %NULL, used to return a #GPtrArray containing the #TpChannel&lt;!-- --&gt;s which have been properly delegated</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="Channel"/>
            </array>
          </parameter>
          <parameter name="not_delegated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="container">
            <doc xml:whitespace="preserve"> if not not %NULL, used to return a #GHashTable mapping #TpChannel&lt;!-- --&gt;s which have not been delegated to a #GError explaining the reason of the failure</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="Channel"/>
              <type name="GLib.Error"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_account_manager"
              c:identifier="tp_base_client_get_account_manager"
              version="0.11.14"
              introspectable="0"
              deprecated="New code should not use this function, it may return %NULL in">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:account-manager construct-only property, which
is the account manager used to look up or create #TpAccount objects.

The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.

It is not guaranteed that any particular features are prepared on this
object; enable and wait for features with tp_proxy_prepare_async().

the case @self was constructed with a #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:account-manager</doc>
          <type name="AccountManager" c:type="TpAccountManager*"/>
        </return-value>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_base_client_get_bus_name"
              version="0.11.5">
        <doc xml:whitespace="preserve">Return the bus name of @self. Note that doesn't mean the client is
actually owning this name; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bus name of the client</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_channel_factory"
              c:identifier="tp_base_client_get_channel_factory"
              version="0.13.2"
              introspectable="0"
              deprecated="since 0.15.5. The factory is taken from">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:channel-factory property.

#TpBaseClient:account-manager.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the value of #TpBaseClient:channel-factory</doc>
          <type name="ClientChannelFactory" c:type="TpClientChannelFactory*"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_base_client_get_dbus_daemon"
              version="0.11.11"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:dbus-daemon construct-only property, which
represents the D-Bus connection used to export this client object.

The returned object's reference count is not incremented, so it is not
necessarily valid after @self is destroyed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:dbus-daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_handled_channels"
              c:identifier="tp_base_client_get_handled_channels"
              version="0.11.6">
        <doc xml:whitespace="preserve">Returns the set of channels currently handled by this base client or by any
other #TpBaseClient with which it shares a unique name.

handled channels</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">the</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="tp_base_client_get_name"
              version="0.11.11"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:name construct-only property, which is used as
part of the bus name and object path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_object_path"
              c:identifier="tp_base_client_get_object_path"
              version="0.11.5">
        <doc xml:whitespace="preserve">Return the object path of @self. Note that doesn't mean the client is
actually registered on this path; for example if tp_base_client_register()
has not been called yet or failed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of the client</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_pending_requests"
              c:identifier="tp_base_client_get_pending_requests"
              version="0.11.6">
        <doc xml:whitespace="preserve">Only works if tp_base_client_set_handler_request_notification() has been
called.
Returns the list of requests @self is likely be asked to handle.

#GList of #TpChannelRequest</doc>
        <return-value transfer-ownership="container">
          <doc xml:whitespace="preserve">a</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <method name="get_uniquify_name"
              c:identifier="tp_base_client_get_uniquify_name"
              version="0.11.11"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpBaseClient:uniquify-name construct-only property; if this
is true, the bus name and object path will be made unique by appending
a suffix that includes the D-Bus unique name and a per-process counter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpBaseClient:uniquify-name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_handling_channel"
              c:identifier="tp_base_client_is_handling_channel"
              version="0.14.5">
        <doc xml:whitespace="preserve">Check if @self is currently handling @channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self is handling @channel, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register"
              c:identifier="tp_base_client_register"
              version="0.11.5"
              throws="1">
        <doc xml:whitespace="preserve">Publish @self as an available client. After this method is called, as long
as it continues to exist, it will receive and process whatever events were
requested via the various filters.

Methods that set the filters and other immutable state, such as
tp_base_client_add_observer_filter(), cannot be called after this one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the client was registered successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_base_client_set_channel_factory"
              version="0.13.2"
              deprecated="since 0.15.5. The factory is taken from">
        <doc xml:whitespace="preserve">Change the value of the #TpBaseClient:channel-factory property.
It can't be changed once @self has been registered.

#TpBaseClient:account-manager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object implementing the #TpClientChannelFactoryInterface interface</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delegated_channels_callback"
              c:identifier="tp_base_client_set_delegated_channels_callback"
              version="0.15.3">
        <doc xml:whitespace="preserve">Turn on support for
the org.freedesktop.Telepathy.ChannelRequest.DelegateToPreferredHandler
hint.

When receiving a request containing this hint, @self will automatically
delegate the channels to the preferred handler of the request and then call
@callback to inform the client that it is no longer handling those
channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">function called when channels currently handled by @self are delegated, may not be %NULL</doc>
            <type name="BaseClientDelegatedChannelsCb"
                  c:type="TpBaseClientDelegatedChannelsCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the @user_data as argument, when @self is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_bypass_approval"
              c:identifier="tp_base_client_set_handler_bypass_approval"
              version="0.11.6">
        <doc xml:whitespace="preserve">Set whether the channels destined for this handler are automatically
handled, without invoking approvers.
(This is implemented by setting the value of its BypassApproval
D-Bus property.)

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handler_request_notification"
              c:identifier="tp_base_client_set_handler_request_notification"
              version="0.11.6">
        <doc xml:whitespace="preserve">Indicate that @self is a Handler willing to be notified about requests for
channels that it is likely to be asked to handle. This means that the
#TpBaseClient::request-added and #TpBaseClient::request-removed signals will
be fired and tp_base_client_get_pending_requests() will return the list of
pending requests.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.handle_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_observer_delay_approvers"
              c:identifier="tp_base_client_set_observer_delay_approvers"
              version="0.13.16">
        <doc xml:whitespace="preserve">Set whether the channel dispatcher should wait for
tp_observe_channels_context_accept() or tp_observe_channels_context_fail()
to be called before calling
#TpBaseClientClass.add_dispatch_operation on appropriate Approvers.

This is implemented by setting the value of the DelayApprovers
D-Bus property.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.DelayApprovers property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_observer_recover"
              c:identifier="tp_base_client_set_observer_recover"
              version="0.11.5">
        <doc xml:whitespace="preserve">Set whether the channel dispatcher should attempt to recover
this Observer if it crashes. (This is implemented by setting
the value of its Recover D-Bus property.)

Normally, Observers are only notified when new channels
appear. If an Observer is set to recover, when it registers with
tp_base_client_register(), it will also be told about any channels
that already existed before it started.

For Observers that are activatable as a D-Bus service, if the
Observer exits or crashes while there are any channels that match
its filter, it will automatically be restarted by service-activation.

This method may only be called before tp_base_client_register() is
called, and may only be called on objects whose class implements
#TpBaseClientClass.observe_channels.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_approver_filter"
              c:identifier="tp_base_client_take_approver_filter"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_approver_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_approver_filter (client,
tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_TEXT,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
TP_HANDLE_TYPE_CONTACT,
...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve"> a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_handler_filter"
              c:identifier="tp_base_client_take_handler_filter"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_handler_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_handler_filter (client,
tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_TEXT,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
TP_HANDLE_TYPE_CONTACT,
...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve"> a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="take_observer_filter"
              c:identifier="tp_base_client_take_observer_filter"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_base_client_add_observer_filter(), but ownership of @filter
is taken by @self. This makes it convenient to call using tp_asv_new():

|[
tp_base_client_take_observer_filter (client,
tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_TEXT,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT,
TP_HANDLE_TYPE_CONTACT,
...));
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="full">
            <doc xml:whitespace="preserve"> a %TP_HASH_TYPE_CHANNEL_CLASS, ownership of which is taken by @self</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="unregister"
              c:identifier="tp_base_client_unregister"
              version="0.11.6">
        <doc xml:whitespace="preserve">Remove this client object from D-Bus, if tp_base_client_register()
has already been called.

If the object is not registered, this method may be called, but has
no effect.

Releasing the last reference to the object also has the same effect
as calling this method, but this method should be preferred, as it
has more deterministic behaviour.

If the object still exists, tp_base_client_register() may be used to
attempt to register it again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="account-manager"
                version="0.11.14"
                deprecated="New code should not use this property, it may be %NULL in"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Account manager for this base client, used to look up or create
#TpAccount objects. This may be specified in the constructor in order
to get existing #TpAccount objects.

It is not guaranteed that any of its features have been prepared, and
it is not necessary to wait for any features before specifying this
property in the constructor.

Clients that interact with the #TpAccount should usually
set this property instead of #TpBaseClient:dbus-daemon. Doing this
will ensure that each account, connection or contact is represented by
a single #TpAccount, #TpConnection or #TpContact object, shared between
all the cooperating modules that have the same #TpAccountManager.

If the #TpBaseClient:dbus-daemon is set to the result of
tp_dbus_daemon_dup(), then this property defaults to
the result of tp_account_manager_dup().

This property may be %NULL initially, but will always be non-%NULL
after the #TpBaseClient has been constructed.

It is an error to specify both a non-%NULL account manager, and a
non-%NULL #TpBaseClient:dbus-daemon that is not the same as the
account manager's #TpProxy:dbus-daemon.

the case @self was constructed with a #TpSimpleClientFactory.</doc>
        <type name="AccountManager"/>
      </property>
      <property name="channel-factory"
                version="0.13.2"
                deprecated="since 0.15.5. The factory is taken from"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The object implementing the #TpClientChannelFactoryInterface interface
that will be used to create channel proxies. While
tp_base_client_register() has not yet been called, this property can be
changed using tp_base_client_set_channel_factory().

If no channel factory is specified then #TpAutomaticProxyFactory is used.

#TpBaseClient:account-manager.</doc>
        <type name="GObject.Object"/>
      </property>
      <property name="dbus-daemon"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.

This property can't be %NULL after construction.

Since 0.11.14 this property may be %NULL or unspecified in
g_object_new(), but only if #TpBaseClient:account-manager is provided
instead, in which case its #TpProxy:dbus-daemon property will be
used.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="factory"
                version="0.15.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Factory for this base client, used to look up or create
#TpAccount objects.</doc>
        <type name="SimpleClientFactory"/>
      </property>
      <property name="name"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the client. This is used to register the D-Bus service name
and object path of the service.

This property can't be %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="uniquify-name"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, tp_base_client_register() will append an unique token to the
service bus name and object path to ensure they are unique.</doc>
        <type name="gboolean"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseClientPrivate" c:type="TpBaseClientPrivate*"/>
      </field>
      <glib:signal name="request-added"
                   when="last"
                   detailed="1"
                   version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when a channels have been requested, and that if the
request is successful, they will probably be handled by this Handler.

This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpAccount on which the request was made, with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
            <type name="Account"/>
          </parameter>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannelRequest having its object-path defined but is not guaranteed to be prepared.</doc>
            <type name="ChannelRequest"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="request-removed"
                   when="last"
                   detailed="1"
                   version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when a request has failed and should be disregarded.

This signal is only fired if
tp_base_client_set_handler_request_notification() has been called
on @self previously.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannelRequest being removed</doc>
            <type name="ChannelRequest"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the D-Bus error with which the request failed.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">any message supplied with the D-Bus error.</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BaseClientClass"
            c:type="TpBaseClientClass"
            glib:is-gtype-struct-for="BaseClient"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpBaseClient.

The virtual methods @observe_channels, @add_dispatch_operation and
@handle_channels can be also implemented by calling
tp_base_client_implement_observe_channels(),
tp_base_client_implement_add_dispatch_operation() and
tp_base_client_implement_handle_channels(). This is compatible with
telepathy-glib versions older than 0.11.13.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="observe_channels">
        <type name="BaseClientClassObserveChannelsImpl"
              c:type="TpBaseClientClassObserveChannelsImpl"/>
      </field>
      <field name="add_dispatch_operation">
        <type name="BaseClientClassAddDispatchOperationImpl"
              c:type="TpBaseClientClassAddDispatchOperationImpl"/>
      </field>
      <field name="handle_channels">
        <type name="BaseClientClassHandleChannelsImpl"
              c:type="TpBaseClientClassHandleChannelsImpl"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="dbus_properties_class"
             introspectable="0"
             readable="0"
             private="1">
        <type c:type="TpDBusPropertiesMixinClass"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseClientClassPrivate"
              c:type="TpBaseClientClassPrivate*"/>
      </field>
    </record>
    <callback name="BaseClientClassAddDispatchOperationImpl"
              c:type="TpBaseClientClassAddDispatchOperationImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the AddDispatchOperation method.

This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.

The implementation can then use
tp_channel_dispatch_operation_handle_with_async() to approve handling of the
channels, or tp_channel_dispatch_operation_claim_async() to take
responsibility for handling or closing them".</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features() or tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation having %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE prepared if possible</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="AddDispatchOperationContext"
                c:type="TpAddDispatchOperationContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassHandleChannelsImpl"
              c:type="TpBaseClientClassHandleChannelsImpl"
              version="0.11.6">
      <doc xml:whitespace="preserve">Signature of the implementation of the HandleChannels method.

This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features() or tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of this D-Bus call</doc>
          <type name="HandleChannelsContext"
                c:type="TpHandleChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseClientClassObserveChannelsImpl"
              c:type="TpBaseClientClassObserveChannelsImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the ObserveChannels method.

This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount with %TP_ACCOUNT_FEATURE_CORE, and any other features added via tp_base_client_add_account_features() or tp_simple_client_factory_add_account_features(), prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection with %TP_CONNECTION_FEATURE_CORE, and any other features added via tp_base_client_add_connection_features(), or tp_simple_client_factory_add_connection_features(), prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, each with %TP_CHANNEL_FEATURE_CORE, and any other features added via tp_base_client_add_channel_features() or tp_simple_client_factory_add_channel_features(), prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="ObserveChannelsContext"
                c:type="TpObserveChannelsContext*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseClientClassPrivate"
            c:type="TpBaseClientClassPrivate"
            disguised="1">
    </record>
    <callback name="BaseClientDelegatedChannelsCb"
              c:type="TpBaseClientDelegatedChannelsCb"
              version="0.15.3">
      <doc xml:whitespace="preserve">Called when a client asked us to delegate @channels to another Handler.
When this function is called @client is not longer handling @channels.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpBaseClient instance</doc>
          <type name="BaseClient" c:type="TpBaseClient*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GPtrArray of #TpChannel</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Channel"/>
          </array>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_base_client_set_delegated_channels_callback()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseClientPrivate"
            c:type="TpBaseClientPrivate"
            disguised="1">
    </record>
    <class name="BaseConnection"
           c:symbol-prefix="base_connection"
           c:type="TpBaseConnection"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TpBaseConnection"
           glib:get-type="tp_base_connection_get_type"
           glib:type-struct="BaseConnectionClass">
      <doc xml:whitespace="preserve">Data structure representing a generic #TpSvcConnection implementation.

In addition to the fields documented here, there are four gpointer fields
which must currently be %NULL (a meaning may be defined for these in a
future version of telepathy-glib), and a pointer to opaque private data.</doc>
      <function name="channel_manager_iter_init"
                c:identifier="tp_base_connection_channel_manager_iter_init"
                version="0.7.15"
                introspectable="0">
        <doc xml:whitespace="preserve">Initializes an iterator over the #TpChannelManager objects known to
@self.  It is intended to be used as followed:

&lt;informalexample&gt;&lt;programlisting&gt;
TpChannelManagerIter iter;
TpChannelManager *manager;

tp_base_connection_channel_manager_iter_init (&amp;amp;iter, base_conn);
while (tp_base_connection_channel_manager_iter_next (&amp;amp;iter, &amp;amp;manager))
{
...do something with manager...
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:whitespace="preserve">an uninitialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="self" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection</doc>
            <type name="BaseConnection" c:type="TpBaseConnection*"/>
          </parameter>
        </parameters>
      </function>
      <function name="channel_manager_iter_next"
                c:identifier="tp_base_connection_channel_manager_iter_next"
                version="0.7.15"
                introspectable="0">
        <doc xml:whitespace="preserve">Advances @iter, and retrieves the #TpChannelManager it now points to.  If
there are no more channel managers, @manager_out is not set and %FALSE is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if there are no more channel managers; else %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:whitespace="preserve">an initialized #TpChannelManagerIter</doc>
            <type name="ChannelManagerIter" c:type="TpChannelManagerIter*"/>
          </parameter>
          <parameter name="manager_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the channel manager, or %NULL.</doc>
            <type c:type="TpChannelManager**"/>
          </parameter>
        </parameters>
      </function>
      <function name="dbus_request_handles"
                c:identifier="tp_base_connection_dbus_request_handles"
                introspectable="0">
        <doc xml:whitespace="preserve">Implements D-Bus method RequestHandles on interface
org.freedesktop.Telepathy.Connection. Exported so subclasses can
use it as a basis for their own implementations (for instance,
at the time of writing Gabble's GabbleConnection does its own processing
for room handles, in order to validate them asynchronously, but delegates
to this implementation for all other types).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to #TpBaseConnection, cast to a pointer to #TpSvcConnection</doc>
            <type c:type="TpSvcConnection*"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle type (#TpHandleType) as a guint</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:whitespace="preserve">A strv of handle names</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:whitespace="preserve">The dbus-glib method invocation context</doc>
            <type c:type="DBusGMethodInvocation*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_client_interest"
              c:identifier="tp_base_connection_add_client_interest">
        <doc xml:whitespace="preserve">Add a "client interest" for @token on behalf of the given client.

This emits #TpBaseConnection::clients-interested if this was the first
time a client expressed an interest in this token.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="unique_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the unique bus name of a D-Bus client</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus interface or a token representing part of an interface, added with tp_base_connection_add_possible_client_interest()</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="only_if_uninterested" transfer-ownership="none">
            <doc xml:whitespace="preserve">only add to the interest count if the client is not already interested (appropriate for APIs that implicitly subscribe on first use if this has not been done already, like Location)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_interfaces"
              c:identifier="tp_base_connection_add_interfaces"
              introspectable="0">
        <doc xml:whitespace="preserve">Add some interfaces to the list supported by this Connection. If you're
going to call this function at all, you must do so before moving to state
CONNECTED (or DISCONNECTED); if you don't call it, only the set of
interfaces always present (@interfaces_always_present in
#TpBaseConnectionClass) will be supported.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">A %NULL-terminated array of D-Bus interface names, which must remain valid at least until the connection enters state #TP_CONNECTION_STATUS_DISCONNECTED (in practice, you should either use static strings, or use strdup'd strings and free them in the dispose callback).</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_possible_client_interest"
              c:identifier="tp_base_connection_add_possible_client_interest">
        <doc xml:whitespace="preserve">Add @token to the set of tokens for which this connection will emit
#TpBaseConnection::clients-interested and
#TpBaseConnection::clients-uninterested.

This method must be called from the #GObjectClass&lt;!--
--&gt;.constructed or #GObjectClass&lt;!-- --&gt;.constructor callback
(otherwise, it will run too late to be useful).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">a quark corresponding to a D-Bus interface, or a token representing part of a D-Bus interface, for which this connection wishes to be notified when clients register an interest</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_status"
              c:identifier="tp_base_connection_change_status">
        <doc xml:whitespace="preserve">Change the status of the connection. The allowed state transitions are:

&lt;itemizedlist&gt;
&lt;listitem&gt;#TP_INTERNAL_CONNECTION_STATUS_NEW 
#TP_CONNECTION_STATUS_CONNECTING&lt;/listitem&gt;
&lt;listitem&gt;#TP_CONNECTION_STATUS_CONNECTING 
#TP_CONNECTION_STATUS_CONNECTED&lt;/listitem&gt;
&lt;listitem&gt;#TP_INTERNAL_CONNECTION_STATUS_NEW 
#TP_CONNECTION_STATUS_CONNECTED (exactly equivalent to both of the above
one after the other; see below)&lt;/listitem&gt;
&lt;listitem&gt;anything except #TP_CONNECTION_STATUS_DISCONNECTED 
#TP_CONNECTION_STATUS_DISCONNECTED&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Before the transition to #TP_CONNECTION_STATUS_CONNECTED, the implementation
must have discovered the handle for the local user and passed it to
tp_base_connection_set_self_handle().

Changing from NEW to CONNECTED is implemented by doing the transition from
NEW to CONNECTING, followed by the transition from CONNECTING to CONNECTED;
it's exactly equivalent to calling tp_base_connection_change_status for
those two transitions one after the other.

Any other valid transition does the following, in this order:

&lt;itemizedlist&gt;
&lt;listitem&gt;Update #TpBaseConnection&lt;!-- --&gt;.status;&lt;/listitem&gt;
&lt;listitem&gt;If the new state is #TP_CONNECTION_STATUS_DISCONNECTED, call
tp_channel_factory_iface_close_all() on all channel factories&lt;/listitem&gt;
&lt;listitem&gt;Emit the D-Bus StatusChanged signal;&lt;/listitem&gt;
&lt;listitem&gt;Call #TpBaseConnectionClass.connecting,
#TpBaseConnectionClass.connected or #TpBaseConnectionClass.disconnected
as appropriate;&lt;/listitem&gt;
&lt;listitem&gt;Call the channel factories' status change callbacks;&lt;/listitem&gt;
&lt;listitem&gt;If the new state is #TP_CONNECTION_STATUS_DISCONNECTED, call the
subclass' #TpBaseConnectionClass.shut_down callback.&lt;/listitem&gt;
&lt;/itemizedlist&gt;

To provide more details about what happened when moving to @status
#TP_CONNECTION_STATUS_DISCONNECTED due to an error, consider calling
tp_base_connection_disconnect_with_dbus_error() instead of this function.

Changed in 0.7.35: the @self_handle member of #TpBaseConnection was
previously set to 0 at this stage. It now remains non-zero until the object
is disposed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new status</doc>
            <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason for the status change</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect_with_dbus_error"
              c:identifier="tp_base_connection_disconnect_with_dbus_error"
              version="0.7.24"
              introspectable="0">
        <doc xml:whitespace="preserve">Changes the #TpBaseConnection&lt;!-- --&gt;.status of @self to
%TP_CONNECTION_STATUS_DISCONNECTED, as if by a call to
tp_base_connection_change_status(), but additionally emits the
&lt;code&gt;ConnectionError&lt;/code&gt; D-Bus signal to provide more details about the
error.

Well-known keys for @details are documented in the Telepathy specification's
&lt;ulink url='http://telepathy.freedesktop.org/spec/Connection.html#Signal:ConnectionError'&gt;definition
of the ConnectionError signal&lt;/ulink&gt;, and include:

&lt;itemizedlist&gt;
&lt;listitem&gt;&lt;code&gt;"debug-message"&lt;/code&gt;, whose value should have type
#G_TYPE_STRING, for debugging information about the
disconnection which should not be shown to the user&lt;/listitem&gt;
&lt;listitem&gt;&lt;code&gt;"server-message"&lt;/code&gt;, whose value should also have type
#G_TYPE_STRING, for a human-readable error message from the server (in an
unspecified language) explaining why the user was
disconnected.&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The D-Bus error with which the connection changed status to Disconnected</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">Further details of the error, as a hash table where the keys are strings as defined in the Telepathy specification, and the values are #GValue&lt;!-- --&gt;s. %NULL is allowed, and treated as an empty hash table.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason code to use in the StatusChanged signal (a less specific, non-extensible version of @error_name)</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_shutdown"
              c:identifier="tp_base_connection_finish_shutdown"
              introspectable="0">
        <doc xml:whitespace="preserve">Tell the connection manager that this Connection has been disconnected,
has emitted StatusChanged and is ready to be removed from D-Bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_base_connection_get_dbus_daemon"
              version="0.11.3"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpBaseConnectionManager:dbus-daemon property. The caller must reference
the returned object with g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_handles" c:identifier="tp_base_connection_get_handles">
        <doc xml:whitespace="preserve">&lt;!----&gt;

handle type, or #NULL if it's unsupported or invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle repository corresponding to the given</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_self_handle"
              c:identifier="tp_base_connection_get_self_handle"
              version="0.7.15"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpBaseConnection:self-handle property, which is guaranteed not
to be 0 once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current self handle of the connection.</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="register"
              c:identifier="tp_base_connection_register"
              throws="1">
        <doc xml:whitespace="preserve">Make the connection object appear on the bus, returning the bus
name and object path used. If %TRUE is returned, the connection owns the
bus name, and will release it when destroyed.

Since 0.11.11, @bus_name and @object_path may be %NULL if the
strings are not needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the connection manager in the Telepathy protocol</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="bus_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Used to return the bus name corresponding to the connection if %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="object_path"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Used to return the object path of the connection if %TRUE is returned. To be freed by the caller.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_with_contacts_mixin"
              c:identifier="tp_base_connection_register_with_contacts_mixin"
              introspectable="0">
        <doc xml:whitespace="preserve">Register the Connection interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_self_handle"
              c:identifier="tp_base_connection_set_self_handle"
              version="0.7.15">
        <doc xml:whitespace="preserve">Sets the #TpBaseConnection:self-handle property.  self_handle may not be 0
once the connection has moved to the CONNECTED state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="self_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new self handle for the connection.</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <property name="dbus-daemon"
                version="0.11.3"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">#TpDBusDaemon object encapsulating this object's connection to D-Bus.
Read-only except during construction.

If this property is %NULL or omitted during construction, the object will
automatically attempt to connect to the starter or session bus with
tp_dbus_daemon_dup() just after it is constructed; if this fails, this
property will remain %NULL, and tp_base_connection_register() will fail.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="dbus-status"
                version="0.11.3"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The Connection.Status as visible on D-Bus, which is the same as
#TpBaseConnection&lt;!-- --&gt;.status except that
%TP_INTERNAL_CONNECTION_STATUS_NEW is replaced by
%TP_CONNECTION_STATUS_DISCONNECTED.

The #GObject::notify signal is not currently emitted for this property.</doc>
        <type name="guint"/>
      </property>
      <property name="has-immortal-handles"
                version="0.13.8"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">This property is not useful to use directly. Its value is %TRUE, to
indicate that this version of telepathy-glib never unreferences handles
until the connection becomes disconnected.</doc>
        <type name="gboolean"/>
      </property>
      <property name="interfaces"
                version="0.11.3"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The set of D-Bus interfaces available on this Connection, other than
Connection itself.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="protocol"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Identifier used in the Telepathy protocol when this connection's protocol
name is required.</doc>
        <type name="utf8"/>
      </property>
      <property name="self-handle"
                version="0.7.15"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The handle of type %TP_HANDLE_TYPE_CONTACT representing the local user.
Must be set nonzero by the subclass before moving to state CONNECTED.</doc>
        <type name="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="bus_name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="status">
        <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
      </field>
      <field name="self_handle">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseConnectionPrivate" c:type="TpBaseConnectionPrivate*"/>
      </field>
      <glib:signal name="clients-interested" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when a client becomes interested in any token that was added with
tp_base_connection_add_possible_client_interest().

The "signal detail" is a GQuark representing @token. Modules implementing
an interface (Location, say) should typically connect to a detailed signal
like
"clients-interested::org.freedesktop.Telepathy.Connection.Interface.Location"
rather than receiving all emissions of this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the interface or part of an interface in which clients are newly interested</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="clients-uninterested" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when no more clients are interested in an interface added with
tp_base_connection_add_possible_client_interest(), for which
#TpBaseConnection::clients-interested was previously emitted.

As with #TpBaseConnection::clients-interested, the "signal detail" is a
GQuark representing @token. Modules implementing an interface (Location,
say) should typically connect to a detailed signal like
"clients-uninterested::org.freedesktop.Telepathy.Connection.Interface.Location"
rather than receiving all emissions of this signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the interface or part of an interface in which clients are no longer interested</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="shutdown-finished"
                   when="last"
                   detailed="1"
                   introspectable="0">
        <doc xml:whitespace="preserve">Emitted by tp_base_connection_finish_shutdown() when the underlying
network connection has been closed; #TpBaseConnectionManager listens
for this signal and removes connections from its table of active
connections when it is received.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="BaseConnectionClass"
            c:type="TpBaseConnectionClass"
            glib:is-gtype-struct-for="BaseConnection">
      <doc xml:whitespace="preserve">The class of a #TpBaseConnection. Many members are virtual methods etc.
to be filled in in the subclass' class_init function.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_internal_create_handle_repos" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="create_channel_factories">
        <type name="BaseConnectionCreateChannelFactoriesImpl"
              c:type="TpBaseConnectionCreateChannelFactoriesImpl"/>
      </field>
      <field name="get_unique_connection_name">
        <type name="BaseConnectionGetUniqueConnectionNameImpl"
              c:type="TpBaseConnectionGetUniqueConnectionNameImpl"/>
      </field>
      <field name="connecting">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="connected">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="disconnected">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="shut_down">
        <type name="BaseConnectionProc" c:type="TpBaseConnectionProc"/>
      </field>
      <field name="start_connecting">
        <type name="BaseConnectionStartConnectingImpl"
              c:type="TpBaseConnectionStartConnectingImpl"/>
      </field>
      <field name="interfaces_always_present">
        <type name="utf8" c:type="gchar**"/>
      </field>
      <field name="create_channel_managers">
        <type name="BaseConnectionCreateChannelManagersImpl"
              c:type="TpBaseConnectionCreateChannelManagersImpl"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <callback name="BaseConnectionCreateChannelFactoriesImpl"
              c:type="TpBaseConnectionCreateChannelFactoriesImpl">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_channel_factories method
of #TpBaseConnection.

#TpChannelFactoryIface which, between them, implement all channel types
this Connection supports.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GPtrArray of objects implementing</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateChannelManagersImpl"
              c:type="TpBaseConnectionCreateChannelManagersImpl">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_channel_managers method
of #TpBaseConnection.

#TpChannelManager which, between them, implement all channel types this
Connection supports.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GPtrArray of objects implementing</doc>
        <array name="GLib.PtrArray" c:type="GPtrArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionCreateHandleReposImpl"
              c:type="TpBaseConnectionCreateHandleReposImpl"
              introspectable="0">
      <doc xml:whitespace="preserve">Signature of an implementation of the create_handle_repos method
of #TpBaseConnection.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of pointers to be filled in; the implementation may assume all are initially NULL.</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionGetUniqueConnectionNameImpl"
              c:type="TpBaseConnectionGetUniqueConnectionNameImpl">
      <doc xml:whitespace="preserve">Signature of the @get_unique_connection_name virtual method
on #TpBaseConnection.

within this connection manager process, as a string which the caller must
free with #g_free.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a name for this connection which will be unique</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The implementation, a subclass of TpBaseConnection</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BaseConnectionPrivate"
            c:type="TpBaseConnectionPrivate"
            disguised="1">
    </record>
    <callback name="BaseConnectionProc" c:type="TpBaseConnectionProc">
      <doc xml:whitespace="preserve">Signature of a virtual method on #TpBaseConnection that takes no
additional parameters and returns nothing.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="BaseConnectionStartConnectingImpl"
              c:type="TpBaseConnectionStartConnectingImpl"
              throws="1">
      <doc xml:whitespace="preserve">Signature of an implementation of the start_connecting method
of #TpBaseConnection.

On entry, the implementation may assume that it is in state NEW.

If %TRUE is returned, the Connect D-Bus method succeeds; the
implementation must either have already set the status to CONNECTED by
calling tp_base_connection_change_status(), or have arranged for a
status change to either state DISCONNECTED or CONNECTED to be signalled by
calling tp_base_connection_change_status() at some later time.
If the status is still NEW after returning %TRUE, #TpBaseConnection will
automatically change it to CONNECTING for reason REQUESTED.

If %FALSE is returned, the error will be raised from Connect as an
exception. If the status is not DISCONNECTED after %FALSE is returned,
#TpBaseConnection will automatically change it to DISCONNECTED
with a reason appropriate to the error; NetworkError results in
NETWORK_ERROR, PermissionDenied results in AUTHENTICATION_FAILED, and all
other errors currently result in NONE_SPECIFIED.

All except the simplest connection managers are expected to implement this
asynchronously, returning %TRUE in most cases and changing the status
to CONNECTED or DISCONNECTED later.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE if failure has already occurred, else %TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection object</doc>
          <type name="BaseConnection" c:type="TpBaseConnection*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="BasicProxyFactory"
           c:symbol-prefix="basic_proxy_factory"
           c:type="TpBasicProxyFactory"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpBasicProxyFactory"
           glib:get-type="tp_basic_proxy_factory_get_type"
           glib:type-struct="BasicProxyFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpBasicProxyFactory</doc>
      <implements name="ClientChannelFactory"/>
      <constructor name="new"
                   c:identifier="tp_basic_proxy_factory_new"
                   version="0.13.2"
                   deprecated="New code should use #TpSimpleClientFactory instead">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpBasicProxyFactory instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpBasicProxyFactory</doc>
          <type name="BasicProxyFactory" c:type="TpBasicProxyFactory*"/>
        </return-value>
      </constructor>
      <function name="dup"
                c:identifier="tp_basic_proxy_factory_dup"
                version="0.13.2"
                deprecated="New code should use #TpSimpleClientFactory instead">
        <doc xml:whitespace="preserve">Returns a cached #TpBasicProxyFactory; the same #TpBasicProxyFactory object
will be returned by this function repeatedly, as long as at least one
reference exists.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #TpBasicProxyFactory</doc>
          <type name="BasicProxyFactory" c:type="TpBasicProxyFactory*"/>
        </return-value>
      </function>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="BasicProxyFactoryClass"
            c:type="TpBasicProxyFactoryClass"
            glib:is-gtype-struct-for="BasicProxyFactory"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpBasicProxyFactory.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <constant name="CHANNEL_DISPATCHER_BUS_NAME"
              value="org.freedesktop.Telepathy.ChannelDispatcher"
              c:type="TP_CHANNEL_DISPATCHER_BUS_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CHANNEL_DISPATCHER_OBJECT_PATH"
              value="/org/freedesktop/Telepathy/ChannelDispatcher"
              c:type="TP_CHANNEL_DISPATCHER_OBJECT_PATH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.Client."
              c:type="TP_CLIENT_BUS_NAME_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CLIENT_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Client/"
              c:type="TP_CLIENT_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="CMInfoSource" version="0.7.1" c:type="TpCMInfoSource">
      <doc xml:whitespace="preserve">Describes possible sources of information on connection managers'
supported protocols.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CM_INFO_SOURCE.</doc>
      <member name="none" value="0" c:identifier="TP_CM_INFO_SOURCE_NONE"/>
      <member name="file" value="1" c:identifier="TP_CM_INFO_SOURCE_FILE"/>
      <member name="live" value="2" c:identifier="TP_CM_INFO_SOURCE_LIVE"/>
    </enumeration>
    <constant name="CM_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.ConnectionManager."
              c:type="TP_CM_BUS_NAME_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CM_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/ConnectionManager/"
              c:type="TP_CM_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONN_BUS_NAME_BASE"
              value="org.freedesktop.Telepathy.Connection."
              c:type="TP_CONN_BUS_NAME_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CONN_OBJECT_PATH_BASE"
              value="/org/freedesktop/Telepathy/Connection/"
              c:type="TP_CONN_OBJECT_PATH_BASE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Capabilities"
           c:symbol-prefix="capabilities"
           c:type="TpCapabilities"
           version="0.11.3"
           parent="GObject.Object"
           glib:type-name="TpCapabilities"
           glib:get-type="tp_capabilities_get_type"
           glib:type-struct="CapabilitiesClass">
      <doc xml:whitespace="preserve">An object representing capabilities a #TpConnection or #TpContact supports.</doc>
      <method name="get_channel_classes"
              c:identifier="tp_capabilities_get_channel_classes"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpCapabilities:channel-classes property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GPtrArray as the</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
      </method>
      <method name="is_specific_to_contact"
              c:identifier="tp_capabilities_is_specific_to_contact"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #gboolean as the #TpCapabilities:contact-specific property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_contact_search"
              c:identifier="tp_capabilities_supports_contact_search"
              version="0.13.11">
        <doc xml:whitespace="preserve">Return whether this protocol or connection can perform contact
searches. Optionally, also return whether a limited number of
results can be specified, and whether alternative servers can be
searched.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if #TpContactSearch can be used.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="with_limit"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return %TRUE if the limit parameter to tp_contact_search_new_async() and tp_contact_search_reset_async() can be nonzero</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="with_server"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return %TRUE if the server parameter to tp_contact_search_new_async() and tp_contact_search_reset_async() can be non-%NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_dbus_tubes"
              c:identifier="tp_capabilities_supports_dbus_tubes"
              version="0.13.0">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
D-Bus tubes with @handle_type as TargetHandleType.
If @service_name is not %NULL, it also checks if it supports stream tubes
with @service as #TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME.

If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if the connection supports requesting D-Bus tube channels with
@handle_type as ChannelType. The @service_name argument is unused in
this case.

tubes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact or connection supports this type of D-Bus</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type of the tube (either #TP_HANDLE_TYPE_CONTACT or #TP_HANDLE_TYPE_ROOM)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="service_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service name of the tube, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_room_list"
              c:identifier="tp_capabilities_supports_room_list"
              version="0.13.14">
        <doc xml:whitespace="preserve">Discovers whether this protocol or connection supports listing rooms.
Specifically, if this function returns %TRUE, a room list channel can be
requested as follows:
|[
GHashTable *request;
TpAccountChannelRequest *req;

request = tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_ROOM_LIST,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_NONE,
NULL);

req = tp_account_channel_request_new (account, request,
TP_USER_ACTION_TIME_CURRENT_TIME);

tp_account_channel_request_create_and_handle_channel_async (req, NULL,
create_channel_cb, NULL);

g_object_unref (req);
g_hash_table_unref (request);
]|

If @with_server is set to %TRUE, a list of rooms on a particular server can
be requested as follows:
|[
/\* Same code as above but with request defined using: *\/
request = tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING,
TP_IFACE_CHANNEL_TYPE_ROOM_LIST,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_NONE,
TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER, G_TYPE_STRING,
"characters.shakespeare.lit",
NULL);
]|

HandleTypeNone as TargetHandleType can be expected to work,
%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing RoomList as ChannelType,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="with_server"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return %TRUE if the #TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER property can be defined when requesting a RoomList channel.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_stream_tubes"
              c:identifier="tp_capabilities_supports_stream_tubes"
              version="0.13.0">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities supports
stream tubes with @handle_type as TargetHandleType.
If @service is not %NULL, it also checks if it supports stream tubes
with @service as #TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE.

If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if the connection supports requesting stream tube channels with
@handle_type as ChannelType. The @service argument is unused in this case.

tubes.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact or connection supports this type of stream</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type of the tube (either #TP_HANDLE_TYPE_CONTACT or #TP_HANDLE_TYPE_ROOM)</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="service" transfer-ownership="none">
            <doc xml:whitespace="preserve">the service of the tube, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_text_chatrooms"
              c:identifier="tp_capabilities_supports_text_chatrooms"
              version="0.11.3">
        <doc xml:whitespace="preserve">If the #TpCapabilities:contact-specific property is %FALSE, this function
checks if named text chatrooms can be joined by providing a chatroom
identifier.

If the #TpCapabilities:contact-specific property is %TRUE, this function
checks if the contact associated with this #TpCapabilities can be invited
to named text chatrooms.

If the protocol is such that chatrooms can be joined or contacts can be
invited, but only via a more elaborate D-Bus API than normal
(because more information is needed), then this method will return %FALSE.

HandleTypeRoom as TargetHandleType and a channel identifier can be
expected to work, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Text as ChannelType,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="supports_text_chats"
              c:identifier="tp_capabilities_supports_text_chats"
              version="0.11.3">
        <doc xml:whitespace="preserve">Return whether private text channels can be established by providing
a contact identifier.

If the protocol is such that text chats can be established, but only via a
more elaborate D-Bus API than normal (because more information is needed),
then this method will return %FALSE.

HandleTypeContact as TargetHandleType and a contact identifier can be
expected to work, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if a channel request containing Text as ChannelType,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="channel-classes"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The underlying data structure used by Telepathy to represent the
requests that can succeed.

This can be used by advanced clients to determine whether an unusually
complex request would succeed. See the Telepathy D-Bus API Specification
for details of how to interpret the returned #GPtrArray of
#TP_STRUCT_TYPE_REQUESTABLE_CHANNEL_CLASS.

The higher-level methods like
tp_capabilities_supports_text_chats() are likely to be more useful to
the majority of clients.</doc>
        <type/>
      </property>
      <property name="contact-specific"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether this object accurately describes the capabilities of a particular
contact, or if it's only a guess based on the capabilities of the
underlying connection.</doc>
        <type name="gboolean"/>
      </property>
    </class>
    <record name="CapabilitiesClass"
            c:type="TpCapabilitiesClass"
            disguised="1"
            glib:is-gtype-struct-for="Capabilities">
    </record>
    <record name="CapabilitiesPrivate"
            c:type="TpCapabilitiesPrivate"
            disguised="1">
    </record>
    <class name="Channel"
           c:symbol-prefix="channel"
           c:type="TpChannel"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpChannel"
           glib:get-type="tp_channel_get_type"
           glib:type-struct="ChannelClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy channel.
A proxy object for a Telepathy channel. There are no interesting
public struct fields.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new"
                   c:identifier="tp_channel_new"
                   version="0.7.1"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments.</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="optional_channel_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the channel type if already known, or %NULL if not</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="optional_handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type if already known, or %TP_UNKNOWN_HANDLE_TYPE if not</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="optional_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle if already known, or 0 if not (if @optional_handle_type is %TP_UNKNOWN_HANDLE_TYPE or %TP_HANDLE_TYPE_NONE, this must be 0)</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_properties"
                   c:identifier="tp_channel_new_from_properties"
                   version="0.7.19"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_chat_states"
                c:identifier="tp_channel_get_feature_quark_chat_states">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contacts"
                c:identifier="tp_channel_get_feature_quark_contacts">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_group"
                c:identifier="tp_channel_get_feature_quark_group">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_password"
                c:identifier="tp_channel_get_feature_quark_password">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_init_known_interfaces"
                version="0.7.6">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannel have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_connection"
              c:identifier="tp_channel_borrow_connection"
              version="0.7.12">
        <doc xml:whitespace="preserve">Returns the connection for this channel. The returned pointer is only valid
while this channel is valid - reference it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="borrow_immutable_properties"
              c:identifier="tp_channel_borrow_immutable_properties">
        <doc xml:whitespace="preserve">Returns the immutable D-Bus properties of this channel, the same as
#TpChannel:channel-properties.

The returned hash table should not be altered, and is not necessarily
valid after the main loop is next re-entered. Copy it with
g_boxed_copy() (its type is %TP_HASH_TYPE_QUALIFIED_PROPERTY_VALUE_MAP)
if a copy that remains valid must be kept.

If the #TpChannel:channel-properties property was not set during
construction (e.g. by calling tp_channel_new_from_properties()), a
reasonable but possibly incomplete version will be made up from the values
of individual properties; reading this property repeatedly may yield
progressively more complete values until the %TP_CHANNEL_FEATURE_CORE
feature is prepared.

where the keys are strings,
D-Bus interface name + "." + property name, and the values are #GValue
instances</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_channel_call_when_ready"
              version="0.7.7"
              introspectable="0">
        <doc xml:whitespace="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.

This is a less general form of tp_proxy_prepare_async(), which should be
used in new code. (One important difference is that this function can call
@callback before it has returned, whereas tp_proxy_prepare_async() always
calls @callback from the main loop.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">called when the channel becomes ready or invalidated, whichever happens first</doc>
            <type name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_async"
              c:identifier="tp_channel_close_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Close channel @self. In most cases, it's generally cleaner to use
tp_channel_leave_async() instead to properly leave and close the channel.

When the channel has been closed, @callback will be called.
You can then call tp_channel_close_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when we closed the channel, or %NULL to ignore any reply</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="tp_channel_close_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to close a channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been closed; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_async"
              c:identifier="tp_channel_destroy_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Destroy channel @self.
If @self doesn't implement #TP_IFACE_QUARK_CHANNEL_INTERFACE_DESTROYABLE
or if for any reason we can't destroy the channel, we close it.

When the channel has been destroyed or closed, @callback will be called.
You can then call tp_channel_destroy_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when we left the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_finish"
              c:identifier="tp_channel_destroy_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to leave a channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been destroyed or closed; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_channel_type"
              c:identifier="tp_channel_get_channel_type"
              version="0.7.12">
        <doc xml:whitespace="preserve">Get the D-Bus interface name representing this channel's type,
if it has been discovered.

This is the same as the #TpChannelIface:channel-type property; it isn't
guaranteed to be non-%NULL until the %TP_CHANNEL_FEATURE_CORE feature has
been prepared.

type or %NULL, if the channel is not yet ready.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel type, if the channel is ready; either the channel</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_channel_type_id"
              c:identifier="tp_channel_get_channel_type_id"
              version="0.7.12">
        <doc xml:whitespace="preserve">Get the D-Bus interface name representing this channel's type, as a GQuark,
if it has been discovered.

This is the same as the #TpChannelIface:channel-type property, except that it
is a GQuark rather than a string. It isn't guaranteed to be nonzero until
the %TP_CHANNEL_FEATURE_CORE property is ready.

type or 0, if the channel is not yet ready.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel type, if the channel is ready; either the channel</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </method>
      <method name="get_chat_state"
              c:identifier="tp_channel_get_chat_state"
              version="0.11.3">
        <doc xml:whitespace="preserve">Return the chat state for the given contact. If tp_proxy_is_prepared()
would return %FALSE for the feature %TP_CHANNEL_FEATURE_CHAT_STATES,
the result will always be %TP_CHANNEL_CHAT_STATE_INACTIVE.

if their chat state is not known</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the chat state for @contact, or %TP_CHANNEL_CHAT_STATE_INACTIVE</doc>
          <type name="ChannelChatState" c:type="TpChannelChatState"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact handle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handle"
              c:identifier="tp_channel_get_handle"
              version="0.7.12">
        <doc xml:whitespace="preserve">Get the handle representing the contact, chatroom, etc. with which this
channel communicates for its whole lifetime, or 0 if there is no such
handle or it has not yet been discovered.

This is the same as the #TpChannelIface:handle property. It isn't
guaranteed to have its final value until the %TP_CHANNEL_FEATURE_CORE
feature is ready.

If @handle_type is not %NULL, the type of handle is written into it.
This will be %TP_UNKNOWN_HANDLE_TYPE if the handle has not yet been
discovered, or %TP_HANDLE_TYPE_NONE if there is no handle with which this
channel will always communicate. This is the same as the
#TpChannelIface:handle-type property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return the type of this handle</doc>
            <type name="HandleType" c:type="TpHandleType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identifier"
              c:identifier="tp_channel_get_identifier"
              version="0.7.21">
        <doc xml:whitespace="preserve">This channel's associated identifier, or the empty string if no identifier
or unknown.

This is the same as the #TpChannel:identifier property, and isn't guaranteed
to be set until the %TP_CHANNEL_FEATURE_CORE property is ready.

Changed in 0.11.4: as with #TpChannel:identifier, this could
previously either be %NULL or the empty string if there was no suitable
value. It is now non-%NULL in all cases.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the identifier</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_initiator_contact"
              c:identifier="tp_channel_get_initiator_contact"
              version="0.15.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:initiator-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="get_initiator_handle"
              c:identifier="tp_channel_get_initiator_handle"
              version="0.11.15"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpChannel:initiator-handle property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:initiator-handle</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_initiator_identifier"
              c:identifier="tp_channel_get_initiator_identifier"
              version="0.11.15"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpChannel:initiator-identifier property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:initiator-identifier</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_requested"
              c:identifier="tp_channel_get_requested"
              version="0.11.15"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpChannel:requested property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:requested</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_target_contact"
              c:identifier="tp_channel_get_target_contact"
              version="0.15.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:target-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="group_dup_local_pending_contacts"
              c:identifier="tp_channel_group_dup_local_pending_contacts"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its local-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of local-pending members, or %NULL.

If @self is not a group, return %NULL.

a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
        <return-value transfer-ownership="container">
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="group_dup_members_contacts"
              c:identifier="tp_channel_group_dup_members_contacts"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of members, or %NULL.

If @self is not a group, return %NULL.

a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
        <return-value transfer-ownership="container">
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="group_dup_remote_pending_contacts"
              c:identifier="tp_channel_group_dup_remote_pending_contacts"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_CONTACTS feature has been
prepared, return a #GPtrArray containing its remote-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_CONTACTS has not been prepared,
the result may either be a set of remote-pending members, or %NULL.

If @self is not a group, return %NULL.

a new #GPtrArray of #TpContact, free it with g_ptr_array_unref(), or %NULL.</doc>
        <return-value transfer-ownership="container">
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="group_get_contact_owner"
              c:identifier="tp_channel_group_get_contact_owner"
              version="0.15.6">
        <doc xml:whitespace="preserve">Synopsis (see below for further explanation):

- if @self is not a group or @contact is not a member of this channel,
result is undefined;
- if %TP_CHANNEL_FEATURE_CONTACTS has not yet been prepared, result is
undefined;
- if @self does not have flags that include
%TP_CHANNEL_GROUP_FLAG_PROPERTIES,
result is undefined;
- if @contact is channel-specific and its globally valid "owner" is known,
return that owner;
- if @contact is channel-specific and its globally valid "owner" is unknown,
return %NULL;
- if @contact is globally valid, return @contact itself

Some channels (those with flags that include
%TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES) have a concept of
"channel-specific contacts". These are contacts that only have meaning within
the context of the channel - for instance, in XMPP Multi-User Chat,
participants in a chatroom are identified by an in-room JID consisting
of the JID of the chatroom plus a local nickname.

Depending on the protocol and configuration, it might be possible to find
out what globally valid contact (i.e. a contact that you could add to
your contact list) "owns" a channel-specific contact. For instance, in
most XMPP MUC chatrooms, normal users cannot see what global JID
corresponds to an in-room JID, but moderators can.

This is further complicated by the fact that channels with channel-specific
contacts can sometimes have members with globally valid contacts (for
instance, if you invite someone to an XMPP MUC using their globally valid
JID, you would expect to see the contact representing that JID in the
Group's remote-pending set).

or %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the global contact that owns the given contact,</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact which is a member of this channel</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_flags"
              c:identifier="tp_channel_group_get_flags"
              version="0.7.12">
        <doc xml:whitespace="preserve">Return the #TpChannel:group-flags property (see the description
of that property for notes on validity).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the group flags, or 0</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </return-value>
      </method>
      <method name="group_get_handle_owner"
              c:identifier="tp_channel_group_get_handle_owner"
              version="0.7.12">
        <doc xml:whitespace="preserve">Synopsis (see below for further explanation):

- if @self is not a group or @handle is not a member of this channel,
result is undefined;
- if %TP_CHANNEL_FEATURE_GROUP has not yet been prepared, result is
undefined;
- if @self does not have flags that include
%TP_CHANNEL_GROUP_FLAG_PROPERTIES,
result is undefined;
- if @handle is channel-specific and its globally valid "owner" is known,
return that owner;
- if @handle is channel-specific and its globally valid "owner" is unknown,
return zero;
- if @handle is globally valid, return @handle itself

Some channels (those with flags that include
%TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES) have a concept of
"channel-specific handles". These are handles that only have meaning within
the context of the channel - for instance, in XMPP Multi-User Chat,
participants in a chatroom are identified by an in-room JID consisting
of the JID of the chatroom plus a local nickname.

Depending on the protocol and configuration, it might be possible to find
out what globally valid handle (i.e. an identifier that you could add to
your contact list) "owns" a channel-specific handle. For instance, in
most XMPP MUC chatrooms, normal users cannot see what global JID
corresponds to an in-room JID, but moderators can.

This is further complicated by the fact that channels with channel-specific
handles can sometimes have members with globally valid handles (for
instance, if you invite someone to an XMPP MUC using their globally valid
JID, you would expect to see the handle representing that JID in the
Group's remote-pending set).

This function's result is undefined unless the channel is ready
and its flags include %TP_CHANNEL_GROUP_FLAG_PROPERTIES (an implementation
without extra D-Bus round trips is not possible using the older API).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the global handle that owns the given handle, or 0</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle which is a member of this channel</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_local_pending"
              c:identifier="tp_channel_group_get_local_pending"
              version="0.7.12">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its local-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of local-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the local-pending members, or %NULL</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </method>
      <method name="group_get_local_pending_contact_info"
              c:identifier="tp_channel_group_get_local_pending_contact_info"
              version="0.15.6">
        <doc xml:whitespace="preserve">If @local_pending is actually a local-pending contact,
write additional information into @actor, @reason and @message and return
%TRUE. The contact and message are not referenced or copied, and can only be
assumed to remain valid until the main loop is re-entered.

If @local_pending is not the handle of a local-pending contact,
write %NULL into @actor, %TP_CHANNEL_GROUP_CHANGE_REASON_NONE into @reason
and "" into @message, and return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact is in fact local-pending</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpContact of a local-pending contact about whom more information is needed</doc>
            <type name="Contact" c:type="TpContact*"/>
          </parameter>
          <parameter name="actor"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the contact who requested the change</doc>
            <type name="Contact" c:type="TpContact**"/>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the reason for the change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the user-supplied message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_local_pending_info"
              c:identifier="tp_channel_group_get_local_pending_info"
              version="0.7.12">
        <doc xml:whitespace="preserve">If @local_pending is actually the handle of a local-pending contact,
write additional information into @actor, @reason and @message and return
%TRUE. The handle and message are not referenced or copied, and can only be
assumed to remain valid until the main loop is re-entered.

If @local_pending is not the handle of a local-pending contact,
write 0 into @actor, %TP_CHANNEL_GROUP_CHANGE_REASON_NONE into @reason
and "" into @message, and return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the contact is in fact local-pending</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle of a local-pending contact about whom more information is needed</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="actor"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the contact who requested the change</doc>
            <type name="Handle" c:type="TpHandle*"/>
          </parameter>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the reason for the change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason*"/>
          </parameter>
          <parameter name="message"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">either %NULL or a location to return the user-supplied message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="group_get_members"
              c:identifier="tp_channel_group_get_members"
              version="0.7.12">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the members, or %NULL</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </method>
      <method name="group_get_remote_pending"
              c:identifier="tp_channel_group_get_remote_pending"
              version="0.7.12">
        <doc xml:whitespace="preserve">If @self is a group and the %TP_CHANNEL_FEATURE_GROUP feature has been
prepared, return a #TpIntset containing its remote-pending members.

If @self is a group but %TP_CHANNEL_FEATURE_GROUP has not been prepared,
the result may either be a set of remote-pending members, or %NULL.

If @self is not a group, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the remote-pending members, or %NULL</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </method>
      <method name="group_get_self_contact"
              c:identifier="tp_channel_group_get_self_contact"
              version="0.15.6">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:group-self-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="group_get_self_handle"
              c:identifier="tp_channel_group_get_self_handle"
              version="0.7.12">
        <doc xml:whitespace="preserve">Return the #TpChannel:group-self-handle property (see the description
of that property for notes on validity).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle representing the user, or 0</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="is_ready"
              c:identifier="tp_channel_is_ready"
              version="0.7.12"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the same thing as the #TpChannel:channel-ready property.

New code should use tp_proxy_is_prepared(), which is a more general form of
this method.

For group channels, this method is equivalent to checking for the
combination of %TP_CHANNEL_FEATURE_CORE and %TP_CHANNEL_FEATURE_GROUP; for
non-group channels, it's equivalent to checking for
%TP_CHANNEL_FEATURE_CORE.

One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if introspection has completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="join_async"
              c:identifier="tp_channel_join_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Join channel @self with @message as join message.

When we joined the channel, @callback will be called.
You can then call tp_channel_join_finish() to get the result of
the operation.

Note that unlike tp_channel_leave_async(), %TP_CHANNEL_FEATURE_GROUP feature
must be prepared before calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the join message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when we joined the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="join_finish"
              c:identifier="tp_channel_join_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to join a channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been joined; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_async"
              c:identifier="tp_channel_leave_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Leave channel @self with @reason as reason and @message as leave message.
If @self doesn't implement #TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP or if
for any reason we can't properly leave the channel, we close it.

When we left the channel, @callback will be called.
You can then call tp_channel_leave_finish() to get the result of
the operation.

Note that unlike tp_channel_join_async(), %TP_CHANNEL_FEATURE_GROUP feature
does not have to be prepared and will be prepared for you. But this is a
deprecated behaviour.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave reason</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when we left the channel</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_finish"
              c:identifier="tp_channel_leave_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to leave a channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been left; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="password_needed"
              c:identifier="tp_channel_password_needed"
              version="0.15.2">
        <doc xml:whitespace="preserve">Return the #TpChannel:password-needed property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannel:password-needed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="provide_password_async"
              c:identifier="tp_channel_provide_password_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Provide @password so that @self can be joined.
This function must be called with the correct password in order for
channel joining to proceed if the TpChannel:password-needed property
is set.

Once the password has been provided, @callback will be
called. You can then call tp_channel_provide_password_finish()
to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="password" transfer-ownership="none">
            <doc xml:whitespace="preserve">the password</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when @password has been provided</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_password_finish"
              c:identifier="tp_channel_provide_password_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to provide a password. If the password was rejected, the operation
fails with #TP_ERROR_AUTHENTICATION_FAILED.

%FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the password has been provided and accepted,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_until_ready"
              c:identifier="tp_channel_run_until_ready"
              version="0.7.1"
              introspectable="0"
              deprecated="Use tp_connection_call_when_ready,"
              deprecated-version="0.11.0">
        <doc xml:whitespace="preserve">If @self is ready for use (introspection has finished, etc.), return
immediately. Otherwise, re-enter the main loop until the channel either
becomes invalid or becomes ready for use, or until the main loop stored
via @loop is cancelled.

%FALSE if the channel has become invalid.

or restructure your program in such a way as to avoid re-entering the
main loop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the channel has been introspected and is ready for use,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a #GMainLoop is placed here while it is being run (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <property name="channel-properties"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable D-Bus properties of this channel, represented by a
#GHashTable where the keys are D-Bus interface name + "." + property
name, and the values are #GValue instances.

Read-only except during construction. If this is not provided
during construction, a reasonable (but possibly incomplete) version
will be made up from the values of individual properties; reading this
property repeatedly may yield progressively more complete values until
tp_proxy_prepare_async() has finished preparing %TP_CHANNEL_FEATURE_CORE.</doc>
        <type/>
      </property>
      <property name="channel-ready" transfer-ownership="none">
        <doc xml:whitespace="preserve">Initially %FALSE; changes to %TRUE when tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE, and if the channel is a
group, %TP_CHANNEL_FEATURE_GROUP.

This is a less general form of tp_proxy_is_prepared(), which should be
used in new code.

One important difference is that after #TpProxy::invalidated is
signalled, #TpChannel:channel-ready keeps its current value - which might
be %TRUE, if the channel was successfully prepared before it became
invalidated - but tp_proxy_is_prepared() returns %FALSE for all features.

Change notification is via notify::channel-ready.</doc>
        <type name="gboolean"/>
      </property>
      <property name="connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection to which this #TpChannel belongs. Used for e.g.
handle manipulation.</doc>
        <type name="Connection"/>
      </property>
      <property name="group-flags" version="0.7.12" transfer-ownership="none">
        <doc xml:whitespace="preserve">If the %TP_CHANNEL_FEATURE_GROUP feature has been prepared successfully,
#TpChannelGroupFlags indicating the capabilities and behaviour of that
group.

Otherwise, this may be 0.

Change notification is via notify::group-flags or
TpChannel::group-flags-changed.</doc>
        <type name="guint"/>
      </property>
      <property name="group-self-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this channel is a group and %TP_CHANNEL_FEATURE_CONTACTS has been
prepared, and the user is a member of the group, the #TpContact
representing them in this group.

Otherwise, the result may be either a contact representing the user,
or %NULL.

Change notification is via notify::group-self-contact.</doc>
        <type name="Contact"/>
      </property>
      <property name="group-self-handle"
                version="0.7.12"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this channel is a group and %TP_CHANNEL_FEATURE_GROUP has been
prepared, and the user is a member of the group, the #TpHandle
representing them in this group.

Otherwise, the result may be either a handle representing the user, or 0.

Change notification is via notify::group-self-handle.</doc>
        <type name="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:whitespace="preserve">This channel's associated identifier, or the empty string if it has
handle type %TP_HANDLE_TYPE_NONE.

For channels where #TpChannelIface:handle is non-zero, this is the result
of inspecting #TpChannelIface:handle.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be
the empty string.

Changed in 0.11.4: this property is never %NULL. Previously,
it was %NULL before an identifier was known, or when a channel
with no TargetID D-Bus property had TargetHandleType %TP_HANDLE_TYPE_NONE.</doc>
        <type name="utf8"/>
      </property>
      <property name="initiator-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpContact of the initiator of this channel, or %NULL if there is no
particular initiator.

If the channel was initiated by a remote contact, this represents
that contact, and #TpChannel:requested will be %FALSE. For instance,
for an incoming call this property indicates the caller, and for a
chatroom invitation this property indicates who sent the invitation.

If the channel was requested by the local user, #TpChannel:requested
will be %TRUE, and this property may be the #TpChannel:group-self-contact
or #TpConnection:self-contact.

If the channel appeared for some other reason (for instance as a
side-effect of connecting to the server), this property may be %NULL.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
%NULL.</doc>
        <type name="Contact"/>
      </property>
      <property name="initiator-handle"
                version="0.11.15"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TP_HANDLE_TYPE_CONTACT #TpHandle of the initiator of this
channel, or 0 if there is no particular initiator.

If the channel was initiated by a remote contact, this handle represents
that contact, and #TpChannel:requested will be %FALSE. For instance,
for an incoming call this property indicates the caller, and for a
chatroom invitation this property indicates who sent the invitation.

If the channel was requested by the local user, #TpChannel:requested
will be %TRUE, and this property may be the #TpChannel:group-self-handle
or #TpConnection:self-handle.

If the channel appeared for some other reason (for instance as a
side-effect of connecting to the server), this property may be 0.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be 0.</doc>
        <type name="guint"/>
      </property>
      <property name="initiator-identifier"
                version="0.11.15"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If #TpChannel:initiator-handle is 0, this will always be "".
Otherwise, this will be the #TpContact:identifier of the contact
with that handle.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may be
the empty string.</doc>
        <type name="utf8"/>
      </property>
      <property name="password-needed"
                version="0.15.2"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, tp_channel_provide_password_async() has to be called
to be able to join the channel.

This is not guaranteed to be meaningful until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_PASSWORD; until then, it may return
%FALSE even if the channel is actually protected by a password.
Preparing %TP_CHANNEL_FEATURE_PASSWORD also ensures that the
notify::password-needed signal will be fired when this property changes.</doc>
        <type name="gboolean"/>
      </property>
      <property name="requested" version="0.11.15" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if this channel was created in response to a local request, such
as a call to tp_account_channel_request_create_channel_async(). %FALSE
if this channel was initiated by a remote contact
(the #TpChannel:initiator-handle), or if it appeared as a side-effect
of some other action.

For instance, this is %FALSE on incoming calls and file transfers,
remotely-initiated 1-1 text conversations, and invitations to chatrooms,
and %TRUE on outgoing calls and file transfers, locally-initiated 1-1
text conversations, and chatrooms joined by local user action.

This is not guaranteed to be meaningful until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CORE; until then, it may return
%FALSE even if the channel was actually requested.</doc>
        <type name="gboolean"/>
      </property>
      <property name="target-contact"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this channel is for communication with a single contact (that is,
#TpChannelIface:handle-type is %TP_HANDLE_TYPE_CONTACT), then a #TpContact
representing the remote contact. For chat rooms, contact search channels and
other channels without a single remote contact, %NULL.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
%NULL.</doc>
        <type name="Contact"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelPrivate" c:type="TpChannelPrivate*"/>
      </field>
      <glib:signal name="chat-state-changed"
                   when="last"
                   detailed="1"
                   version="0.11.3">
        <doc xml:whitespace="preserve">Emitted when a contact's chat state changes after tp_proxy_prepare_async()
has finished preparing the feature %TP_CHANNEL_FEATURE_CHAT_STATES.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="contact" transfer-ownership="none">
            <doc xml:whitespace="preserve">a contact handle for the local user or another contact</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new #TpChannelChatState for the contact</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-contacts-changed"
                   when="last"
                   detailed="1"
                   version="0.15.6">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel.

This is not guaranteed to be emitted until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_FEATURE_CONTACTS; until then, it may be
omitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact containing the full members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact containing the members (full, local-pending or remote-pending) removed</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact containing the local-pending members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact containing the remote-pending members added</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpContact for the "actor" handle in @details</doc>
            <type name="Contact"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GHashTable mapping (gchar *) to #GValue containing details about the change, as described in the specification of the MembersChangedDetailed signal.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-flags-changed"
                   when="last"
                   detailed="1"
                   version="0.7.12">
        <doc xml:whitespace="preserve">Emitted when the #TpChannel:group-flags property changes while the
channel is ready.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpChannelGroupFlags which are newly set</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpChannelGroupFlags which are no longer set</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed"
                   when="last"
                   detailed="1"
                   version="0.7.12"
                   introspectable="0">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel that is ready.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">an optional textual message</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the full members added</doc>
            <type/>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the members (full, local-pending or remote-pending) removed</doc>
            <type/>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the local-pending members added</doc>
            <type/>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the remote-pending members added</doc>
            <type/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpHandle of the contact causing the change, or 0</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the reason for the change as a #TpChannelGroupChangeReason</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-members-changed-detailed"
                   when="last"
                   detailed="1"
                   version="0.7.21">
        <doc xml:whitespace="preserve">Emitted when the group members change in a Group channel that is ready.
Contains a superset of the information in the
TpChannel::group-members-changed signal, and is emitted at the same time;
applications can connect to this signal and ignore the other.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the full members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the members (full, local-pending or remote-pending) removed</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the local-pending members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GArray of #guint containing the remote-pending members added</doc>
            <array name="GLib.Array">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GHashTable mapping (gchar *) to #GValue containing details about the change, as described in the specification of the MembersChangedDetailed signal.</doc>
            <type name="GLib.HashTable">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ChannelCallStateFlags" c:type="TpChannelCallStateFlags">
      <member name="ringing"
              value="1"
              c:identifier="TP_CHANNEL_CALL_STATE_RINGING"/>
      <member name="queued"
              value="2"
              c:identifier="TP_CHANNEL_CALL_STATE_QUEUED"/>
      <member name="held" value="4" c:identifier="TP_CHANNEL_CALL_STATE_HELD"/>
      <member name="forwarded"
              value="8"
              c:identifier="TP_CHANNEL_CALL_STATE_FORWARDED"/>
      <member name="in_progress"
              value="16"
              c:identifier="TP_CHANNEL_CALL_STATE_IN_PROGRESS"/>
      <member name="conference_host"
              value="32"
              c:identifier="TP_CHANNEL_CALL_STATE_CONFERENCE_HOST"/>
    </bitfield>
    <enumeration name="ChannelChatState" c:type="TpChannelChatState">
      <member name="gone" value="0" c:identifier="TP_CHANNEL_CHAT_STATE_GONE"/>
      <member name="inactive"
              value="1"
              c:identifier="TP_CHANNEL_CHAT_STATE_INACTIVE"/>
      <member name="active"
              value="2"
              c:identifier="TP_CHANNEL_CHAT_STATE_ACTIVE"/>
      <member name="paused"
              value="3"
              c:identifier="TP_CHANNEL_CHAT_STATE_PAUSED"/>
      <member name="composing"
              value="4"
              c:identifier="TP_CHANNEL_CHAT_STATE_COMPOSING"/>
    </enumeration>
    <record name="ChannelClass"
            c:type="TpChannelClass"
            glib:is-gtype-struct-for="Channel"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpChannel. In addition to @parent_class there are four
pointers reserved for possible future use.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <enumeration name="ChannelContactSearchState"
                 c:type="TpChannelContactSearchState">
      <member name="not_started"
              value="0"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_NOT_STARTED"/>
      <member name="in_progress"
              value="1"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_IN_PROGRESS"/>
      <member name="more_available"
              value="2"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_MORE_AVAILABLE"/>
      <member name="completed"
              value="3"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_COMPLETED"/>
      <member name="failed"
              value="4"
              c:identifier="TP_CHANNEL_CONTACT_SEARCH_STATE_FAILED"/>
    </enumeration>
    <class name="ChannelDispatchOperation"
           c:symbol-prefix="channel_dispatch_operation"
           c:type="TpChannelDispatchOperation"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelDispatchOperation"
           glib:get-type="tp_channel_dispatch_operation_get_type"
           glib:type-struct="ChannelDispatchOperationClass">
      <doc xml:whitespace="preserve">One of the channel dispatcher's functions is to offer incoming channels to
Approver clients for approval. An approver should generally ask the user
whether they want to participate in the requested communication channels
(join the chat or chatroom, answer the call, accept the file transfer, or
whatever is appropriate). A collection of channels offered in this way
is represented by a ChannelDispatchOperation object.

If the user wishes to accept the communication channels, the approver
should call tp_cli_channel_dispatch_operation_call_handle_with() to
indicate the user's or approver's preferred handler for the channels (the
empty string indicates no particular preference, and will cause any
suitable handler to be used).

If the user wishes to reject the communication channels, or if the user
accepts the channels and the approver will handle them itself, the approver
should call tp_cli_channel_dispatch_operation_call_claim(). If this method
succeeds, the approver immediately has control over the channels as their
primary handler, and may do anything with them (in particular, it may close
them in whatever way seems most appropriate).

There are various situations in which the channel dispatch operation will
be closed, causing the #TpProxy::invalidated signal to be emitted. If this
happens, the approver should stop prompting the user.

Because all approvers are launched simultaneously, the user might respond
to another approver; if this happens, the #TpProxy::invalidated signal
will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

If a channel closes, the #TpChannelDispatchOperation::channel-lost signal
is emitted. If all channels
close, there is nothing more to dispatch, so the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED.

If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST. In a high-quality implementation, the
dispatcher should be restarted, at which point it will create new
channel dispatch operations for any undispatched channels, and the approver
will be notified again.

This proxy is usable but incomplete: accessors for the D-Bus properties will
be added in a later version of telepathy-glib, along with a mechanism
similar to tp_connection_call_when_ready().</doc>
      <constructor name="new"
                   c:identifier="tp_channel_dispatch_operation_new"
                   throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new channel dispatch operation proxy.

The @immutable_properties argument is not yet used.

@object_path is not syntactically valid or the channel dispatcher is not
running</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an channel dispatch operation proxy, or %NULL if</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this channel dispatch operation</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">As many as are known of the immutable D-Bus properties of this channel dispatch operation, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_channel_dispatch_operation_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_dispatch_operation_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelDispatchOperation have been
set up. This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_DISPATCH_OPERATION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="borrow_account"
              c:identifier="tp_channel_dispatch_operation_borrow_account"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpAccount of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="borrow_channels"
              c:identifier="tp_channel_dispatch_operation_borrow_channels"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns a #GPtrArray containing the #TpChannel of this
ChannelDispatchOperation.
The returned array and its #TpChannel are only valid while @self is
valid - copy array and reference channels with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:channels</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
      </method>
      <method name="borrow_connection"
              c:identifier="tp_channel_dispatch_operation_borrow_connection"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the #TpConnection of this ChannelDispatchOperation.
The returned pointer is only valid while @self is valid - reference
it with g_object_ref() if needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelDispatchOperation:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="borrow_immutable_properties"
              c:identifier="tp_channel_dispatch_operation_borrow_immutable_properties"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the immutable D-Bus properties of this channel.
The returned hash table is only valid while @self is valid - reference
it with g_hash_table_ref() if needed.

#TpChannelDispatchOperation:cdo-properties</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="borrow_possible_handlers"
              c:identifier="tp_channel_dispatch_operation_borrow_possible_handlers"
              version="0.11.5"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns a #GStrv containing the possible handlers of this
ChannelDispatchOperation.
The returned array and its strings are only valid while @self is
valid - copy it with g_strdupv if needed.

#TpChannelDispatchOperation:possible-handlers</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="claim_async"
              c:identifier="tp_channel_dispatch_operation_claim_async"
              version="0.11.5"
              deprecated="since 0.15.0. Use">
        <doc xml:whitespace="preserve">Called by an approver to claim channels for handling internally.
If this method is called successfully, the process calling this
method becomes the handler for the channel.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details. The approver MUST NOT attempt to interact with
the channels further in this case.

tp_channel_dispatch_operation_claim_with_async()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_finish"
              c:identifier="tp_channel_dispatch_operation_claim_finish"
              version="0.11.5"
              deprecated="since 0.15.0. Use"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to Claim().


tp_channel_dispatch_operation_claim_with_finish()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_with_async"
              c:identifier="tp_channel_dispatch_operation_claim_with_async"
              version="0.15.0">
        <doc xml:whitespace="preserve">Called by an approver to claim channels for handling internally.
If this method is called successfully, the process calling this
method becomes the handler for the channel.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details. The approver MUST NOT attempt to interact with
the channels further in this case.

This is an improved version of tp_channel_dispatch_operation_claim_async()
as it tells @client about the new channels being handled.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="client" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpBaseClient claiming @self</doc>
            <type name="BaseClient" c:type="TpBaseClient*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="claim_with_finish"
              c:identifier="tp_channel_dispatch_operation_claim_with_finish"
              version="0.15.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to Claim() initiated using
tp_channel_dispatch_operation_claim_with_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_channels_async"
              c:identifier="tp_channel_dispatch_operation_close_channels_async"
              version="0.15.1">
        <doc xml:whitespace="preserve">Called by an approver to claim channels and close them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_close_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_channels_finish"
              c:identifier="tp_channel_dispatch_operation_close_channels_finish"
              version="0.15.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_close_channels_async().

Close() has at least been attempted on all the channels, otherwise %FALSE</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful and</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_channels_async"
              c:identifier="tp_channel_dispatch_operation_destroy_channels_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Called by an approver to claim channels and destroy them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_destroy_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy_channels_finish"
              c:identifier="tp_channel_dispatch_operation_destroy_channels_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_destroy_channels_async().

tp_channel_destroy_async() has at least been attempted on all the
channels, otherwise %FALSE</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful and</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_async"
              c:identifier="tp_channel_dispatch_operation_handle_with_async"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by an approver to accept a channel bundle and request that the
given handler be used to handle it.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted with the TP_DBUS_ERROR_OBJECT_REMOVED error code.

However, this method may fail because the dispatch has already been
completed and the object has already gone. If this occurs, it indicates
that another approver has asked for the bundle to be handled by a
particular handler. The approver MUST NOT attempt to interact with
the channels further in this case, unless it is separately
invoked as the handler.

Approvers which are also channel handlers SHOULD use
tp_channel_dispatch_operation_claim_async() instead
of tp_channel_dispatch_operation_handle_with_async() to request
that they can handle a channel bundle themselves.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_finish"
              c:identifier="tp_channel_dispatch_operation_handle_with_finish"
              version="0.11.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to HandleWith().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the HandleWith() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_async"
              c:identifier="tp_channel_dispatch_operation_handle_with_time_async"
              version="0.11.7">
        <doc xml:whitespace="preserve">A variant of tp_channel_dispatch_operation_handle_with_async()
allowing the approver to pass an user action time.
This timestamp will be passed to the Handler when HandleChannels is called.

If an X server timestamp for the user action causing this method call is
available, @user_action_time should be this timestamp (for instance, the
result of gdk_event_get_time() if it is not %GDK_CURRENT_TIME). Otherwise, it
may be %TP_USER_ACTION_TIME_NOT_USER_ACTION to behave as if there was no
user action or it happened a long time ago, or
%TP_USER_ACTION_TIME_CURRENT_TIME to have the Handler behave as though the
user action had just happened (resembling, but not numerically equal to,
%GDK_CURRENT_TIME).

This method has been introduced in telepathy-mission-control 5.5.0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handler" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE) of the channel handler that should handle the channel, or %NULL if the client has no preferred channel handler</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the call returns</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="handle_with_time_finish"
              c:identifier="tp_channel_dispatch_operation_handle_with_time_finish"
              version="0.11.7"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async call to HandleWithTime().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the HandleWithTime() call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_channels_async"
              c:identifier="tp_channel_dispatch_operation_leave_channels_async"
              version="0.15.2">
        <doc xml:whitespace="preserve">Called by an approver to claim channels and leave them all right away.
If this method is called successfully, @self has been claimed and
tp_channel_leave_async() has been called on all of its channels.

If successful, this method will cause the #TpProxy::invalidated signal
to be emitted, in the same way as for
tp_channel_dispatch_operation_handle_with_async().

This method may fail because the dispatch operation has already
been completed. Again, see tp_channel_dispatch_operation_handle_with_async()
for more details.

%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE feature must be prepared before
calling this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave reason</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the leave message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="leave_channels_finish"
              c:identifier="tp_channel_dispatch_operation_leave_channels_finish"
              version="0.15.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async operation initiated using
tp_channel_dispatch_operation_leave_channels_async().

tp_channel_leave_async() has at least been attempted on all the
channels, otherwise %FALSE</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the Claim() call was successful and</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount with which the connection and channels are associated.

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Account"/>
      </property>
      <property name="cdo-properties"
                version="0.11.5"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable D-Bus properties of this ChannelDispatchOperation,
represented by a #GHashTable where the keys are D-Bus
interface name + "." + property name, and the values are #GValue instances.

Read-only except during construction. If this is not provided
during construction, it is not guaranteed to be set until
tp_proxy_prepare_async() has finished preparing
%TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing the #TpChannel to be dispatched.

Read-only.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection with which the channels are associated.

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <type name="Connection"/>
      </property>
      <property name="possible-handlers"
                version="0.11.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GStrv containing the well known bus names (starting
with TP_CLIENT_BUS_NAME_BASE) of the possible Handlers for
the channels

Read-only except during construction.

This is not guaranteed to be set until tp_proxy_prepare_async() has
finished preparing %TP_CHANNEL_DISPATCH_OPERATION_FEATURE_CORE.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatchOperationPrivate"
              c:type="TpChannelDispatchOperationPrivate*"/>
      </field>
      <glib:signal name="channel-lost"
                   when="last"
                   detailed="1"
                   version="0.11.5">
        <doc xml:whitespace="preserve">Emitted when a channel has closed before it could be claimed or handled.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel that closed</doc>
            <type name="Channel"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">domain of a #GError indicating why the channel has been closed</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">error code of a #GError indicating why the channel has been closed</doc>
            <type name="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message associated with the error</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChannelDispatchOperationClass"
            c:type="TpChannelDispatchOperationClass"
            glib:is-gtype-struct-for="ChannelDispatchOperation">
      <doc xml:whitespace="preserve">The class of a #TpChannelDispatchOperation.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatchOperationClassPrivate"
              c:type="TpChannelDispatchOperationClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelDispatchOperationClassPrivate"
            c:type="TpChannelDispatchOperationClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelDispatchOperationPrivate"
            c:type="TpChannelDispatchOperationPrivate"
            disguised="1">
    </record>
    <class name="ChannelDispatcher"
           c:symbol-prefix="channel_dispatcher"
           c:type="TpChannelDispatcher"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelDispatcher"
           glib:get-type="tp_channel_dispatcher_get_type"
           glib:type-struct="ChannelDispatcherClass">
      <doc xml:whitespace="preserve">The Channel Dispatcher's main D-Bus API is used to request channels,
which is done by calling tp_cli_channel_dispatcher_call_create_channel() or
tp_cli_channel_dispatcher_call_ensure_channel() as appropriate.

The Telepathy Channel Dispatcher is also responsible for responding to new
channels and launching client processes to handle them. However, clients
that can work with incoming channels do not have to call methods
on the channel dispatcher: instead, they must register with the channel
dispatcher passively, by taking a bus name starting with
%TP_CLIENT_BUS_NAME_BASE and implementing the #TpSvcClient interface.
See the Telepathy D-Bus Interface Specification for details.

This proxy is usable but incomplete: convenience methods will be added in
a later version of telepathy-glib, along with a mechanism similar to
tp_connection_call_when_ready().</doc>
      <constructor name="new" c:identifier="tp_channel_dispatcher_new">
        <doc xml:whitespace="preserve">Convenience function to create a new channel dispatcher proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to a channel dispatcher proxy</doc>
          <type name="ChannelDispatcher" c:type="TpChannelDispatcher*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_dispatcher_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelDispatcher have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_DISPATCHER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="present_channel_async"
              c:identifier="tp_channel_dispatcher_present_channel_async"
              version="0.15.0">
        <doc xml:whitespace="preserve">Asynchronously calls PresentChannel on the ChannelDispatcher to ask
to the handler of @channel to re-present it to the user.
You can then call tp_channel_dispatcher_present_channel_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
          <parameter name="user_action_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time at which user action occurred, or #TP_USER_ACTION_TIME_NOT_USER_ACTION if this presentation request is for some reason not involving user action.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="present_channel_finish"
              c:identifier="tp_channel_dispatcher_present_channel_finish"
              version="0.15.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async channel presentation request started using
tp_channel_dispatcher_present_channel_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the call succeeded, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatcherPrivate"
              c:type="TpChannelDispatcherPrivate*"/>
      </field>
    </class>
    <record name="ChannelDispatcherClass"
            c:type="TpChannelDispatcherClass"
            glib:is-gtype-struct-for="ChannelDispatcher">
      <doc xml:whitespace="preserve">The class of a #TpChannelDispatcher.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelDispatcherClassPrivate"
              c:type="TpChannelDispatcherClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelDispatcherClassPrivate"
            c:type="TpChannelDispatcherClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelDispatcherPrivate"
            c:type="TpChannelDispatcherPrivate"
            disguised="1">
    </record>
    <enumeration name="ChannelGroupChangeReason"
                 c:type="TpChannelGroupChangeReason">
      <member name="none"
              value="0"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NONE"/>
      <member name="offline"
              value="1"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_OFFLINE"/>
      <member name="kicked"
              value="2"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_KICKED"/>
      <member name="busy"
              value="3"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BUSY"/>
      <member name="invited"
              value="4"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVITED"/>
      <member name="banned"
              value="5"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_BANNED"/>
      <member name="error"
              value="6"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_ERROR"/>
      <member name="invalid_contact"
              value="7"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_INVALID_CONTACT"/>
      <member name="no_answer"
              value="8"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_NO_ANSWER"/>
      <member name="renamed"
              value="9"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_RENAMED"/>
      <member name="permission_denied"
              value="10"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_PERMISSION_DENIED"/>
      <member name="separated"
              value="11"
              c:identifier="TP_CHANNEL_GROUP_CHANGE_REASON_SEPARATED"/>
    </enumeration>
    <bitfield name="ChannelGroupFlags" c:type="TpChannelGroupFlags">
      <member name="can_add"
              value="1"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_ADD"/>
      <member name="can_remove"
              value="2"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_REMOVE"/>
      <member name="can_rescind"
              value="4"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CAN_RESCIND"/>
      <member name="message_add"
              value="8"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ADD"/>
      <member name="message_remove"
              value="16"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REMOVE"/>
      <member name="message_accept"
              value="32"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_ACCEPT"/>
      <member name="message_reject"
              value="64"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_REJECT"/>
      <member name="message_rescind"
              value="128"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_RESCIND"/>
      <member name="channel_specific_handles"
              value="256"
              c:identifier="TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES"/>
      <member name="only_one_group"
              value="512"
              c:identifier="TP_CHANNEL_GROUP_FLAG_ONLY_ONE_GROUP"/>
      <member name="handle_owners_not_available"
              value="1024"
              c:identifier="TP_CHANNEL_GROUP_FLAG_HANDLE_OWNERS_NOT_AVAILABLE"/>
      <member name="properties"
              value="2048"
              c:identifier="TP_CHANNEL_GROUP_FLAG_PROPERTIES"/>
      <member name="members_changed_detailed"
              value="4096"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED"/>
      <member name="message_depart"
              value="8192"
              c:identifier="TP_CHANNEL_GROUP_FLAG_MESSAGE_DEPART"/>
    </bitfield>
    <record name="ChannelManagerIter"
            c:type="TpChannelManagerIter"
            version="0.7.15"
            introspectable="0">
      <doc xml:whitespace="preserve">An iterator over the #TpChannelManager objects known to a #TpBaseConnection.
It has no public fields.

Use tp_base_connection_channel_manager_iter_init() to start iteration and
tp_base_connection_channel_manager_iter_next() to continue.</doc>
      <field name="self" readable="0" private="1">
        <type name="BaseConnection" c:type="TpBaseConnection*"/>
      </field>
      <field name="index" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_future" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ChannelMediaCapabilities"
              c:type="TpChannelMediaCapabilities">
      <member name="audio"
              value="1"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_AUDIO"/>
      <member name="video"
              value="2"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_VIDEO"/>
      <member name="nat_traversal_stun"
              value="4"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_STUN"/>
      <member name="nat_traversal_gtalk_p2p"
              value="8"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_GTALK_P2P"/>
      <member name="nat_traversal_ice_udp"
              value="16"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_NAT_TRAVERSAL_ICE_UDP"/>
      <member name="immutable_streams"
              value="32"
              c:identifier="TP_CHANNEL_MEDIA_CAPABILITY_IMMUTABLE_STREAMS"/>
    </bitfield>
    <bitfield name="ChannelPasswordFlags" c:type="TpChannelPasswordFlags">
      <member name="provide"
              value="8"
              c:identifier="TP_CHANNEL_PASSWORD_FLAG_PROVIDE"/>
      <member name="hint"
              value="4"
              c:identifier="TP_CHANNEL_PASSWORD_FLAG_HINT"/>
    </bitfield>
    <record name="ChannelPrivate" c:type="TpChannelPrivate" disguised="1">
    </record>
    <class name="ChannelRequest"
           c:symbol-prefix="channel_request"
           c:type="TpChannelRequest"
           version="0.7.32"
           parent="Proxy"
           glib:type-name="TpChannelRequest"
           glib:get-type="tp_channel_request_get_type"
           glib:type-struct="ChannelRequestClass">
      <doc xml:whitespace="preserve">Requesting a channel from the channel dispatcher can take some time, so an
object is created in the channel dispatcher to represent each request. This
proxy represents one of those objects.

Any client can call tp_cli_channel_request_call_cancel() at any time to
attempt to cancel the request.

On success, the #TpChannelRequest::succeeded signal will be emitted.
Immediately after that, the #TpProxy::invalidated signal will be emitted,
with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_OBJECT_REMOVED (this is not an error condition, it merely
indicates that the channel request no longer exists).

On failure, the #TpProxy::invalidated signal will be emitted with some
other suitable error, usually from the %TP_ERRORS domain.

If the channel dispatcher crashes or exits, the #TpProxy::invalidated
signal will be emitted with the domain %TP_DBUS_ERRORS and the error code
%TP_DBUS_ERROR_NAME_OWNER_LOST.

This proxy is usable but incomplete: accessors for the Account,
UserActionTime, PreferredHandler, Requests and Interfaces properties will
be added in a later version of telepathy-glib, along with a mechanism
similar to tp_connection_call_when_ready().

Until suitable convenience methods are implemented, the generic
tp_cli_dbus_properties_call_get_all() method can be used to get those
properties.</doc>
      <constructor name="new" c:identifier="tp_channel_request_new" throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new channel request proxy.

If the channel request was newly created, the client making the request
is responsible for calling tp_cli_channel_request_call_proceed() when it
is ready for the channel request to proceed.

@object_path is not syntactically valid or the channel dispatcher is
not running</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to an channel request proxy, or %NULL if</doc>
          <type name="ChannelRequest" c:type="TpChannelRequest*"/>
        </return-value>
        <parameters>
          <parameter name="bus_daemon" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">The non-NULL object path of this channel request</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">As many as are known of the immutable D-Bus properties of this channel request, or %NULL if none are known</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="init_known_interfaces"
                c:identifier="tp_channel_request_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpChannelRequest have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CHANNEL_REQUEST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_account"
              c:identifier="tp_channel_request_get_account"
              version="0.15.3">
        <doc xml:whitespace="preserve">Return the value of the #TpChannelRequest:account construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:account</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_hints"
              c:identifier="tp_channel_request_get_hints"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return the #TpChannelRequest:hints property

#TpChannelRequest:hints</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="get_immutable_properties"
              c:identifier="tp_channel_request_get_immutable_properties"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return the #TpChannelRequest:immutable-properties construct-only property

#TpChannelRequest:immutable-properties</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="get_preferred_handler"
              c:identifier="tp_channel_request_get_preferred_handler"
              version="0.15.3">
        <doc xml:whitespace="preserve">return the #TpChannelRequest:preferred-handler construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:preferred-handler</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_user_action_time"
              c:identifier="tp_channel_request_get_user_action_time"
              version="0.15.3">
        <doc xml:whitespace="preserve">return the #TpChannelRequest:user-action-time construct-only property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpChannelRequest:user-action-time</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="set_channel_factory"
              c:identifier="tp_channel_request_set_channel_factory"
              version="0.13.14"
              deprecated="since 0.15.5. Use #TpProxy:factory instead.">
        <doc xml:whitespace="preserve">Change the value of the #TpChannelRequest:channel-factory property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object implementing the #TpClientChannelFactoryInterface interface</doc>
            <type name="ClientChannelFactory"
                  c:type="TpClientChannelFactory*"/>
          </parameter>
        </parameters>
      </method>
      <property name="account" version="0.15.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpAccount on which this request was made, not guaranteed
to be prepared.

Read-only.</doc>
        <type name="Account"/>
      </property>
      <property name="channel-factory"
                version="0.13.14"
                deprecated="since 0.15.5. Use #TpProxy:factory instead."
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The object implementing the #TpClientChannelFactoryInterface interface
that will be used to create channel proxies when the
#TpChannelRequest::succeeded-with-channel signal is fired.
This property can be changed using
tp_channel_request_set_channel_factory().

If no channel factory is specified then #TpAutomaticProxyFactory is used.</doc>
        <type name="GObject.Object"/>
      </property>
      <property name="hints"
                version="0.13.14"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TP_HASH_TYPE_STRING_VARIANT_MAP of metadata provided by
the channel requester; or %NULL if #TpChannelRequest:immutable-properties
is not defined or if no hints has been defined.

Read-only.</doc>
        <type/>
      </property>
      <property name="immutable-properties"
                version="0.13.14"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable D-Bus properties of this channel request, represented by a
#GHashTable where the keys are D-Bus interface name + "." + property
name, and the values are #GValue instances.

Note that this property is set only if the immutable properties have been
set during the construction of the #TpChannelRequest.

Read-only except during construction.</doc>
        <type/>
      </property>
      <property name="preferred-handler"
                version="0.15.3"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Either the well-known bus name (starting with #TP_CLIENT_BUS_NAME_BASE)
of the preferred handler for this channel request,
or %NULL to indicate that any handler would be acceptable.

Read-only.</doc>
        <type name="utf8"/>
      </property>
      <property name="user-action-time"
                version="0.15.3"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The time at which user action occurred, or
#TP_USER_ACTION_TIME_NOT_USER_ACTION if this channel request is
for some reason not involving user action.

Read-only.</doc>
        <type name="gint64"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelRequestPrivate" c:type="TpChannelRequestPrivate*"/>
      </field>
      <glib:signal name="succeeded"
                   when="last"
                   detailed="1"
                   deprecated="since 0.13.14. Use">
        <doc xml:whitespace="preserve">Emitted when the channel request succeeds.

#TpChannelRequest::succeeded-with-channel, which provides the resulting
channel, instead.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="succeeded-with-channel"
                   when="last"
                   detailed="1"
                   version="0.13.14">
        <doc xml:whitespace="preserve">Emitted when the channel request succeeds.

With telepathy-mission-control version 5.7.1 and earlier, @connection and
@channel will be %NULL. When using newer versions, they will be correctly
set to the newly-created channel, and the connection which owns it.

The #TpChannel is created using #TpChannelRequest:channel-factory or
#TpProxy:factory but the features of the factory are NOT prepared.
It's up to the user to prepare the features returned by
tp_simple_client_factory_dup_channel_features() himself.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpConnection of @channel, or %NULL</doc>
            <type name="Connection"/>
          </parameter>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpChannel created, or %NULL</doc>
            <type name="Channel"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ChannelRequestClass"
            c:type="TpChannelRequestClass"
            glib:is-gtype-struct-for="ChannelRequest">
      <doc xml:whitespace="preserve">The class of a #TpChannelRequest.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ChannelRequestClassPrivate"
              c:type="TpChannelRequestClassPrivate*"/>
      </field>
    </record>
    <record name="ChannelRequestClassPrivate"
            c:type="TpChannelRequestClassPrivate"
            disguised="1">
    </record>
    <record name="ChannelRequestPrivate"
            c:type="TpChannelRequestPrivate"
            disguised="1">
    </record>
    <bitfield name="ChannelTextMessageFlags"
              c:type="TpChannelTextMessageFlags">
      <member name="truncated"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_TRUNCATED"/>
      <member name="non_text_content"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_NON_TEXT_CONTENT"/>
      <member name="scrollback"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_SCROLLBACK"/>
      <member name="rescued"
              value="8"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_FLAG_RESCUED"/>
    </bitfield>
    <enumeration name="ChannelTextMessageType"
                 c:type="TpChannelTextMessageType">
      <member name="normal"
              value="0"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NORMAL"/>
      <member name="action"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_ACTION"/>
      <member name="notice"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_NOTICE"/>
      <member name="auto_reply"
              value="3"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_AUTO_REPLY"/>
      <member name="delivery_report"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_MESSAGE_TYPE_DELIVERY_REPORT"/>
    </enumeration>
    <enumeration name="ChannelTextSendError" c:type="TpChannelTextSendError">
      <member name="unknown"
              value="0"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_UNKNOWN"/>
      <member name="offline"
              value="1"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_OFFLINE"/>
      <member name="invalid_contact"
              value="2"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_INVALID_CONTACT"/>
      <member name="permission_denied"
              value="3"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_PERMISSION_DENIED"/>
      <member name="too_long"
              value="4"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_TOO_LONG"/>
      <member name="not_implemented"
              value="5"
              c:identifier="TP_CHANNEL_TEXT_SEND_ERROR_NOT_IMPLEMENTED"/>
    </enumeration>
    <callback name="ChannelWhenReadyCb" c:type="TpChannelWhenReadyCb">
      <doc xml:whitespace="preserve">Signature of a callback passed to tp_channel_call_when_ready(), which
will be called exactly once, when the channel becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="channel" transfer-ownership="none">
          <doc xml:whitespace="preserve">the channel (which may be in the middle of being disposed, if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL if the channel is ready for use, or the error with which it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">whatever was passed to tp_channel_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <interface name="ClientChannelFactory"
               c:symbol-prefix="client_channel_factory"
               c:type="TpClientChannelFactory"
               version="0.13.6"
               glib:type-name="TpClientChannelFactory"
               glib:get-type="tp_client_channel_factory_get_type"
               glib:type-struct="ClientChannelFactoryInterface">
      <doc xml:whitespace="preserve">Opaque typedef representing a #GObject that implements
the %TP_TYPE_CLIENT_CHANNEL_FACTORY interface.</doc>
      <virtual-method name="obj_create_channel" introspectable="0" throws="1">
        <return-value>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="obj_dup_channel_features" introspectable="0">
        <return-value>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_channel"
              c:identifier="tp_client_channel_factory_create_channel"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Function called when a channel need to be created.
Implementation can return a subclass of #TpChannel if they need to.

Changed in 0.13.6: the function's signature was previously wrong;
it expected an object instance as its first parameter, but the type of the
parameter was the type of the interface vtable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new channel proxy, or %NULL on invalid arguments</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the channel</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="dup_channel_features"
              c:identifier="tp_client_channel_factory_dup_channel_features"
              version="0.13.3">
        <doc xml:whitespace="preserve">Return a zero terminated #GArray containing the #TpChannel features that
should be prepared on @channel.

Changed in 0.13.6: the function's signature was previously wrong;
it expected an object instance as its first parameter, but the type of the
parameter was the type of the interface vtable.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GArray</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="ClientChannelFactoryInterface"
            c:type="TpClientChannelFactoryInterface"
            glib:is-gtype-struct-for="ClientChannelFactory"
            version="0.13.2">
      <doc xml:whitespace="preserve">Interface for a channel factory</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="create_channel" introspectable="0">
        <callback name="create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactoryInterface"
                    c:type="TpClientChannelFactoryInterface*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_channel_features" introspectable="0">
        <callback name="dup_channel_features" introspectable="0">
          <return-value>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactoryInterface"
                    c:type="TpClientChannelFactoryInterface*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="obj_create_channel" introspectable="0">
        <callback name="obj_create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactory"
                    c:type="TpClientChannelFactory*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="path" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="obj_dup_channel_features" introspectable="0">
        <callback name="obj_dup_channel_features" introspectable="0">
          <return-value>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="ClientChannelFactory"
                    c:type="TpClientChannelFactory*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="ClientMessage"
           c:symbol-prefix="client_message"
           c:type="TpClientMessage"
           version="0.13.9"
           parent="Message"
           glib:type-name="TpClientMessage"
           glib:get-type="tp_client_message_get_type"
           glib:type-struct="ClientMessageClass">
      <doc xml:whitespace="preserve">Opaque structure representing a message in the Telepathy messages interface
(client side).</doc>
      <constructor name="new"
                   c:identifier="tp_client_message_new"
                   version="0.13.9">
        <doc xml:whitespace="preserve">A convenient function to create a new #TpClientMessage

the header part.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpClientMessage having only</doc>
          <type name="Message" c:type="TpMessage*"/>
        </return-value>
      </constructor>
      <constructor name="new_text"
                   c:identifier="tp_client_message_new_text"
                   version="0.13.9">
        <doc xml:whitespace="preserve">A convenient function to create a new #TpClientMessage having
'text/plain' as 'content-type', @type as 'message-type' and
@text as 'content'.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpClientMessage</doc>
          <type name="Message" c:type="TpMessage*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of message</doc>
            <type name="ChannelTextMessageType"
                  c:type="TpChannelTextMessageType"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:whitespace="preserve">content of the messsage</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <record name="ClientMessageClass"
            c:type="TpClientMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="ClientMessage">
    </record>
    <bitfield name="ConnMgrParamFlags" c:type="TpConnMgrParamFlags">
      <member name="required"
              value="1"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_REQUIRED"/>
      <member name="register"
              value="2"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_REGISTER"/>
      <member name="has_default"
              value="4"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_HAS_DEFAULT"/>
      <member name="secret"
              value="8"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_SECRET"/>
      <member name="dbus_property"
              value="16"
              c:identifier="TP_CONN_MGR_PARAM_FLAG_DBUS_PROPERTY"/>
    </bitfield>
    <class name="Connection"
           c:symbol-prefix="connection"
           c:type="TpConnection"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpConnection"
           glib:get-type="tp_connection_get_type"
           glib:type-struct="ConnectionClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy connection. There are no interesting
public struct fields.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <constructor name="new"
                   c:identifier="tp_connection_new"
                   version="0.7.1"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

fails or on invalid arguments</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new connection proxy, or %NULL if unique-name resolution</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bus_name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the well-known or unique name of the connection process; if well-known, this function will make a blocking call to the bus daemon to resolve the unique name. May be %NULL if @object_path is not, in which case a well-known name will be derived from @object_path.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object_path"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the object path of the connection process. May be %NULL if @bus_name is a well-known name, in which case the object path will be derived from @bus_name.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_aliasing"
                c:identifier="tp_connection_get_feature_quark_aliasing">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_avatar_requirements"
                c:identifier="tp_connection_get_feature_quark_avatar_requirements">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_balance"
                c:identifier="tp_connection_get_feature_quark_balance">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_capabilities"
                c:identifier="tp_connection_get_feature_quark_capabilities">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_connected"
                c:identifier="tp_connection_get_feature_quark_connected">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_blocking"
                c:identifier="tp_connection_get_feature_quark_contact_blocking">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_groups"
                c:identifier="tp_connection_get_feature_quark_contact_groups">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_info"
                c:identifier="tp_connection_get_feature_quark_contact_info">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_list"
                c:identifier="tp_connection_get_feature_quark_contact_list">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_contact_list_properties"
                c:identifier="tp_connection_get_feature_quark_contact_list_properties">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_connection_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_connection_init_known_interfaces"
                version="0.7.6">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpConnection have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="presence_type_cmp_availability"
                c:identifier="tp_connection_presence_type_cmp_availability"
                version="0.7.16">
        <doc xml:whitespace="preserve">Compares @p1 and @p2 like strcmp(). @p1 &gt; @p2 means @p1 is more available
than @p2.

The order used is: available &gt; busy &gt; away &gt; xa &gt; hidden &gt; offline &gt; error &gt;
unknown &gt; unset</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">-1, 0 or 1, if @p1 is &lt;, == or &gt; than @p2.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnectionPresenceType</doc>
            <type name="ConnectionPresenceType"
                  c:type="TpConnectionPresenceType"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_client_interest"
              c:identifier="tp_connection_add_client_interest"
              version="0.11.3">
        <doc xml:whitespace="preserve">Subscribe to any opt-in change notifications for @interested_in.

For contact information, use #TpContact instead, which will call this
automatically.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interested_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string identifying an interface or part of an interface to which this connection will subscribe</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_client_interest_by_id"
              c:identifier="tp_connection_add_client_interest_by_id"
              version="0.11.3"
              introspectable="0">
        <doc xml:whitespace="preserve">Subscribe to any opt-in change notifications for @interested_in.

Equivalent to, but a little more efficient than, calling
tp_connection_add_client_interest() for the string value of @interested_in.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="interested_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">a quark identifying an interface or part of an interface to which this connection will subscribe</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_async"
              c:identifier="tp_connection_add_to_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add the given @contacts to the given @group, creating it if necessary.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to include in the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_finish"
              c:identifier="tp_connection_add_to_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_add_to_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_async"
              c:identifier="tp_connection_authorize_publication_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">For each of the given @contacts, request that the local user's presence is
sent to that contact, i.e. that their #TpContact:publish-state property
becomes %TP_SUBSCRIPTION_STATE_YES.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to authorize</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_finish"
              c:identifier="tp_connection_authorize_publication_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_authorize_publication_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_connection_status_to_property"
              c:identifier="tp_connection_bind_connection_status_to_property"
              version="0.13.16">
        <doc xml:whitespace="preserve">Binds the :status of @self to the boolean property of another
object using a #GBinding such that the @target_property will be set to
%TRUE when @self is connected (and @invert is %FALSE).

@target_property will be synchronised immediately (%G_BINDING_SYNC_CREATE).
@invert can be interpreted as analogous to %G_BINDING_INVERT_BOOLEAN.

For instance, this function can be used to bind the GtkWidget:sensitive
property to only make a widget sensitive when the account is connected.

See g_object_bind_property() for more information.

between the @self and the @target. The binding is released whenever the
#GBinding reference count reaches zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GBinding instance representing the binding</doc>
          <type name="GObject.Binding" c:type="GBinding*"/>
        </return-value>
        <parameters>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GObject</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="target_property" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property on @target to bind (must be %G_TYPE_BOOLEAN)</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="invert" transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if you wish to invert the value of @target_property (i.e. %FALSE if connected)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_contacts_async"
              c:identifier="tp_connection_block_contacts_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Direct the server to block @contacts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to block</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="report_abusive" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE, report these contacts as abusive to the server administrators as well as blocking them. See #TpConnection:can-report-abusive to discover whether reporting abuse is supported. If #TpConnection:can-report-abusive is %FALSE, this parameter will be ignored.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_contacts_finish"
              c:identifier="tp_connection_block_contacts_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_block_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_connection_call_when_ready"
              version="0.7.7"
              introspectable="0">
        <doc xml:whitespace="preserve">If @self is ready for use or has been invalidated, call @callback
immediately, then return. Otherwise, arrange
for @callback to be called when @self either becomes ready for use
or becomes invalid.

Note that if the connection is not in state CONNECTED, the callback will
not be called until the connection either goes to state CONNECTED
or is invalidated (e.g. by going to state DISCONNECTED or by becoming
unreferenced). In particular, this method does not call Connect().
Call tp_cli_connection_call_connect() too, if you want to do that.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">called when the connection becomes ready or invalidated, whichever happens first</doc>
            <type name="ConnectionWhenReadyCb"
                  c:type="TpConnectionWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_report_abusive"
              c:identifier="tp_connection_can_report_abusive"
              version="0.17.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:can-report-abusive</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="can_set_contact_alias"
              c:identifier="tp_connection_can_set_contact_alias">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="dup_contact_if_possible"
              c:identifier="tp_connection_dup_contact_if_possible"
              version="0.13.9">
        <doc xml:whitespace="preserve">Try to return an existing contact object or create a new contact object
immediately.

If tp_connection_has_immortal_handles() would return %TRUE and
@identifier is non-%NULL, this function always succeeds.

On connections without immortal handles, it is not possible to guarantee
that @handle remains valid without making asynchronous D-Bus calls, so
it might be necessary to delay processing of messages or other events
until a #TpContact can be constructed asynchronously, for instance by using
tp_connection_get_contacts_by_id().

Similarly, if @identifier is %NULL, it might not be possible to find the
identifier for @handle without making asynchronous D-Bus calls, so
it might be necessary to delay processing of messages or other events
until a #TpContact can be constructed asynchronously, for instance by using
tp_connection_get_contacts_by_handle().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a contact or %NULL</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle of type %TP_HANDLE_TYPE_CONTACT</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">the normalized identifier (XMPP JID, etc.) corresponding to @handle, or %NULL if not known</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_list"
              c:identifier="tp_connection_dup_contact_list"
              version="0.15.5">
        <doc xml:whitespace="preserve">Retrieves the user's contact list. In general, blocked contacts are not
included in this list. The #TpContact objects returned are guaranteed to
have all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.

Before calling this method, you must first call tp_proxy_prepare_async() with
the %TP_CONNECTION_FEATURE_CONTACT_LIST feature, and verify that
#TpConnection:contact-list-state is set to %TP_CONTACT_LIST_STATE_SUCCESS.

a new #GPtrArray of #TpContact. Use g_ptr_array_unref() when done.</doc>
        <return-value transfer-ownership="container">
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="get_account"
              c:identifier="tp_connection_get_account"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the the #TpAccount associated with this connection. Will return %NULL
if @self was not acquired from a #TpAccount via tp_account_get_connection(),
or if the account object got finalized in the meantime (#TpConnection does
not keep a strong ref on its #TpAccount).

%NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the account associated with this connection, or</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_avatar_requirements"
              c:identifier="tp_connection_get_avatar_requirements"
              version="0.11.4">
        <doc xml:whitespace="preserve">To wait for valid avatar requirements, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_AVATAR_REQUIREMENTS.

This property cannot change after @self goes to the Connected state.

feature is not yet prepared or the connection doesn't have the necessary
properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAvatarRequirements struct, or %NULL if the</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="get_balance"
              c:identifier="tp_connection_get_balance"
              version="0.15.1">
        <doc xml:whitespace="preserve">If @self has a valid account balance, returns %TRUE and sets the variables
pointed to by @balance, @scale and @currency to the appropriate fields
of the Balance.AccountBalance property.

The monetary value of the balance is expressed as a fixed-point number,
@balance, with a decimal scale defined by @scale; for instance a @balance
of 1234 with @scale of 2 represents a value of "12.34" in the currency
represented by @currency.

Requires %TP_CONNECTION_FEATURE_BALANCE to be prepared.

balance is invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the balance is valid (and the values set), %FALSE if the</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="balance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to store the account balance (or %NULL)</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="scale"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to store the balance scale (or %NULL)</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="currency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to store the balance currency (or %NULL)</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_balance_uri"
              c:identifier="tp_connection_get_balance_uri"
              version="0.15.1">
        <doc xml:whitespace="preserve">The value of Balance.ManageCreditURI.

Requires %TP_CONNECTION_FEATURE_BALANCE to be prepared.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #TpConnection:balance-uri property.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_blocked_contacts"
              c:identifier="tp_connection_get_blocked_contacts"
              version="0.17.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpConnection:blocked-contacts</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray*">
            <type name="Contact"/>
          </array>
        </return-value>
      </method>
      <method name="get_can_change_contact_list"
              c:identifier="tp_connection_get_can_change_contact_list"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:can-change-contact-list property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_connection_get_capabilities"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpConnection:capabilities property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #TpCapabilities as the</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_connection_manager_name"
              c:identifier="tp_connection_get_connection_manager_name">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_contact_attributes"
              c:identifier="tp_connection_get_contact_attributes">
        <doc xml:whitespace="preserve">Return (via a callback) any number of attributes of the given handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, if @hold
was %TRUE, the callback would hold a reference to them which could be
released with tp_connection_unref_handles().

This is a thin wrapper around the GetContactAttributes D-Bus method, and
should be used in preference to
tp_cli_connection_interface_contacts_call_get_contact_attributes(); mixing this
function, tp_connection_hold_handles(), tp_connection_unref_handles(), and
#TpContact with direct use of the RequestHandles, HoldHandles and
GetContactAttributes D-Bus methods is unwise, as #TpConnection and
#TpContact perform client-side reference counting of handles.
The #TpContact API provides a higher-level abstraction which should
usually be used instead.

@callback will later be called with the attributes of those of the given
handles that were valid. Invalid handles are simply omitted from the
parameter to the callback.

If @hold is %TRUE, the @callback is given one reference to each handle
that appears as a key in the callback's @attributes parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of handles</doc>
            <array length="1" zero-terminated="0" c:type="TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GStrv of interfaces</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, the callback will hold one reference to each valid handle</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="GObject.Callback"
                  c:type="tp_cli_connection_interface_contacts_callback_for_get_contact_attributes"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contact_groups"
              c:identifier="tp_connection_get_contact_groups"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpConnection:contact-groups</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_contact_info_flags"
              c:identifier="tp_connection_get_contact_info_flags"
              version="0.11.7">
        <doc xml:whitespace="preserve">Returns the flags describing how contact info (vCards) behaves on this
connection

To wait for valid contact info flags, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a set of #TpContactInfoFlags</doc>
          <type name="ContactInfoFlags" c:type="TpContactInfoFlags"/>
        </return-value>
      </method>
      <method name="get_contact_info_supported_fields"
              c:identifier="tp_connection_get_contact_info_supported_fields"
              version="0.11.7">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of supported contact info fields for this
connection. The list must be freed with g_list_free() after used.

Note that the #TpContactInfoFieldSpec&lt;!-- --&gt;s in the returned #GList are not
dupped before returning from this function. One could copy every item in the
list using tp_contact_info_field_spec_copy().

To wait for valid supported fields, call tp_proxy_prepare_async() with the
feature %TP_CONNECTION_FEATURE_CONTACT_INFO.

This property cannot change after @self goes to the Connected state.

a #GList of #TpContactInfoFieldSpec struct, or %NULL if the feature is not
yet prepared or the connection doesn't have the necessary properties.</doc>
        <return-value transfer-ownership="container">
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoFieldSpec"/>
          </type>
        </return-value>
      </method>
      <method name="get_contact_list_attributes"
              c:identifier="tp_connection_get_contact_list_attributes">
        <doc xml:whitespace="preserve">Return (via a callback) the contacts on the contact list and any number of
their attributes.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, if @hold
was %TRUE, the callback would hold a reference to them which could be
released with tp_connection_unref_handles().

This is a thin wrapper around the RequestContactList D-Bus method,
and should be used in preference to lower-level functions; it is similar
to tp_connection_get_contact_attributes().

The #TpContact API provides a higher-level abstraction which should
usually be used instead.

If @hold is %TRUE, the @callback is given a reference to each handle
that appears as a key in the callback's @attributes parameter.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds (using a large timeout is recommended)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GStrv of interfaces</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="hold" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, the callback will hold one reference to each handle it receives</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="GObject.Callback"
                  c:type="tp_cli_connection_interface_contacts_callback_for_get_contact_attributes"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contact_list_persists"
              c:identifier="tp_connection_get_contact_list_persists"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:contact-list-persists property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_contact_list_state"
              c:identifier="tp_connection_get_contact_list_state"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:contact-list-state property</doc>
          <type name="ContactListState" c:type="TpContactListState"/>
        </return-value>
      </method>
      <method name="get_contacts_by_handle"
              c:identifier="tp_connection_get_contacts_by_handle"
              version="0.7.18">
        <doc xml:whitespace="preserve">Create a number of #TpContact objects and make asynchronous method calls
to hold their handles and ensure that all the features specified in
@features are ready for use (if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of handles of type %TP_HANDLE_TYPE_CONTACT representing the desired contacts</doc>
            <array length="0" zero-terminated="0" c:type="TpHandle*">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="2" zero-terminated="0" c:type="TpContactFeature*">
              <type name="guint"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByHandleCb"
                  c:type="TpConnectionContactsByHandleCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_contacts_by_id"
              c:identifier="tp_connection_get_contacts_by_id"
              version="0.7.18">
        <doc xml:whitespace="preserve">Create a number of #TpContact objects and make asynchronous method calls
to obtain their handles and ensure that all the features specified in
@features are ready for use (if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of IDs in @ids (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of strings representing the desired contacts by their identifiers in the IM protocol (XMPP JIDs, SIP URIs, MSN Passports, AOL screen-names etc.)</doc>
            <array length="0" zero-terminated="0" c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called (may be %NULL if @n_features is 0)</doc>
            <array length="2" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionContactsByIdCb"
                  c:type="TpConnectionContactsByIdCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_detailed_error"
              c:identifier="tp_connection_get_detailed_error"
              version="0.11.4">
        <doc xml:whitespace="preserve">If the connection has disconnected, return the D-Bus error name with which
it disconnected (in particular, this is %TP_ERROR_STR_CANCELLED if it was
disconnected by a user request).

Otherwise, return %NULL, without altering @details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus error name, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="details"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve"> optionally used to return a map from string to #GValue, which must not be modified or destroyed by the caller</doc>
            <type name="GLib.HashTable" c:type="GHashTable**">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_disjoint_groups"
              c:identifier="tp_connection_get_disjoint_groups"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:disjoint-groups</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_group_storage"
              c:identifier="tp_connection_get_group_storage"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:group-storage</doc>
          <type name="ContactMetadataStorageType"
                c:type="TpContactMetadataStorageType"/>
        </return-value>
      </method>
      <method name="get_protocol_name"
              c:identifier="tp_connection_get_protocol_name">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_request_uses_message"
              c:identifier="tp_connection_get_request_uses_message"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpConnection:request-uses-message property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_self_contact"
              c:identifier="tp_connection_get_self_contact"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return a #TpContact representing the local user on this connection.

The returned object is not necessarily valid after the main loop is
re-entered; ref it with g_object_ref() if you want to keep it.

property, which may be %NULL</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the TpConnection:self-contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="get_self_handle"
              c:identifier="tp_connection_get_self_handle"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return the %TP_HANDLE_TYPE_CONTACT handle of the local user on this
connection, or 0 if the self-handle is not known yet or the connection
has become invalid (the TpProxy::invalidated signal).

The returned handle is not necessarily valid forever (the
notify::self-handle signal will be emitted if it changes, which can happen
on protocols such as IRC). Construct a #TpContact object if you want to
track the local user's identifier in the protocol, or other information
like their presence status, over time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the TpConnection:self-handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_status"
              c:identifier="tp_connection_get_status"
              version="0.7.14">
        <doc xml:whitespace="preserve">If @reason is not %NULL it is set to the reason why "status" changed to its
current value, or %TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.

don't know yet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we</doc>
          <type name="ConnectionStatus" c:type="TpConnectionStatus"/>
        </return-value>
        <parameters>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a TpConnectionStatusReason, or %NULL</doc>
            <type name="ConnectionStatusReason"
                  c:type="TpConnectionStatusReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_immortal_handles"
              c:identifier="tp_connection_has_immortal_handles">
        <doc xml:whitespace="preserve">Return %TRUE if this connection is known to not destroy handles
(#TpHandle) until it disconnects.

On such connections, if you know that a handle maps to a particular
identifier now, then you can rely on that handle mapping to that
identifier for the whole lifetime of the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if handles last as long as the connection itself</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="hold_handles" c:identifier="tp_connection_hold_handles">
        <doc xml:whitespace="preserve">Hold (ensure a reference to) the given handles, if they are valid.

If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.

This function, along with tp_connection_unref_handles(),
tp_connection_get_contact_attributes() and #TpContact, keeps a client-side
reference count of handles; you should not use the RequestHandles,
HoldHandles and GetContactAttributes D-Bus methods directly as well as these
functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of handles</doc>
            <array length="2" zero-terminated="0" c:type="TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="ConnectionHoldHandlesCb"
                  c:type="TpConnectionHoldHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready"
              c:identifier="tp_connection_is_ready"
              version="0.7.17"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns the same thing as the #TpConnection:connection-ready property.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if introspection has completed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="parse_object_path"
              c:identifier="tp_connection_parse_object_path"
              version="0.7.27">
        <doc xml:whitespace="preserve">If the object path of @connection is in the correct form, set
@protocol and @cm_name, return TRUE. Otherwise leave them unchanged and
return FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the object path was correctly parsed, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">If not NULL, used to return the protocol of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="cm_name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">If not NULL, used to return the connection manager name of the connection</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh_contact_info"
              c:identifier="tp_connection_refresh_contact_info"
              version="0.11.7">
        <doc xml:whitespace="preserve">Requests to refresh the #TpContact:contact-info property on each contact from
@contacts, requesting it from the network if an up-to-date version is not
cached locally. "notify::contact-info" will be emitted when the contact's
information are updated.

If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on a contact, it will be
set before its property gets updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="remove_contacts_async"
              c:identifier="tp_connection_remove_contacts_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Remove the given @contacts from the contact list entirely. It is
protocol-dependent whether this works, and under which circumstances.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_contacts_finish"
              c:identifier="tp_connection_remove_contacts_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_remove_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_async"
              c:identifier="tp_connection_remove_from_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Remove the given @contacts from the given @group. If there are no members
left in the group afterwards, the group MAY itself be removed.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove from the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_finish"
              c:identifier="tp_connection_remove_from_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_remove_from_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_async"
              c:identifier="tp_connection_remove_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Remove all members from the given group, then remove the group itself.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to remove.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_group_finish"
              c:identifier="tp_connection_remove_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_remove_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_group_async"
              c:identifier="tp_connection_rename_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Rename the given @old_name.

On protocols where groups behave like tags, this is an API short-cut for
adding all of the group's members to a group with the new name, then removing
the old group.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to rename</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new name for the group</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_group_finish"
              c:identifier="tp_connection_rename_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_rename_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_handles"
              c:identifier="tp_connection_request_handles">
        <doc xml:whitespace="preserve">Request the handles corresponding to the given identifiers, and if they
are valid, hold (ensure a reference to) the corresponding handles.

If they are valid, the callback will later be called with the given
handles; if not all of them are valid, the callback will be called with
an error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timeout in milliseconds, or -1 to use the default</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="ids" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of string identifiers for which handles are required, terminated by %NULL (must not be %NULL or empty)</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">called on success or failure (unless @weak_object has become unreferenced)</doc>
            <type name="ConnectionRequestHandlesCb"
                  c:type="TpConnectionRequestHandlesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data after calling @callback, or when @weak_object becomes unreferenced (whichever occurs sooner)</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, an object to be weakly referenced: if it is destroyed, @callback will not be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_async"
              c:identifier="tp_connection_request_subscription_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Request that the given @contacts allow the local user to subscribe to their
presence, i.e. that their #TpContact:subscribe-state property becomes
%TP_SUBSCRIPTION_STATE_YES.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to whom requests are to be sent.</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">an optional plain-text message from the user, to send to those @contacts with the subscription request.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_finish"
              c:identifier="tp_connection_request_subscription_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_request_subscription_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run_until_ready"
              c:identifier="tp_connection_run_until_ready"
              version="0.7.1"
              introspectable="0"
              deprecated="Use tp_connection_call_when_ready,"
              deprecated-version="0.11.0">
        <doc xml:whitespace="preserve">If @self is connected and ready for use, return immediately. Otherwise,
call Connect() (unless @connect is %FALSE) and re-enter the main loop
until the connection becomes invalid, the connection connects successfully
and is introspected, or the main loop stored via @loop is cancelled.

%FALSE if the connection has become invalid.

or restructure your program in such a way as to avoid re-entering the
main loop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection is now connected and ready for use,</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="connect" transfer-ownership="none">
            <doc xml:whitespace="preserve">if %TRUE, call Connect() if it appears to be necessary; if %FALSE, rely on Connect() to be called by another client</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL and %FALSE is returned, used to raise an error</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="loop" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a #GMainLoop is placed here while it is being run (so calling code can call g_main_loop_quit() to abort), and %NULL is placed here after the loop has been run</doc>
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_info_async"
              c:identifier="tp_connection_set_contact_info_async"
              version="0.11.7">
        <doc xml:whitespace="preserve">Requests an asynchronous set of the contact info of @self. When
the operation is finished, @callback will be called. You can then call
tp_connection_set_contact_info_finish() to get the result of the operation.

This method should not be expected to succeed if the result of
tp_connection_get_contact_info_flags() does not include
%TP_CONTACT_INFO_FLAG_CAN_SET.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ContactInfoField"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_info_finish"
              c:identifier="tp_connection_set_contact_info_finish"
              version="0.11.7"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of @self info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_group_members_async"
              c:identifier="tp_connection_set_group_members_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add the given @contacts to the given @group (creating it if necessary), and
remove all other members.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects members for the group. If this set is empty, this method MAY remove the group.</doc>
            <array length="1" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_group_members_finish"
              c:identifier="tp_connection_set_group_members_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_set_group_members_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_contacts_async"
              c:identifier="tp_connection_unblock_contacts_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Direct the server to unblock @contacts.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to block</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_contacts_finish"
              c:identifier="tp_connection_unblock_contacts_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_unblock_contacts_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_async"
              c:identifier="tp_connection_unpublish_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Attempt to set the given @contacts' #TpContact:publish-state property to
%TP_SUBSCRIPTION_STATE_NO, i.e. stop sending presence to them.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_finish"
              c:identifier="tp_connection_unpublish_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_unpublish_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref_handles" c:identifier="tp_connection_unref_handles">
        <doc xml:whitespace="preserve">Do nothing. In versions of telepathy-glib prior to 0.13.8,
this released a reference to the handles in @handles.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="n_handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of handles in @handles</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of @n_handles handles</doc>
            <array length="1" zero-terminated="0" c:type="TpHandle*">
              <type name="Handle" c:type="TpHandle"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_async"
              c:identifier="tp_connection_unsubscribe_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Attempt to set the given @contacts' #TpContact:subscribe-state property to
%TP_SUBSCRIPTION_STATE_NO, i.e. stop receiving their presence.

For this to work properly @self must have interface
%TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects to remove</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_finish"
              c:identifier="tp_connection_unsubscribe_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_connection_unsubscribe_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="upgrade_contacts"
              c:identifier="tp_connection_upgrade_contacts"
              version="0.7.18">
        <doc xml:whitespace="preserve">Given several #TpContact objects, make asynchronous method calls
ensure that all the features specified in @features are ready for use
(if they are supported at all).

It is not an error to put features in @features even if the connection
manager doesn't support them - users of this method should have a static
list of features they would like to use if possible, and use it for all
connection managers.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of contacts in @contacts (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpContact objects associated with @self</doc>
            <array length="0" zero-terminated="0" c:type="TpContact**">
              <type name="Contact" c:type="TpContact*"/>
            </array>
          </parameter>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (must be at least 1)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of features that must be ready for use (if supported) before the callback is called</doc>
            <array length="2" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">A user callback to call when the contacts are ready</doc>
            <type name="ConnectionUpgradeContactsCb"
                  c:type="TpConnectionUpgradeContactsCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data either after @callback has been called, or if the operation is cancelled</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">An object to pass to the callback, which will be weakly referenced; if this object is destroyed, the operation will be cancelled</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <property name="balance" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Amount field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="gint"/>
      </property>
      <property name="balance-currency" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Currency field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="utf8"/>
      </property>
      <property name="balance-scale" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Scale field of the Balance.AccountBalance property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.

See Also: tp_connection_get_balance()</doc>
        <type name="guint"/>
      </property>
      <property name="balance-uri" transfer-ownership="none">
        <doc xml:whitespace="preserve">The Balance.ManageCreditURI property.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.</doc>
        <type name="utf8"/>
      </property>
      <property name="blocked-contacts"
                version="0.17.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray of blocked #TpContact. Changes are notified using the
#TpConnection::blocked-contacts-changed signal.

These TpContact objects have been prepared with the desired features.
See tp_simple_client_factory_add_contact_features() to define which
features needs to be prepared on them.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="can-change-contact-list"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If true, presence subscription and publication can be changed using the
RequestSubscription, AuthorizePublication and RemoveContacts methods.

Rational: link-local XMPP, presence is implicitly published to everyone in
the local subnet, so the user cannot control their presence publication.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean"/>
      </property>
      <property name="can-report-abusive"
                version="0.17.0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this property is %TRUE, contacts may be reported as abusive to the
server administrators by setting report_abusive to %TRUE when calling
tp_connection_block_contacts_async().

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <type name="gboolean"/>
      </property>
      <property name="capabilities" transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TpCapabilities object representing the capabilities of this
connection, or NULL if we don't know yet.

To wait for valid capability information, call tp_proxy_prepare_async()
with the feature %TP_CONNECTION_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="connection-manager-name"
                version="0.13.16"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">This connection's connection manager name.</doc>
        <type name="utf8"/>
      </property>
      <property name="connection-ready" transfer-ownership="none">
        <doc xml:whitespace="preserve">Initially %FALSE; changes to %TRUE when the connection has gone to
CONNECTED status, introspection has finished and it's ready for use.

By the time this property becomes %TRUE, any extra interfaces will
have been set up and the #TpProxy:interfaces property will have been
populated.

This is similar to %TP_CONNECTION_FEATURE_CONNECTED, except that once
it has changed to %TRUE, it remains %TRUE even if the connection has
been invalidated.</doc>
        <type name="gboolean"/>
      </property>
      <property name="contact-groups"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The names of all groups that currently exist. This may be a larger set than
the union of all #TpContact:contact-groups properties, if the connection
allows groups to be empty.

This property's value is not meaningful until the
#TpConnection:contact-list-state property has become
%TP_CONTACT_LIST_STATE_SUCCESS.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="contact-list-persists"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If true, presence subscriptions (in both directions) on this connection are
stored by the server or other infrastructure.

If false, presence subscriptions on this connection are not stored.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean"/>
      </property>
      <property name="contact-list-state"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The progress made in retrieving the contact list.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="guint"/>
      </property>
      <property name="disjoint-groups"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">True if each contact can be in at most one group; false if each contact
can be in many groups.

This property cannot change after the connection has moved to the
%TP_CONNECTION_STATUS_CONNECTED state. Until then, its value is undefined,
and it may change at any time, without notification.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <type name="gboolean"/>
      </property>
      <property name="group-storage"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Indicates the extent to which contacts' groups can be set and stored.

This property cannot change after the connection has moved to the
%TP_CONNECTION_STATUS_CONNECTED state. Until then, its value is undefined,
and it may change at any time, without notification.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <type name="guint"/>
      </property>
      <property name="protocol-name"
                version="0.13.16"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The connection's machine-readable protocol name, such as "jabber",
"msn" or "local-xmpp". Recommended names for most protocols can be
found in the Telepathy D-Bus Interface Specification.</doc>
        <type name="utf8"/>
      </property>
      <property name="request-uses-message"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If true, the Message parameter to RequestSubscription is likely to be
significant, and user interfaces SHOULD prompt the user for a message to
send with the request; a message such as "I would like to add you to my
contact list", translated into the local user's language, might make a
suitable default.

For this property to be valid, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST_PROPERTIES or
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <type name="gboolean"/>
      </property>
      <property name="self-contact" version="0.13.9" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpContact representing the local user on this connection,
or %NULL if not yet available.

If the local user's unique identifier changes (for instance by using
/nick on IRC), this property will change to a different #TpContact object
representing the new identifier, and #GObject::notify will be emitted.

The #TpContact object is guaranteed to have all of the features previously
passed to tp_simple_client_factory_add_contact_features() prepared.

To wait for a non-%NULL self-contact (and other properties), call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONNECTED.</doc>
        <type name="Contact"/>
      </property>
      <property name="self-handle" transfer-ownership="none">
        <doc xml:whitespace="preserve">The %TP_HANDLE_TYPE_CONTACT handle of the local user on this connection,
or 0 if we don't know yet or if the connection has become invalid.

This may change if the local user's unique identifier changes (for
instance by using /nick on IRC), in which case #GObject::notify will be
emitted.

To wait for a valid self-handle (and other properties), call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONNECTED.</doc>
        <type name="guint"/>
      </property>
      <property name="status" transfer-ownership="none">
        <doc xml:whitespace="preserve">This connection's status, or %TP_UNKNOWN_CONNECTION_STATUS if we don't
know yet.

To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.

Since version 0.11.3, the change to status
%TP_CONNECTION_STATUS_CONNECTED is delayed slightly, until introspection
of the connection has finished.</doc>
        <type name="guint"/>
      </property>
      <property name="status-reason" transfer-ownership="none">
        <doc xml:whitespace="preserve">To wait for a valid status (and other properties), call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_CORE.

The reason why #TpConnection:status changed to its current value,
or TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED if unknown.
know yet.</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ConnectionPrivate" c:type="TpConnectionPrivate*"/>
      </field>
      <glib:signal name="balance-changed"
                   when="last"
                   detailed="1"
                   version="0.15.1">
        <doc xml:whitespace="preserve">Emitted when at least one of the #TpConnection:balance,
#TpConnection:balance-scale or #TpConnection:balance-currency
property is changed.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature %TP_CONNECTION_FEATURE_BALANCE.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="balance" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpConnection:balance property</doc>
            <type name="gint"/>
          </parameter>
          <parameter name="balance_scale" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpConnection:balance-scale property</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="balance_currency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpConnection:balance-currency property</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="blocked-contacts-changed"
                   when="last"
                   version="0.17.0">
        <doc xml:whitespace="preserve">Notify of changes in #TpConnection:blocked-contacts.
It is guaranteed that all contacts have desired features prepared. See
tp_simple_client_factory_add_contact_features() to define which features
needs to be prepared.

This signal is also emitted for the initial set of blocked contacts once
retrieved.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_BLOCKING.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact which have been blocked</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact which are no longer blocked</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="contact-list-changed" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Notify of changes in the list of contacts as returned by
tp_connection_dup_contact_list(). It is guaranteed that all contacts have
desired features prepared. See
tp_simple_client_factory_add_contact_features() to define which features
needs to be prepared.

This signal is also emitted for the initial set of contacts once retrieved.

For this signal to be emitted, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact added to contacts list</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GPtrArray of #TpContact removed from contacts list</doc>
            <array name="GLib.PtrArray">
              <type name="Contact"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="group-renamed" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Emitted when a group is renamed, in protocols where this can be
distinguished from group creation, removal and membership changes.

Immediately after this signal is emitted, #TpConnection::groups-created
signal the creation of a group with the new name, and
#TpConnection::groups-removed signal the removal of a group with the old
name.
If the group was not empty, immediately after those signals are emitted,
#TpContact::contact-groups-changed signal that the members of that group
were removed from the old name and added to the new name.

When this signal is emitted, #TpConnection:contact-groups property is
already updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the old name of the group.</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new name of the group.</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="groups-created" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Emitted when new, empty groups are created. This will often be followed by
#TpContact::contact-groups-changed signals that add some members. When this
signal is emitted, #TpConnection:contact-groups property is already
updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GStrv with the names of the new groups.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="groups-removed" when="last" version="0.15.5">
        <doc xml:whitespace="preserve">Emitted when one or more groups are removed. If they had members at the
time that they were removed, then immediately after this signal is emitted,
#TpContact::contact-groups-changed signals that their members were removed.
When this signal is emitted, #TpConnection:contact-groups property is
already updated.

For this signal to be emited, you must first call
tp_proxy_prepare_async() with the feature
%TP_CONNECTION_FEATURE_CONTACT_GROUPS.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GStrv with the names of the groups.</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ConnectionAliasFlags" c:type="TpConnectionAliasFlags">
      <member name="connection_alias_flag_user_set"
              value="1"
              c:identifier="TP_CONNECTION_ALIAS_FLAG_USER_SET"/>
    </bitfield>
    <bitfield name="ConnectionCapabilityFlags"
              c:type="TpConnectionCapabilityFlags">
      <member name="create"
              value="1"
              c:identifier="TP_CONNECTION_CAPABILITY_FLAG_CREATE"/>
      <member name="invite"
              value="2"
              c:identifier="TP_CONNECTION_CAPABILITY_FLAG_INVITE"/>
    </bitfield>
    <record name="ConnectionClass"
            c:type="TpConnectionClass"
            glib:is-gtype-struct-for="Connection"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpConnection. In addition to @parent_class there are four
pointers reserved for possible future use.

(Changed in 0.7.12: the layout of the structure is visible, allowing
subclassing.)</doc>
      <field name="parent_class">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="ConnectionContactsByHandleCb"
              c:type="TpConnectionContactsByHandleCb"
              version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_handle().

If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts or
invalid handles are returned.

If some or even all of the @handles passed to
tp_connection_get_contacts_by_handle() were not valid, this is not
considered to be a failure. @error will be %NULL in this situation,
@contacts will contain contact objects for those handles that were
valid (possibly none of them), and @invalid will contain the handles
that were not valid.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects successfully created (one per valid handle), or 0 on unrecoverable errors</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given a reference to any of these objects, and must call g_object_ref() on any that it will keep), or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="TpContact**">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="n_failed" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of invalid handles that were passed to tp_connection_get_contacts_by_handle() (or on unrecoverable errors, the total number of handles that were given)</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="failed" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_failed handles that were passed to tp_connection_get_contacts_by_handle() but turned out to be invalid (or on unrecoverable errors, all the handles that were given)</doc>
          <array length="3" zero-terminated="0" c:type="TpHandle*">
            <type name="Handle" c:type="TpHandle"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an unrecoverable error that caused everything to fail</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_get_contacts_by_handle()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_get_contacts_by_handle()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionContactsByIdCb"
              c:type="TpConnectionContactsByIdCb"
              version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_get_contacts_by_id().

@requested_ids contains the IDs that were converted to handles successfully.
The normalized form of requested_ids[i] is
tp_contact_get_identifier (contacts[i]).

If some or even all of the @ids passed to
tp_connection_get_contacts_by_id() were not valid, this is not
considered to be a fatal error. @error will be %NULL in this situation,
@contacts will contain contact objects for those IDs that were
valid (it may be empty), and @failed_id_errors will map the IDs
that were not valid to a corresponding #GError (if the connection manager
complies with the Telepathy spec, it will have domain %TP_ERRORS and code
%TP_ERROR_INVALID_HANDLE).

If an unrecoverable error occurs (for instance, if @connection
becomes disconnected) the whole operation fails, and no contacts
or requested IDs are returned. @failed_id_errors will contain all the IDs
that were requested, mapped to a corresponding #GError (either one
indicating that the ID was invalid, if that was determined before the
fatal error occurred, or a copy of @error).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects successfully created (one per valid ID), or 0 on unrecoverable errors</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given a reference to any of these objects, and must call g_object_ref() on any that it will keep), or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="TpContact**">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="requested_ids" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts valid IDs (JIDs, SIP URIs etc.) that were passed to tp_connection_get_contacts_by_id(), in an order corresponding to @contacts, or %NULL on unrecoverable errors</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="failed_id_errors" transfer-ownership="none">
          <doc xml:whitespace="preserve">A hash table in which the keys are IDs and the values are errors (#GError)</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GLib.Error"/>
          </type>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an unrecoverable error that caused everything to fail</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_get_contacts_by_id()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_get_contacts_by_id()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionHoldHandlesCb"
              c:type="TpConnectionHoldHandlesCb">
      <doc xml:whitespace="preserve">Signature of the callback called when tp_connection_hold_handles() succeeds
or fails.

On success, the caller has a reference to each handle in @handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, they could be
released with tp_connection_unref_handles().

For convenience, the handle type and handles requested by the caller are
passed through to this callback on success, so the caller does not have to
include them in @user_data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle type that was passed to tp_connection_hold_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of handles that were passed to tp_connection_hold_handles() on success, or 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">a copy of the array of @n_handles handles that was passed to tp_connection_hold_handles() on success, or %NULL on failure</doc>
          <type name="Handle" c:type="TpHandle*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">the same arbitrary pointer that was passed to tp_connection_hold_handles()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_connection_hold_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ConnectionManager"
           c:symbol-prefix="connection_manager"
           c:type="TpConnectionManager"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpConnectionManager"
           glib:get-type="tp_connection_manager_get_type"
           glib:type-struct="ConnectionManagerClass">
      <doc xml:whitespace="preserve">A proxy object for a Telepathy connection manager.

This might represent a connection manager which is currently running
(in which case it can be introspected) or not (in which case its
capabilities can be read from .manager files in the filesystem).
Accordingly, this object never emits #TpProxy::invalidated unless all
references to it are discarded.

Various fields and methods on this object do not work until
%TP_CONNECTION_MANAGER_FEATURE_CORE is prepared. Use
tp_proxy_prepare_async() to wait for this to happen.

Note that the @protocols may be freed and reallocated (based on new
information) whenever the main loop is entered. Since 0.11.3, each protocol
struct can be copied with tp_connection_manager_protocol_copy() if a
private copy is needed.</doc>
      <constructor name="new"
                   c:identifier="tp_connection_manager_new"
                   throws="1">
        <doc xml:whitespace="preserve">Convenience function to create a new connection manager proxy. If
its protocol and parameter information are required, you should call
tp_connection_manager_call_when_ready() on the result.

is set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new reference to a connection manager proxy, or %NULL if @error</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">Proxy for the D-Bus daemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="manager_filename"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">The #TpConnectionManager:manager-file property, which may (and generally should) be %NULL.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="check_valid_name"
                c:identifier="tp_connection_manager_check_valid_name"
                version="0.7.1"
                throws="1">
        <doc xml:whitespace="preserve">Check that the given string is a valid connection manager name, i.e. that
it consists entirely of ASCII letters, digits and underscores, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a possible connection manager name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="check_valid_protocol_name"
                c:identifier="tp_connection_manager_check_valid_protocol_name"
                version="0.7.1"
                throws="1">
        <doc xml:whitespace="preserve">Check that the given string is a valid protocol name, i.e. that
it consists entirely of ASCII letters, digits and hyphen/minus, and starts
with a letter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a possible protocol name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_feature_quark_core"
                c:identifier="tp_connection_manager_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_connection_manager_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpConnectionManager have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_CONNECTION_MANAGER.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="activate"
              c:identifier="tp_connection_manager_activate"
              version="0.7.1"
              introspectable="0">
        <doc xml:whitespace="preserve">Attempt to run and introspect the connection manager, asynchronously.
Since 0.7.26 this function is not generally very useful, since
the connection manager will now be activated automatically if necessary.

If the CM was already running, do nothing and return %FALSE.

On success, emit #TpConnectionManager::activated when the CM appears
on the bus, and #TpConnectionManager::got-info when its capabilities
have been (re-)discovered.

On failure, emit #TpConnectionManager::exited without first emitting
activated.

if the connection manager was already running and no additional signals
will be emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if activation was needed and is now in progress, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="call_when_ready"
              c:identifier="tp_connection_manager_call_when_ready"
              version="0.7.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Call the @callback from the main loop when information about @cm's
supported protocols and parameters has been retrieved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">callback to call when information has been retrieved or on error</doc>
            <type name="ConnectionManagerWhenReadyCb"
                  c:type="TpConnectionManagerWhenReadyCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called to destroy @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">object to reference weakly; if it is destroyed, @callback will not be called, but @destroy will still be called</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_protocol_names"
              c:identifier="tp_connection_manager_dup_protocol_names"
              version="0.7.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns a list of protocol names supported by this connection manager.
These are the internal protocol names used by the Telepathy specification
(e.g. "jabber" and "msn"), rather than user-visible names in any particular
locale.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_connection_manager_call_when_ready() to wait for this.

The result is copied and must be freed by the caller, but it is not
necessarily still true after the main loop is re-entered.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GStrv of protocol names</doc>
          <type name="GObject.Strv" c:type="gchar**"/>
        </return-value>
      </method>
      <method name="get_info_source"
              c:identifier="tp_connection_manager_get_info_source"
              version="0.7.26">
        <doc xml:whitespace="preserve">If protocol and parameter information has been obtained from the connection
manager, return %TP_CM_INFO_SOURCE_LIVE; if it has been obtained from the
cache in the .manager file, return %TP_CM_INFO_SOURCE_FILE. If this
information has not yet been obtained, or obtaining it failed, return
%TP_CM_INFO_SOURCE_NONE.

This may increase at any time that the main loop is running; the
#GObject::notify signal is emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpConnectionManager:info-source property</doc>
          <type name="CMInfoSource" c:type="TpCMInfoSource"/>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="tp_connection_manager_get_name"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return the internal name of this connection manager in the Telepathy
D-Bus API, e.g. "gabble" or "haze". This is often the name of the binary
without the "telepathy-" prefix.

The returned string is valid as long as @self is. Copy it with g_strdup()
if a longer lifetime is required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #TpConnectionManager:connection-manager property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_protocol"
              c:identifier="tp_connection_manager_get_protocol"
              version="0.7.26">
        <doc xml:whitespace="preserve">Returns a structure representing a protocol, or %NULL if this connection
manager does not support the specified protocol.

Since 0.11.11, you can get a #GObject version with more
functionality by calling tp_connection_manager_get_protocol_object().

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use
tp_connection_manager_call_when_ready() to wait for this.

The result is not necessarily valid after the main loop is re-entered.
Since 0.11.3, it can be copied with tp_connection_manager_protocol_copy()
if a permanently-valid copy is needed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the protocol</doc>
          <type name="ConnectionManagerProtocol"
                c:type="TpConnectionManagerProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_protocol_object"
              c:identifier="tp_connection_manager_get_protocol_object"
              version="0.11.11">
        <doc xml:whitespace="preserve">Returns an object representing a protocol, or %NULL if this connection
manager does not support the specified protocol.

If this function is called before the connection manager information has
been obtained, the result is always %NULL. Use tp_proxy_prepare_async()
to wait for this.

The result should be referenced with g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an object representing the protocol, or %NULL</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_protocol"
              c:identifier="tp_connection_manager_has_protocol"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return whether @protocol is supported by this connection manager.

If this function is called before the connection manager information has
been obtained, the result is always %FALSE. Use
tp_connection_manager_call_when_ready() to wait for this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this connection manager supports @protocol</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="protocol" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a protocol as defined in the Telepathy D-Bus API, e.g. "jabber" or "msn"</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_ready"
              c:identifier="tp_connection_manager_is_ready"
              version="0.7.26"
              introspectable="0">
        <doc xml:whitespace="preserve">If protocol and parameter information has been obtained from the connection
manager or the cache in the .manager file, return %TRUE. Otherwise,
return %FALSE.

This may change from %FALSE to %TRUE at any time that the main loop is
running; the #GObject::notify signal is emitted for the
#TpConnectionManager:info-source property.

%TP_CM_INFO_SOURCE_NONE</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE, unless the #TpConnectionManager:info-source property is</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_running"
              c:identifier="tp_connection_manager_is_running"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return %TRUE if this connection manager currently appears to be running.
This may change at any time that the main loop is running; the
#TpConnectionManager::activated and #TpConnectionManager::exited signals
are emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the connection manager is currently running</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="always-introspect"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, always introspect the connection manager as it comes online,
even if we already have its info from a .manager file. Default %FALSE.</doc>
        <type name="gboolean"/>
      </property>
      <property name="connection-manager" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the connection manager, e.g. "gabble" (read-only).</doc>
        <type name="utf8"/>
      </property>
      <property name="info-source" transfer-ownership="none">
        <doc xml:whitespace="preserve">Where we got the current information on supported protocols
(a #TpCMInfoSource).

Since 0.7.26, the #GObject::notify signal is emitted for this
property.

(Note that this is of type %G_TYPE_UINT, not %TP_TYPE_CM_INFO_SOURCE,
for historical reasons.)</doc>
        <type name="guint"/>
      </property>
      <property name="manager-file"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The absolute path of the .manager file. If set to %NULL (the default),
the XDG data directories will be searched for a .manager file of the
correct name.

If set to the empty string, no .manager file will be read.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="protocols">
        <type name="ConnectionManagerProtocol"
              c:type="TpConnectionManagerProtocol**"/>
      </field>
      <field name="running" bits="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="always_introspect" bits="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="info_source" bits="2">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="reserved_flags" bits="28">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv">
        <type name="ConnectionManagerPrivate"
              c:type="TpConnectionManagerPrivate*"/>
      </field>
      <glib:signal name="activated" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when the connection manager's well-known name appears on the bus.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="exited" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when the connection manager's well-known name disappears from
the bus or when activation fails.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="got-info" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when the connection manager's capabilities have been discovered.

This signal is not very helpful. Since 0.7.26, using
tp_connection_manager_call_when_ready() instead is recommended.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpCMInfoSource</doc>
            <type name="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ConnectionManagerClass"
            c:type="TpConnectionManagerClass"
            glib:is-gtype-struct-for="ConnectionManager"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpConnectionManager.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ProxyClass" c:type="TpProxyClass"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer*"/>
      </field>
    </record>
    <callback name="ConnectionManagerListCb"
              c:type="TpConnectionManagerListCb"
              version="0.7.1">
      <doc xml:whitespace="preserve">Signature of the callback supplied to tp_list_connection_managers().

Since 0.11.3, tp_list_connection_managers() will
wait for %TP_CONNECTION_MANAGER_FEATURE_CORE to be prepared on each
connection manager passed to @callback, unless an error occurred while
launching that connection manager.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of #TpConnectionManager (the objects will be unreferenced and the array will be freed after the callback returns, so the callback must reference any CMs it stores a pointer to), or %NULL on error</doc>
          <array c:type="TpConnectionManager**">
            <type name="ConnectionManager" c:type="TpConnectionManager*"/>
          </array>
        </parameter>
        <parameter name="n_cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of connection managers in @cms (not including the final %NULL)</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user-supplied data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ConnectionManagerParam"
            c:type="TpConnectionManagerParam"
            version="0.7.1"
            glib:type-name="TpConnectionManagerParam"
            glib:get-type="tp_connection_manager_param_get_type"
            c:symbol-prefix="connection_manager_param">
      <doc xml:whitespace="preserve">Structure representing a connection manager parameter.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="dbus_signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="default_value" writable="1">
        <type name="GObject.Value" c:type="GValue"/>
      </field>
      <field name="flags" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy"
              c:identifier="tp_connection_manager_param_copy"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- Returns: says it all --&gt;

tp_connection_manager_param_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly (slice) allocated #TpConnectionManagerParam, free with</doc>
          <type name="ConnectionManagerParam"
                c:type="TpConnectionManagerParam*"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_connection_manager_param_free"
              version="0.11.3">
        <doc xml:whitespace="preserve">Frees @param, which was copied with tp_connection_manager_param_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_dbus_signature"
              c:identifier="tp_connection_manager_param_get_dbus_signature"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the D-Bus signature of the parameter</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_default"
              c:identifier="tp_connection_manager_param_get_default"
              version="0.7.26">
        <doc xml:whitespace="preserve">Get the default value for this parameter, if there is one. If %FALSE is
returned, @value is left uninitialized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there is a default value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to an unset (all zeroes) #GValue into which the default's type and value are written</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name"
              c:identifier="tp_connection_manager_param_get_name"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the parameter</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_dbus_property"
              c:identifier="tp_connection_manager_param_is_dbus_property"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter represents a D-Bus property of the same name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_required"
              c:identifier="tp_connection_manager_param_is_required"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter is normally required</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_required_for_registration"
              c:identifier="tp_connection_manager_param_is_required_for_registration"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

(by setting the special "register" parameter to %TRUE)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter is required when registering a new account</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_secret"
              c:identifier="tp_connection_manager_param_is_secret"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter's value is a password or other secret</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </record>
    <record name="ConnectionManagerPrivate"
            c:type="TpConnectionManagerPrivate"
            disguised="1">
    </record>
    <record name="ConnectionManagerProtocol"
            c:type="TpConnectionManagerProtocol"
            version="0.7.1"
            glib:type-name="TpConnectionManagerProtocol"
            glib:get-type="tp_connection_manager_protocol_get_type"
            c:symbol-prefix="connection_manager_protocol">
      <doc xml:whitespace="preserve">Structure representing a protocol supported by a connection manager.
Note that the size of this structure may change, so its size must not be
relied on.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="params" writable="1">
        <type name="ConnectionManagerParam"
              c:type="TpConnectionManagerParam*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="can_register"
              c:identifier="tp_connection_manager_protocol_can_register"
              version="0.7.26">
        <doc xml:whitespace="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="copy"
              c:identifier="tp_connection_manager_protocol_copy"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- Returns: says it all --&gt;

tp_connection_manager_protocol_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly (slice) allocated #TpConnectionManagerProtocol, free with</doc>
          <type name="ConnectionManagerProtocol"
                c:type="TpConnectionManagerProtocol*"/>
        </return-value>
      </method>
      <method name="dup_param_names"
              c:identifier="tp_connection_manager_protocol_dup_param_names"
              version="0.7.26"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.

The result is copied and must be freed by the caller with g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GStrv of protocol names</doc>
          <type name="GObject.Strv" c:type="gchar**"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_connection_manager_protocol_free"
              version="0.11.3">
        <doc xml:whitespace="preserve">Frees @proto, which was copied with tp_connection_manager_protocol_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_param"
              c:identifier="tp_connection_manager_protocol_get_param"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;

supported</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the parameter @param, or %NULL if not</doc>
          <type name="ConnectionManagerParam"
                c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_param"
              c:identifier="tp_connection_manager_protocol_has_param"
              version="0.7.26">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter @param.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="ConnectionManagerWhenReadyCb"
              c:type="TpConnectionManagerWhenReadyCb">
      <doc xml:whitespace="preserve">Called as the result of tp_connection_manager_call_when_ready(). If the
connection manager's protocol and parameter information could be retrieved,
@error is %NULL and @cm is considered to be ready. Otherwise, @error is
non-%NULL and @cm is not ready.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cm" transfer-ownership="none">
          <doc xml:whitespace="preserve">a connection manager</doc>
          <type name="ConnectionManager" c:type="TpConnectionManager*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or the reason why tp_connection_manager_is_ready() would return %FALSE</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the @user_data passed to tp_connection_manager_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object passed to tp_connection_manager_call_when_ready()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionNameListCb"
              c:type="TpConnectionNameListCb"
              version="0.7.1">
      <doc xml:whitespace="preserve">Signature of the callback supplied to tp_list_connection_names().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="names" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n connection bus names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of names (not including the final %NULL), or 0 on error</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="cms" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n connection manager names (e.g. "gabble") in the same order as @names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="protocols" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL-terminated array of @n protocol names as defined in the Telepathy spec (e.g. "jabber") in the same order as @names, or %NULL on error</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error that occurred</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:whitespace="preserve">user-supplied data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied weakly referenced object</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionPresenceType"
                 c:type="TpConnectionPresenceType">
      <member name="unset"
              value="0"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNSET"/>
      <member name="offline"
              value="1"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_OFFLINE"/>
      <member name="available"
              value="2"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_AVAILABLE"/>
      <member name="away"
              value="3"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_AWAY"/>
      <member name="extended_away"
              value="4"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_EXTENDED_AWAY"/>
      <member name="hidden"
              value="5"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_HIDDEN"/>
      <member name="busy"
              value="6"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_BUSY"/>
      <member name="unknown"
              value="7"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_UNKNOWN"/>
      <member name="error"
              value="8"
              c:identifier="TP_CONNECTION_PRESENCE_TYPE_ERROR"/>
    </enumeration>
    <record name="ConnectionPrivate"
            c:type="TpConnectionPrivate"
            disguised="1">
    </record>
    <callback name="ConnectionRequestHandlesCb"
              c:type="TpConnectionRequestHandlesCb">
      <doc xml:whitespace="preserve">Signature of the callback called when tp_connection_request_handles()
succeeds or fails.

On success, the caller has a reference to each handle in @handles.

Since telepathy-glib version 0.13.8,
the handles will remain valid until @connection becomes invalid
(signalled by #TpProxy::invalidated). In earlier versions, they could be
released with tp_connection_unref_handles().

For convenience, the handle type and IDs requested by the caller are
passed through to this callback, so the caller does not have to include
them in @user_data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the handle type that was passed to tp_connection_request_handles()</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="n_handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of IDs that were passed to tp_connection_request_handles() on success, or 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @n_handles handles corresponding to @ids, in the same order, or %NULL on failure</doc>
          <array length="2" zero-terminated="0" c:type="TpHandle*">
            <type name="guint"/>
          </array>
        </parameter>
        <parameter name="ids" transfer-ownership="none">
          <doc xml:whitespace="preserve">a copy of the array of @n_handles IDs that was passed to tp_connection_request_handles() on success, or %NULL on failure</doc>
          <array length="2" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL on success, or an error on failure</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">the same arbitrary pointer that was passed to tp_connection_request_handles()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_connection_request_handles()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ConnectionStatus" c:type="TpConnectionStatus">
      <member name="connected"
              value="0"
              c:identifier="TP_CONNECTION_STATUS_CONNECTED"/>
      <member name="connecting"
              value="1"
              c:identifier="TP_CONNECTION_STATUS_CONNECTING"/>
      <member name="disconnected"
              value="2"
              c:identifier="TP_CONNECTION_STATUS_DISCONNECTED"/>
    </enumeration>
    <enumeration name="ConnectionStatusReason"
                 c:type="TpConnectionStatusReason">
      <member name="none_specified"
              value="0"
              c:identifier="TP_CONNECTION_STATUS_REASON_NONE_SPECIFIED"/>
      <member name="requested"
              value="1"
              c:identifier="TP_CONNECTION_STATUS_REASON_REQUESTED"/>
      <member name="network_error"
              value="2"
              c:identifier="TP_CONNECTION_STATUS_REASON_NETWORK_ERROR"/>
      <member name="authentication_failed"
              value="3"
              c:identifier="TP_CONNECTION_STATUS_REASON_AUTHENTICATION_FAILED"/>
      <member name="encryption_error"
              value="4"
              c:identifier="TP_CONNECTION_STATUS_REASON_ENCRYPTION_ERROR"/>
      <member name="name_in_use"
              value="5"
              c:identifier="TP_CONNECTION_STATUS_REASON_NAME_IN_USE"/>
      <member name="cert_not_provided"
              value="6"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_PROVIDED"/>
      <member name="cert_untrusted"
              value="7"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_UNTRUSTED"/>
      <member name="cert_expired"
              value="8"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_EXPIRED"/>
      <member name="cert_not_activated"
              value="9"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_NOT_ACTIVATED"/>
      <member name="cert_hostname_mismatch"
              value="10"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_HOSTNAME_MISMATCH"/>
      <member name="cert_fingerprint_mismatch"
              value="11"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_FINGERPRINT_MISMATCH"/>
      <member name="cert_self_signed"
              value="12"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_SELF_SIGNED"/>
      <member name="cert_other_error"
              value="13"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_OTHER_ERROR"/>
      <member name="cert_revoked"
              value="14"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_REVOKED"/>
      <member name="cert_insecure"
              value="15"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_INSECURE"/>
      <member name="cert_limit_exceeded"
              value="16"
              c:identifier="TP_CONNECTION_STATUS_REASON_CERT_LIMIT_EXCEEDED"/>
    </enumeration>
    <callback name="ConnectionUpgradeContactsCb"
              c:type="TpConnectionUpgradeContactsCb"
              version="0.7.18">
      <doc xml:whitespace="preserve">Signature of a callback used to receive the result of
tp_connection_upgrade_contacts().

If an unrecoverable error occurs (for instance, if @connection becomes
disconnected) it is indicated by @error, but the contacts in @contacts
are still provided.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="n_contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of TpContact objects for which an upgrade was requested</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of @n_contacts TpContact objects (this callback is not given an extra reference to any of these objects, and must call g_object_ref() on any that it will keep)</doc>
          <array length="1" zero-terminated="0" c:type="TpContact**">
            <type name="Contact" c:type="TpContact*"/>
          </array>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">An unrecoverable error, or %NULL if the connection remains valid</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="4">
          <doc xml:whitespace="preserve">the @user_data that was passed to tp_connection_upgrade_contacts()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the @weak_object that was passed to tp_connection_upgrade_contacts()</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ConnectionWhenReadyCb" c:type="TpConnectionWhenReadyCb">
      <doc xml:whitespace="preserve">Signature of a callback passed to tp_connection_call_when_ready(), which
will be called exactly once, when the connection becomes ready or
invalid (whichever happens first)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">the connection (which may be in the middle of being disposed, if error is non-%NULL, error-&gt;domain is TP_DBUS_ERRORS and error-&gt;code is TP_DBUS_ERROR_PROXY_UNREFERENCED)</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">%NULL if the connection is ready for use, or the error with which it was invalidated if it is now invalid</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">whatever was passed to tp_connection_call_when_ready()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Contact"
           c:symbol-prefix="contact"
           c:type="TpContact"
           version="0.7.18"
           parent="GObject.Object"
           glib:type-name="TpContact"
           glib:get-type="tp_contact_get_type"
           glib:type-struct="ContactClass">
      <doc xml:whitespace="preserve">An object representing a contact on a #TpConnection.

Contact objects support tracking a number of attributes of contacts, as
described by the #TpContactFeature flags. Features can be specified when
instantiating contact objects (with tp_connection_get_contacts_by_id() or
tp_connection_get_contacts_by_handle()), or added to an existing contact
object with tp_connection_upgrade_contacts(). For example, a client wishing
to keep track of a contact's alias would set #TP_CONTACT_FEATURE_ALIAS, and
then listen for the "notify::alias" signal, emitted whenever the
#TpContact:alias property changes.

Note that releasing a #TpContact object might release handle references
held by calling tp_cli_connection_call_request_handles(),
tp_cli_connection_run_request_handles(),
tp_cli_connection_call_hold_handles(),
tp_cli_connection_run_hold_handles(),
tp_cli_connection_interface_contacts_call_get_contact_attributes() or
tp_cli_connection_interface_contacts_run_get_contact_attributes() directly.
Those functions should be avoided in favour of using #TpContact,
tp_connection_hold_handles(), tp_connection_request_handles() and
tp_connection_get_contact_attributes().</doc>
      <method name="add_to_group_async"
              c:identifier="tp_contact_add_to_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_add_to_group_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_to_group_finish"
              c:identifier="tp_contact_add_to_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_add_to_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_async"
              c:identifier="tp_contact_authorize_publication_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_authorize_publication_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="authorize_publication_finish"
              c:identifier="tp_contact_authorize_publication_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_authorize_publication_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_async"
              c:identifier="tp_contact_block_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Block communications with a contact, optionally reporting the contact as
abusive to the server administrators. To block more than one contact at once,
see tp_connection_block_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="report_abusive" transfer-ownership="none">
            <doc xml:whitespace="preserve">If %TRUE, report this contact as abusive to the server administrators as well as blocking him. See #TpConnection:can-report-abusive to discover whether reporting abuse is supported. If #TpConnection:can-report-abusive is %FALSE, this parameter will be ignored.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="block_finish"
              c:identifier="tp_contact_block_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_block_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alias"
              c:identifier="tp_contact_get_alias"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's alias. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL alias as the #TpContact:alias</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_avatar_file"
              c:identifier="tp_contact_get_avatar_file"
              version="0.11.6">
        <doc xml:whitespace="preserve">Return the contact's avatar file. This remains valid until the main loop
is re-entered; if the caller requires a #GFile that will persist for
longer than that, it must be reffed with g_object_ref().

(possibly %NULL)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #GFile as the #TpContact:avatar-file property</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
      </method>
      <method name="get_avatar_mime_type"
              c:identifier="tp_contact_get_avatar_mime_type"
              version="0.11.6">
        <doc xml:whitespace="preserve">Return the contact's avatar MIME type. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().

(possibly %NULL)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same MIME type as the #TpContact:avatar-mime-type property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_avatar_token"
              c:identifier="tp_contact_get_avatar_token"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's avatar token. This remains valid until the main loop
is re-entered; if the caller requires a string that will persist for
longer than that, it must be copied with g_strdup().

(possibly %NULL)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same token as the #TpContact:avatar-token property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_contact_get_capabilities"
              version="0.11.3">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

#TpContact:capabilities property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same #TpCapabilities (or %NULL) as the</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_client_types"
              c:identifier="tp_contact_get_client_types"
              version="0.13.1">
        <doc xml:whitespace="preserve">Return the contact's client types or %NULL if the client types are
unspecified.

#GStrv as the #TpContact:client-types property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_connection"
              c:identifier="tp_contact_get_connection"
              version="0.7.18">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;

(it must be referenced with g_object_ref if it must remain valid
longer than the contact)</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a borrowed reference to the #TpContact:connection</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
      </method>
      <method name="get_contact_groups"
              c:identifier="tp_contact_get_contact_groups"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return names of groups of which a contact is a member. It is incorrect to
call this method before %TP_CONTACT_FEATURE_CONTACT_GROUPS has been
prepared. This remains valid until the main loop is re-entered; if the caller
requires a #GStrv that will persist for longer than that, it must be copied
with g_strdupv().

#GStrv as the #TpContact:contact-groups property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_contact_info"
              c:identifier="tp_contact_get_contact_info"
              version="0.11.7">
        <doc xml:whitespace="preserve">Returns a newly allocated #GList of contact's vCard fields. The list must be
freed with g_list_free() after used.

Note that the #TpContactInfoField&lt;!-- --&gt;s in the returned #GList are not
dupped before returning from this function. One could copy every item in the
list using tp_contact_info_field_copy().

Same as the #TpContact:contact-info property.

a #GList of #TpContactInfoField, or %NULL if the feature is not yet
prepared.</doc>
        <return-value transfer-ownership="container">
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
      </method>
      <method name="get_handle"
              c:identifier="tp_contact_get_handle"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's handle, which is of type %TP_HANDLE_TYPE_CONTACT,
or 0 if the #TpContact:connection has become invalid.

This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as @self exists and the
#TpContact:connection remains valid.

However, the caller of this function does not gain an additional reference
to the handle.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same handle as the #TpContact:handle property</doc>
          <type name="Handle" c:type="TpHandle"/>
        </return-value>
      </method>
      <method name="get_identifier"
              c:identifier="tp_contact_get_identifier"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's identifier. This remains valid for as long as @self
exists; if the caller requires a string that will persist for longer than
that, it must be copied with g_strdup().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL identifier as the #TpContact:identifier property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_location"
              c:identifier="tp_contact_get_location"
              version="0.11.1">
        <doc xml:whitespace="preserve">Return the contact's user-defined location or %NULL if the location is
unspecified.
This remains valid until the main loop is re-entered; if the caller
requires a hash table that will persist for longer than that, it must be
reffed with g_hash_table_ref().

#GHashTable (or %NULL) as the #TpContact:location property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_presence_message"
              c:identifier="tp_contact_get_presence_message"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the contact's user-defined status message, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().

property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL message as the #TpContact:presence-message</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_presence_status"
              c:identifier="tp_contact_get_presence_status"
              version="0.7.18">
        <doc xml:whitespace="preserve">Return the name of the contact's presence status, or an empty string.
This remains valid until the main loop is re-entered; if the caller
requires a string that will persist for longer than that, it must be
copied with g_strdup().

property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same non-%NULL status name as the #TpContact:presence-status</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_presence_type"
              c:identifier="tp_contact_get_presence_type"
              version="0.7.18">
        <doc xml:whitespace="preserve">If this object has been set up to track %TP_CONTACT_FEATURE_PRESENCE
and the underlying connection supports either the Presence or
SimplePresence interfaces, return the type of the contact's presence.

Otherwise, return %TP_CONNECTION_PRESENCE_TYPE_UNSET.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same presence type as the #TpContact:presence-type property</doc>
          <type name="ConnectionPresenceType"
                c:type="TpConnectionPresenceType"/>
        </return-value>
      </method>
      <method name="get_publish_request"
              c:identifier="tp_contact_get_publish_request"
              version="0.13.12">
        <doc xml:whitespace="preserve">If #TpContact:publish-state is set to %TP_SUBSCRIPTION_STATE_ASK, return the
message that this remote contact sent when they requested permission to see
the local user's presence, an empty string ("") otherwise. This remains valid
until the main loop is re-entered; if the caller requires a string that will
persist for longer than that, it must be copied with g_strdup().

This is set to %NULL until %TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been
prepared, and it is guaranteed to be non-%NULL afterward.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:publish-request.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_publish_state"
              c:identifier="tp_contact_get_publish_state"
              version="0.13.12">
        <doc xml:whitespace="preserve">Return the state of this remote contact's subscription to the local user's
presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:publish-state.</doc>
          <type name="SubscriptionState" c:type="TpSubscriptionState"/>
        </return-value>
      </method>
      <method name="get_subscribe_state"
              c:identifier="tp_contact_get_subscribe_state"
              version="0.13.12">
        <doc xml:whitespace="preserve">Return the state of the local user's subscription to this remote contact's
presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:subscribe-state.</doc>
          <type name="SubscriptionState" c:type="TpSubscriptionState"/>
        </return-value>
      </method>
      <method name="has_feature"
              c:identifier="tp_contact_has_feature"
              version="0.7.18">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self has been set up to track the feature @feature</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a desired feature</doc>
            <type name="ContactFeature" c:type="TpContactFeature"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_blocked"
              c:identifier="tp_contact_is_blocked"
              version="0.17.0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpContact:is-blocked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove_async"
              c:identifier="tp_contact_remove_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_remove_contacts_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_finish"
              c:identifier="tp_contact_remove_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_remove_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_async"
              c:identifier="tp_contact_remove_from_group_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_remove_from_group_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="group" transfer-ownership="none">
            <doc xml:whitespace="preserve">the group to alter.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_from_group_finish"
              c:identifier="tp_contact_remove_from_group_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_remove_from_group_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_contact_info_async"
              c:identifier="tp_contact_request_contact_info_async"
              version="0.11.7">
        <doc xml:whitespace="preserve">Requests an asynchronous request of the contact info of @self. When
the operation is finished, @callback will be called. You can then call
tp_contact_request_contact_info_finish() to get the result of the operation.

If the operation is successful, the #TpContact:contact-info property will be
updated (emitting "notify::contact-info" signal) before @callback is called.
That means you can call tp_contact_get_contact_info() to get the new vCard
inside @callback.

Note that requesting the vCard from the network can take significant time, so
a bigger timeout is set on the underlying D-Bus call. @cancellable can be
cancelled to free resources used in the D-Bus call if the caller is no longer
interested in the vCard.

If %TP_CONTACT_FEATURE_CONTACT_INFO is not yet set on @self, it will be
set before its property gets updated and @callback is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_contact_info_finish"
              c:identifier="tp_contact_request_contact_info_finish"
              version="0.11.7"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async request of @self info. If the operation was successful,
the contact's vCard can be accessed using tp_contact_get_contact_info().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_async"
              c:identifier="tp_contact_request_subscription_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_request_subscription_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">an optional message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_subscription_finish"
              c:identifier="tp_contact_request_subscription_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_request_subscription_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_groups_async"
              c:identifier="tp_contact_set_contact_groups_async"
              version="0.13.14">
        <doc xml:whitespace="preserve">Add @self to the given groups (creating new groups if necessary), and remove
it from all other groups. If the user is removed from a group of which they
were the only member, the group MAY be removed automatically. You can then
call tp_contact_set_contact_groups_finish() to get the result of the
operation.

If the operation is successful and %TP_CONTACT_FEATURE_CONTACT_GROUPS is
prepared, the #TpContact:contact-groups property will be
updated (emitting "notify::contact-groups" signal) and
#TpContact::contact-groups-changed signal will be emitted before @callback
is called. That means you can call tp_contact_get_contact_groups() to get the
new contact groups inside @callback.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_groups" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of groups, or -1 if @groups is %NULL-terminated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="groups" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the set of groups which the contact should be in (may be %NULL if @n_groups is 0)</doc>
            <array length="0" zero-terminated="0" c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_contact_groups_finish"
              c:identifier="tp_contact_set_contact_groups_finish"
              version="0.13.14"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async set of @self contact groups.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the request call was successful, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_async"
              c:identifier="tp_contact_unblock_async"
              version="0.17.0">
        <doc xml:whitespace="preserve">Unblock communications with a contact. To unblock more than one contact
at once, see tp_connection_unblock_contacts_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unblock_finish"
              c:identifier="tp_contact_unblock_finish"
              version="0.17.0"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_unblock_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_async"
              c:identifier="tp_contact_unpublish_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_unpublish_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpublish_finish"
              c:identifier="tp_contact_unpublish_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_unpublish_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_async"
              c:identifier="tp_contact_unsubscribe_async"
              version="0.15.5">
        <doc xml:whitespace="preserve">Convenience wrapper for tp_connection_unsubscribe_async()
on a single contact.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the operation finishes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unsubscribe_finish"
              c:identifier="tp_contact_unsubscribe_finish"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Finishes tp_contact_unsubscribe_async()</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="alias" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's alias if available, falling back to their
#TpContact:identifier if no alias is available or if the #TpContact has
not been set up to track %TP_CONTACT_FEATURE_ALIAS.

This alias may have been supplied by the contact themselves, or by the
local user, so it does not necessarily unambiguously identify the contact.
However, it is suitable for use as a main "display name" for the contact.

This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8"/>
      </property>
      <property name="avatar-file" version="0.11.6" transfer-ownership="none">
        <doc xml:whitespace="preserve">#GFile to the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.

When #TpContact:avatar-token changes, this property is not updated
immediately, but will be updated when the new avatar data is retrieved and
stored in cache. Until then, the file will keep its old value of the latest
cached avatar image.

This is set to %NULL if %TP_CONTACT_FEATURE_AVATAR_DATA is not set on this
contact. Note that setting %TP_CONTACT_FEATURE_AVATAR_DATA will also
implicitly set %TP_CONTACT_FEATURE_AVATAR_TOKEN.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="avatar-mime-type"
                version="0.11.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">MIME type of the latest cached avatar image, or %NULL if this contact has
no avatar, or if the avatar data is not yet retrieved.

This is always the MIME type of the image given by #TpContact:avatar-file.</doc>
        <type name="utf8"/>
      </property>
      <property name="avatar-token" transfer-ownership="none">
        <doc xml:whitespace="preserve">An opaque string representing state of the contact's avatar (depending on
the protocol, this might be a hash, a timestamp or something else), or
an empty string if there is no avatar.

This may be %NULL if it is not known whether this contact has an avatar
or not (either for network protocol reasons, or because this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_AVATAR_TOKEN).</doc>
        <type name="utf8"/>
      </property>
      <property name="capabilities" version="0.11.3" transfer-ownership="none">
        <doc xml:whitespace="preserve">The capabilities supported by this contact. If the underlying Connection
doesn't support the ContactCapabilities interface, this property will
contain the capabilities supported by the connection.
Use tp_capabilities_is_specific_to_contact() to check if the capabilities
are specific to this #TpContact or not.

This may be %NULL if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_CAPABILITIES.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="client-types" version="0.13.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GStrv containing the client types of this contact.

This is set to %NULL if %TP_CONTACT_FEATURE_CLIENT_TYPES is not
set on this contact; it may also be %NULL if that feature is prepared, but
the contact's client types are unknown.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="connection" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnection to which this contact belongs.</doc>
        <type name="Connection"/>
      </property>
      <property name="contact-groups"
                version="0.13.14"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GStrv with names of groups of which a contact is a member.

This is set to %NULL if %TP_CONTACT_FEATURE_CONTACT_GROUPS is not prepared
on this contact, or if the connection does not implement ContactGroups
interface.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="contact-info" version="0.11.7" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GList of #TpContactInfoField representing the vCard of this contact.

This is set to %NULL if %TP_CONTACT_FEATURE_CONTACT_INFO is not set on this
contact.</doc>
        <type name="ContactInfoList"/>
      </property>
      <property name="handle" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's handle in the Telepathy D-Bus API, a handle of type
%TP_HANDLE_TYPE_CONTACT representing the string
given by #TpContact:identifier.

This handle is referenced using the Telepathy D-Bus API and remains
referenced for as long as the #TpContact exists and the
#TpContact:connection remains valid.

However, getting this property does not cause an additional reference
to the handle to be held.

If the #TpContact:connection becomes invalid, this property is no longer
meaningful and will be set to 0.</doc>
        <type name="guint"/>
      </property>
      <property name="identifier" transfer-ownership="none">
        <doc xml:whitespace="preserve">The contact's identifier in the instant messaging protocol (e.g.
XMPP JID, SIP URI, AOL screenname or IRC nick - whatever the underlying
protocol uses to identify a user).

This is never %NULL for contact objects that are visible to library-user
code.</doc>
        <type name="utf8"/>
      </property>
      <property name="is-blocked" version="0.17.0" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the contact has been blocked.

This is set to %FALSE if %TP_CONTACT_FEATURE_CONTACT_BLOCKING is not
prepared on this contact, or if the connection does not implement
ContactBlocking interface.</doc>
        <type name="gboolean"/>
      </property>
      <property name="location"
                version="0.11.1"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If this contact has set a user-defined location, a string to
#GValue * hash table containing his location. If not, %NULL.
tp_asv_get_string() and similar functions can be used to access
the contents.

This may be %NULL even if the contact has set a location,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_LOCATION.</doc>
        <type/>
      </property>
      <property name="presence-message" transfer-ownership="none">
        <doc xml:whitespace="preserve">If this contact has set a user-defined status message, that message;
if not, an empty string (which user interfaces may replace with a
localized form of the #TpContact:presence-status or
#TpContact:presence-type).

This may be an empty string even if the contact has set a message,
if this #TpContact object has not been set up to track
%TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="presence-status" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the presence status of this contact. This may be
a well-known string from the Telepathy specification, like "available",
or a connection-manager-specific string, like "out-to-lunch".

This may be an empty string if this #TpContact object has not been set up
to track %TP_CONTACT_FEATURE_PRESENCE. It is never %NULL.</doc>
        <type name="utf8"/>
      </property>
      <property name="presence-type" transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpConnectionPresenceType representing the type of presence status
for this contact.

This is provided so even unknown values for #TpContact:presence-status
can be classified into their fundamental types.

This may be %TP_CONNECTION_PRESENCE_TYPE_UNSET if this #TpContact
has not been set up to track %TP_CONTACT_FEATURE_PRESENCE.</doc>
        <type name="guint"/>
      </property>
      <property name="publish-request"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The message that contact sent when they requested permission to see the
local user's presence, if #TpContact:publish-state is
%TP_SUBSCRIPTION_STATE_ASK, an empty string ("") otherwise.

This is set to %NULL until %TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been
prepared, and it is guaranteed to be non-%NULL afterward.</doc>
        <type name="utf8"/>
      </property>
      <property name="publish-state"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpSubscriptionState indicating the state of this contact's subscription
to the local user's presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <type name="guint"/>
      </property>
      <property name="subscribe-state"
                version="0.13.12"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpSubscriptionState indicating the state of the local user's
subscription to this contact's presence.

This is set to %TP_SUBSCRIPTION_STATE_UNKNOWN until
%TP_CONTACT_FEATURE_SUBSCRIPTION_STATES has been prepared</doc>
        <type name="guint"/>
      </property>
      <glib:signal name="contact-groups-changed" when="last" version="0.13.14">
        <doc xml:whitespace="preserve">Emitted when this contact's groups changes. When this signal is emitted,
#TpContact:contact-groups property is already updated.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="added" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GStrv with added contact groups</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="removed" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GStrv with removed contact groups</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="presence-changed" when="last" version="0.11.7">
        <doc xml:whitespace="preserve">Emitted when this contact's presence changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-type</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-status</doc>
            <type name="utf8"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new value of #TpContact:presence-message</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="subscription-states-changed"
                   when="last"
                   version="0.13.12">
        <doc xml:whitespace="preserve">Emitted when this contact's subscription states changes.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="subscribe" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of #TpContact:subscribe-state</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="publish" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of #TpContact:publish-state</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="publish_request" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of #TpContact:publish-request</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <bitfield name="ContactBlockingCapabilities"
              c:type="TpContactBlockingCapabilities">
      <member name="contact_blocking_capability_can_report_abusive"
              value="1"
              c:identifier="TP_CONTACT_BLOCKING_CAPABILITY_CAN_REPORT_ABUSIVE"/>
    </bitfield>
    <record name="ContactClass"
            c:type="TpContactClass"
            disguised="1"
            glib:is-gtype-struct-for="Contact">
    </record>
    <enumeration name="ContactFeature"
                 version="0.7.18"
                 c:type="TpContactFeature">
      <doc xml:whitespace="preserve">Enumeration representing the features a #TpContact can optionally support.
When requesting a #TpContact, library users specify the desired features;
the #TpContact code will only initialize state for those features, to
avoid unwanted D-Bus round-trips and signal connections.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_CONTACT_FEATURE.</doc>
      <member name="alias" value="0" c:identifier="TP_CONTACT_FEATURE_ALIAS"/>
      <member name="avatar_token"
              value="1"
              c:identifier="TP_CONTACT_FEATURE_AVATAR_TOKEN"/>
      <member name="presence"
              value="2"
              c:identifier="TP_CONTACT_FEATURE_PRESENCE"/>
      <member name="location"
              value="3"
              c:identifier="TP_CONTACT_FEATURE_LOCATION"/>
      <member name="capabilities"
              value="4"
              c:identifier="TP_CONTACT_FEATURE_CAPABILITIES"/>
      <member name="avatar_data"
              value="5"
              c:identifier="TP_CONTACT_FEATURE_AVATAR_DATA"/>
      <member name="contact_info"
              value="6"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_INFO"/>
      <member name="client_types"
              value="7"
              c:identifier="TP_CONTACT_FEATURE_CLIENT_TYPES"/>
      <member name="subscription_states"
              value="8"
              c:identifier="TP_CONTACT_FEATURE_SUBSCRIPTION_STATES"/>
      <member name="contact_groups"
              value="9"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_GROUPS"/>
      <member name="contact_blocking"
              value="10"
              c:identifier="TP_CONTACT_FEATURE_CONTACT_BLOCKING"/>
    </enumeration>
    <record name="ContactInfoField"
            c:type="TpContactInfoField"
            version="0.11.7"
            glib:type-name="TpContactInfoField"
            glib:get-type="tp_contact_info_field_get_type"
            c:symbol-prefix="contact_info_field">
      <doc xml:whitespace="preserve">A structure representing an information about a contact. Similar to a vCard
field.</doc>
      <field name="field_name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="field_value" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="tp_contact_info_field_new"
                   version="0.11.7">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_contact_info_field_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpContactInfoField, free it with</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the field; this is the lowercased name of a vCard field. For example, a field representing a contact's address would be named "adr".</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:whitespace="preserve">A list of vCard type parameters applicable to this field, with their values. The type parameter names, and any values that are case-insensitive in vCard, MUST be in lower case. For example, a contact's preferred home address would have parameters 'type=home' and 'type=pref'.</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="field_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">For unstructured vCard fields (such as 'fn', a formatted name field), a single-element array containing the field's value. For structured fields (such as 'adr', an address field), an array corresponding to the semicolon-separated elements of the field (with empty strings for empty elements).</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="tp_contact_info_field_copy"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_contact_info_field_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpContactInfoField, free it with</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_contact_info_field_free"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #TpContactInfoField.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags">
      <member name="parameters_exact"
              value="1"
              c:identifier="TP_CONTACT_INFO_FIELD_FLAG_PARAMETERS_EXACT"/>
      <member name="overwritten_by_nickname"
              value="2"
              c:identifier="TP_CONTACT_INFO_FIELD_FLAG_OVERWRITTEN_BY_NICKNAME"/>
    </bitfield>
    <record name="ContactInfoFieldSpec"
            c:type="TpContactInfoFieldSpec"
            version="0.11.7"
            glib:type-name="TpContactInfoFieldSpec"
            glib:get-type="tp_contact_info_field_spec_get_type"
            c:symbol-prefix="contact_info_field_spec">
      <doc xml:whitespace="preserve">A struct describing a vCard field.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parameters" writable="1">
        <array c:type="GStrv">
          <type name="utf8"/>
        </array>
      </field>
      <field name="flags" writable="1">
        <type name="ContactInfoFieldFlags" c:type="TpContactInfoFieldFlags"/>
      </field>
      <field name="max" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy"
              c:identifier="tp_contact_info_field_spec_copy"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_contact_info_field_spec_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #TpContactInfoFieldSpec, free it with</doc>
          <type name="ContactInfoFieldSpec" c:type="TpContactInfoFieldSpec*"/>
        </return-value>
      </method>
      <method name="free"
              c:identifier="tp_contact_info_field_spec_free"
              version="0.11.7"
              introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #TpContactInfoFieldSpec.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <bitfield name="ContactInfoFlags" c:type="TpContactInfoFlags">
      <member name="can_set"
              value="1"
              c:identifier="TP_CONTACT_INFO_FLAG_CAN_SET"/>
      <member name="push" value="2" c:identifier="TP_CONTACT_INFO_FLAG_PUSH"/>
    </bitfield>
    <glib:boxed glib:name="ContactInfoList"
                c:symbol-prefix="contact_info_list"
                glib:type-name="TpContactInfoList"
                glib:get-type="tp_contact_info_list_get_type">
      <function name="copy"
                c:identifier="tp_contact_info_list_copy"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_contact_info_list_free()</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoField, free it with</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free"
                c:identifier="tp_contact_info_list_free"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <glib:boxed glib:name="ContactInfoSpecList"
                c:symbol-prefix="contact_info_spec_list"
                glib:type-name="TpContactInfoSpecList"
                glib:get-type="tp_contact_info_spec_list_get_type">
      <function name="copy"
                c:identifier="tp_contact_info_spec_list_copy"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

free it with tp_contact_info_spec_list_free()</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoFieldSpec,</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="free"
                c:identifier="tp_contact_info_spec_list_free"
                version="0.11.7"
                introspectable="0">
        <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <enumeration name="ContactListState" c:type="TpContactListState">
      <member name="none" value="0" c:identifier="TP_CONTACT_LIST_STATE_NONE"/>
      <member name="waiting"
              value="1"
              c:identifier="TP_CONTACT_LIST_STATE_WAITING"/>
      <member name="failure"
              value="2"
              c:identifier="TP_CONTACT_LIST_STATE_FAILURE"/>
      <member name="success"
              value="3"
              c:identifier="TP_CONTACT_LIST_STATE_SUCCESS"/>
    </enumeration>
    <enumeration name="ContactMetadataStorageType"
                 c:type="TpContactMetadataStorageType">
      <member name="none"
              value="0"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_NONE"/>
      <member name="subscribed_or_pending"
              value="1"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_SUBSCRIBED_OR_PENDING"/>
      <member name="subscribed"
              value="2"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_SUBSCRIBED"/>
      <member name="anyone"
              value="3"
              c:identifier="TP_CONTACT_METADATA_STORAGE_TYPE_ANYONE"/>
    </enumeration>
    <record name="ContactPrivate" c:type="TpContactPrivate" disguised="1">
    </record>
    <class name="ContactSearch"
           c:symbol-prefix="contact_search"
           c:type="TpContactSearch"
           version="0.13.11"
           parent="GObject.Object"
           glib:type-name="TpContactSearch"
           glib:get-type="tp_contact_search_get_type"
           glib:type-struct="ContactSearchClass">
      <doc xml:whitespace="preserve">An object for Telepathy contact searches.
There are no interesting public struct fields.</doc>
      <implements name="Gio.AsyncInitable"/>
      <constructor name="new_finish"
                   c:identifier="tp_contact_search_new_finish"
                   version="0.13.11"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

in case of error.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new contact search object, or %NULL</doc>
          <type name="ContactSearch" c:type="TpContactSearch*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="new_async"
                c:identifier="tp_contact_search_new_async"
                version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account for the contact search</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
          <parameter name="server" transfer-ownership="none">
            <doc xml:whitespace="preserve">the server on which to search for contacts, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum number of results the server should return, or 0 for the server default.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_account"
              c:identifier="tp_contact_search_get_account"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The TpContactSearch:account property</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
      </method>
      <method name="get_limit"
              c:identifier="tp_contact_search_get_limit"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The TpContactSearch:limit property</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_search_keys"
              c:identifier="tp_contact_search_get_search_keys"
              version="0.13.11">
        <doc xml:whitespace="preserve">Get the search keys for a contact search.
The keys are vCard field names in lower case, except when
they're one of the special cases from telepathy-spec like
"tel;cell" or "x-n-given". See the
&lt;ulink url="http://telepathy.freedesktop.org/spec/Channel_Type_Contact_Search.html"&gt;
Channel.Type.ContactSearch interface&lt;/ulink&gt;
for a list of the special cases.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new search keys, or %NULL.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_server"
              c:identifier="tp_contact_search_get_server"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The TpContactSearch:server property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="reset_async"
              c:identifier="tp_contact_search_reset_async"
              version="0.13.11">
        <doc xml:whitespace="preserve">Resets the contact search object so a new search can be performed.
If another tp_contact_search_reset_async() call is in progress,
it will be cancelled and tp_contact_search_reset_finish() will
return an appropriate error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="server" transfer-ownership="none">
            <doc xml:whitespace="preserve">the server on which to search for contacts, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="limit" transfer-ownership="none">
            <doc xml:whitespace="preserve">The maximum number of results the server should return, or 0 for the server default.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a #GAsyncReadyCallback to call when the initialization is finished</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to the callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset_finish"
              c:identifier="tp_contact_search_reset_finish"
              version="0.13.11"
              throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

in case of error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new search keys, or %NULL</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GAsyncResult from the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start"
              c:identifier="tp_contact_search_start"
              version="0.13.11">
        <doc xml:whitespace="preserve">Starts a search for the keys specified in @criteria. Connect
to the #TpContactSearch::search-results-received signal
before calling this function.

Before searching again on the same #TpContactSearch, you must
call tp_contact_search_reset_async().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="criteria" transfer-ownership="none">
            <doc xml:whitespace="preserve">a map from keys returned by tp_contact_search_get_search_keys() to values to search for</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="account"
                version="0.13.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">This search's account.</doc>
        <type name="Account"/>
      </property>
      <property name="limit"
                version="0.13.11"
                writable="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The maximum number of results that the server should return.
This is only supported by some protocols; use
tp_capabilities_supports_contact_search() to check if it's
supported.

To change the limit after the object has been constructed,
use tp_contact_search_reset_async().</doc>
        <type name="guint"/>
      </property>
      <property name="server"
                version="0.13.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The search server. This is only supported by some protocols;
use tp_capabilities_supports_contact_search() to check if it's
supported.

To change the server after the object has been constructed,
use tp_contact_search_reset_async().</doc>
        <type name="utf8"/>
      </property>
      <property name="state" version="0.13.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">This search's state, as a %TpChannelContactSearchState.</doc>
        <type name="guint"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ContactSearchPrivate" c:type="TpContactSearchPrivate*"/>
      </field>
      <glib:signal name="search-results-received"
                   when="last"
                   version="0.13.11">
        <doc xml:whitespace="preserve">Emitted when search results are received. Note that this signal may
be emitted multiple times for the same search.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="results" transfer-ownership="none">
            <doc xml:whitespace="preserve"> a #GList with the search results</doc>
            <type name="GLib.List">
              <type name="ContactSearchResult"/>
            </type>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ContactSearchClass"
            c:type="TpContactSearchClass"
            glib:is-gtype-struct-for="ContactSearch"
            version="0.13.11">
      <doc xml:whitespace="preserve">The class of a #TpContactSearch.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="ContactSearchPrivate"
            c:type="TpContactSearchPrivate"
            disguised="1">
    </record>
    <class name="ContactSearchResult"
           c:symbol-prefix="contact_search_result"
           c:type="TpContactSearchResult"
           version="0.13.11"
           parent="GObject.Object"
           glib:type-name="TpContactSearchResult"
           glib:get-type="tp_contact_search_result_get_type"
           glib:type-struct="ContactSearchResultClass">
      <doc xml:whitespace="preserve">An object representing the results of a Telepathy contact
search channel.
There are no interesting public struct fields.</doc>
      <method name="get_field"
              c:identifier="tp_contact_search_result_get_field"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

result doesn't have it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the specified field, or %NULL if the</doc>
          <type name="ContactInfoField" c:type="TpContactInfoField*"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fields"
              c:identifier="tp_contact_search_result_get_fields">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

a #GList of #TpContactInfoField for the specified contact. You should free
it when you're done with g_list_free().</doc>
        <return-value transfer-ownership="container">
          <type name="GLib.List" c:type="GList*">
            <type name="ContactInfoField"/>
          </type>
        </return-value>
      </method>
      <method name="get_identifier"
              c:identifier="tp_contact_search_result_get_identifier"
              version="0.13.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the contact identifier.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <property name="identifier"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ContactSearchResultPrivate"
              c:type="TpContactSearchResultPrivate*"/>
      </field>
    </class>
    <record name="ContactSearchResultClass"
            c:type="TpContactSearchResultClass"
            glib:is-gtype-struct-for="ContactSearchResult"
            version="0.13.11">
      <doc xml:whitespace="preserve">The class of a #TpContactSearchResult.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="ContactSearchResultPrivate"
            c:type="TpContactSearchResultPrivate"
            disguised="1">
    </record>
    <record name="ContactsMixin" c:type="TpContactsMixin">
      <doc xml:whitespace="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="ContactsMixinPrivate" c:type="TpContactsMixinPrivate*"/>
      </field>
      <function name="add_contact_attributes_iface"
                c:identifier="tp_contacts_mixin_add_contact_attributes_iface"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Declare that the given interface has contact attributes which can be added
to the attributes hash using the filler function. All the handles in the
handle array passed to the filler function are guaranteed to be valid and
referenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:whitespace="preserve">Name of the interface that has ContactAttributes</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="fill_contact_attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">Contact attribute filler function</doc>
            <type name="ContactsMixinFillContactAttributesFunc"
                  c:type="TpContactsMixinFillContactAttributesFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_contacts_mixin_finalize"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Free resources held by the contacts mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object with this mixin.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_contact_attributes"
                c:identifier="tp_contacts_mixin_get_contact_attributes"
                introspectable="0">
        <doc xml:whitespace="preserve">Get contact attributes for the given contacts. Provide attributes for all requested
interfaces. If contact attributes are not immediately known, the behaviour is defined
by the interface; the attribute should either be omitted from the result or replaced
with a default value.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A dictionary mapping the contact handles to contact attributes.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A connection instance that uses this mixin. The connection must be connected.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">List of handles to retrieve contacts for. Any invalid handles will be dropped from the returned mapping.</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">A list of interfaces to retrieve attributes from.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="assumed_interfaces" transfer-ownership="none">
            <doc xml:whitespace="preserve">A list of additional interfaces to retrieve attributes from. This can be used for interfaces documented as automatically included, like %TP_IFACE_CONNECTION for GetContactAttributes, or %TP_IFACE_CONNECTION and %TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST for GetContactListAttributes.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="sender" transfer-ownership="none">
            <doc xml:whitespace="preserve">The DBus client's unique name. If this is not NULL, the requested handles will be held on behalf of this client.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_contacts_mixin_get_offset_quark"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="iface_init"
                c:identifier="tp_contacts_mixin_iface_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the contacts interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceContacts in an object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_contacts_mixin_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_init ((GObject *) self,
G_STRUCT_OFFSET (SomeObject, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpContactsMixin within the object structure</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_contact_attribute"
                c:identifier="tp_contacts_mixin_set_contact_attribute"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Utility function to set attribute for handle to value in the attributes hash
as passed to a TpContactsMixinFillContactAttributesFunc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="contact_attributes" transfer-ownership="none">
            <doc xml:whitespace="preserve">contacts attribute hash as passed to TpContactsMixinFillContactAttributesFunc</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">Handle to set the attribute on</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">attribute name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">slice allocated GValue containing the value of the attribute, for instance with tp_g_value_slice_new. Ownership of the GValue is taken over by the mixin</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ContactsMixinClass" c:type="TpContactsMixinClass">
      <doc xml:whitespace="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_contacts_mixin_class_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="ContactsMixinClassPrivate"
              c:type="TpContactsMixinClassPrivate*"/>
      </field>
      <function name="get_offset_quark"
                c:identifier="tp_contacts_mixin_class_get_offset_quark"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_contacts_mixin_class_init"
                version="0.7.14"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_class_init ((GObjectClass *) klass,
G_STRUCT_OFFSET (SomeObjectClass, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpContactsMixinClass within the class structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ContactsMixinClassPrivate"
            c:type="TpContactsMixinClassPrivate"
            disguised="1">
    </record>
    <callback name="ContactsMixinFillContactAttributesFunc"
              c:type="TpContactsMixinFillContactAttributesFunc">
      <doc xml:whitespace="preserve">This function is called to supply contact attributes pertaining to
a particular interface, for a list of contacts.
All the handles in @contacts are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the Contacts interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">The contact handles for which attributes are requested</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="attributes_hash" transfer-ownership="none">
          <doc xml:whitespace="preserve">hash of handle =&gt; hash of attributes, containing all the contacts in the contacts array</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </callback>
    <record name="ContactsMixinPrivate"
            c:type="TpContactsMixinPrivate"
            disguised="1">
    </record>
    <class name="DBusDaemon"
           c:symbol-prefix="dbus_daemon"
           c:type="TpDBusDaemon"
           version="0.7.1"
           parent="Proxy"
           glib:type-name="TpDBusDaemon"
           glib:get-type="tp_dbus_daemon_get_type"
           glib:type-struct="DBusDaemonClass">
      <doc xml:whitespace="preserve">A subclass of #TpProxy that represents the D-Bus daemon. It mainly provides
functionality to manage well-known names on the bus.</doc>
      <constructor name="new"
                   c:identifier="tp_dbus_daemon_new"
                   version="0.7.1"
                   introspectable="0">
        <doc xml:whitespace="preserve">Returns a proxy for signals and method calls on a particular bus
connection.

Use tp_dbus_daemon_dup() instead if you just want a connection to the
starter or session bus (which is almost always the right thing for
Telepathy).

to which @connection is connected</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new proxy for signals and method calls on the bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a connection to D-Bus</doc>
            <type c:type="DBusGConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="dup"
                c:identifier="tp_dbus_daemon_dup"
                version="0.7.26"
                throws="1">
        <doc xml:whitespace="preserve">Returns a proxy for signals and method calls on the D-Bus daemon on which
this process was activated (if it was launched by D-Bus service
activation), or the session bus (otherwise).

If it is not possible to connect to the appropriate bus, raise an error
and return %NULL.

The returned #TpDBusDaemon is cached; the same #TpDBusDaemon object will
be returned by this function repeatedly, as long as at least one reference
exists.

calls on the bus daemon, or %NULL</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a proxy for signals and method</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_dbus_daemon_init_known_interfaces"
                version="0.7.32">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpDBusDaemon have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_DBUS_DAEMON.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="cancel_name_owner_watch"
              c:identifier="tp_dbus_daemon_cancel_name_owner_watch"
              version="0.7.1"
              introspectable="0">
        <doc xml:whitespace="preserve">If there was a previous call to tp_dbus_daemon_watch_name_owner()
with exactly the given @name, @callback and @user_data, remove it.

If more than one watch matching the details provided was active, remove
only the most recently added one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if there was such a watch, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name that was being watched</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">the callback that was called</doc>
            <type name="DBusDaemonNameOwnerChangedCb"
                  c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the user data that was provided</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_unique_name"
              c:identifier="tp_dbus_daemon_get_unique_name"
              version="0.7.35">
        <doc xml:whitespace="preserve">&lt;!-- Returns: is enough --&gt;

as long as this #TpDBusDaemon is</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the unique name of this connection to the bus, which is valid for</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="list_activatable_names"
              c:identifier="tp_dbus_daemon_list_activatable_names"
              version="0.7.35">
        <doc xml:whitespace="preserve">Call the ListActivatableNames method on the bus daemon, asynchronously.
The @callback will be called from the main loop with a list of all the
well-known names that are available for service-activation on the bus.

In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_activatable_names(), since
that function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">timeout for the call</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb"
                  c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">if not %NULL, called with @user_data as argument after the call has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a GObject which will be weakly referenced; if it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_names"
              c:identifier="tp_dbus_daemon_list_names"
              version="0.7.35">
        <doc xml:whitespace="preserve">Call the ListNames method on the bus daemon, asynchronously. The @callback
will be called from the main loop with a list of all the names (either
unique or well-known) that exist on the bus.

In versions of telepathy-glib that have it, this should be preferred
instead of calling tp_cli_dbus_daemon_call_list_names(), since that
function will result in wakeups for every NameOwnerChanged signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout_ms" transfer-ownership="none">
            <doc xml:whitespace="preserve">timeout for the call</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">callback to be called on success or failure; must not be %NULL</doc>
            <type name="DBusDaemonListNamesCb"
                  c:type="TpDBusDaemonListNamesCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">opaque user-supplied data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">if not %NULL, called with @user_data as argument after the call has succeeded or failed, or after @weak_object has been destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, a GObject which will be weakly referenced; if it is destroyed, @callback will not be called at all</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_object"
              c:identifier="tp_dbus_daemon_register_object"
              version="0.11.3">
        <doc xml:whitespace="preserve">Export @object at @object_path. This is a convenience wrapper around
dbus_g_connection_register_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object path</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object to export</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_name"
              c:identifier="tp_dbus_daemon_release_name"
              version="0.7.30"
              throws="1">
        <doc xml:whitespace="preserve">Release the given well-known name. This makes a synchronous call to the bus
daemon.

if an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @well_known_name was released, or %FALSE and sets @error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a well-known name owned by this process to release</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_name"
              c:identifier="tp_dbus_daemon_request_name"
              version="0.7.30"
              throws="1">
        <doc xml:whitespace="preserve">Claim the given well-known name without queueing, allowing replacement
or replacing an existing name-owner. This makes a synchronous call to the
bus daemon.

an error occurred.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @well_known_name was claimed, or %FALSE and sets @error if</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="well_known_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a well-known name to acquire</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="idempotent" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to consider it to be a success if this process already owns the name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_object"
              c:identifier="tp_dbus_daemon_unregister_object"
              version="0.11.3">
        <doc xml:whitespace="preserve">Stop exporting @object on D-Bus. This is a convenience wrapper around
dbus_g_connection_unregister_g_object(), and behaves similarly.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">an object previously exported with tp_dbus_daemon_register_object()</doc>
            <type name="GObject.Object" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="watch_name_owner"
              c:identifier="tp_dbus_daemon_watch_name_owner"
              version="0.7.1">
        <doc xml:whitespace="preserve">Arrange for @callback to be called with the owner of @name as soon as
possible (which might even be before this function returns!), then
again every time the ownership of @name changes.

If multiple watches are registered for the same @name, they will be called
in the order they were registered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name whose ownership is to be watched</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">Callback to call when the ownership is discovered or changes</doc>
            <type name="DBusDaemonNameOwnerChangedCb"
                  c:type="TpDBusDaemonNameOwnerChangedCb"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Arbitrary data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Called to destroy @user_data when the name owner watch is cancelled due to tp_dbus_daemon_cancel_name_owner_watch()</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="DBusDaemonClass"
            c:type="TpDBusDaemonClass"
            disguised="1"
            glib:is-gtype-struct-for="DBusDaemon"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of #TpDBusDaemon.</doc>
    </record>
    <callback name="DBusDaemonListNamesCb"
              c:type="TpDBusDaemonListNamesCb"
              version="0.7.35">
      <doc xml:whitespace="preserve">Signature of a callback for functions that list bus names.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">object representing a connection to a bus</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="names" transfer-ownership="none">
          <doc xml:whitespace="preserve">constant %NULL-terminated array of constant strings representing bus names, or %NULL on error</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">the error that occurred, or %NULL on success</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">the same user data that was passed to tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the same object that was passed to tp_dbus_daemon_list_names or tp_dbus_daemon_list_activatable_names</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DBusDaemonNameOwnerChangedCb"
              c:type="TpDBusDaemonNameOwnerChangedCb"
              version="0.7.1">
      <doc xml:whitespace="preserve">The signature of the callback called by tp_dbus_daemon_watch_name_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name whose ownership has changed or been discovered</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="new_owner" transfer-ownership="none">
          <doc xml:whitespace="preserve">The unique name that now owns @name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">Arbitrary user-supplied data as passed to tp_dbus_daemon_watch_name_owner()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusDaemonPrivate"
            c:type="TpDBusDaemonPrivate"
            disguised="1">
    </record>
    <enumeration name="DBusError" version="0.7.1" c:type="TpDBusError">
      <doc xml:whitespace="preserve">#GError codes for use with the %TP_DBUS_ERRORS domain.

Since 0.11.5, there is a corresponding #GEnumClass type,
%TP_TYPE_DBUS_ERROR.</doc>
      <member name="unknown_remote_error"
              value="0"
              c:identifier="TP_DBUS_ERROR_UNKNOWN_REMOTE_ERROR"/>
      <member name="proxy_unreferenced"
              value="1"
              c:identifier="TP_DBUS_ERROR_PROXY_UNREFERENCED"/>
      <member name="no_interface"
              value="2"
              c:identifier="TP_DBUS_ERROR_NO_INTERFACE"/>
      <member name="name_owner_lost"
              value="3"
              c:identifier="TP_DBUS_ERROR_NAME_OWNER_LOST"/>
      <member name="invalid_bus_name"
              value="4"
              c:identifier="TP_DBUS_ERROR_INVALID_BUS_NAME"/>
      <member name="invalid_interface_name"
              value="5"
              c:identifier="TP_DBUS_ERROR_INVALID_INTERFACE_NAME"/>
      <member name="invalid_object_path"
              value="6"
              c:identifier="TP_DBUS_ERROR_INVALID_OBJECT_PATH"/>
      <member name="invalid_member_name"
              value="7"
              c:identifier="TP_DBUS_ERROR_INVALID_MEMBER_NAME"/>
      <member name="object_removed"
              value="8"
              c:identifier="TP_DBUS_ERROR_OBJECT_REMOVED"/>
      <member name="cancelled"
              value="9"
              c:identifier="TP_DBUS_ERROR_CANCELLED"/>
      <member name="inconsistent"
              value="10"
              c:identifier="TP_DBUS_ERROR_INCONSISTENT"/>
    </enumeration>
    <bitfield name="DBusNameType" version="0.7.1" c:type="TpDBusNameType">
      <doc xml:whitespace="preserve">A set of flags indicating which D-Bus bus names are acceptable.
They can be combined with the bitwise-or operator to accept multiple
types. %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON and %TP_DBUS_NAME_TYPE_ANY are
the bitwise-or of other appropriate types, for convenience.

Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_NAME_TYPE.</doc>
      <member name="unique" value="1" c:identifier="TP_DBUS_NAME_TYPE_UNIQUE"/>
      <member name="well_known"
              value="2"
              c:identifier="TP_DBUS_NAME_TYPE_WELL_KNOWN"/>
      <member name="bus_daemon"
              value="4"
              c:identifier="TP_DBUS_NAME_TYPE_BUS_DAEMON"/>
      <member name="not_bus_daemon"
              value="3"
              c:identifier="TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON"/>
      <member name="any" value="7" c:identifier="TP_DBUS_NAME_TYPE_ANY"/>
    </bitfield>
    <bitfield name="DBusPropertiesMixinFlags"
              version="0.7.3"
              c:type="TpDBusPropertiesMixinFlags">
      <doc xml:whitespace="preserve">Bitfield representing allowed access to a property. At most one of
%TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_CHANGED and
%TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_INVALIDATED may be specified for a
property.

Since 0.11.5, there is a corresponding #GFlagsClass type,
%TP_TYPE_DBUS_PROPERTIES_MIXIN_FLAGS.</doc>
      <member name="read"
              value="1"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_READ"/>
      <member name="write"
              value="2"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_WRITE"/>
      <member name="emits_changed"
              value="4"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_CHANGED"/>
      <member name="emits_invalidated"
              value="8"
              c:identifier="TP_DBUS_PROPERTIES_MIXIN_FLAG_EMITS_INVALIDATED"/>
    </bitfield>
    <callback name="DBusPropertiesMixinGetter"
              c:type="TpDBusPropertiesMixinGetter">
      <doc xml:whitespace="preserve">Signature of a callback used to get the value of a property.

For simplicity, in this mixin we don't allow getting a property to fail;
implementations must always be prepared to return *something*.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DBusPropertiesMixinIfaceImpl"
            c:type="TpDBusPropertiesMixinIfaceImpl"
            version="0.7.3">
      <doc xml:whitespace="preserve">Structure representing an implementation of an interface's properties.

In addition to the documented fields, there are four pointers which must
be initialized to %NULL.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="getter" writable="1">
        <type name="DBusPropertiesMixinGetter"
              c:type="TpDBusPropertiesMixinGetter"/>
      </field>
      <field name="setter" writable="1">
        <type name="DBusPropertiesMixinSetter"
              c:type="TpDBusPropertiesMixinSetter"/>
      </field>
      <field name="props" writable="1">
        <type name="DBusPropertiesMixinPropImpl"
              c:type="TpDBusPropertiesMixinPropImpl*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_next" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="mixin_priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinIfaceInfo"
            c:type="TpDBusPropertiesMixinIfaceInfo"
            version="0.7.3">
      <doc xml:whitespace="preserve">Semi-abstract description of an interface. Each service GInterface that
has properties must have one of these attached to it via
tp_svc_interface_set_dbus_properties_info() in its base_init function;
service GInterfaces that do not have properties may have one of these
with no properties.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.

In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="dbus_interface" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="props" writable="1">
        <type name="DBusPropertiesMixinPropInfo"
              c:type="TpDBusPropertiesMixinPropInfo*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropImpl"
            c:type="TpDBusPropertiesMixinPropImpl"
            version="0.7.3">
      <doc xml:whitespace="preserve">Structure representing an implementation of a property.

In addition to the documented fields, there are three pointers which must
be initialized to %NULL.

This structure must either be statically allocated, or duplicated and never
freed, so it always remains valid.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="getter_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="setter_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="mixin_priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="DBusPropertiesMixinPropInfo"
            c:type="TpDBusPropertiesMixinPropInfo"
            version="0.7.3">
      <doc xml:whitespace="preserve">Semi-abstract description of a property, as attached to a service
GInterface. This structure must either be statically allocated, or
duplicated and never freed, so it always remains valid.

In addition to the documented members, there are two private pointers
for future expansion, which must always be initialized to %NULL.</doc>
      <field name="name" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="flags" writable="1">
        <type name="DBusPropertiesMixinFlags"
              c:type="TpDBusPropertiesMixinFlags"/>
      </field>
      <field name="dbus_signature" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
    </record>
    <callback name="DBusPropertiesMixinSetter"
              c:type="TpDBusPropertiesMixinSetter"
              throws="1">
      <doc xml:whitespace="preserve">Signature of a callback used to get the value of a property.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="setter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="DBusTubeChannel"
           c:symbol-prefix="dbus_tube_channel"
           c:type="TpDBusTubeChannel"
           version="0.15.6"
           parent="Channel"
           glib:type-name="TpDBusTubeChannel"
           glib:get-type="tp_dbus_tube_channel_get_type"
           glib:type-struct="DBusTubeChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpDBusTubeChannel.</doc>
      <method name="get_parameters"
              c:identifier="tp_dbus_tube_channel_get_parameters"
              version="0.15.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpDBusTubeChannel:parameters property

the value of #TpDBusTubeChannel:parameters</doc>
        <return-value transfer-ownership="none">
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_service_name"
              c:identifier="tp_dbus_tube_channel_get_service_name"
              version="0.15.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpDBusTubeChannel:service-name property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpDBusTubeChannel:service-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <property name="parameters"
                version="0.15.6"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A string to #GValue #GHashTable representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.</doc>
        <type/>
      </property>
      <property name="service-name" version="0.15.6" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the service name that will be used over the tube.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DBusTubeChannelPrivate"
              c:type="TpDBusTubeChannelPrivate*"/>
      </field>
    </class>
    <record name="DBusTubeChannelClass"
            c:type="TpDBusTubeChannelClass"
            glib:is-gtype-struct-for="DBusTubeChannel"
            version="0.15.6">
      <doc xml:whitespace="preserve">The class of a #TpDBusTubeChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="DBusTubeChannelPrivate"
            c:type="TpDBusTubeChannelPrivate"
            disguised="1">
    </record>
    <enumeration name="DTMFEvent" c:type="TpDTMFEvent">
      <member name="digit_0" value="0" c:identifier="TP_DTMF_EVENT_DIGIT_0"/>
      <member name="digit_1" value="1" c:identifier="TP_DTMF_EVENT_DIGIT_1"/>
      <member name="digit_2" value="2" c:identifier="TP_DTMF_EVENT_DIGIT_2"/>
      <member name="digit_3" value="3" c:identifier="TP_DTMF_EVENT_DIGIT_3"/>
      <member name="digit_4" value="4" c:identifier="TP_DTMF_EVENT_DIGIT_4"/>
      <member name="digit_5" value="5" c:identifier="TP_DTMF_EVENT_DIGIT_5"/>
      <member name="digit_6" value="6" c:identifier="TP_DTMF_EVENT_DIGIT_6"/>
      <member name="digit_7" value="7" c:identifier="TP_DTMF_EVENT_DIGIT_7"/>
      <member name="digit_8" value="8" c:identifier="TP_DTMF_EVENT_DIGIT_8"/>
      <member name="digit_9" value="9" c:identifier="TP_DTMF_EVENT_DIGIT_9"/>
      <member name="asterisk"
              value="10"
              c:identifier="TP_DTMF_EVENT_ASTERISK"/>
      <member name="hash" value="11" c:identifier="TP_DTMF_EVENT_HASH"/>
      <member name="letter_a"
              value="12"
              c:identifier="TP_DTMF_EVENT_LETTER_A"/>
      <member name="letter_b"
              value="13"
              c:identifier="TP_DTMF_EVENT_LETTER_B"/>
      <member name="letter_c"
              value="14"
              c:identifier="TP_DTMF_EVENT_LETTER_C"/>
      <member name="letter_d"
              value="15"
              c:identifier="TP_DTMF_EVENT_LETTER_D"/>
    </enumeration>
    <enumeration name="DebugLevel" c:type="TpDebugLevel">
      <member name="error" value="0" c:identifier="TP_DEBUG_LEVEL_ERROR"/>
      <member name="critical"
              value="1"
              c:identifier="TP_DEBUG_LEVEL_CRITICAL"/>
      <member name="warning" value="2" c:identifier="TP_DEBUG_LEVEL_WARNING"/>
      <member name="message" value="3" c:identifier="TP_DEBUG_LEVEL_MESSAGE"/>
      <member name="info" value="4" c:identifier="TP_DEBUG_LEVEL_INFO"/>
      <member name="debug" value="5" c:identifier="TP_DEBUG_LEVEL_DEBUG"/>
    </enumeration>
    <bitfield name="DeliveryReportingSupportFlags"
              c:type="TpDeliveryReportingSupportFlags">
      <member name="failures"
              value="1"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_FAILURES"/>
      <member name="successes"
              value="2"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_SUCCESSES"/>
      <member name="read"
              value="4"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_READ"/>
      <member name="deleted"
              value="8"
              c:identifier="TP_DELIVERY_REPORTING_SUPPORT_FLAG_RECEIVE_DELETED"/>
    </bitfield>
    <enumeration name="DeliveryStatus" c:type="TpDeliveryStatus">
      <member name="unknown"
              value="0"
              c:identifier="TP_DELIVERY_STATUS_UNKNOWN"/>
      <member name="delivered"
              value="1"
              c:identifier="TP_DELIVERY_STATUS_DELIVERED"/>
      <member name="temporarily_failed"
              value="2"
              c:identifier="TP_DELIVERY_STATUS_TEMPORARILY_FAILED"/>
      <member name="permanently_failed"
              value="3"
              c:identifier="TP_DELIVERY_STATUS_PERMANENTLY_FAILED"/>
      <member name="accepted"
              value="4"
              c:identifier="TP_DELIVERY_STATUS_ACCEPTED"/>
      <member name="read" value="5" c:identifier="TP_DELIVERY_STATUS_READ"/>
      <member name="deleted"
              value="6"
              c:identifier="TP_DELIVERY_STATUS_DELETED"/>
    </enumeration>
    <constant name="ERROR_PREFIX"
              value="org.freedesktop.Telepathy.Error"
              c:type="TP_ERROR_PREFIX">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="Error" c:type="TpError" glib:error-domain="tp_errors">
      <doc xml:whitespace="preserve">Enumerated type representing the Telepathy D-Bus errors.</doc>
      <member name="network_error"
              value="0"
              c:identifier="TP_ERROR_NETWORK_ERROR"/>
      <member name="not_implemented"
              value="1"
              c:identifier="TP_ERROR_NOT_IMPLEMENTED"/>
      <member name="invalid_argument"
              value="2"
              c:identifier="TP_ERROR_INVALID_ARGUMENT"/>
      <member name="not_available"
              value="3"
              c:identifier="TP_ERROR_NOT_AVAILABLE"/>
      <member name="permission_denied"
              value="4"
              c:identifier="TP_ERROR_PERMISSION_DENIED"/>
      <member name="disconnected"
              value="5"
              c:identifier="TP_ERROR_DISCONNECTED"/>
      <member name="invalid_handle"
              value="6"
              c:identifier="TP_ERROR_INVALID_HANDLE"/>
      <member name="channel_banned"
              value="7"
              c:identifier="TP_ERROR_CHANNEL_BANNED"/>
      <member name="channel_full"
              value="8"
              c:identifier="TP_ERROR_CHANNEL_FULL"/>
      <member name="channel_invite_only"
              value="9"
              c:identifier="TP_ERROR_CHANNEL_INVITE_ONLY"/>
      <member name="not_yours" value="10" c:identifier="TP_ERROR_NOT_YOURS"/>
      <member name="cancelled" value="11" c:identifier="TP_ERROR_CANCELLED"/>
      <member name="authentication_failed"
              value="12"
              c:identifier="TP_ERROR_AUTHENTICATION_FAILED"/>
      <member name="encryption_not_available"
              value="13"
              c:identifier="TP_ERROR_ENCRYPTION_NOT_AVAILABLE"/>
      <member name="encryption_error"
              value="14"
              c:identifier="TP_ERROR_ENCRYPTION_ERROR"/>
      <member name="cert_not_provided"
              value="15"
              c:identifier="TP_ERROR_CERT_NOT_PROVIDED"/>
      <member name="cert_untrusted"
              value="16"
              c:identifier="TP_ERROR_CERT_UNTRUSTED"/>
      <member name="cert_expired"
              value="17"
              c:identifier="TP_ERROR_CERT_EXPIRED"/>
      <member name="cert_not_activated"
              value="18"
              c:identifier="TP_ERROR_CERT_NOT_ACTIVATED"/>
      <member name="cert_fingerprint_mismatch"
              value="19"
              c:identifier="TP_ERROR_CERT_FINGERPRINT_MISMATCH"/>
      <member name="cert_hostname_mismatch"
              value="20"
              c:identifier="TP_ERROR_CERT_HOSTNAME_MISMATCH"/>
      <member name="cert_self_signed"
              value="21"
              c:identifier="TP_ERROR_CERT_SELF_SIGNED"/>
      <member name="cert_invalid"
              value="22"
              c:identifier="TP_ERROR_CERT_INVALID"/>
      <member name="not_capable"
              value="23"
              c:identifier="TP_ERROR_NOT_CAPABLE"/>
      <member name="offline" value="24" c:identifier="TP_ERROR_OFFLINE"/>
      <member name="channel_kicked"
              value="25"
              c:identifier="TP_ERROR_CHANNEL_KICKED"/>
      <member name="busy" value="26" c:identifier="TP_ERROR_BUSY"/>
      <member name="no_answer" value="27" c:identifier="TP_ERROR_NO_ANSWER"/>
      <member name="does_not_exist"
              value="28"
              c:identifier="TP_ERROR_DOES_NOT_EXIST"/>
      <member name="terminated" value="29" c:identifier="TP_ERROR_TERMINATED"/>
      <member name="connection_refused"
              value="30"
              c:identifier="TP_ERROR_CONNECTION_REFUSED"/>
      <member name="connection_failed"
              value="31"
              c:identifier="TP_ERROR_CONNECTION_FAILED"/>
      <member name="connection_lost"
              value="32"
              c:identifier="TP_ERROR_CONNECTION_LOST"/>
      <member name="already_connected"
              value="33"
              c:identifier="TP_ERROR_ALREADY_CONNECTED"/>
      <member name="connection_replaced"
              value="34"
              c:identifier="TP_ERROR_CONNECTION_REPLACED"/>
      <member name="registration_exists"
              value="35"
              c:identifier="TP_ERROR_REGISTRATION_EXISTS"/>
      <member name="service_busy"
              value="36"
              c:identifier="TP_ERROR_SERVICE_BUSY"/>
      <member name="resource_unavailable"
              value="37"
              c:identifier="TP_ERROR_RESOURCE_UNAVAILABLE"/>
      <member name="would_break_anonymity"
              value="38"
              c:identifier="TP_ERROR_WOULD_BREAK_ANONYMITY"/>
      <member name="cert_revoked"
              value="39"
              c:identifier="TP_ERROR_CERT_REVOKED"/>
      <member name="cert_insecure"
              value="40"
              c:identifier="TP_ERROR_CERT_INSECURE"/>
      <member name="cert_limit_exceeded"
              value="41"
              c:identifier="TP_ERROR_CERT_LIMIT_EXCEEDED"/>
      <member name="not_yet" value="42" c:identifier="TP_ERROR_NOT_YET"/>
      <member name="rejected" value="43" c:identifier="TP_ERROR_REJECTED"/>
      <member name="picked_up_elsewhere"
              value="44"
              c:identifier="TP_ERROR_PICKED_UP_ELSEWHERE"/>
      <member name="confused" value="45" c:identifier="TP_ERROR_CONFUSED"/>
      <member name="service_confused"
              value="46"
              c:identifier="TP_ERROR_SERVICE_CONFUSED"/>
      <member name="emergency_calls_not_supported"
              value="47"
              c:identifier="TP_ERROR_EMERGENCY_CALLS_NOT_SUPPORTED"/>
      <member name="software_upgrade_required"
              value="48"
              c:identifier="TP_ERROR_SOFTWARE_UPGRADE_REQUIRED"/>
      <member name="insufficient_balance"
              value="49"
              c:identifier="TP_ERROR_INSUFFICIENT_BALANCE"/>
      <member name="media_codecs_incompatible"
              value="50"
              c:identifier="TP_ERROR_MEDIA_CODECS_INCOMPATIBLE"/>
      <member name="media_unsupported_type"
              value="51"
              c:identifier="TP_ERROR_MEDIA_UNSUPPORTED_TYPE"/>
      <member name="media_streaming_error"
              value="52"
              c:identifier="TP_ERROR_MEDIA_STREAMING_ERROR"/>
    </enumeration>
    <enumeration name="FileHashType" c:type="TpFileHashType">
      <member name="none" value="0" c:identifier="TP_FILE_HASH_TYPE_NONE"/>
      <member name="md5" value="1" c:identifier="TP_FILE_HASH_TYPE_MD5"/>
      <member name="sha1" value="2" c:identifier="TP_FILE_HASH_TYPE_SHA1"/>
      <member name="sha256" value="3" c:identifier="TP_FILE_HASH_TYPE_SHA256"/>
    </enumeration>
    <class name="FileTransferChannel"
           c:symbol-prefix="file_transfer_channel"
           c:type="TpFileTransferChannel"
           version="0.15.5"
           parent="Channel"
           glib:type-name="TpFileTransferChannel"
           glib:get-type="tp_file_transfer_channel_get_type"
           glib:type-struct="FileTransferChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpFileTransferChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_file_transfer_channel_new"
                   version="0.15.5"
                   throws="1">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpFileTransferChannel</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpFileTransferChannel</doc>
          <type name="FileTransferChannel" c:type="TpFileTransferChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_file_transfer_channel_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="accept_file_async"
              c:identifier="tp_file_transfer_channel_accept_file_async"
              version="0.17.1">
        <doc xml:whitespace="preserve">Accept an incoming file transfer in the
%TP_FILE_TRANSFER_STATE_PENDING state. Once the accept has been
processed, @callback will be called. You can then call
tp_file_transfer_channel_accept_file_finish() to get the result of
the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile where the file should be saved</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">Offset from the start of @file where transfer begins</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the transfer has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_file_finish"
              c:identifier="tp_file_transfer_channel_accept_file_finish"
              version="0.17.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a call to tp_file_transfer_channel_accept_file_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the accept operation was a success, or %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date"
              c:identifier="tp_file_transfer_channel_get_date"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:date property

property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:date</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
      </method>
      <method name="get_description"
              c:identifier="tp_file_transfer_channel_get_description"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:description property

#TpFileTransferChannel:description property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_filename"
              c:identifier="tp_file_transfer_channel_get_filename"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:filename property

#TpFileTransferChannel:filename property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_metadata"
              c:identifier="tp_file_transfer_channel_get_metadata"
              version="0.17.1"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:metadata property

value of the #TpFileTransferChannel:metadata property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Strv"/>
          </type>
        </return-value>
      </method>
      <method name="get_mime_type"
              c:identifier="tp_file_transfer_channel_get_mime_type"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:mime-type property

#TpFileTransferChannel:mime-type property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_service_name"
              c:identifier="tp_file_transfer_channel_get_service_name"
              version="0.17.1">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:service-name property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:service-name property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_size"
              c:identifier="tp_file_transfer_channel_get_size"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:size property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:size property</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="get_state"
              c:identifier="tp_file_transfer_channel_get_state"
              version="0.17.1">
        <doc xml:whitespace="preserve">Returns the #TpFileTransferChannel:state property.

If @reason is not %NULL it is set to the reason why
#TpFileTransferChannel:state changed to its current value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:state property</doc>
          <type name="FileTransferState" c:type="TpFileTransferState"/>
        </return-value>
        <parameters>
          <parameter name="reason"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #TpFileTransferStateChangeReason, or %NULL</doc>
            <type name="FileTransferStateChangeReason"
                  c:type="TpFileTransferStateChangeReason*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_transferred_bytes"
              c:identifier="tp_file_transfer_channel_get_transferred_bytes"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return the #TpFileTransferChannel:transferred-bytes property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpFileTransferChannel:transferred-bytes property</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="provide_file_async"
              c:identifier="tp_file_transfer_channel_provide_file_async"
              version="0.17.1">
        <doc xml:whitespace="preserve">Provide a file transfer. This should be called when the file
transfer state changes (tp_file_transfer_channel_get_state() and
the "notify::state" signal) to
%TP_FILE_TRANSFER_STATE_ACCEPTED or
%TP_FILE_TRANSFER_STATE_PENDING. Once the file has been provided,
the channel #TpFileTransferChannel:state will change to
%TP_FILE_TRANSFER_STATE_OPEN.

Once the file has been provided, @callback will be called. You
should then call tp_file_transfer_channel_provide_file_finish() to
get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GFile to send to the remote contact</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the transfer has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_file_finish"
              c:identifier="tp_file_transfer_channel_provide_file_finish"
              version="0.17.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes a call to tp_file_transfer_channel_provide_file_async().


Successful return from this function does not mean that the file
transfer has completed or has even started at all. The state of the
file transfer should be monitored with the "notify::state" signal.

%FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file has been successfully provided, or</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="date" transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GDateTime representing the last modification time of the file to be
transferred.

Since 0.15.5</doc>
        <type name="GLib.DateTime"/>
      </property>
      <property name="description" transfer-ownership="none">
        <doc xml:whitespace="preserve">The description of the file transfer, defined by the sender when
sending the file transfer offer.

Since 0.15.5</doc>
        <type name="utf8"/>
      </property>
      <property name="file" version="0.17.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">For incoming file transfers, this property will be set to a
#GFile for the location where the file will be saved (given by
tp_file_transfer_channel_accept_file_async()) when the transfer
starts. The feature %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE must
already be prepared for this property to have a meaningful
value, and to receive change notification.  Once the initial
value is set, this property will not be changed.

For outgoing file transfers, this property is a #GFile for the
location of the file being sent (given by
tp_file_transfer_channel_provide_file_async()). The feature
%TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE does not have to be
prepared and there is no change notification.</doc>
        <type name="Gio.File"/>
      </property>
      <property name="filename" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the file on the sender's side. This is therefore given as a
suggested filename for the receiver.

Since 0.15.5</doc>
        <type name="utf8"/>
      </property>
      <property name="initial-offset"
                version="0.17.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The offset in bytes from where the file should be sent.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.</doc>
        <type name="guint64"/>
      </property>
      <property name="metadata"
                version="0.17.1"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">Additional information about the file transfer set by the channel
initiator, or an empty #GHashTable if the initiator did not
provide any additional information.

To provide metadata along with a file offer, include
%TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA in the
channel request. For example:

|[
GHashTable *request;
GHashTable *metadata = g_hash_table_new (g_str_hash, g_str_equal);
const gchar * const values[] = { "Jason Derulo", "Tinie Tempah", NULL };

g_hash_table_insert (metadata, "best buds", values);

request = tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING, TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_CONTACT,
TP_PROP_CHANNEL_TARGET_ID, G_TYPE_STRING, "foo@bar.com",
TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE, G_TYPE_STRING, "text/plain",
TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE, G_TYPE_INT64, 1320925992,
TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION, G_TYPE_STRING, "",
TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME, G_TYPE_STRING, "test.pdf",
TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET, G_TYPE_UINT64, 0,
TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE, G_TYPE_UINT64, 165710,
TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA, TP_TYPE_METADATA, metadata,
NULL);

...
]|

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful.</doc>
        <type/>
      </property>
      <property name="mime-type" version="0.15.5" transfer-ownership="none">
        <doc xml:whitespace="preserve">The MIME type of the file to be transferred.</doc>
        <type name="utf8"/>
      </property>
      <property name="service-name" version="0.17.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the name of the service suggested to handle
this file transfer channel, or %NULL if the initiator did not
provide one.

This is a useful way of requesting file transfer channels with a
hint of what handler they should be handled by on the remote
side. If a channel request is made with this property set (to a
contact who also supports the metadata extension; see the
requestable channel classes for said contact), this property will
be set to the same value on the remote incoming channel and
handlers can match on this in their handler filter. For example,
a remote handler could call the following:

|[
tp_base_client_take_handler_filter (handler, tp_asv_new (
TP_PROP_CHANNEL_CHANNEL_TYPE, G_TYPE_STRING, TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER,
TP_PROP_CHANNEL_TARGET_HANDLE_TYPE, G_TYPE_UINT, TP_HANDLE_TYPE_CONTACT,
TP_PROP_CHANNEL_REQUESTED, G_TYPE_BOOLEAN, FALSE,
TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME, G_TYPE_STRING, "service.name",
NULL));
]|

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful.</doc>
        <type name="utf8"/>
      </property>
      <property name="size" transfer-ownership="none">
        <doc xml:whitespace="preserve">The size of the file to be transferred,
or %G_MAXUINT64 if not known.

Since 0.15.5</doc>
        <type name="guint64"/>
      </property>
      <property name="state" transfer-ownership="none">
        <doc xml:whitespace="preserve">A TpFileTransferState holding the state of the file transfer.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.

Since 0.17.1</doc>
        <type name="guint"/>
      </property>
      <property name="transferred-bytes"
                version="0.15.5"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The number of bytes transferred so far in this
file transfer.

The %TP_FILE_TRANSFER_CHANNEL_FEATURE_CORE feature has to be
prepared for this property to be meaningful and kept up to date.</doc>
        <type name="guint64"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="FileTransferChannelPrivate"
              c:type="TpFileTransferChannelPrivate*"/>
      </field>
    </class>
    <record name="FileTransferChannelClass"
            c:type="TpFileTransferChannelClass"
            glib:is-gtype-struct-for="FileTransferChannel"
            version="0.15.5">
      <doc xml:whitespace="preserve">The class of a #TpFileTransferChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="8">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="FileTransferChannelPrivate"
            c:type="TpFileTransferChannelPrivate"
            disguised="1">
    </record>
    <enumeration name="FileTransferState" c:type="TpFileTransferState">
      <member name="none"
              value="0"
              c:identifier="TP_FILE_TRANSFER_STATE_NONE"/>
      <member name="pending"
              value="1"
              c:identifier="TP_FILE_TRANSFER_STATE_PENDING"/>
      <member name="accepted"
              value="2"
              c:identifier="TP_FILE_TRANSFER_STATE_ACCEPTED"/>
      <member name="open"
              value="3"
              c:identifier="TP_FILE_TRANSFER_STATE_OPEN"/>
      <member name="completed"
              value="4"
              c:identifier="TP_FILE_TRANSFER_STATE_COMPLETED"/>
      <member name="cancelled"
              value="5"
              c:identifier="TP_FILE_TRANSFER_STATE_CANCELLED"/>
    </enumeration>
    <enumeration name="FileTransferStateChangeReason"
                 c:type="TpFileTransferStateChangeReason">
      <member name="none"
              value="0"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_NONE"/>
      <member name="requested"
              value="1"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REQUESTED"/>
      <member name="local_stopped"
              value="2"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_STOPPED"/>
      <member name="remote_stopped"
              value="3"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_STOPPED"/>
      <member name="local_error"
              value="4"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_LOCAL_ERROR"/>
      <member name="remote_error"
              value="5"
              c:identifier="TP_FILE_TRANSFER_STATE_CHANGE_REASON_REMOTE_ERROR"/>
    </enumeration>
    <record name="GroupMixin" c:type="TpGroupMixin">
      <doc xml:whitespace="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's instance structure.

All fields should be considered read-only.</doc>
      <field name="handle_repo" writable="1">
        <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
      </field>
      <field name="self_handle" writable="1">
        <type name="Handle" c:type="TpHandle"/>
      </field>
      <field name="group_flags" writable="1">
        <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
      </field>
      <field name="members" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="local_pending" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="remote_pending" writable="1">
        <type name="HandleSet" c:type="TpHandleSet*"/>
      </field>
      <field name="priv" writable="1">
        <type name="GroupMixinPrivate" c:type="TpGroupMixinPrivate*"/>
      </field>
      <function name="add_handle_owner"
                c:identifier="tp_group_mixin_add_handle_owner"
                introspectable="0">
        <doc xml:whitespace="preserve">Note that the given local handle is an alias within this group
for the given globally-valid handle. It will be returned from subsequent
GetHandleOwner queries where appropriate.

Changed in 0.7.10: The @owner_handle may be 0. To comply with telepathy-spec
0.17.6, before adding any channel-specific handle to the members,
local-pending members or remote-pending members, you must call either
this function or tp_group_mixin_add_handle_owners().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="local_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A contact handle valid within this group (may not be 0)</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="owner_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A contact handle valid globally, or 0 if the owner of the @local_handle is unknown</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="add_handle_owners"
                c:identifier="tp_group_mixin_add_handle_owners"
                version="0.7.10"
                introspectable="0">
        <doc xml:whitespace="preserve">Note that the given local handles are aliases within this group
for the given globally-valid handles.

To comply with telepathy-spec 0.17.6, before adding any channel-specific
handle to the members, local-pending members or remote-pending members, you
must call either this function or tp_group_mixin_add_handle_owner().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="local_to_owner_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A map from contact handles valid within this group (which may not be 0) to either contact handles valid globally, or 0 if the owner of the corresponding key is unknown; all handles are stored using GUINT_TO_POINTER</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="add_members"
                c:identifier="tp_group_mixin_add_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Request that the given contacts be added to the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
Otherwise attempt to add the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message associated with the addition request, if supported</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_flags"
                c:identifier="tp_group_mixin_change_flags"
                introspectable="0">
        <doc xml:whitespace="preserve">Request a change to be made to the flags. If any flags were actually
set or cleared, emits the GroupFlagsChanged signal with the changes.

It is an error to set any of the same bits in both @add and @del.

Changed in 0.7.7: the signal is not emitted if adding @add and
removing @del had no effect on the existing group flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the groups interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags to be added</doc>
            <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:whitespace="preserve">Flags to be removed</doc>
            <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_members"
                c:identifier="tp_group_mixin_change_members"
                introspectable="0">
        <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

signals were emitted; %FALSE if nothing actually changed and the signals
were suppressed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message to be sent to the affected contacts if possible; %NULL is allowed, and is mapped to an empty string</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="add_local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="add_remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="actor" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle of the contact responsible for this change</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">The reason for this change</doc>
            <type name="ChannelGroupChangeReason"
                  c:type="TpChannelGroupChangeReason"/>
          </parameter>
        </parameters>
      </function>
      <function name="change_members_detailed"
                c:identifier="tp_group_mixin_change_members_detailed"
                version="0.7.21"
                introspectable="0">
        <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

details may contain, among other entries, the well-known
keys (and corresponding type, wrapped in a GValue) defined by the
Group.MembersChangedDetailed signal's specification; these include "actor"
(a handle as G_TYPE_UINT), "change-reason" (an element of
#TpChannelGroupChangeReason as G_TYPE_UINT), "message" (G_TYPE_STRING),
"error" (G_TYPE_STRING), "debug-message" (G_TYPE_STRING).

If all of the information in details could be passed to
tp_group_mixin_change_members() then calling this function instead provides
no benefit. Calling this function without setting
#TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED with
tp_group_mixin_change_members() first is not very useful, as clients will
not know to listen for MembersChangedDetailed and thus will miss the
details.

signals were emitted; %FALSE if nothing actually changed and the signals
were suppressed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="del" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="add_local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="add_remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
          <parameter name="details" transfer-ownership="none">
            <doc xml:whitespace="preserve">a map from strings to GValues detailing the change</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="change_self_handle"
                c:identifier="tp_group_mixin_change_self_handle"
                introspectable="0">
        <doc xml:whitespace="preserve">Change the self-handle for this group to the given value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="new_self_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new self-handle for this group</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_group_mixin_finalize"
                introspectable="0">
        <doc xml:whitespace="preserve">Unreference handles and free resources used by this mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_all_members"
                c:identifier="tp_group_mixin_get_all_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's current and pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="members" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="local_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's local pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="remote_pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_dbus_property"
                c:identifier="tp_group_mixin_get_dbus_property"
                version="0.7.10"
                introspectable="0">
        <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the group mixin. It can only be used for the Group interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="unused" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_group_flags"
                c:identifier="tp_group_mixin_get_group_flags"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Set the guint pointed to by ret to this group's flags, to be
interpreted according to TpChannelGroupFlags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return the flags</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_handle_owners"
                c:identifier="tp_group_mixin_get_handle_owners"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">If the mixin has the flag %TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,
return the global owners of the given local handles, or 0 where
unavailable.

failure</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE (setting @ret) on success, %FALSE (setting @error) on</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handles" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of guint representing locally valid handles</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return an array of guint representing globally valid handles, or 0 where unavailable, if %TRUE is returned</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_local_pending_members"
                c:identifier="tp_group_mixin_get_local_pending_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's local-pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_local_pending_members_with_info"
                c:identifier="tp_group_mixin_get_local_pending_members_with_info"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's local-pending members and information about their
requests to join the channel.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GPtrArray of D-Bus structures each containing the handle of a local-pending contact, the handle of a contact responsible for adding them to the group (or 0), the reason code and a related message (e.g. their request to join the group)</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_members"
                c:identifier="tp_group_mixin_get_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's current members</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_group_mixin_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_remote_pending_members"
                c:identifier="tp_group_mixin_get_remote_pending_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Get the group's remote-pending members.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
            <array name="GLib.Array" c:type="GArray**">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="get_self_handle"
                c:identifier="tp_group_mixin_get_self_handle"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Set the guint pointed to by ret to the local user's handle in this
group, or to 0 if the local user is not present in this group.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">Used to return the local user's handle in this group</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="iface_init"
                c:identifier="tp_group_mixin_iface_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Unused</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_group_mixin_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The offset of the TpGroupMixin structure within the instance structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="handle_repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">The connection's handle repository for contacts</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="self_handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle of the local user in this group, if any</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_dbus_properties"
                c:identifier="tp_group_mixin_init_dbus_properties"
                version="0.7.10"
                introspectable="0">
        <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to any channels of this class
with tp_group_mixin_change_flags() to indicate that the DBus properties are
available.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_members"
                c:identifier="tp_group_mixin_remove_members"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_members_with_reason"
                c:identifier="tp_group_mixin_remove_members_with_reason"
                introspectable="0"
                throws="1">
        <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contacts" transfer-ownership="none">
            <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="GroupMixinAddMemberFunc"
              c:type="TpGroupMixinAddMemberFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to add a member to the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be added.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be added</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="GroupMixinClass" c:type="TpGroupMixinClass">
      <doc xml:whitespace="preserve">Structure representing the group mixin as used in a particular class.
To be placed in the implementation's class structure.

Initialize this with tp_group_mixin_class_init().

All fields should be considered read-only.</doc>
      <field name="add_member" writable="1">
        <type name="GroupMixinAddMemberFunc"
              c:type="TpGroupMixinAddMemberFunc"/>
      </field>
      <field name="remove_member" writable="1">
        <type name="GroupMixinRemMemberFunc"
              c:type="TpGroupMixinRemMemberFunc"/>
      </field>
      <field name="priv" writable="1">
        <type name="GroupMixinClassPrivate"
              c:type="TpGroupMixinClassPrivate*"/>
      </field>
      <function name="allow_self_removal"
                c:identifier="tp_group_mixin_class_allow_self_removal"
                version="0.7.27"
                introspectable="0">
        <doc xml:whitespace="preserve">Configure the mixin to allow attempts to remove the SelfHandle from this
Group, even if the group flags would otherwise disallow this. The
channel's #TpGroupMixinRemMemberFunc or
#TpGroupMixinRemMemberWithReasonFunc will be called as usual for such
attempts, and may make them fail with %TP_ERROR_PERMISSION_DENIED if
required.

This function should be called from the GObject @class_init callback,
after calling tp_group_mixin_class_init().

(Recent telepathy-spec changes make it valid to try to remove the
self-handle at all times, regardless of group flags. However, if this was
implemented automatically in TpGroupMixin, this would risk crashing
connection manager implementations that assume that TpGroupMixin will
enforce the group flags strictly. As a result, connection managers should
call this function to indicate to the TpGroupMixin that it may call their
removal callback with the self-handle regardless of flag settings.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_group_mixin_class_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_group_mixin_class_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Configure the mixin for use with the given class.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The offset of the TpGroupMixinClass structure within the class structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="add_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to add contacts to this group</doc>
            <type name="GroupMixinAddMemberFunc"
                  c:type="TpGroupMixinAddMemberFunc"/>
          </parameter>
          <parameter name="rem_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group. This must be %NULL if you will subsequently call tp_group_mixin_class_set_remove_with_reason_func().</doc>
            <type name="GroupMixinRemMemberFunc"
                  c:type="TpGroupMixinRemMemberFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="set_remove_with_reason_func"
                c:identifier="tp_group_mixin_class_set_remove_with_reason_func"
                version="0.5.13"
                introspectable="0">
        <doc xml:whitespace="preserve">Set a callback to be used to implement RemoveMembers() and
RemoveMembersWithReason(). If this function is called during class
initialization, the given callback will be used instead of the remove
callback passed to tp_group_mixin_class_init() (which must be %NULL
in this case).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group with a specified reason.</doc>
            <type name="GroupMixinRemMemberWithReasonFunc"
                  c:type="TpGroupMixinRemMemberWithReasonFunc"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="GroupMixinClassPrivate"
            c:type="TpGroupMixinClassPrivate"
            disguised="1">
    </record>
    <record name="GroupMixinPrivate"
            c:type="TpGroupMixinPrivate"
            disguised="1">
    </record>
    <callback name="GroupMixinRemMemberFunc"
              c:type="TpGroupMixinRemMemberFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="GroupMixinRemMemberWithReasonFunc"
              c:type="TpGroupMixinRemMemberWithReasonFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to remove a member from the group.
This should perform the necessary operations in the underlying IM protocol
to cause the member to be removed.

Set this with tp_group_mixin_class_set_remove_with_reason_func(), .</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success, %FALSE with @error set on error</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to be removed</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent if the protocol supports it</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason indicating the reason</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="HTTPMethod" c:type="TpHTTPMethod">
      <member name="get" value="0" c:identifier="TP_HTTP_METHOD_GET"/>
      <member name="post" value="1" c:identifier="TP_HTTP_METHOD_POST"/>
    </enumeration>
    <class name="HandleChannelsContext"
           c:symbol-prefix="handle_channels_context"
           c:type="TpHandleChannelsContext"
           version="0.11.6"
           parent="GObject.Object"
           glib:type-name="TpHandleChannelsContext"
           glib:get-type="tp_handle_channels_context_get_type"
           glib:type-struct="HandleChannelsContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Handler.HandleChannels()
call.</doc>
      <method name="accept"
              c:identifier="tp_handle_channels_context_accept"
              version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl when it's done so
the D-Bus method can return.

The caller is responsible for closing channels with
tp_cli_channel_call_close() when it has finished handling them.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delay"
              c:identifier="tp_handle_channels_context_delay"
              version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpHandleChannelsContext before calling this function, and
is responsible for calling either
tp_handle_channels_context_accept() or
tp_handle_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail"
              c:identifier="tp_handle_channels_context_fail"
              version="0.11.6">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassAddDispatchOperationImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_handler_info"
              c:identifier="tp_handle_channels_context_get_handler_info"
              version="0.11.14">
        <doc xml:whitespace="preserve">Return any extra information that accompanied this request to handle
channels (the Handler_Info argument from the HandleChannels D-Bus method).
Well-known keys for this map will be defined by the Telepathy D-Bus
Interface Specification; at the time of writing, none have been defined.

The returned hash table is only valid for as long as @self is.

extra handler information, in a form suitable for use with
tp_asv_get_string() etc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">extensible</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_requests"
              c:identifier="tp_handle_channels_context_get_requests"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return a list of the #TpChannelRequest which have been satisfied by the
channels associated with #self.

a newly allocated #GList of reffed #TpChannelRequest.</doc>
        <return-value transfer-ownership="full">
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <property name="account"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection of the DispatchOperation
that has been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.6"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
HandleChannels call.
Can only be written during construction.</doc>
        <type name="gpointer"/>
      </property>
      <property name="handler-info"
                version="0.11.6"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GHashTable where the keys are string and values are GValue instances.
It represents the Handler_info hash table that has been passed to
HandleChannels.

This property can't be %NULL.</doc>
        <type/>
      </property>
      <property name="requests-satisfied"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to HandleChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="user-action-time"
                version="0.11.6"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The time at which user action occurred, or one of the
special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or
%TP_USER_ACTION_TIME_CURRENT_TIME
(see #TpAccountChannelRequest:user-action-time for details)

Read-only except during construction.</doc>
        <type name="gint64"/>
      </property>
      <glib:signal name="done" when="last" detailed="1" version="0.11.6">
        <doc xml:whitespace="preserve">Emitted when tp_handle_channels_context_accept has been called on @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="HandleChannelsContextClass"
            c:type="TpHandleChannelsContextClass"
            disguised="1"
            glib:is-gtype-struct-for="HandleChannelsContext"
            version="0.11.6">
      <doc xml:whitespace="preserve">The class of a #TpHandleChannelsContext.</doc>
    </record>
    <record name="HandleChannelsContextPrivate"
            c:type="TpHandleChannelsContextPrivate"
            disguised="1">
    </record>
    <interface name="HandleRepoIface"
               c:symbol-prefix="handle_repo_iface"
               c:type="TpHandleRepoIface"
               glib:type-name="TpHandleRepoIface"
               glib:get-type="tp_handle_repo_iface_get_type">
      <doc xml:whitespace="preserve">Dummy typedef representing any implementation of this interface.</doc>
      <property name="handle-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint"/>
      </property>
    </interface>
    <record name="HandleRepoIfaceClass"
            c:type="TpHandleRepoIfaceClass"
            disguised="1">
      <doc xml:whitespace="preserve">The class of a handle repository interface. The structure layout is
only available within telepathy-glib, for the handle repository
implementations' benefit.</doc>
    </record>
    <record name="HandleSet"
            c:type="TpHandleSet"
            glib:type-name="TpHandleSet"
            glib:get-type="tp_handle_set_get_type"
            c:symbol-prefix="handle_set">
      <doc xml:whitespace="preserve">A set of handles. This is similar to a #TpIntset (and implemented using
one), but adding a handle to the set also references it.</doc>
      <constructor name="new"
                   c:identifier="tp_handle_set_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_containing"
                   c:identifier="tp_handle_set_new_containing"
                   version="0.13.0"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet from a specified handle repository and single
handle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a valid handle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_array"
                   c:identifier="tp_handle_set_new_from_array"
                   version="0.11.7"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:whitespace="preserve">array of handles to be referenced by this set</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="guint"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_intset"
                   c:identifier="tp_handle_set_new_from_intset"
                   version="0.13.0"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet from a specified handle repository and
set of handles.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #TpHandleSet</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">#TpHandleRepoIface that holds the handles to be reffed by this set</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="intset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set of handles, which must all be valid</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="tp_handle_set_add" introspectable="0">
        <doc xml:whitespace="preserve">Add a handle to a #TpHandleSet, and reference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to add</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="tp_handle_set_clear"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove every handle from @set, releasing the references it holds.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="copy"
              c:identifier="tp_handle_set_copy"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #TpHandleSet with the same contents as @other.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new set</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </return-value>
      </method>
      <method name="destroy"
              c:identifier="tp_handle_set_destroy"
              introspectable="0">
        <doc xml:whitespace="preserve">Delete a #TpHandleSet and unreference any handles that it holds</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="difference_update"
              c:identifier="tp_handle_set_difference_update"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove a set of handles from a handle set, dereferencing those which are
members. The TpIntset returned must be freed with tp_intset_destroy.

If you want to be able to inspect the handles in the set returned,
you must ensure that this function does not cause their refcount to drop
to zero, for instance by temporarily taking a reference to all the
handles in @remove, calling this function, doing something with the
result and discarding the temporary references.

of @remove).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handles which were dereferenced and removed (some subset</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="remove" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpIntset of handles to remove</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="tp_handle_set_dump">
        <doc xml:whitespace="preserve">Format a #TpHandleSet for debug output.

handle set suitable for debug output</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string representation of the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="foreach"
              c:identifier="tp_handle_set_foreach"
              introspectable="0">
        <doc xml:whitespace="preserve">Call @func(@set, @handle, @userdata) for each handle in @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">A callback</doc>
            <type name="HandleSetMemberFunc" c:type="TpHandleSetMemberFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Arbitrary data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="tp_handle_set_is_empty"
              version="0.11.6"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the same thing as &lt;code&gt;(tp_handle_set_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the set has no members</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_member"
              c:identifier="tp_handle_set_is_member"
              introspectable="0">
        <doc xml:whitespace="preserve">Check if the handle is in this set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the handle is in this set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to check</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="tp_handle_set_peek" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the underlying #TpIntset used by this #TpHandleSet</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </method>
      <method name="remove"
              c:identifier="tp_handle_set_remove"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove a handle from a #TpHandleSet, and unreference it in the attached
#TpHandleRepoIface</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if the handle was invalid, or was not in this set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">handle to remove</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="tp_handle_set_size" introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no further documentation needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of handles in this set</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="to_array"
              c:identifier="tp_handle_set_to_array"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all, this comment is just to keep gtkdoc happy--&gt;

the handles in the set</doc>
        <return-value>
          <doc xml:whitespace="preserve">a newly-allocated GArray of guint representing</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint"/>
          </array>
        </return-value>
      </method>
      <method name="to_identifier_map"
              c:identifier="tp_handle_set_to_identifier_map">
        <doc xml:whitespace="preserve">Returns a dictionary mapping each handle in @self to the corresponding
identifier, as if retrieved by calling tp_handle_inspect() on each handle.
The type of the returned value is described as
&lt;code&gt;Handle_Identifier_Map&lt;/code&gt; in the Telepathy specification.

handles in @self to the corresponding identifier.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a map from the</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="Handle"/>
            <type name="utf8"/>
          </type>
        </return-value>
      </method>
      <method name="update"
              c:identifier="tp_handle_set_update"
              introspectable="0">
        <doc xml:whitespace="preserve">Add a set of handles to a handle set, referencing those which are not
already members. The TpIntset returned must be freed with tp_intset_destroy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the handles which were added (some subset of @add)</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="add" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpIntset of handles to add</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <function name="qdata"
                c:identifier="tp_handle_set_qdata"
                introspectable="0">
        <doc xml:whitespace="preserve">Associates a blob of data with a given handle and a given key

If @destroy is set, then the data is freed when the handle is freed.

Since version 0.13.8, handles always last as long as the
connection, so @destroy will not be called until the connection
disconnects.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="repo" transfer-ownership="none">
            <doc xml:whitespace="preserve">A handle repository implementation</doc>
            <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">A handle to set data on</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="key_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">Key id to associate data with</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to associate with handle</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">A #GDestroyNotify to call to destroy the data, or NULL if not needed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="HandleSetMemberFunc"
              c:type="TpHandleSetMemberFunc"
              introspectable="0">
      <doc xml:whitespace="preserve">Signature of the callback used to iterate over the handle set in
tp_handle_set_foreach().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <doc xml:whitespace="preserve">The set of handles on which tp_handle_set_foreach() was called</doc>
          <type name="HandleSet" c:type="TpHandleSet*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle in the set</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">Arbitrary user data as supplied to tp_handle_set_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="HandleType" c:type="TpHandleType">
      <member name="none" value="0" c:identifier="TP_HANDLE_TYPE_NONE"/>
      <member name="contact" value="1" c:identifier="TP_HANDLE_TYPE_CONTACT"/>
      <member name="room" value="2" c:identifier="TP_HANDLE_TYPE_ROOM"/>
      <member name="list" value="3" c:identifier="TP_HANDLE_TYPE_LIST"/>
      <member name="group" value="4" c:identifier="TP_HANDLE_TYPE_GROUP"/>
    </enumeration>
    <constant name="IFACE_ACCOUNT"
              value="org.freedesktop.Telepathy.Account"
              c:type="TP_IFACE_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Account.Interface.Addressing"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_AVATAR"
              value="org.freedesktop.Telepathy.Account.Interface.Avatar"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_AVATAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_INTERFACE_STORAGE"
              value="org.freedesktop.Telepathy.Account.Interface.Storage"
              c:type="TP_IFACE_ACCOUNT_INTERFACE_STORAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_ACCOUNT_MANAGER"
              value="org.freedesktop.Telepathy.AccountManager"
              c:type="TP_IFACE_ACCOUNT_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_AUTHENTICATION_TLS_CERTIFICATE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate"
              c:type="TP_IFACE_AUTHENTICATION_TLS_CERTIFICATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL"
              value="org.freedesktop.Telepathy.Channel"
              c:type="TP_IFACE_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER"
              value="org.freedesktop.Telepathy.ChannelDispatcher"
              c:type="TP_IFACE_CHANNEL_DISPATCHER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList"
              c:type="TP_IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_DISPATCH_OPERATION"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation"
              c:type="TP_IFACE_CHANNEL_DISPATCH_OPERATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ANONYMITY"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ANONYMITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CALL_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.CallState"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CALL_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CHAT_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.ChatState"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CHAT_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_CONFERENCE"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference"
              c:type="TP_IFACE_CHANNEL_INTERFACE_CONFERENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DESTROYABLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Destroyable"
              c:type="TP_IFACE_CHANNEL_INTERFACE_DESTROYABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_DTMF"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF"
              c:type="TP_IFACE_CHANNEL_INTERFACE_DTMF">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata"
              c:type="TP_IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_GROUP"
              value="org.freedesktop.Telepathy.Channel.Interface.Group"
              c:type="TP_IFACE_CHANNEL_INTERFACE_GROUP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_HOLD"
              value="org.freedesktop.Telepathy.Channel.Interface.Hold"
              c:type="TP_IFACE_CHANNEL_INTERFACE_HOLD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling"
              c:type="TP_IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_MESSAGES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages"
              c:type="TP_IFACE_CHANNEL_INTERFACE_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_PASSWORD"
              value="org.freedesktop.Telepathy.Channel.Interface.Password"
              c:type="TP_IFACE_CHANNEL_INTERFACE_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ROOM"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ROOM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_ROOM_CONFIG"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1"
              c:type="TP_IFACE_CHANNEL_INTERFACE_ROOM_CONFIG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SECURABLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SECURABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SMS"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_SUBJECT"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2"
              c:type="TP_IFACE_CHANNEL_INTERFACE_SUBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_INTERFACE_TUBE"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube"
              c:type="TP_IFACE_CHANNEL_INTERFACE_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_REQUEST"
              value="org.freedesktop.Telepathy.ChannelRequest"
              c:type="TP_IFACE_CHANNEL_REQUEST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Channel.Type.ContactList"
              c:type="TP_IFACE_CHANNEL_TYPE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_CONTACT_SEARCH"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch"
              c:type="TP_IFACE_CHANNEL_TYPE_CONTACT_SEARCH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_DBUS_TUBE"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube"
              c:type="TP_IFACE_CHANNEL_TYPE_DBUS_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_FILE_TRANSFER"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer"
              c:type="TP_IFACE_CHANNEL_TYPE_FILE_TRANSFER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_ROOM_LIST"
              value="org.freedesktop.Telepathy.Channel.Type.RoomList"
              c:type="TP_IFACE_CHANNEL_TYPE_ROOM_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION"
              value="org.freedesktop.Telepathy.Channel.Type.ServerAuthentication"
              c:type="TP_IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection"
              c:type="TP_IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAMED_MEDIA"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia"
              c:type="TP_IFACE_CHANNEL_TYPE_STREAMED_MEDIA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_STREAM_TUBE"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube"
              c:type="TP_IFACE_CHANNEL_TYPE_STREAM_TUBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TEXT"
              value="org.freedesktop.Telepathy.Channel.Type.Text"
              c:type="TP_IFACE_CHANNEL_TYPE_TEXT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CHANNEL_TYPE_TUBES"
              value="org.freedesktop.Telepathy.Channel.Type.Tubes"
              c:type="TP_IFACE_CHANNEL_TYPE_TUBES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT"
              value="org.freedesktop.Telepathy.Client"
              c:type="TP_IFACE_CLIENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_APPROVER"
              value="org.freedesktop.Telepathy.Client.Approver"
              c:type="TP_IFACE_CLIENT_APPROVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_HANDLER"
              value="org.freedesktop.Telepathy.Client.Handler"
              c:type="TP_IFACE_CLIENT_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_INTERFACE_REQUESTS"
              value="org.freedesktop.Telepathy.Client.Interface.Requests"
              c:type="TP_IFACE_CLIENT_INTERFACE_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CLIENT_OBSERVER"
              value="org.freedesktop.Telepathy.Client.Observer"
              c:type="TP_IFACE_CLIENT_OBSERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION"
              value="org.freedesktop.Telepathy.Connection"
              c:type="TP_IFACE_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ALIASING"
              value="org.freedesktop.Telepathy.Connection.Interface.Aliasing"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ALIASING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_ANONYMITY"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity"
              c:type="TP_IFACE_CONNECTION_INTERFACE_ANONYMITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_AVATARS"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars"
              c:type="TP_IFACE_CONNECTION_INTERFACE_AVATARS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_BALANCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance"
              c:type="TP_IFACE_CONNECTION_INTERFACE_BALANCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.Capabilities"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CELLULAR"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CELLULAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CLIENT_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.ClientTypes"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CLIENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACTS"
              value="org.freedesktop.Telepathy.Connection.Interface.Contacts"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_INFO"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList"
              c:type="TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_LOCATION"
              value="org.freedesktop.Telepathy.Connection.Interface.Location"
              c:type="TP_IFACE_CONNECTION_INTERFACE_LOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification"
              c:type="TP_IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_POWER_SAVING"
              value="org.freedesktop.Telepathy.Connection.Interface.PowerSaving"
              c:type="TP_IFACE_CONNECTION_INTERFACE_POWER_SAVING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Presence"
              c:type="TP_IFACE_CONNECTION_INTERFACE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_REQUESTS"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests"
              c:type="TP_IFACE_CONNECTION_INTERFACE_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint"
              c:type="TP_IFACE_CONNECTION_INTERFACE_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence"
              c:type="TP_IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_CONNECTION_MANAGER"
              value="org.freedesktop.Telepathy.ConnectionManager"
              c:type="TP_IFACE_CONNECTION_MANAGER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_DAEMON"
              value="org.freedesktop.DBus"
              c:type="TP_IFACE_DBUS_DAEMON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_INTROSPECTABLE"
              value="org.freedesktop.DBus.Introspectable"
              c:type="TP_IFACE_DBUS_INTROSPECTABLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_PEER"
              value="org.freedesktop.DBus.Peer"
              c:type="TP_IFACE_DBUS_PEER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DBUS_PROPERTIES"
              value="org.freedesktop.DBus.Properties"
              c:type="TP_IFACE_DBUS_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_DEBUG"
              value="org.freedesktop.Telepathy.Debug"
              c:type="TP_IFACE_DEBUG">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_MEDIA_SESSION_HANDLER"
              value="org.freedesktop.Telepathy.Media.SessionHandler"
              c:type="TP_IFACE_MEDIA_SESSION_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_MEDIA_STREAM_HANDLER"
              value="org.freedesktop.Telepathy.Media.StreamHandler"
              c:type="TP_IFACE_MEDIA_STREAM_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROPERTIES_INTERFACE"
              value="org.freedesktop.Telepathy.Properties"
              c:type="TP_IFACE_PROPERTIES_INTERFACE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL"
              value="org.freedesktop.Telepathy.Protocol"
              c:type="TP_IFACE_PROTOCOL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_ADDRESSING"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_ADDRESSING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_AVATARS"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_AVATARS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="IFACE_PROTOCOL_INTERFACE_PRESENCE"
              value="org.freedesktop.Telepathy.Protocol.Interface.Presence"
              c:type="TP_IFACE_PROTOCOL_INTERFACE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <callback name="IntFunc" c:type="TpIntFunc">
      <doc xml:whitespace="preserve">A callback function acting on unsigned integers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="i" transfer-ownership="none">
          <doc xml:whitespace="preserve">The relevant integer</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">Opaque user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Intset"
            c:type="TpIntset"
            glib:type-name="TpIntset"
            glib:get-type="tp_intset_get_type"
            c:symbol-prefix="intset">
      <doc xml:whitespace="preserve">Opaque type representing a set of unsigned integers.

Before 0.11.16, this type was called &lt;type&gt;TpIntSet&lt;/type&gt;, which is
now a backwards compatibility typedef.</doc>
      <constructor name="new" c:identifier="tp_intset_new">
        <doc xml:whitespace="preserve">Allocate a new integer set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </constructor>
      <constructor name="new_containing"
                   c:identifier="tp_intset_new_containing"
                   version="0.7.26">
        <doc xml:whitespace="preserve">Allocate a new integer set containing the given integer.

tp_intset_destroy()</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new integer set containing @element, to be destroyed with</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add to a new set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="sized_new" c:identifier="tp_intset_sized_new">
        <doc xml:whitespace="preserve">Allocate a new integer set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty integer set to be destroyed with tp_intset_destroy()</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">ignored (it was previously 1 more than the largest integer you expect to store)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="tp_intset_add">
        <doc xml:whitespace="preserve">Add an integer into a TpIntset.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="tp_intset_clear">
        <doc xml:whitespace="preserve">Unset every integer in the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="copy" c:identifier="tp_intset_copy">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A set containing the same integers as @orig, to be freed with</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
      </method>
      <method name="destroy" c:identifier="tp_intset_destroy">
        <doc xml:whitespace="preserve">Free all memory used by the set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="difference" c:identifier="tp_intset_difference">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

(analogous to the bitwise operation left &amp; (~right)), to be freed with
tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in @left and not in @right</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="difference_update"
              c:identifier="tp_intset_difference_update"
              version="0.13.10">
        <doc xml:whitespace="preserve">Remove each integer in @other from @self, analogous to the bitwise
operation self &amp;= (~other).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">members to remove</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="tp_intset_dump">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

numbers in @set in a human-readable format</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string which the caller must free with g_free, listing the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="foreach" c:identifier="tp_intset_foreach">
        <doc xml:whitespace="preserve">Call @func(element, @userdata) for each element of @set, in order.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">@TpIntFunc to use to iterate the set</doc>
            <type name="IntFunc" c:type="TpIntFunc"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to each call of @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersection" c:identifier="tp_intset_intersection">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

(analogous to the bitwise operation left &amp; right), to be freed with
tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in both @left and @right</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="tp_intset_is_empty"
              version="0.11.6">
        <doc xml:whitespace="preserve">Return the same thing as &lt;code&gt;(tp_intset_size (set) == 0)&lt;/code&gt;,
but calculated more efficiently.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @set is empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_equal" c:identifier="tp_intset_is_equal">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @left and @right contain the same bits</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">A set of integers</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_member" c:identifier="tp_intset_is_member">
        <doc xml:whitespace="preserve">Tests if @element is a member of @set</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @element is in @set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to test</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="tp_intset_remove">
        <doc xml:whitespace="preserve">Remove an integer from a TpIntset</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @element was previously in @set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">integer to add</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="size" c:identifier="tp_intset_size">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of integers in @set</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="symmetric_difference"
              c:identifier="tp_intset_symmetric_difference">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

but not both (analogous to the bitwise operation left ^ right), to be freed
with tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in either @left or @right</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_array" c:identifier="tp_intset_to_array">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

be freed by the caller) containing the same integers as @set.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a GArray of guint (which must</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint"/>
          </array>
        </return-value>
      </method>
      <method name="union" c:identifier="tp_intset_union">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

(analogous to the bitwise operation left | right), to be freed with
tp_intset_destroy() by the caller</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The set of those integers which are in either @left or @right</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="right" transfer-ownership="none">
            <doc xml:whitespace="preserve">The right operand</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="union_update"
              c:identifier="tp_intset_union_update"
              version="0.13.10">
        <doc xml:whitespace="preserve">Add each integer in @other to @self, analogous to the bitwise operation
self |= other.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">members to add</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <function name="from_array" c:identifier="tp_intset_from_array">
        <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A set containing the same integers as @array.</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </return-value>
        <parameters>
          <parameter name="array" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of guint</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="guint"/>
            </array>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="IntsetFastIter" c:type="TpIntsetFastIter" version="0.11.6">
      <doc xml:whitespace="preserve">An opaque structure representing iteration in undefined order over a set of
integers. Must be initialized with tp_intset_fast_iter_init().

Before 0.11.16, this type was called &lt;type&gt;TpIntSetFastIter&lt;/type&gt;,
which is now a backwards compatibility typedef.

Usage is similar to #GHashTableIter:

&lt;informalexample&gt;&lt;programlisting&gt;
TpIntsetFastIter iter;
guint element;

tp_intset_fast_iter_init (&amp;amp;iter, intset);

while (tp_intset_fast_iter_next (&amp;amp;iter, &amp;amp;element))
{
printf ("%u is in the intset\n", element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <field name="_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="init"
              c:identifier="tp_intset_fast_iter_init"
              version="0.11.6">
        <doc xml:whitespace="preserve">Initialize @iter to iterate over @set in arbitrary order. @iter will become
invalid if @set is modified.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="set" transfer-ownership="none">
            <doc xml:whitespace="preserve">a set</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next"
              c:identifier="tp_intset_fast_iter_next"
              version="0.11.6">
        <doc xml:whitespace="preserve">Advances @iter and retrieves the integer it now points to. Iteration
is not necessarily in numerical order.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if the end of the set has been reached</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="output" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store a new integer, in arbitrary order</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="IntsetIter" c:type="TpIntsetIter">
      <doc xml:whitespace="preserve">A structure representing iteration over a set of integers. Must be
initialized with either TP_INTSET_ITER_INIT() or tp_intset_iter_init().

Since 0.11.6, consider using #TpIntsetFastIter if iteration in
numerical order is not required.

Before 0.11.16, this type was called &lt;type&gt;TpIntSetIter&lt;/type&gt;,
which is now a backwards compatibility typedef.</doc>
      <field name="set" writable="1">
        <type name="Intset" c:type="TpIntset*"/>
      </field>
      <field name="element" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <method name="init" c:identifier="tp_intset_iter_init">
        <doc xml:whitespace="preserve">Reset the iterator @iter to the beginning and make it iterate over @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="set" transfer-ownership="none">
            <doc xml:whitespace="preserve">An integer set to be used by that iterator</doc>
            <type name="Intset" c:type="TpIntset*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="tp_intset_iter_next">
        <doc xml:whitespace="preserve">If there are integers in (@iter-&gt;set) higher than (@iter-&gt;element), set
(iter-&gt;element) to the next one and return %TRUE. Otherwise return %FALSE.

Usage:

&lt;informalexample&gt;&lt;programlisting&gt;
TpIntsetIter iter = TP_INTSET_INIT (intset);
while (tp_intset_iter_next (&amp;amp;iter))
{
printf ("%u is in the intset\n", iter.element);
}
&lt;/programlisting&gt;&lt;/informalexample&gt;

Since 0.11.6, consider using #TpIntsetFastIter if iteration in
numerical order is not required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if (@iter-&gt;element) has been advanced</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="reset" c:identifier="tp_intset_iter_reset">
        <doc xml:whitespace="preserve">Reset the iterator @iter to the beginning. It must already be associated
with a set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="LocalHoldState" c:type="TpLocalHoldState">
      <member name="unheld"
              value="0"
              c:identifier="TP_LOCAL_HOLD_STATE_UNHELD"/>
      <member name="held" value="1" c:identifier="TP_LOCAL_HOLD_STATE_HELD"/>
      <member name="pending_hold"
              value="2"
              c:identifier="TP_LOCAL_HOLD_STATE_PENDING_HOLD"/>
      <member name="pending_unhold"
              value="3"
              c:identifier="TP_LOCAL_HOLD_STATE_PENDING_UNHOLD"/>
    </enumeration>
    <enumeration name="LocalHoldStateReason" c:type="TpLocalHoldStateReason">
      <member name="none"
              value="0"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_NONE"/>
      <member name="requested"
              value="1"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_REQUESTED"/>
      <member name="resource_not_available"
              value="2"
              c:identifier="TP_LOCAL_HOLD_STATE_REASON_RESOURCE_NOT_AVAILABLE"/>
    </enumeration>
    <bitfield name="LocationFeatures" c:type="TpLocationFeatures">
      <member name="location_feature_can_set"
              value="1"
              c:identifier="TP_LOCATION_FEATURE_CAN_SET"/>
    </bitfield>
    <bitfield name="MailNotificationFlags" c:type="TpMailNotificationFlags">
      <member name="supports_unread_mail_count"
              value="1"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_UNREAD_MAIL_COUNT"/>
      <member name="supports_unread_mails"
              value="2"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_UNREAD_MAILS"/>
      <member name="emits_mails_received"
              value="4"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_EMITS_MAILS_RECEIVED"/>
      <member name="supports_request_inbox_url"
              value="8"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_REQUEST_INBOX_URL"/>
      <member name="supports_request_mail_url"
              value="16"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_SUPPORTS_REQUEST_MAIL_URL"/>
      <member name="thread_based"
              value="32"
              c:identifier="TP_MAIL_NOTIFICATION_FLAG_THREAD_BASED"/>
    </bitfield>
    <enumeration name="MediaStreamBaseProto" c:type="TpMediaStreamBaseProto">
      <member name="udp"
              value="0"
              c:identifier="TP_MEDIA_STREAM_BASE_PROTO_UDP"/>
      <member name="tcp"
              value="1"
              c:identifier="TP_MEDIA_STREAM_BASE_PROTO_TCP"/>
    </enumeration>
    <enumeration name="MediaStreamDirection" c:type="TpMediaStreamDirection">
      <member name="none"
              value="0"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_NONE"/>
      <member name="send"
              value="1"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_SEND"/>
      <member name="receive"
              value="2"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_RECEIVE"/>
      <member name="bidirectional"
              value="3"
              c:identifier="TP_MEDIA_STREAM_DIRECTION_BIDIRECTIONAL"/>
    </enumeration>
    <enumeration name="MediaStreamError" c:type="TpMediaStreamError">
      <member name="unknown"
              value="0"
              c:identifier="TP_MEDIA_STREAM_ERROR_UNKNOWN"/>
      <member name="eos" value="1" c:identifier="TP_MEDIA_STREAM_ERROR_EOS"/>
      <member name="codec_negotiation_failed"
              value="2"
              c:identifier="TP_MEDIA_STREAM_ERROR_CODEC_NEGOTIATION_FAILED"/>
      <member name="connection_failed"
              value="3"
              c:identifier="TP_MEDIA_STREAM_ERROR_CONNECTION_FAILED"/>
      <member name="network_error"
              value="4"
              c:identifier="TP_MEDIA_STREAM_ERROR_NETWORK_ERROR"/>
      <member name="no_codecs"
              value="5"
              c:identifier="TP_MEDIA_STREAM_ERROR_NO_CODECS"/>
      <member name="invalid_cm_behavior"
              value="6"
              c:identifier="TP_MEDIA_STREAM_ERROR_INVALID_CM_BEHAVIOR"/>
      <member name="media_error"
              value="7"
              c:identifier="TP_MEDIA_STREAM_ERROR_MEDIA_ERROR"/>
    </enumeration>
    <bitfield name="MediaStreamPendingSend" c:type="TpMediaStreamPendingSend">
      <member name="local_send"
              value="1"
              c:identifier="TP_MEDIA_STREAM_PENDING_LOCAL_SEND"/>
      <member name="remote_send"
              value="2"
              c:identifier="TP_MEDIA_STREAM_PENDING_REMOTE_SEND"/>
    </bitfield>
    <enumeration name="MediaStreamState" c:type="TpMediaStreamState">
      <member name="disconnected"
              value="0"
              c:identifier="TP_MEDIA_STREAM_STATE_DISCONNECTED"/>
      <member name="connecting"
              value="1"
              c:identifier="TP_MEDIA_STREAM_STATE_CONNECTING"/>
      <member name="connected"
              value="2"
              c:identifier="TP_MEDIA_STREAM_STATE_CONNECTED"/>
    </enumeration>
    <enumeration name="MediaStreamTransportType"
                 c:type="TpMediaStreamTransportType">
      <member name="local"
              value="0"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_LOCAL"/>
      <member name="derived"
              value="1"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_DERIVED"/>
      <member name="relay"
              value="2"
              c:identifier="TP_MEDIA_STREAM_TRANSPORT_TYPE_RELAY"/>
    </enumeration>
    <enumeration name="MediaStreamType" c:type="TpMediaStreamType">
      <member name="audio"
              value="0"
              c:identifier="TP_MEDIA_STREAM_TYPE_AUDIO"/>
      <member name="video"
              value="1"
              c:identifier="TP_MEDIA_STREAM_TYPE_VIDEO"/>
    </enumeration>
    <class name="Message"
           c:symbol-prefix="message"
           c:type="TpMessage"
           parent="GObject.Object"
           glib:type-name="TpMessage"
           glib:get-type="tp_message_get_type"
           glib:type-struct="MessageClass">
      <doc xml:whitespace="preserve">Opaque structure representing a message in the Telepathy messages interface
(an array of at least one mapping from string to variant, where the first
mapping contains message headers and subsequent mappings contain the
message body).

This base class provides convenience API for most of the common keys that
can appear in the header. One notable exception is the sender of the
message. Inside a connection manager, messages are represented by the
#TpCMMessage subclass, and you should use tp_cm_message_get_sender().
When composing a message in a client using #TpClientMessage, messages do
not have an explicit sender (the sender is automatically the local user).
When a client sees a sent or received message signalled by the connection
manager (represented by #TpSignalledMessage), the message's sender (if any)
can be accessed with tp_signalled_message_get_sender().</doc>
      <method name="append_part"
              c:identifier="tp_message_append_part"
              version="0.7.21">
        <doc xml:whitespace="preserve">Append a body part to the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the part number</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="count_parts"
              c:identifier="tp_message_count_parts"
              version="0.7.21">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;

part 0</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of parts in the message, including the headers in</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="delete_key"
              c:identifier="tp_message_delete_key"
              version="0.7.21">
        <doc xml:whitespace="preserve">Remove the given key and its value from the given part.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the key previously existed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_part"
              c:identifier="tp_message_delete_part"
              version="0.7.21">
        <doc xml:whitespace="preserve">Delete the given body part from the message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly greater than 0, and strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="tp_message_destroy"
              version="0.7.21">
        <doc xml:whitespace="preserve">Since 0.13.9 this function is a simple wrapper around
g_object_unref()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_message_type"
              c:identifier="tp_message_get_message_type"
              version="0.13.10">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of this message</doc>
          <type name="ChannelTextMessageType"
                c:type="TpChannelTextMessageType"/>
        </return-value>
      </method>
      <method name="get_pending_message_id"
              c:identifier="tp_message_get_pending_message_id"
              version="0.15.3">
        <doc xml:whitespace="preserve">Return the incoming message ID of @self. Only incoming messages have such
ID, for outgoing ones this function returns 0 and set @valid to %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the incoming message ID.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <parameter name="valid"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">either %NULL, or a location in which to store %TRUE if @self contains a pending message ID.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_received_timestamp"
              c:identifier="tp_message_get_received_timestamp"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return when this message was received locally, as a number of seconds since
the beginning of 1970 in the UTC timezone (the same representation used by
g_date_time_new_from_unix_utc(), for instance), or 0 if not known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a Unix timestamp, or 0</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_sent_timestamp"
              c:identifier="tp_message_get_sent_timestamp"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return when this message was sent, as a number of seconds since the
beginning of 1970 in the UTC timezone (the same representation used by
g_date_time_new_from_unix_utc(), for instance), or 0 if not known.

If this protocol does not track the time at which the message was
initially sent, this timestamp might be approximated by using the
time at which it arrived at a central server.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a Unix timestamp, or 0</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_specific_to_interface"
              c:identifier="tp_message_get_specific_to_interface"
              version="0.13.9">
        <doc xml:whitespace="preserve">If this message is specific to a particular D-Bus interface and should
be ignored by clients without knowledge of that interface, return the
name of the interface.

If this message is an ordinary message or delivery report, return %NULL.

messages and delivery reports</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus interface name, or %NULL for ordinary</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_supersedes"
              c:identifier="tp_message_get_supersedes"
              version="0.13.9">
        <doc xml:whitespace="preserve">If this message replaces a previous message, return the value of
tp_message_get_token() for that previous message. Otherwise, return %NULL.

For instance, a user interface could replace the superseded
message with this message, or grey out the superseded message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-empty opaque identifier, or %NULL if none</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_token"
              c:identifier="tp_message_get_token"
              version="0.13.9">
        <doc xml:whitespace="preserve">Return this message's identifier in the underlying protocol. This is
&lt;emphasis&gt;not&lt;/emphasis&gt; guaranteed to be unique, even within the scope
of a single channel or contact: the only guarantee made is that two
messages with different non-empty tokens are different messages.

If there is no suitable token, return %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-empty opaque identifier, or %NULL if none</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="is_delivery_report"
              c:identifier="tp_message_is_delivery_report"
              version="0.13.9">
        <doc xml:whitespace="preserve">If this message is a delivery report indicating success or failure of
delivering a message, return %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this is a delivery report</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_mutable"
              c:identifier="tp_message_is_mutable"
              version="0.13.9">
        <doc xml:whitespace="preserve">Check if @self is mutable. Only mutable messages can be modified using
functions such as tp_message_set_string().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message is mutable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_rescued"
              c:identifier="tp_message_is_rescued"
              version="0.13.9">
        <doc xml:whitespace="preserve">Returns %TRUE if this incoming message has been seen in a previous channel
during the lifetime of the Connection, but had not been acknowledged when
that channel closed, causing an identical channel (in which the message now
appears) to open.

Loggers should check this flag to avoid duplicating messages, for instance.

Connection</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this message was seen in a previous Channel on this</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_scrollback"
              c:identifier="tp_message_is_scrollback"
              version="0.13.9">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;

instance in an XMPP chatroom.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this message is part of a replay of message history, for</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="tp_message_peek" version="0.7.21">
        <doc xml:whitespace="preserve">&lt;!-- nothing more to say --&gt;

the #GHashTable used to implement the given part, or %NULL if the
part number is out of range. The hash table is only valid as long as the
message is valid and the part is not deleted.</doc>
        <return-value transfer-ownership="none">
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref_handle"
              c:identifier="tp_message_ref_handle"
              version="0.7.21"
              deprecated="since 0.13.9. Handles are now immortal so there is">
        <doc xml:whitespace="preserve">Reference the given handle until this message is destroyed.

no point to ref them. Furthermore, the only handle that should be stored
in a TpMessage is message-sender which should be set using
tp_cm_message_set_sender().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle type, greater than %TP_HANDLE_TYPE_NONE and less than %NUM_TP_HANDLE_TYPES</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle of the given type</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="tp_message_set" version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have a copy of @source as its value.

If @source represents a data structure containing handles, they should
all be referenced with tp_message_ref_handle() first.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_boolean"
              c:identifier="tp_message_set_boolean"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @b as a boolean value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:whitespace="preserve">a boolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_bytes"
              c:identifier="tp_message_set_bytes"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @bytes as a byte-array value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">a number of bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array of @len bytes</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_handle"
              c:identifier="tp_message_set_handle"
              version="0.7.21"
              deprecated="since 0.13.9. Use tp_cm_message_set_sender()">
        <doc xml:whitespace="preserve">If @handle_or_0 is not zero, reference it with tp_message_ref_handle().

Set @key in part @part of @self to have @handle_or_0 as an unsigned integer
value.

Since 0.13.9 this function has been deprecated in favor or
tp_cm_message_set_sender() as 'message-sender' is the only handle
you can put in a #TpCMMessage.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="handle_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle type</doc>
            <type name="HandleType" c:type="TpHandleType"/>
          </parameter>
          <parameter name="handle_or_0" transfer-ownership="none">
            <doc xml:whitespace="preserve">a handle of that type, or 0</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int32"
              c:identifier="tp_message_set_int32"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @i as a signed integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer value</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64"
              c:identifier="tp_message_set_int64"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @i as a signed integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <doc xml:whitespace="preserve">an integer value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string"
              c:identifier="tp_message_set_string"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @s as a string value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="s" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string value</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string_printf"
              c:identifier="tp_message_set_string_printf"
              version="0.7.21"
              introspectable="0">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have a string value constructed from a
printf-style format string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:whitespace="preserve">a printf-style format string for the string value</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint32"
              c:identifier="tp_message_set_uint32"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @u as an unsigned integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="u" transfer-ownership="none">
            <doc xml:whitespace="preserve">an unsigned integer value</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uint64"
              c:identifier="tp_message_set_uint64"
              version="0.7.21">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @u as an unsigned integer value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="u" transfer-ownership="none">
            <doc xml:whitespace="preserve">an unsigned integer value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_message"
              c:identifier="tp_message_take_message"
              version="0.7.21"
              deprecated="since 0.13.9. Use tp_cm_message_take_message()">
        <doc xml:whitespace="preserve">Set @key in part @part of @self to have @message as an aa{sv} value (that
is, an array of Message_Part), and take ownership of @message.  The caller
should not use @message after passing it to this function.  All handle
references owned by @message will subsequently belong to and be released
with @self.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="part" transfer-ownership="none">
            <doc xml:whitespace="preserve">a part number, which must be strictly less than the number returned by tp_message_count_parts()</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key in the mapping representing the part</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">another (distinct) message created for the same #TpBaseConnection</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_text"
              c:identifier="tp_message_to_text"
              version="0.13.9">
        <doc xml:whitespace="preserve">Concatene all the text parts contained in @message.

text content of #message</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string containing the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="out_flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, the #TpChannelTextMessageFlags of @message</doc>
            <type name="ChannelTextMessageFlags"
                  c:type="TpChannelTextMessageFlags*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="MessageClass"
            c:type="TpMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="Message">
    </record>
    <bitfield name="MessagePartSupportFlags"
              c:type="TpMessagePartSupportFlags">
      <member name="one_attachment"
              value="1"
              c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_ONE_ATTACHMENT"/>
      <member name="multiple_attachments"
              value="2"
              c:identifier="TP_MESSAGE_PART_SUPPORT_FLAG_MULTIPLE_ATTACHMENTS"/>
    </bitfield>
    <bitfield name="MessageSendingFlags" c:type="TpMessageSendingFlags">
      <member name="delivery"
              value="1"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELIVERY"/>
      <member name="read"
              value="2"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_READ"/>
      <member name="deleted"
              value="4"
              c:identifier="TP_MESSAGE_SENDING_FLAG_REPORT_DELETED"/>
    </bitfield>
    <class name="ObserveChannelsContext"
           c:symbol-prefix="observe_channels_context"
           c:type="TpObserveChannelsContext"
           version="0.11.5"
           parent="GObject.Object"
           glib:type-name="TpObserveChannelsContext"
           glib:get-type="tp_observe_channels_context_get_type"
           glib:type-struct="ObserveChannelsContextClass">
      <doc xml:whitespace="preserve">Data structure representing the context of a Observer.ObserveChannels()
call.</doc>
      <method name="accept"
              c:identifier="tp_observe_channels_context_accept"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl when it's done so the D-Bus
method can return.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="delay"
              c:identifier="tp_observe_channels_context_delay"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl to indicate that it
implements the method in an async way. The caller must take a reference
to the #TpObserveChannelsContext before calling this function, and
is responsible for calling either tp_observe_channels_context_accept() or
tp_observe_channels_context_fail() later.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fail"
              c:identifier="tp_observe_channels_context_fail"
              version="0.11.5">
        <doc xml:whitespace="preserve">Called by #TpBaseClientClassObserveChannelsImpl to raise a D-Bus error.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the error to return from the method</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_requests"
              c:identifier="tp_observe_channels_context_get_requests"
              version="0.13.14">
        <doc xml:whitespace="preserve">Return a list of the #TpChannelRequest which have been satisfied by the
channels associated with #self.

a newly allocated #GList of reffed #TpChannelRequest.</doc>
        <return-value transfer-ownership="full">
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </return-value>
      </method>
      <method name="is_recovering"
              c:identifier="tp_observe_channels_context_is_recovering"
              version="0.11.5">
        <doc xml:whitespace="preserve">If this call to ObserveChannels is for channels that already
existed before this observer started (because the observer used
tp_base_client_set_observer_recover()), return %TRUE.

In most cases, the result is %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for pre-existing channels, %FALSE for new channels</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <property name="account"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAccount object representing the Account that has been passed to
ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Account"/>
      </property>
      <property name="channels"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannel objects representing the channels
that have been passed to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
      <property name="connection"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpConnection object representing the Connection that has been passed
to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Connection"/>
      </property>
      <property name="dbus-context"
                version="0.11.5"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #DBusGMethodInvocation representing the D-Bus context of the
ObserveChannels call.
Can only be written during construction.</doc>
        <type name="gpointer"/>
      </property>
      <property name="dispatch-operation"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpChannelDispatchOperation object representing the
ChannelDispatchOperation that has been passed to ObserveChannels,
or %NULL if none has been passed.
Read-only except during construction.</doc>
        <type name="ChannelDispatchOperation"/>
      </property>
      <property name="observer-info"
                version="0.11.5"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GHashTable where the keys are string and values are GValue instances.
It represents the Observer_Info hash table that has been passed to
ObserveChannels.
It's recommended to use high-level method such as
tp_observe_channels_context_is_recovering() to access to its content.

This property can't be %NULL.</doc>
        <type/>
      </property>
      <property name="requests"
                version="0.11.5"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GPtrArray containing #TpChannelRequest objects representing the
requests that have been passed to ObserveChannels.
Read-only except during construction.

This property can't be %NULL.</doc>
        <array name="GLib.PtrArray">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </property>
    </class>
    <record name="ObserveChannelsContextClass"
            c:type="TpObserveChannelsContextClass"
            disguised="1"
            glib:is-gtype-struct-for="ObserveChannelsContext"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpObserveChannelsContext.</doc>
    </record>
    <record name="ObserveChannelsContextPrivate"
            c:type="TpObserveChannelsContextPrivate"
            disguised="1">
    </record>
    <constant name="PROP_ACCOUNT_AUTOMATIC_PRESENCE"
              value="org.freedesktop.Telepathy.Account.AutomaticPresence"
              c:type="TP_PROP_ACCOUNT_AUTOMATIC_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CHANGING_PRESENCE"
              value="org.freedesktop.Telepathy.Account.ChangingPresence"
              c:type="TP_PROP_ACCOUNT_CHANGING_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION"
              value="org.freedesktop.Telepathy.Account.Connection"
              c:type="TP_PROP_ACCOUNT_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR"
              value="org.freedesktop.Telepathy.Account.ConnectionError"
              c:type="TP_PROP_ACCOUNT_CONNECTION_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Account.ConnectionErrorDetails"
              c:type="TP_PROP_ACCOUNT_CONNECTION_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS"
              value="org.freedesktop.Telepathy.Account.ConnectionStatus"
              c:type="TP_PROP_ACCOUNT_CONNECTION_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECTION_STATUS_REASON"
              value="org.freedesktop.Telepathy.Account.ConnectionStatusReason"
              c:type="TP_PROP_ACCOUNT_CONNECTION_STATUS_REASON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CONNECT_AUTOMATICALLY"
              value="org.freedesktop.Telepathy.Account.ConnectAutomatically"
              c:type="TP_PROP_ACCOUNT_CONNECT_AUTOMATICALLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_CURRENT_PRESENCE"
              value="org.freedesktop.Telepathy.Account.CurrentPresence"
              c:type="TP_PROP_ACCOUNT_CURRENT_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_DISPLAY_NAME"
              value="org.freedesktop.Telepathy.Account.DisplayName"
              c:type="TP_PROP_ACCOUNT_DISPLAY_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_ENABLED"
              value="org.freedesktop.Telepathy.Account.Enabled"
              c:type="TP_PROP_ACCOUNT_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_HAS_BEEN_ONLINE"
              value="org.freedesktop.Telepathy.Account.HasBeenOnline"
              c:type="TP_PROP_ACCOUNT_HAS_BEEN_ONLINE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_ICON"
              value="org.freedesktop.Telepathy.Account.Icon"
              c:type="TP_PROP_ACCOUNT_ICON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACES"
              value="org.freedesktop.Telepathy.Account.Interfaces"
              c:type="TP_PROP_ACCOUNT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES"
              value="org.freedesktop.Telepathy.Account.Interface.Addressing.URISchemes"
              c:type="TP_PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR"
              value="org.freedesktop.Telepathy.Account.Interface.Avatar.Avatar"
              c:type="TP_PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageIdentifier"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageProvider"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageRestrictions"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION"
              value="org.freedesktop.Telepathy.Account.Interface.Storage.StorageSpecificInformation"
              c:type="TP_PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INTERFACES"
              value="org.freedesktop.Telepathy.AccountManager.Interfaces"
              c:type="TP_PROP_ACCOUNT_MANAGER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS"
              value="org.freedesktop.Telepathy.AccountManager.InvalidAccounts"
              c:type="TP_PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES"
              value="org.freedesktop.Telepathy.AccountManager.SupportedAccountProperties"
              c:type="TP_PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS"
              value="org.freedesktop.Telepathy.AccountManager.ValidAccounts"
              c:type="TP_PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_NICKNAME"
              value="org.freedesktop.Telepathy.Account.Nickname"
              c:type="TP_PROP_ACCOUNT_NICKNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_NORMALIZED_NAME"
              value="org.freedesktop.Telepathy.Account.NormalizedName"
              c:type="TP_PROP_ACCOUNT_NORMALIZED_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_PARAMETERS"
              value="org.freedesktop.Telepathy.Account.Parameters"
              c:type="TP_PROP_ACCOUNT_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_REQUESTED_PRESENCE"
              value="org.freedesktop.Telepathy.Account.RequestedPresence"
              c:type="TP_PROP_ACCOUNT_REQUESTED_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_SERVICE"
              value="org.freedesktop.Telepathy.Account.Service"
              c:type="TP_PROP_ACCOUNT_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_ACCOUNT_VALID"
              value="org.freedesktop.Telepathy.Account.Valid"
              c:type="TP_PROP_ACCOUNT_VALID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.CertificateChainData"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.CertificateType"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.Rejections"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE"
              value="org.freedesktop.Telepathy.Authentication.TLSCertificate.State"
              c:type="TP_PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_CHANNEL_TYPE"
              value="org.freedesktop.Telepathy.Channel.ChannelType"
              c:type="TP_PROP_CHANNEL_CHANNEL_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interfaces"
              c:type="TP_PROP_CHANNEL_DISPATCHER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS"
              value="org.freedesktop.Telepathy.ChannelDispatcher.Interface.OperationList.DispatchOperations"
              c:type="TP_PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS"
              value="org.freedesktop.Telepathy.ChannelDispatcher.SupportsRequestHints"
              c:type="TP_PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Account"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Channels"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Connection"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.Interfaces"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS"
              value="org.freedesktop.Telepathy.ChannelDispatchOperation.PossibleHandlers"
              c:type="TP_PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.InitiatorHandle"
              c:type="TP_PROP_CHANNEL_INITIATOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INITIATOR_ID"
              value="org.freedesktop.Telepathy.Channel.InitiatorID"
              c:type="TP_PROP_CHANNEL_INITIATOR_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACES"
              value="org.freedesktop.Telepathy.Channel.Interfaces"
              c:type="TP_PROP_CHANNEL_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityMandatory"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymityModes"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID"
              value="org.freedesktop.Telepathy.Channel.Interface.Anonymity.AnonymousID"
              c:type="TP_PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES"
              value="org.freedesktop.Telepathy.Channel.Interface.ChatState.ChatStates"
              c:type="TP_PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.Channels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialChannels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialInviteeHandles"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InitialInviteeIDs"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.InvitationMessage"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS"
              value="org.freedesktop.Telepathy.Channel.Interface.Conference.OriginalChannels"
              c:type="TP_PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.CurrentlySendingTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.DeferredTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES"
              value="org.freedesktop.Telepathy.Channel.Interface.DTMF.InitialTones"
              c:type="TP_PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata.Metadata"
              c:type="TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME"
              value="org.freedesktop.Telepathy.Channel.Interface.FileTransfer.Metadata.ServiceName"
              c:type="TP_PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.GroupFlags"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.HandleOwners"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.LocalPendingMembers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.Members"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.MemberIdentifiers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.RemotePendingMembers"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Group.SelfHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.DeliveryReportingSupport"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.MessagePartSupportFlags"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.MessageTypes"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.PendingMessages"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES"
              value="org.freedesktop.Telepathy.Channel.Interface.Messages.SupportedContentTypes"
              c:type="TP_PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Anonymous"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.CanUpdateConfiguration"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.ConfigurationRetrieved"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Description"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.InviteOnly"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Limit"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Moderated"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.MutableProperties"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Password"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.PasswordHint"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.PasswordProtected"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Persistent"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Private"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE"
              value="org.freedesktop.Telepathy.Channel.Interface.RoomConfig1.Title"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.CreationTimestamp"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATOR"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.Creator"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.CreatorHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.RoomName"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_ROOM_SERVER"
              value="org.freedesktop.Telepathy.Channel.Interface.Room2.Server"
              c:type="TP_PROP_CHANNEL_INTERFACE_ROOM_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.AuthorizationIdentity"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.AvailableMechanisms"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.CanTryAgain"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.DefaultRealm"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.DefaultUsername"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.HasInitialData"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.MaySaveResponse"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLError"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLErrorDetails"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS"
              value="org.freedesktop.Telepathy.Channel.Interface.SASLAuthentication.SASLStatus"
              c:type="TP_PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable.Encrypted"
              c:type="TP_PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED"
              value="org.freedesktop.Telepathy.Channel.Interface.Securable.Verified"
              c:type="TP_PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.CurrentServicePoint"
              c:type="TP_PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT"
              value="org.freedesktop.Telepathy.Channel.Interface.ServicePoint.InitialServicePoint"
              c:type="TP_PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SMS_FLASH"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS.Flash"
              c:type="TP_PROP_CHANNEL_INTERFACE_SMS_FLASH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL"
              value="org.freedesktop.Telepathy.Channel.Interface.SMS.SMSChannel"
              c:type="TP_PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Actor"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.ActorHandle"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.CanSet"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Subject"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP"
              value="org.freedesktop.Telepathy.Channel.Interface.Subject2.Timestamp"
              c:type="TP_PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube.Parameters"
              c:type="TP_PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_INTERFACE_TUBE_STATE"
              value="org.freedesktop.Telepathy.Channel.Interface.Tube.State"
              c:type="TP_PROP_CHANNEL_INTERFACE_TUBE_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUESTED"
              value="org.freedesktop.Telepathy.Channel.Requested"
              c:type="TP_PROP_CHANNEL_REQUESTED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_ACCOUNT"
              value="org.freedesktop.Telepathy.ChannelRequest.Account"
              c:type="TP_PROP_CHANNEL_REQUEST_ACCOUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_HINTS"
              value="org.freedesktop.Telepathy.ChannelRequest.Hints"
              c:type="TP_PROP_CHANNEL_REQUEST_HINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_INTERFACES"
              value="org.freedesktop.Telepathy.ChannelRequest.Interfaces"
              c:type="TP_PROP_CHANNEL_REQUEST_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_PREFERRED_HANDLER"
              value="org.freedesktop.Telepathy.ChannelRequest.PreferredHandler"
              c:type="TP_PROP_CHANNEL_REQUEST_PREFERRED_HANDLER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_REQUESTS"
              value="org.freedesktop.Telepathy.ChannelRequest.Requests"
              c:type="TP_PROP_CHANNEL_REQUEST_REQUESTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_REQUEST_USER_ACTION_TIME"
              value="org.freedesktop.Telepathy.ChannelRequest.UserActionTime"
              c:type="TP_PROP_CHANNEL_REQUEST_USER_ACTION_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE"
              value="org.freedesktop.Telepathy.Channel.TargetHandle"
              c:type="TP_PROP_CHANNEL_TARGET_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_HANDLE_TYPE"
              value="org.freedesktop.Telepathy.Channel.TargetHandleType"
              c:type="TP_PROP_CHANNEL_TARGET_HANDLE_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TARGET_ID"
              value="org.freedesktop.Telepathy.Channel.TargetID"
              c:type="TP_PROP_CHANNEL_TARGET_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.AvailableSearchKeys"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Limit"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.SearchState"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER"
              value="org.freedesktop.Telepathy.Channel.Type.ContactSearch.Server"
              c:type="TP_PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.DBusNames"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.ServiceName"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS"
              value="org.freedesktop.Telepathy.Channel.Type.DBusTube.SupportedAccessControls"
              c:type="TP_PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.AvailableSocketTypes"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHash"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentHashType"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.ContentType"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Date"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Description"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Filename"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.InitialOffset"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.Size"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.State"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.TransferredBytes"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_FILE_TRANSFER_URI"
              value="org.freedesktop.Telepathy.Channel.Type.FileTransfer.URI"
              c:type="TP_PROP_CHANNEL_TYPE_FILE_TRANSFER_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_ROOM_LIST_SERVER"
              value="org.freedesktop.Telepathy.Channel.Type.RoomList.Server"
              c:type="TP_PROP_CHANNEL_TYPE_ROOM_LIST_SERVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD"
              value="org.freedesktop.Telepathy.Channel.Type.ServerAuthentication.AuthenticationMethod"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.Hostname"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.ReferenceIdentities"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE"
              value="org.freedesktop.Telepathy.Channel.Type.ServerTLSConnection.ServerCertificate"
              c:type="TP_PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.ImmutableStreams"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialAudio"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO"
              value="org.freedesktop.Telepathy.Channel.Type.StreamedMedia.InitialVideo"
              c:type="TP_PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube.Service"
              c:type="TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES"
              value="org.freedesktop.Telepathy.Channel.Type.StreamTube.SupportedSocketTypes"
              c:type="TP_PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Approver.ApproverChannelFilter"
              c:type="TP_PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_BYPASS_APPROVAL"
              value="org.freedesktop.Telepathy.Client.Handler.BypassApproval"
              c:type="TP_PROP_CLIENT_HANDLER_BYPASS_APPROVAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_CAPABILITIES"
              value="org.freedesktop.Telepathy.Client.Handler.Capabilities"
              c:type="TP_PROP_CLIENT_HANDLER_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLED_CHANNELS"
              value="org.freedesktop.Telepathy.Client.Handler.HandledChannels"
              c:type="TP_PROP_CLIENT_HANDLER_HANDLED_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Handler.HandlerChannelFilter"
              c:type="TP_PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_INTERFACES"
              value="org.freedesktop.Telepathy.Client.Interfaces"
              c:type="TP_PROP_CLIENT_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_DELAY_APPROVERS"
              value="org.freedesktop.Telepathy.Client.Observer.DelayApprovers"
              c:type="TP_PROP_CLIENT_OBSERVER_DELAY_APPROVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER"
              value="org.freedesktop.Telepathy.Client.Observer.ObserverChannelFilter"
              c:type="TP_PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CLIENT_OBSERVER_RECOVER"
              value="org.freedesktop.Telepathy.Client.Observer.Recover"
              c:type="TP_PROP_CLIENT_OBSERVER_RECOVER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_HAS_IMMORTAL_HANDLES"
              value="org.freedesktop.Telepathy.Connection.HasImmortalHandles"
              c:type="TP_PROP_CONNECTION_HAS_IMMORTAL_HANDLES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACES"
              value="org.freedesktop.Telepathy.Connection.Interfaces"
              c:type="TP_PROP_CONNECTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityMandatory"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.AnonymityModes"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES"
              value="org.freedesktop.Telepathy.Connection.Interface.Anonymity.SupportedAnonymityModes"
              c:type="TP_PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarBytes"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MaximumAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.MinimumAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarHeight"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.RecommendedAvatarWidth"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars.SupportedAvatarMIMETypes"
              c:type="TP_PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance.AccountBalance"
              c:type="TP_PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI"
              value="org.freedesktop.Telepathy.Connection.Interface.Balance.ManageCreditURI"
              c:type="TP_PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_IMSI"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.IMSI"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_IMSI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageNationalCharacterSet"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageReducedCharacterSet"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageServiceCentre"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.MessageValidityPeriod"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE"
              value="org.freedesktop.Telepathy.Connection.Interface.Cellular.OverrideMessageServiceCentre"
              c:type="TP_PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES"
              value="org.freedesktop.Telepathy.Connection.Interface.Contacts.ContactAttributeInterfaces"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking.ContactBlockingCapabilities"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.DisjointGroups"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.Groups"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups.GroupStorage"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.ContactInfoFlags"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo.SupportedFields"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.CanChangeContactList"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.ContactListPersists"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.ContactListState"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList.RequestUsesMessage"
              c:type="TP_PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControl"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.LocationAccessControlTypes"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES"
              value="org.freedesktop.Telepathy.Connection.Interface.Location.SupportedLocationFeatures"
              c:type="TP_PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.MailAddress"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.MailNotificationFlags"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.UnreadMails"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT"
              value="org.freedesktop.Telepathy.Connection.Interface.MailNotification.UnreadMailCount"
              c:type="TP_PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE"
              value="org.freedesktop.Telepathy.Connection.Interface.PowerSaving.PowerSavingActive"
              c:type="TP_PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests.Channels"
              c:type="TP_PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES"
              value="org.freedesktop.Telepathy.Connection.Interface.Requests.RequestableChannelClasses"
              c:type="TP_PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS"
              value="org.freedesktop.Telepathy.Connection.Interface.ServicePoint.KnownServicePoints"
              c:type="TP_PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence.MaximumStatusMessageLength"
              c:type="TP_PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence.Statuses"
              c:type="TP_PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_INTERFACES"
              value="org.freedesktop.Telepathy.ConnectionManager.Interfaces"
              c:type="TP_PROP_CONNECTION_MANAGER_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_MANAGER_PROTOCOLS"
              value="org.freedesktop.Telepathy.ConnectionManager.Protocols"
              c:type="TP_PROP_CONNECTION_MANAGER_PROTOCOLS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_SELF_HANDLE"
              value="org.freedesktop.Telepathy.Connection.SelfHandle"
              c:type="TP_PROP_CONNECTION_SELF_HANDLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_CONNECTION_STATUS"
              value="org.freedesktop.Telepathy.Connection.Status"
              c:type="TP_PROP_CONNECTION_STATUS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_DEBUG_ENABLED"
              value="org.freedesktop.Telepathy.Debug.Enabled"
              c:type="TP_PROP_DEBUG_ENABLED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY"
              value="org.freedesktop.Telepathy.Media.StreamHandler.CreatedLocally"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL"
              value="org.freedesktop.Telepathy.Media.StreamHandler.NATTraversal"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_RELAY_INFO"
              value="org.freedesktop.Telepathy.Media.StreamHandler.RelayInfo"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_RELAY_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS"
              value="org.freedesktop.Telepathy.Media.StreamHandler.STUNServers"
              c:type="TP_PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_AUTHENTICATION_TYPES"
              value="org.freedesktop.Telepathy.Protocol.AuthenticationTypes"
              c:type="TP_PROP_PROTOCOL_AUTHENTICATION_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_CONNECTION_INTERFACES"
              value="org.freedesktop.Telepathy.Protocol.ConnectionInterfaces"
              c:type="TP_PROP_PROTOCOL_CONNECTION_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_ENGLISH_NAME"
              value="org.freedesktop.Telepathy.Protocol.EnglishName"
              c:type="TP_PROP_PROTOCOL_ENGLISH_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_ICON"
              value="org.freedesktop.Telepathy.Protocol.Icon"
              c:type="TP_PROP_PROTOCOL_ICON">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACES"
              value="org.freedesktop.Telepathy.Protocol.Interfaces"
              c:type="TP_PROP_PROTOCOL_INTERFACES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing.AddressableURISchemes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS"
              value="org.freedesktop.Telepathy.Protocol.Interface.Addressing.AddressableVCardFields"
              c:type="TP_PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarBytes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MaximumAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MinimumAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.MinimumAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.RecommendedAvatarHeight"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.RecommendedAvatarWidth"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Avatars.SupportedAvatarMIMETypes"
              c:type="TP_PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES"
              value="org.freedesktop.Telepathy.Protocol.Interface.Presence.Statuses"
              c:type="TP_PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_PARAMETERS"
              value="org.freedesktop.Telepathy.Protocol.Parameters"
              c:type="TP_PROP_PROTOCOL_PARAMETERS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES"
              value="org.freedesktop.Telepathy.Protocol.RequestableChannelClasses"
              c:type="TP_PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PROP_PROTOCOL_VCARD_FIELD"
              value="org.freedesktop.Telepathy.Protocol.VCardField"
              c:type="TP_PROP_PROTOCOL_VCARD_FIELD">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="PresenceMixin" c:type="TpPresenceMixin">
      <doc xml:whitespace="preserve">Structure to be included in the instance structure of objects that
use this mixin. Initialize it with tp_presence_mixin_init().

There are no public fields.</doc>
      <field name="priv" readable="0" private="1">
        <type name="PresenceMixinPrivate" c:type="TpPresenceMixinPrivate*"/>
      </field>
      <function name="emit_one_presence_update"
                c:identifier="tp_presence_mixin_emit_one_presence_update"
                introspectable="0">
        <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for a single contact. This method is just a
convenience wrapper around #tp_presence_mixin_emit_presence_update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A connection object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">The handle of the contact to emit the signal for</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="status" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new status to emit</doc>
            <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
          </parameter>
        </parameters>
      </function>
      <function name="emit_presence_update"
                c:identifier="tp_presence_mixin_emit_presence_update"
                introspectable="0">
        <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for multiple contacts. For emitting
PresenceUpdate for a single contact, there is a convenience wrapper called
#tp_presence_mixin_emit_one_presence_update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">A connection object with this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="contact_presences" transfer-ownership="none">
            <doc xml:whitespace="preserve">A mapping of contact handles to #TpPresenceStatus structures with the presence data to emit</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="finalize"
                c:identifier="tp_presence_mixin_finalize"
                introspectable="0">
        <doc xml:whitespace="preserve">Free resources held by the presence mixin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An object with this mixin.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_offset_quark"
                c:identifier="tp_presence_mixin_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="iface_init"
                c:identifier="tp_presence_mixin_iface_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the presence interface using
this mixin. This function should usually be called via G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfacePresenceClass in an object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="init"
                c:identifier="tp_presence_mixin_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_init ((GObject *) self,
G_STRUCT_OFFSET (SomeObject, presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixin within the object structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_iface_init"
                c:identifier="tp_presence_mixin_simple_presence_iface_init"
                version="0.7.13"
                introspectable="0">
        <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the simple presence interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="g_iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceSimplePresenceClass in an object class</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="iface_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Ignored</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_init_dbus_properties"
                c:identifier="tp_presence_mixin_simple_presence_init_dbus_properties"
                version="0.7.13"
                introspectable="0">
        <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the SimplePresence interface's properties.

This automatically sets up a list of the supported properties for the
SimplePresence interface.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
        </parameters>
      </function>
      <function name="simple_presence_register_with_contacts_mixin"
                c:identifier="tp_presence_mixin_simple_presence_register_with_contacts_mixin"
                introspectable="0">
        <doc xml:whitespace="preserve">Register the SimplePresence interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:whitespace="preserve">An instance that of the implementation that uses both the Contacts mixin and this mixin</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceMixinClass" c:type="TpPresenceMixinClass">
      <doc xml:whitespace="preserve">Structure to be included in the class structure of objects that
use this mixin. Initialize it with tp_presence_mixin_class_init().

If the protocol imposes a limit on the length of status messages, one should
implement @get_maximum_status_message_length. If this callback is not
implemented, it is assumed that there is no limit. The callback function
should be set after calling tp_presence_mixin_class_init(), like so:

|[
TpPresenceMixinClass *mixin_class;

tp_presence_mixin_class_init ((GObjectClass *) klass,
G_STRUCT_OFFSET (SomeObjectClass, presence_mixin));
mixin_class = TP_PRESENCE_MIXIN_CLASS (klass);
mixin_class-&gt;get_maximum_status_message_length =
some_object_get_maximum_status_message_length;
]|

All other fields should be considered read-only.</doc>
      <field name="status_available" writable="1">
        <type name="PresenceMixinStatusAvailableFunc"
              c:type="TpPresenceMixinStatusAvailableFunc"/>
      </field>
      <field name="get_contact_statuses" writable="1">
        <type name="PresenceMixinGetContactStatusesFunc"
              c:type="TpPresenceMixinGetContactStatusesFunc"/>
      </field>
      <field name="set_own_status" writable="1">
        <type name="PresenceMixinSetOwnStatusFunc"
              c:type="TpPresenceMixinSetOwnStatusFunc"/>
      </field>
      <field name="statuses" writable="1">
        <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PresenceMixinClassPrivate"
              c:type="TpPresenceMixinClassPrivate*"/>
      </field>
      <field name="get_maximum_status_message_length" writable="1">
        <type name="PresenceMixinGetMaximumStatusMessageLengthFunc"
              c:type="TpPresenceMixinGetMaximumStatusMessageLengthFunc"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <function name="get_offset_quark"
                c:identifier="tp_presence_mixin_class_get_offset_quark"
                introspectable="0">
        <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init"
                c:identifier="tp_presence_mixin_class_init"
                introspectable="0">
        <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_class_init ((GObjectClass *) klass,
G_STRUCT_OFFSET (SomeObjectClass,
presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="obj_cls" transfer-ownership="none">
            <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
            <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixinClass within the class structure</doc>
            <type name="glong" c:type="glong"/>
          </parameter>
          <parameter name="status_available" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to determine if a given presence status can be set on a particular connection. Should usually be %NULL, to consider all statuses with #TpPresenceStatusSpec.self set to %TRUE to be settable.</doc>
            <type name="PresenceMixinStatusAvailableFunc"
                  c:type="TpPresenceMixinStatusAvailableFunc"/>
          </parameter>
          <parameter name="get_contact_statuses" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used get the current presence status for contacts. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
            <type name="PresenceMixinGetContactStatusesFunc"
                  c:type="TpPresenceMixinGetContactStatusesFunc"/>
          </parameter>
          <parameter name="set_own_status" transfer-ownership="none">
            <doc xml:whitespace="preserve">A callback to be used to commit changes to the user's own presence status to the server. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
            <type name="PresenceMixinSetOwnStatusFunc"
                  c:type="TpPresenceMixinSetOwnStatusFunc"/>
          </parameter>
          <parameter name="statuses" transfer-ownership="none">
            <doc xml:whitespace="preserve">An array of #TpPresenceStatusSpec structures representing all presence statuses supported by the protocol, terminated by a NULL name.</doc>
            <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceMixinClassPrivate"
            c:type="TpPresenceMixinClassPrivate"
            disguised="1">
    </record>
    <callback name="PresenceMixinGetContactStatusesFunc"
              c:type="TpPresenceMixinGetContactStatusesFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to get the stored presence status of
contacts. The returned hash table should have contact handles mapped to
their respective presence statuses in #TpPresenceStatus structs.

The returned hash table will be freed with g_hash_table_unref. The
callback is responsible for ensuring that this does any cleanup that
may be necessary.

error set on error</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">The contact presence on success, %NULL with</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #TpHandle for the contacts to get presence status for</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </callback>
    <callback name="PresenceMixinGetMaximumStatusMessageLengthFunc"
              c:type="TpPresenceMixinGetMaximumStatusMessageLengthFunc"
              version="0.14.5">
      <doc xml:whitespace="preserve">Signature of a callback used to determine the maximum length of status
messages. If this callback is provided and returns non-zero, the
#TpPresenceMixinSetOwnStatusFunc implementation is responsible for
truncating the message to fit this limit, if necessary.

message, or 0 if there is no limit.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maximum number of UTF-8 characters which may appear in a status</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceMixinPrivate"
            c:type="TpPresenceMixinPrivate"
            disguised="1">
    </record>
    <callback name="PresenceMixinSetOwnStatusFunc"
              c:type="TpPresenceMixinSetOwnStatusFunc"
              throws="1">
      <doc xml:whitespace="preserve">Signature of the callback used to commit changes to the user's own presence
status in SetStatuses. It is also used in ClearStatus and RemoveStatus to
reset the user's own status back to the "default" one with a %NULL status
argument.

The optional_arguments hash table in @status, if not NULL, will have been
filtered so it only contains recognised parameters, so the callback
need not (and cannot) check for unrecognised parameters. However, the
types of the parameters are not currently checked, so the callback is
responsible for doing so.

The callback is responsible for emitting PresenceUpdate, if appropriate,
by calling tp_presence_mixin_emit_presence_update().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the operation was successful, %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:whitespace="preserve">The status to set, or NULL for whatever the protocol defines as a "default" status</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PresenceMixinStatusAvailableFunc"
              c:type="TpPresenceMixinStatusAvailableFunc">
      <doc xml:whitespace="preserve">Signature of a callback to be used to determine if a given presence
status can be set on the connection. Most users of this mixin do not need to
supply an implementation of this callback: the value of
#TpPresenceStatusSpec.self is enough to determine whether this is a
user-settable presence, so %NULL should be passed to
tp_presence_mixin_class_init() for this callback.

One place where this callback may be needed is on XMPP: not all server
implementation support the user becoming invisible. So an XMPP
implementation would implement this function, so thatonce connectedthe
hidden status is only available if the server supports it. Before the
connection is connected, this callback should return %TRUE for every status
that might possibly be supported: this allows the user to at least try to
sign in as invisible.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the status can be set on this connection; %FALSE if not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of a #TpBaseConnection subclass implementing the presence interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="which" transfer-ownership="none">
          <doc xml:whitespace="preserve">An index into the array of #TpPresenceStatusSpec provided to tp_presence_mixin_class_init()</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PresenceStatus" c:type="TpPresenceStatus">
      <doc xml:whitespace="preserve">Structure representing a presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="index" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="optional_arguments" writable="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="free"
              c:identifier="tp_presence_status_free"
              introspectable="0">
        <doc xml:whitespace="preserve">Deallocate all resources associated with a presence status structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <function name="new"
                c:identifier="tp_presence_status_new"
                introspectable="0">
        <doc xml:whitespace="preserve">Construct a presence status structure. You should free the returned
structure with #tp_presence_status_free.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A pointer to the newly allocated presence status structure.</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </return-value>
        <parameters>
          <parameter name="which" transfer-ownership="none">
            <doc xml:whitespace="preserve">Index of the presence status in the provided supported presence statuses array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="optional_arguments" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional arguments for the presence statuses. Can be NULL if there are no optional arguments. The presence status object makes a copy of the hashtable, so you should free the original.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="PresenceStatusOptionalArgumentSpec"
            c:type="TpPresenceStatusOptionalArgumentSpec">
      <doc xml:whitespace="preserve">Structure specifying a supported optional argument for a presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="dtype" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="PresenceStatusSpec" c:type="TpPresenceStatusSpec">
      <doc xml:whitespace="preserve">Structure specifying a supported presence status.

In addition to the fields documented here, there are two gpointer fields
which must currently be %NULL. A meaning may be defined for these in a
future version of telepathy-glib.</doc>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="presence_type" writable="1">
        <type name="ConnectionPresenceType" c:type="TpConnectionPresenceType"/>
      </field>
      <field name="self" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="optional_arguments" writable="1">
        <type name="PresenceStatusOptionalArgumentSpec"
              c:type="TpPresenceStatusOptionalArgumentSpec*"/>
      </field>
      <field name="_future1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_future2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <bitfield name="PropertyFlags" c:type="TpPropertyFlags">
      <member name="read" value="1" c:identifier="TP_PROPERTY_FLAG_READ"/>
      <member name="write" value="2" c:identifier="TP_PROPERTY_FLAG_WRITE"/>
    </bitfield>
    <class name="Protocol"
           c:symbol-prefix="protocol"
           c:type="TpProtocol"
           version="0.11.11"
           parent="Proxy"
           glib:type-name="TpProtocol"
           glib:get-type="tp_protocol_get_type"
           glib:type-struct="ProtocolClass">
      <doc xml:whitespace="preserve">A base class for connection managers' protocols.</doc>
      <constructor name="new"
                   c:identifier="tp_protocol_new"
                   version="0.11.11"
                   throws="1">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new protocol proxy, or %NULL on invalid arguments</doc>
          <type name="Protocol" c:type="TpProtocol*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">proxy for the D-Bus daemon; may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="cm_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the connection manager name (such as "gabble")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="protocol_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the protocol name (such as "jabber")</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve">the immutable D-Bus properties for this protocol</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_core"
                c:identifier="tp_protocol_get_feature_quark_core">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_parameters"
                c:identifier="tp_protocol_get_feature_quark_parameters">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="init_known_interfaces"
                c:identifier="tp_protocol_init_known_interfaces"
                version="0.11.11">
        <doc xml:whitespace="preserve">Ensure that the known interfaces for TpProtocol have been set up.
This is done automatically when necessary, but for correct
overriding of library interfaces by local extensions, you should
call this function before calling
tp_proxy_or_subclass_hook_on_interface_add() with first argument
%TP_TYPE_PROTOCOL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="can_register"
              c:identifier="tp_protocol_can_register"
              version="0.11.11">
        <doc xml:whitespace="preserve">Return whether a new account can be registered on this protocol, by setting
the special "register" parameter to %TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @protocol supports the parameter "register"</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="dup_param_names"
              c:identifier="tp_protocol_dup_param_names"
              version="0.11.11"
              introspectable="0">
        <doc xml:whitespace="preserve">Returns a list of parameter names supported by this connection manager
for this protocol.

The result is copied and must be freed by the caller with g_strfreev().

#TpProtocol:param-names</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of</doc>
          <type name="GObject.Strv" c:type="GStrv"/>
        </return-value>
      </method>
      <method name="get_authentication_types"
              c:identifier="tp_protocol_get_authentication_types"
              version="0.13.9">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:authentication-types</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_avatar_requirements"
              c:identifier="tp_protocol_get_avatar_requirements"
              version="0.15.6">
        <doc xml:whitespace="preserve">Return the #TpProtocol:avatar-requirements property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:avatar-requirements</doc>
          <type name="AvatarRequirements" c:type="TpAvatarRequirements*"/>
        </return-value>
      </method>
      <method name="get_capabilities"
              c:identifier="tp_protocol_get_capabilities"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

(if non-%NULL) if it will be kept</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TpProtocol:capabilities, which must be referenced</doc>
          <type name="Capabilities" c:type="TpCapabilities*"/>
        </return-value>
      </method>
      <method name="get_english_name"
              c:identifier="tp_protocol_get_english_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the non-%NULL, non-empty value of #TpProtocol:english-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_icon_name"
              c:identifier="tp_protocol_get_icon_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the non-%NULL, non-empty value of #TpProtocol:icon-name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_name"
              c:identifier="tp_protocol_get_name"
              version="0.11.11">
        <doc xml:whitespace="preserve">Return the same thing as the protocol-name property, for convenient use
in C code. The returned string is valid for as long as @self exists.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpProtocol:protocol-name property</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_param"
              c:identifier="tp_protocol_get_param"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;

supported</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a structure representing the parameter @param, or %NULL if not</doc>
          <type name="ConnectionManagerParam"
                c:type="TpConnectionManagerParam*"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_vcard_field"
              c:identifier="tp_protocol_get_vcard_field"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpProtocol:vcard-field</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="has_param"
              c:identifier="tp_protocol_has_param"
              version="0.11.11">
        <doc xml:whitespace="preserve">&lt;!-- no more to say --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @self supports the parameter @param.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="authentication-types"
                version="0.13.9"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A non-%NULL #GStrv of interfaces which provide information as to
what kind of authentication channels can possibly appear before
the connection reaches the CONNECTED state, or %NULL if
%TP_PROTOCOL_FEATURE_CORE has not been prepared.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="avatar-requirements"
                version="0.15.6"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpAvatarRequirements representing the avatar requirements on this
protocol, or %NULL if %TP_PROTOCOL_FEATURE_CORE has not been prepared or
if the protocol doesn't support avatars.</doc>
        <type name="gpointer"/>
      </property>
      <property name="capabilities"
                version="0.11.11"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The classes of channel that can be requested from connections to this
protocol, or %NULL if this is unknown or the %TP_PROTOCOL_FEATURE_CORE
feature has not been prepared.</doc>
        <type name="Capabilities"/>
      </property>
      <property name="english-name"
                version="0.11.11"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of the protocol in a form suitable for display to users,
such as "AIM" or "Yahoo!", or a string based on #TpProtocol:protocol-name
(currently constructed by putting the first character in title case,
but this is not guaranteed) if no better name is available or the
%TP_PROTOCOL_FEATURE_CORE feature has not been prepared.

This is effectively in the C locale (international English); user
interfaces requiring a localized protocol name should look one up in their
own message catalog based on either #TpProtocol:protocol-name or
#TpProtocol:english-name, but should use this English version as a
fallback if no translated version can be found.</doc>
        <type name="utf8"/>
      </property>
      <property name="icon-name" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The name of an icon in the system's icon theme. If none was supplied
by the Protocol, or the %TP_PROTOCOL_FEATURE_CORE feature has not been
prepared, a default is used; currently, this is "im-" plus
#TpProtocol:protocol-name.</doc>
        <type name="utf8"/>
      </property>
      <property name="param-names" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">A list of parameter names supported by this connection manager
for this protocol, or %NULL if %TP_PROTOCOL_FEATURE_PARAMETERS has not
been prepared.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="protocol-name"
                version="0.11.11"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The machine-readable name of the protocol, taken from the Telepathy
D-Bus Interface Specification, such as "jabber" or "local-xmpp".</doc>
        <type name="utf8"/>
      </property>
      <property name="protocol-properties"
                version="0.11.11"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The immutable properties of this Protocol, as provided at construction
time. This is a map from string to #GValue, which must not be modified.

If the immutable properties were not provided at construction time,
the %TP_PROTOCOL_FEATURE_PARAMETERS and %TP_PROTOCOL_FEATURE_CORE features
will both be unavailable, and this #TpProtocol object will only be useful
as a way to access lower-level D-Bus calls.</doc>
        <type/>
      </property>
      <property name="vcard-field" version="0.11.11" transfer-ownership="none">
        <doc xml:whitespace="preserve">The most common vCard field used for this protocol's contact
identifiers, normalized to lower case, or %NULL if there is no such field
or the %TP_PROTOCOL_FEATURE_CORE feature has not been prepared.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Proxy" c:type="TpProxy"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProtocolPrivate" c:type="TpProtocolPrivate*"/>
      </field>
    </class>
    <record name="ProtocolClass"
            c:type="TpProtocolClass"
            disguised="1"
            glib:is-gtype-struct-for="Protocol"
            version="0.11.11">
      <doc xml:whitespace="preserve">The class of a #TpProtocol.</doc>
    </record>
    <record name="ProtocolClassPrivate"
            c:type="TpProtocolClassPrivate"
            disguised="1">
    </record>
    <record name="ProtocolPrivate" c:type="TpProtocolPrivate" disguised="1">
    </record>
    <class name="Proxy"
           c:symbol-prefix="proxy"
           c:type="TpProxy"
           version="0.7.1"
           parent="GObject.Object"
           glib:type-name="TpProxy"
           glib:get-type="tp_proxy_get_type"
           glib:type-struct="ProxyClass">
      <doc xml:whitespace="preserve">Structure representing a Telepathy client-side proxy.</doc>
      <method name="dbus_error_to_gerror"
              c:identifier="tp_proxy_dbus_error_to_gerror"
              version="0.7.24"
              throws="1">
        <doc xml:whitespace="preserve">Convert a D-Bus error name into a GError as if it was returned by a method
on this proxy. This method is useful when D-Bus error names are emitted in
signals, such as Connection.ConnectionError and
Group.MembersChangedDetailed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dbus_error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a D-Bus error name, for instance from the callback for tp_cli_connection_connect_to_connection_error()</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="debug_message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a debug message that accompanied the error name, or %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bus_name"
              c:identifier="tp_proxy_get_bus_name"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

must copy the string with g_strdup() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the bus name of the application exporting the object. The caller</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_dbus_connection"
              c:identifier="tp_proxy_get_dbus_connection"
              version="0.7.17"
              introspectable="0">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

The caller must reference the returned pointer with
dbus_g_connection_ref() if it will be kept.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a borrowed reference to the D-Bus connection used by this object.</doc>
          <type c:type="DBusGConnection*"/>
        </return-value>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_proxy_get_dbus_daemon"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

this object, if any; always %NULL if this object is itself a
#TpDBusDaemon. The caller must reference the returned object with
g_object_ref() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a borrowed reference to the #TpDBusDaemon for</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <method name="get_factory"
              c:identifier="tp_proxy_get_factory"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the same value as #TpProxy:factory property</doc>
          <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
        </return-value>
      </method>
      <method name="get_invalidated"
              c:identifier="tp_proxy_get_invalidated"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

invalidated. The caller must copy the error, for instance with
g_error_copy(), if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the reason this proxy was invalidated, or %NULL if has not been</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </return-value>
      </method>
      <method name="get_object_path"
              c:identifier="tp_proxy_get_object_path"
              version="0.7.17">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

string with g_strdup() if it will be kept.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the object path of the remote object. The caller must copy the</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="has_interface"
              c:identifier="tp_proxy_has_interface"
              version="0.7.1">
        <doc xml:whitespace="preserve">Return whether this proxy is known to have a particular interface. In
versions older than 0.11.11, this was a macro wrapper around
tp_proxy_has_interface_by_id().

For objects that discover their interfaces at runtime, this method will
indicate that interfaces are missing until they are known to be present.
In subclasses that define features for use with tp_proxy_prepare_async(),
successfully preparing the "core" feature for that subclass (such as
%TP_CHANNEL_FEATURE_CORE or %TP_CONNECTION_FEATURE_CORE) implies that the
interfaces are known.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the D-Bus interface required, as a string</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_interface_by_id"
              c:identifier="tp_proxy_has_interface_by_id"
              version="0.7.1">
        <doc xml:whitespace="preserve">Return whether this proxy is known to have a particular interface, by its
quark ID. This is equivalent to using g_quark_to_string() followed by
tp_proxy_has_interface(), but more efficient.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if this proxy implements the given interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">quark representing the D-Bus interface required</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_prepared"
              c:identifier="tp_proxy_is_prepared"
              version="0.11.3">
        <doc xml:whitespace="preserve">Return %TRUE if @feature has been prepared successfully, or %FALSE if
@feature has not been requested, has not been prepared yet, or is not
available on this object at all.

(For instance, if @feature is %TP_CHANNEL_FEATURE_CHAT_STATES and @self
is a #TpChannel in a protocol that doesn't actually implement chat states,
or is not a #TpChannel at all, then this method will return %FALSE.)

To prepare features, call tp_proxy_prepare_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @feature has been prepared successfully</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">a feature that is supported by @self's class</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_async"
              c:identifier="tp_proxy_prepare_async"
              version="0.11.3">
        <doc xml:whitespace="preserve">#TpProxy itself does not support any features, but subclasses like
#TpChannel can support features, which can either be core functionality like
%TP_CHANNEL_FEATURE_CORE, or extended functionality like
%TP_CHANNEL_FEATURE_CHAT_STATES.

Proxy instances start with no features prepared. When features are
requested via tp_proxy_prepare_async(), the proxy starts to do the
necessary setup to use those features.

tp_proxy_prepare_async() always waits for core functionality of the proxy's
class to be prepared, even if it is not specifically requested: for
instance, because %TP_CHANNEL_FEATURE_CORE is core functionality of a
#TpChannel,

|[
TpChannel *channel = ...;

tp_proxy_prepare_async (channel, NULL, callback, user_data);
]|

is equivalent to

|[
TpChannel *channel = ...;
GQuark features[] = { TP_CHANNEL_FEATURE_CORE, 0 };

tp_proxy_prepare_async (channel, features, callback, user_data);
]|

If a feature represents core functionality (like %TP_CHANNEL_FEATURE_CORE),
failure to prepare it will result in tp_proxy_prepare_async() finishing
unsuccessfully: if failure to prepare the feature indicates that the proxy
is no longer useful, it will also emit #TpProxy::invalidated.

If a feature represents non-essential functionality
(like %TP_CHANNEL_FEATURE_CHAT_STATES), or is not supported by the object
at all, then failure to prepare it is not fatal:
tp_proxy_prepare_async() will complete successfully, but
tp_proxy_is_prepared() will still return %FALSE for the feature, and
accessor methods for the feature will typically return a dummy value.

Some #TpProxy subclasses automatically start to prepare their core
features when instantiated, and features will sometimes become prepared as
a side-effect of other actions, but to ensure that a feature is present you
must generally call tp_proxy_prepare_async() and wait for the result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">if not %NULL, called exactly once, when the features have all been prepared or failed to prepare, or after the proxy is invalidated</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data for @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare_finish"
              c:identifier="tp_proxy_prepare_finish"
              version="0.11.3"
              throws="1">
        <doc xml:whitespace="preserve">Check for error in a call to tp_proxy_prepare_async(). An error here
generally indicates that either the asynchronous call was cancelled,
or @self has emitted #TpProxy::invalidated.

or was cancelled</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE (setting @error) if tp_proxy_prepare_async() failed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result passed to the callback of tp_proxy_prepare_async()</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="bus-name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus bus name for this object. Read-only except during construction.</doc>
        <type name="utf8"/>
      </property>
      <property name="dbus-connection"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus connection for this object. Read-only except during
construction.</doc>
        <type/>
      </property>
      <property name="dbus-daemon"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus daemon for this object (this object itself, if it is a
TpDBusDaemon). Read-only except during construction.</doc>
        <type name="DBusDaemon"/>
      </property>
      <property name="factory"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpSimpleClientFactory used to create this proxy,
or %NULL if this proxy was not created through a factory.</doc>
        <type name="SimpleClientFactory"/>
      </property>
      <property name="interfaces" transfer-ownership="none">
        <doc xml:whitespace="preserve">Known D-Bus interface names for this object.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="object-path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus object path for this object. Read-only except during
construction.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="dbus_daemon" readable="0" private="1">
        <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
      </field>
      <field name="dbus_connection"
             introspectable="0"
             readable="0"
             private="1">
        <type c:type="DBusGConnection*"/>
      </field>
      <field name="bus_name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="object_path" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="invalidated" readable="0" private="1">
        <type name="GLib.Error" c:type="GError*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyPrivate" c:type="TpProxyPrivate*"/>
      </field>
      <glib:signal name="interface-added"
                   when="last"
                   detailed="1"
                   introspectable="0">
        <doc xml:whitespace="preserve">Emitted when this proxy has gained an interface. It is not guaranteed
to be emitted immediately, but will be emitted before the interface is
first used (at the latest: before it's returned from
tp_proxy_borrow_interface_by_id(), any signal is connected, or any
method is called).

The intended use is to call dbus_g_proxy_add_signals(). This signal
should only be used by TpProy implementations</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GQuark representing the interface</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="proxy" transfer-ownership="none">
            <doc xml:whitespace="preserve">the dbus-glib proxy representing the interface</doc>
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidated" when="last" detailed="1">
        <doc xml:whitespace="preserve">Emitted when this proxy has been become invalid for
whatever reason. Any more specific signal should be emitted first.

An invalidated proxy is one which can make no more method calls and will
emit no more D-Bus signals. This is typically because the D-Bus object
represented by the proxy ceased to exist, or there was some error
obtaining the initial state.

Any pending or future method calls made on this proxy will fail gracefully
with the same error as returned by tp_proxy_get_invalidated().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">domain of a GError indicating why this proxy was invalidated</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">error code of a GError indicating why this proxy was invalidated</doc>
            <type name="gint"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a message associated with the error</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ProxyClass"
            c:type="TpProxyClass"
            glib:is-gtype-struct-for="Proxy"
            version="0.7.1">
      <doc xml:whitespace="preserve">The class of a #TpProxy. The struct fields not documented here are reserved.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="interface">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="must_have_unique_name" bits="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="_reserved_flags" readable="0" bits="31" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_internal_list_features" readable="0" private="1">
        <type name="GObject.Callback" c:type="GCallback"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="3">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="ProxyFeature" c:type="TpProxyFeature" version="0.11.3">
      <doc xml:whitespace="preserve">Structure representing a feature.</doc>
      <field name="name" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <field name="core" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="prepare_async" writable="1">
        <type name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync"/>
      </field>
      <field name="prepare_before_signalling_connected_async" writable="1">
        <type name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync"/>
      </field>
      <field name="interfaces_needed" writable="1">
        <type name="GLib.Quark" c:type="GQuark*"/>
      </field>
      <field name="depends_on" writable="1">
        <type name="GLib.Quark" c:type="GQuark*"/>
      </field>
      <field name="can_retry" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="4">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyFeaturePrivate" c:type="TpProxyFeaturePrivate*"/>
      </field>
    </record>
    <record name="ProxyFeaturePrivate"
            c:type="TpProxyFeaturePrivate"
            disguised="1">
    </record>
    <record name="ProxyPendingCall" c:type="TpProxyPendingCall" disguised="1">
      <method name="cancel" c:identifier="tp_proxy_pending_call_cancel">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="ProxyPrepareAsync" c:type="TpProxyPrepareAsync">
      <doc xml:whitespace="preserve">Function called when @feature has to be prepared for @proxy.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="proxy" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object on which @feature has to be prepared</doc>
          <type name="Proxy" c:type="TpProxy*"/>
        </parameter>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GQuark representing the feature to prepare</doc>
          <type name="ProxyFeature" c:type="TpProxyFeature*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:whitespace="preserve">called when the feature has been prepared, or the preparation failed</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">data to pass to @callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ProxyPrivate" c:type="TpProxyPrivate" disguised="1">
    </record>
    <record name="ProxySignalConnection"
            c:type="TpProxySignalConnection"
            disguised="1">
      <method name="disconnect"
              c:identifier="tp_proxy_signal_connection_disconnect">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <enumeration name="RichPresenceAccessControlType"
                 c:type="TpRichPresenceAccessControlType">
      <member name="whitelist"
              value="0"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_WHITELIST"/>
      <member name="publish_list"
              value="1"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_PUBLISH_LIST"/>
      <member name="group"
              value="2"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_GROUP"/>
      <member name="open"
              value="3"
              c:identifier="TP_RICH_PRESENCE_ACCESS_CONTROL_TYPE_OPEN"/>
    </enumeration>
    <enumeration name="SASLAbortReason" c:type="TpSASLAbortReason">
      <member name="invalid_challenge"
              value="0"
              c:identifier="TP_SASL_ABORT_REASON_INVALID_CHALLENGE"/>
      <member name="user_abort"
              value="1"
              c:identifier="TP_SASL_ABORT_REASON_USER_ABORT"/>
    </enumeration>
    <enumeration name="SASLStatus" c:type="TpSASLStatus">
      <member name="not_started"
              value="0"
              c:identifier="TP_SASL_STATUS_NOT_STARTED"/>
      <member name="in_progress"
              value="1"
              c:identifier="TP_SASL_STATUS_IN_PROGRESS"/>
      <member name="server_succeeded"
              value="2"
              c:identifier="TP_SASL_STATUS_SERVER_SUCCEEDED"/>
      <member name="client_accepted"
              value="3"
              c:identifier="TP_SASL_STATUS_CLIENT_ACCEPTED"/>
      <member name="succeeded"
              value="4"
              c:identifier="TP_SASL_STATUS_SUCCEEDED"/>
      <member name="server_failed"
              value="5"
              c:identifier="TP_SASL_STATUS_SERVER_FAILED"/>
      <member name="client_failed"
              value="6"
              c:identifier="TP_SASL_STATUS_CLIENT_FAILED"/>
    </enumeration>
    <enumeration name="ServicePointType" c:type="TpServicePointType">
      <member name="none" value="0" c:identifier="TP_SERVICE_POINT_TYPE_NONE"/>
      <member name="emergency"
              value="1"
              c:identifier="TP_SERVICE_POINT_TYPE_EMERGENCY"/>
      <member name="counseling"
              value="2"
              c:identifier="TP_SERVICE_POINT_TYPE_COUNSELING"/>
    </enumeration>
    <class name="SignalledMessage"
           c:symbol-prefix="signalled_message"
           c:type="TpSignalledMessage"
           version="0.13.9"
           parent="Message"
           glib:type-name="TpSignalledMessage"
           glib:get-type="tp_signalled_message_get_type"
           glib:type-struct="SignalledMessageClass">
      <doc xml:whitespace="preserve">Opaque structure representing a received message using the Telepathy
messages interface</doc>
      <function name="get_sender"
                c:identifier="tp_signalled_message_get_sender"
                version="0.13.9">
        <doc xml:whitespace="preserve">Returns a #TpContact representing the sender of @message if known, %NULL
otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the sender of the message</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
        </parameters>
      </function>
      <property name="sender"
                version="0.13.9"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpContact representing the sender of the message, if known, or %NULL
otherwise.</doc>
        <type name="Contact"/>
      </property>
    </class>
    <record name="SignalledMessageClass"
            c:type="TpSignalledMessageClass"
            disguised="1"
            glib:is-gtype-struct-for="SignalledMessage">
    </record>
    <class name="SimpleApprover"
           c:symbol-prefix="simple_approver"
           c:type="TpSimpleApprover"
           version="0.11.5"
           parent="BaseClient"
           glib:type-name="TpSimpleApprover"
           glib:get-type="tp_simple_approver_get_type"
           glib:type-struct="SimpleApproverClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Approver implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_approver_new"
                   version="0.11.5"
                   deprecated="New code should use tp_simple_approver_new_with_am() instead.">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_approver_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_approver_new_with_am"
                   version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_approver_new_with_factory"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleApprover instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleApprover</doc>
          <type name="SimpleApprover" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">an #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Approver (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <doc xml:whitespace="preserve">the function called when AddDispatchOperation is called</doc>
            <type name="SimpleApproverAddDispatchOperationImpl"
                  c:type="TpSimpleApproverAddDispatchOperationImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleApprover is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpSimpleApproverAddDispatchOperationImpl callback implementing the
AddDispatchOperation D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free #TpSimpleApprover:user-data
when the #TpSimpleApprover is destroyed.</doc>
        <type name="gpointer"/>
      </property>
      <property name="user-data"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to #TpSimpleApprover:callback.</doc>
        <type name="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleApproverPrivate" c:type="TpSimpleApproverPrivate*"/>
      </field>
    </class>
    <callback name="SimpleApproverAddDispatchOperationImpl"
              c:type="TpSimpleApproverAddDispatchOperationImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the AddDispatchOperation method.

This function must call either tp_add_dispatch_operation_context_accept(),
tp_add_dispatch_operation_context_delay() or
tp_add_dispatch_operation_context_fail() on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="approver" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleApprover instance</doc>
          <type name="SimpleApprover" c:type="TpSimpleApprover*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAddDispatchOperationContext representing the context of this D-Bus call</doc>
          <type name="AddDispatchOperationContext"
                c:type="TpAddDispatchOperationContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="6">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_approver_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleApproverClass"
            c:type="TpSimpleApproverClass"
            glib:is-gtype-struct-for="SimpleApprover"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpSimpleApprover.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="SimpleApproverPrivate"
            c:type="TpSimpleApproverPrivate"
            disguised="1">
    </record>
    <class name="SimpleClientFactory"
           c:symbol-prefix="simple_client_factory"
           c:type="TpSimpleClientFactory"
           version="0.15.5"
           parent="GObject.Object"
           glib:type-name="TpSimpleClientFactory"
           glib:get-type="tp_simple_client_factory_get_type"
           glib:type-struct="SimpleClientFactoryClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpSimpleClientFactory</doc>
      <constructor name="new"
                   c:identifier="tp_simple_client_factory_new"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Creates a new #TpSimpleClientFactory instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleClientFactory</doc>
          <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="create_account" introspectable="0" throws="1">
        <return-value>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_channel" introspectable="0" throws="1">
        <return-value>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_connection" introspectable="0" throws="1">
        <return-value>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_contact" introspectable="0">
        <return-value>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_account_features"
                      invoker="dup_account_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpAccount features that
should be prepared on @account.

#GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_channel_features"
                      invoker="dup_channel_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpChannel features that
should be prepared on @channel.

#GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_connection_features"
                      invoker="dup_connection_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpConnection features that
should be prepared on @connection.

#GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="dup_contact_features"
                      invoker="dup_contact_features"
                      version="0.15.5">
        <doc xml:whitespace="preserve">Return a #GArray containing the #TpContactFeature that should be prepared on
all contacts of @connection.

allocated #GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ContactFeature"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_account_features"
              c:identifier="tp_simple_client_factory_add_account_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpAccount
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_account_features().

It is not necessary to add %TP_ACCOUNT_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpAccount
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_account_features_varargs"
              c:identifier="tp_simple_client_factory_add_account_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_account_features(), but with a more
convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features"
              c:identifier="tp_simple_client_factory_add_channel_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpChannel
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_channel_features().

It is not necessary to add %TP_CHANNEL_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpChannel
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_channel_features_varargs"
              c:identifier="tp_simple_client_factory_add_channel_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_channel_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features"
              c:identifier="tp_simple_client_factory_add_connection_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpConnection
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_connection_features().

It is not necessary to add %TP_CONNECTION_FEATURE_CORE as it is already
included by default.

Note that these features will not be added to existing #TpConnection
objects; the user must call tp_proxy_prepare_async() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features, ending with 0; %NULL is equivalent to an array containing only 0</doc>
            <array c:type="GQuark*">
              <type name="GLib.Quark" c:type="GQuark"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_connection_features_varargs"
              c:identifier="tp_simple_client_factory_add_connection_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_connection_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_contact_features"
              c:identifier="tp_simple_client_factory_add_contact_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Add @features to the desired features to be prepared on #TpContact
objects. Those features will be added to the features already returned be
tp_simple_client_factory_dup_contact_features().

Note that these features will not be added to existing #TpContact
objects; the user must call tp_connection_upgrade_contacts() themself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_features" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of features in @features (may be 0)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="features" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an array of desired features (may be %NULL if @n_features is 0)</doc>
            <array length="0" zero-terminated="0" c:type="TpContactFeature*">
              <type name="ContactFeature" c:type="TpContactFeature"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="add_contact_features_varargs"
              c:identifier="tp_simple_client_factory_add_contact_features_varargs"
              version="0.15.5"
              introspectable="0">
        <doc xml:whitespace="preserve">The same as tp_simple_client_factory_add_contact_features(), but with a
more convenient calling convention from C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first feature</doc>
            <type name="ContactFeature" c:type="TpContactFeature"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="dup_account_features"
              c:identifier="tp_simple_client_factory_dup_account_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpAccount features that
should be prepared on @account.

#GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="account" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpAccount</doc>
            <type name="Account" c:type="TpAccount*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_channel_features"
              c:identifier="tp_simple_client_factory_dup_channel_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpChannel features that
should be prepared on @channel.

#GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="channel" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannel</doc>
            <type name="Channel" c:type="TpChannel*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_connection_features"
              c:identifier="tp_simple_client_factory_dup_connection_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a zero-terminated #GArray containing the #TpConnection features that
should be prepared on @connection.

#GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="GLib.Quark"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_contact_features"
              c:identifier="tp_simple_client_factory_dup_contact_features"
              version="0.15.5">
        <doc xml:whitespace="preserve">Return a #GArray containing the #TpContactFeature that should be prepared on
all contacts of @connection.

allocated #GArray</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="ContactFeature"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_account"
              c:identifier="tp_simple_client_factory_ensure_account"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Returns a #TpAccount proxy for the account at @object_path. The returned
#TpAccount is cached; the same #TpAccount object will be returned by this
function repeatedly, as long as at least one reference exists.

Note that the returned #TpAccount is not guaranteed to be ready; the caller
is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_account_features()).

see tp_account_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpAccount;</doc>
          <type name="Account" c:type="TpAccount*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of an account</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the account, or %NULL.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_channel"
              c:identifier="tp_simple_client_factory_ensure_channel"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Returns a #TpChannel proxy for the channel at @object_path on @connection.
The returned #TpChannel is cached; the same #TpChannel object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpChannel is not guaranteed to be ready; the
caller is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_channel_features()).

see tp_channel_new_from_properties().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpChannel;</doc>
          <type name="Channel" c:type="TpChannel*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of a channel on @connection</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the channel</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_connection"
              c:identifier="tp_simple_client_factory_ensure_connection"
              version="0.15.5"
              throws="1">
        <doc xml:whitespace="preserve">Returns a #TpConnection proxy for the connection at @object_path.
The returned #TpConnection is cached; the same #TpConnection object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpConnection is not guaranteed to be ready; the
caller is responsible for calling tp_proxy_prepare_async() with the desired
features (as given by tp_simple_client_factory_dup_connection_features()).

see tp_connection_new().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpConnection;</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </return-value>
        <parameters>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of a connection</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the connection.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_contact"
              c:identifier="tp_simple_client_factory_ensure_contact"
              version="0.15.5">
        <doc xml:whitespace="preserve">Returns a #TpContact representing @identifier (and @handle) on @connection.
The returned #TpContact is cached; the same #TpContact object
will be returned by this function repeatedly, as long as at least one
reference exists.

Note that the returned #TpContact is not guaranteed to be ready; the caller
is responsible for calling tp_connection_upgrade_contacts() with the desired
features (as given by tp_simple_client_factory_dup_contact_features()).

For this function to work properly, tp_connection_has_immortal_handles()
must return %TRUE for @connection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a #TpContact.</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
        <parameters>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="handle" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpHandle</doc>
            <type name="Handle" c:type="TpHandle"/>
          </parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string representing the contact's identifier</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dbus_daemon"
              c:identifier="tp_simple_client_factory_get_dbus_daemon"
              version="0.15.5">
        <doc xml:whitespace="preserve">&lt;!-- --&gt;

property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of the #TpSimpleClientFactory:dbus-daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </return-value>
      </method>
      <property name="dbus-daemon"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The D-Bus daemon for this object.</doc>
        <type name="DBusDaemon"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleClientFactoryPrivate"
              c:type="TpSimpleClientFactoryPrivate*"/>
      </field>
    </class>
    <record name="SimpleClientFactoryClass"
            c:type="TpSimpleClientFactoryClass"
            glib:is-gtype-struct-for="SimpleClientFactory"
            version="0.15.5">
      <doc xml:whitespace="preserve">The class structure for #TpSimpleClientFactory.

#TpSimpleClientFactory maintains a cache of previously-constructed proxy
objects, so the implementations of @create_account,
@create_connection, @create_channel, and @create_contact may assume that a
new object should be created when they are called. The default
implementations create unadorned instances of the relevant classes;
subclasses of the factory may choose to create more interesting proxy
subclasses.

The default implementation of @dup_channel_features returns
#TP_CHANNEL_FEATURE_CORE, plus all features passed to
tp_simple_client_factory_add_channel_features() by the application.
Subclasses may override this method to prepare more interesting features
from subclasses of #TpChannel, for instance. The default implementations of
the other &lt;function&gt;dup_x_features&lt;/function&gt; methods behave similarly.</doc>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="create_account" introspectable="0">
        <callback name="create_account" introspectable="0" throws="1">
          <return-value>
            <type name="Account" c:type="TpAccount*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_account_features">
        <callback name="dup_account_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="account" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpAccount</doc>
              <type name="Account" c:type="TpAccount*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_connection" introspectable="0">
        <callback name="create_connection" introspectable="0" throws="1">
          <return-value>
            <type name="Connection" c:type="TpConnection*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_connection_features">
        <callback name="dup_connection_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpConnection</doc>
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_channel" introspectable="0">
        <callback name="create_channel" introspectable="0" throws="1">
          <return-value>
            <type name="Channel" c:type="TpChannel*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="conn" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="object_path" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
            <parameter name="immutable_properties" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_channel_features">
        <callback name="dup_channel_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly allocated</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="GLib.Quark"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="channel" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpChannel</doc>
              <type name="Channel" c:type="TpChannel*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_contact" introspectable="0">
        <callback name="create_contact" introspectable="0">
          <return-value>
            <type name="Contact" c:type="TpContact*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
            <parameter name="handle" transfer-ownership="none">
              <type name="Handle" c:type="TpHandle"/>
            </parameter>
            <parameter name="identifier" transfer-ownership="none">
              <type name="utf8" c:type="gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="dup_contact_features">
        <callback name="dup_contact_features">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a newly</doc>
            <array name="GLib.Array" c:type="GArray*">
              <type name="ContactFeature"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="SimpleClientFactory"
                    c:type="TpSimpleClientFactory*"/>
            </parameter>
            <parameter name="connection" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #TpConnection</doc>
              <type name="Connection" c:type="TpConnection*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="20">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="SimpleClientFactoryPrivate"
            c:type="TpSimpleClientFactoryPrivate"
            disguised="1">
    </record>
    <class name="SimpleHandler"
           c:symbol-prefix="simple_handler"
           c:type="TpSimpleHandler"
           version="0.11.6"
           parent="BaseClient"
           glib:type-name="TpSimpleHandler"
           glib:get-type="tp_simple_handler_get_type"
           glib:type-struct="SimpleHandlerClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Handler implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_handler_new"
                   version="0.11.6"
                   deprecated="New code should use tp_simple_handler_new_with_am() instead.">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_handler_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether this handler should implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_handler_new_with_am"
                   version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether this handler should implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_handler_new_with_factory"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleHandler instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleHandler</doc>
          <type name="SimpleHandler" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="bypass_approval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Handler.BypassApproval D-Bus property (see tp_base_client_set_handler_bypass_approval() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="requests" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether this handler should implement Requests (see tp_base_client_set_handler_request_notification() for details)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Handler (see #TpBaseClient:name for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">the function called when HandleChannels is called</doc>
            <type name="SimpleHandlerHandleChannelsImpl"
                  c:type="TpSimpleHandlerHandleChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data as its argument when the #TpSimpleHandler is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="bypass-approval"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The value of the Handler.BypassApproval D-Bus property.</doc>
        <type name="gboolean"/>
      </property>
      <property name="callback"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpSimpleHandlerHandleChannelsImpl callback implementing the
HandleChannels D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free #TpSimpleHandler:user-data
when the #TpSimpleHandler is destroyed.</doc>
        <type name="gpointer"/>
      </property>
      <property name="requests"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">If %TRUE, the Handler will implement the Requests interface</doc>
        <type name="gboolean"/>
      </property>
      <property name="user-data"
                version="0.11.6"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to #TpSimpleHandler:callback.</doc>
        <type name="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleHandlerPrivate" c:type="TpSimpleHandlerPrivate*"/>
      </field>
    </class>
    <record name="SimpleHandlerClass"
            c:type="TpSimpleHandlerClass"
            glib:is-gtype-struct-for="SimpleHandler"
            version="0.11.6">
      <doc xml:whitespace="preserve">The class of a #TpSimpleHandler.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleHandlerHandleChannelsImpl"
              c:type="TpSimpleHandlerHandleChannelsImpl"
              version="0.11.6">
      <doc xml:whitespace="preserve">Signature of the implementation of the HandleChannels method.

This function must call either tp_handle_channels_context_accept(),
tp_handle_channels_context_delay() or tp_handle_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handler" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleHandler instance</doc>
          <type name="SimpleHandler" c:type="TpSimpleHandler*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="requests_satisfied" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="user_action_time" transfer-ownership="none">
          <doc xml:whitespace="preserve">the time at which user action occurred, or one of the special values %TP_USER_ACTION_TIME_NOT_USER_ACTION or %TP_USER_ACTION_TIME_CURRENT_TIME (see #TpAccountChannelRequest:user-action-time for details)</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpHandleChannelsContext representing the context of this D-Bus call</doc>
          <type name="HandleChannelsContext"
                c:type="TpHandleChannelsContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_handler_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleHandlerPrivate"
            c:type="TpSimpleHandlerPrivate"
            disguised="1">
    </record>
    <class name="SimpleObserver"
           c:symbol-prefix="simple_observer"
           c:type="TpSimpleObserver"
           version="0.11.5"
           parent="BaseClient"
           glib:type-name="TpSimpleObserver"
           glib:get-type="tp_simple_observer_get_type"
           glib:type-struct="SimpleObserverClass">
      <doc xml:whitespace="preserve">Data structure representing a simple Observer implementation.</doc>
      <constructor name="new"
                   c:identifier="tp_simple_observer_new"
                   version="0.11.5"
                   deprecated="New code should use tp_simple_observer_new_with_am() instead.">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance.

If @dbus is not the result of tp_dbus_daemon_dup(), you should call
tp_simple_observer_new_with_am() instead, so that #TpAccount,
#TpConnection and #TpContact instances can be shared between modules.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="dbus" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpDBusDaemon object, may not be %NULL</doc>
            <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_am"
                   c:identifier="tp_simple_observer_new_with_am"
                   version="0.11.14">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance with a
specified #TpAccountManager.

It is not necessary to prepare any features on @account_manager before
calling this function.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="account_manager" transfer-ownership="none">
            <doc xml:whitespace="preserve">an account manager, which may not be %NULL</doc>
            <type name="AccountManager" c:type="TpAccountManager*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_factory"
                   c:identifier="tp_simple_observer_new_with_factory"
                   version="0.15.5">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpSimpleObserver instance with a
specified #TpSimpleClientFactory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #TpSimpleObserver</doc>
          <type name="SimpleObserver" c:type="TpBaseClient*"/>
        </return-value>
        <parameters>
          <parameter name="factory" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSimpleClientFactory, which may not be %NULL</doc>
            <type name="SimpleClientFactory" c:type="TpSimpleClientFactory*"/>
          </parameter>
          <parameter name="recover" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the Observer.Recover D-Bus property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the Observer (see #TpBaseClient:name: for details)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="uniquify" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the #TpBaseClient:uniquify-name: property</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="5"
                     destroy="6">
            <doc xml:whitespace="preserve">the function called when ObserveChannels is called</doc>
            <type name="SimpleObserverObserveChannelsImpl"
                  c:type="TpSimpleObserverObserveChannelsImpl"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">arbitrary user-supplied data passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with the user_data as argument, when the #TpSimpleObserver is destroyed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="callback"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The TpSimpleObserverObserveChannelsImpl callback implementing the
ObserveChannels D-Bus method.

This property can't be %NULL.</doc>
        <type name="gpointer"/>
      </property>
      <property name="destroy"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GDestroyNotify function called to free the user-data pointer when
the #TpSimpleObserver is destroyed.</doc>
        <type name="gpointer"/>
      </property>
      <property name="recover"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The value of the Observer.Recover D-Bus property.</doc>
        <type name="gboolean"/>
      </property>
      <property name="user-data"
                version="0.11.5"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The user-data pointer passed to the callback implementing the
ObserveChannels D-Bus method.</doc>
        <type name="gpointer"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="BaseClient" c:type="TpBaseClient"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SimpleObserverPrivate" c:type="TpSimpleObserverPrivate*"/>
      </field>
    </class>
    <record name="SimpleObserverClass"
            c:type="TpSimpleObserverClass"
            glib:is-gtype-struct-for="SimpleObserver"
            version="0.11.5">
      <doc xml:whitespace="preserve">The class of a #TpSimpleObserver.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="BaseClientClass" c:type="TpBaseClientClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <callback name="SimpleObserverObserveChannelsImpl"
              c:type="TpSimpleObserverObserveChannelsImpl"
              version="0.11.5">
      <doc xml:whitespace="preserve">Signature of the implementation of the ObserveChannels method.

This function must call either tp_observe_channels_context_accept(),
tp_observe_channels_context_delay() or tp_observe_channels_context_fail()
on @context before it returns.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="observer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpSimpleObserver instance</doc>
          <type name="SimpleObserver" c:type="TpSimpleObserver*"/>
        </parameter>
        <parameter name="account" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpAccount having %TP_ACCOUNT_FEATURE_CORE prepared if possible</doc>
          <type name="Account" c:type="TpAccount*"/>
        </parameter>
        <parameter name="connection" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpConnection having %TP_CONNECTION_FEATURE_CORE prepared if possible</doc>
          <type name="Connection" c:type="TpConnection*"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannel, all having %TP_CHANNEL_FEATURE_CORE prepared if possible</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Channel"/>
          </type>
        </parameter>
        <parameter name="dispatch_operation"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">a #TpChannelDispatchOperation or %NULL; the dispatch_operation is not guaranteed to be prepared</doc>
          <type name="ChannelDispatchOperation"
                c:type="TpChannelDispatchOperation*"/>
        </parameter>
        <parameter name="requests" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpChannelRequest, all having their object-path defined but are not guaranteed to be prepared.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ChannelRequest"/>
          </type>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #TpObserveChannelsContext representing the context of this D-Bus call</doc>
          <type name="ObserveChannelsContext"
                c:type="TpObserveChannelsContext*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">arbitrary user-supplied data passed to tp_simple_observer_new()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="SimpleObserverPrivate"
            c:type="TpSimpleObserverPrivate"
            disguised="1">
    </record>
    <enumeration name="SocketAccessControl" c:type="TpSocketAccessControl">
      <member name="localhost"
              value="0"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_LOCALHOST"/>
      <member name="port"
              value="1"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_PORT"/>
      <member name="netmask"
              value="2"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_NETMASK"/>
      <member name="credentials"
              value="3"
              c:identifier="TP_SOCKET_ACCESS_CONTROL_CREDENTIALS"/>
    </enumeration>
    <enumeration name="SocketAddressType" c:type="TpSocketAddressType">
      <member name="unix"
              value="0"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_UNIX"/>
      <member name="abstract_unix"
              value="1"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_ABSTRACT_UNIX"/>
      <member name="ipv4"
              value="2"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV4"/>
      <member name="ipv6"
              value="3"
              c:identifier="TP_SOCKET_ADDRESS_TYPE_IPV6"/>
    </enumeration>
    <bitfield name="StorageRestrictionFlags"
              c:type="TpStorageRestrictionFlags">
      <member name="parameters"
              value="1"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PARAMETERS"/>
      <member name="enabled"
              value="2"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_ENABLED"/>
      <member name="presence"
              value="4"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_PRESENCE"/>
      <member name="service"
              value="8"
              c:identifier="TP_STORAGE_RESTRICTION_FLAG_CANNOT_SET_SERVICE"/>
    </bitfield>
    <class name="StreamTubeChannel"
           c:symbol-prefix="stream_tube_channel"
           c:type="TpStreamTubeChannel"
           version="0.13.2"
           parent="Channel"
           glib:type-name="TpStreamTubeChannel"
           glib:get-type="tp_stream_tube_channel_get_type"
           glib:type-struct="StreamTubeChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpStreamTubeChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_stream_tube_channel_new"
                   version="0.13.2"
                   throws="1">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpStreamTubeChannel</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpStreamTubeChannel</doc>
          <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <method name="accept_async"
              c:identifier="tp_stream_tube_channel_accept_async"
              version="0.13.2">
        <doc xml:whitespace="preserve">Accept an incoming stream tube. When the tube has been accepted, @callback
will be called. You can then call tp_stream_tube_channel_accept_finish()
to get a #TpStreamTubeConnection connected to the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the tube has been accepted</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="accept_finish"
              c:identifier="tp_stream_tube_channel_accept_finish"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to accept an incoming stream tube. The returned
#TpStreamTubeConnection can then be used to exchange data through the tube.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpStreamTubeConnection</doc>
          <type name="StreamTubeConnection" c:type="TpStreamTubeConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parameters"
              c:identifier="tp_stream_tube_channel_get_parameters"
              version="0.13.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeChannel:parameters property

the value of #TpStreamTubeChannel:parameters</doc>
        <return-value transfer-ownership="none">
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </return-value>
      </method>
      <method name="get_service"
              c:identifier="tp_stream_tube_channel_get_service"
              version="0.13.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeChannel:service property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeChannel:service</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="offer_async"
              c:identifier="tp_stream_tube_channel_offer_async"
              version="0.13.2">
        <doc xml:whitespace="preserve">Offer an outgoing stream tube. When the tube has been offered, @callback
will be called. You can then call tp_stream_tube_channel_offer_finish()
to get the result of the operation.

You have to connect to the #TpStreamTubeChannel::incoming signal to get a
#TpStreamTubeConnection each time a contact establishes a connection to
the tube.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters of the tube, or %NULL</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the tube has been offered</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="offer_finish"
              c:identifier="tp_stream_tube_channel_offer_finish"
              version="0.13.2"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to offer an outgoing stream tube.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE when a Tube has been successfully offered; %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="parameters"
                version="0.13.2"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A string to #GValue #GHashTable representing the parameters of the tube.

Will be %NULL for outgoing tubes until the tube has been offered.</doc>
        <type/>
      </property>
      <property name="service" version="0.13.2" transfer-ownership="none">
        <doc xml:whitespace="preserve">A string representing the service name that will be used over the tube.</doc>
        <type name="utf8"/>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="StreamTubeChannelPrivate"
              c:type="TpStreamTubeChannelPrivate*"/>
      </field>
      <glib:signal name="incoming" when="last">
        <doc xml:whitespace="preserve">The ::incoming signal is emitted on offered Tubes when a new incoming
connection is made from a remote user (one accepting the Tube).

Consumers of this signal must take their own references to
@tube_connection</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="tube_connection" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpStreamTubeConnection for the connection</doc>
            <type name="StreamTubeConnection"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamTubeChannelClass"
            c:type="TpStreamTubeChannelClass"
            glib:is-gtype-struct-for="StreamTubeChannel"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpStreamTubeChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="StreamTubeChannelPrivate"
            c:type="TpStreamTubeChannelPrivate"
            disguised="1">
    </record>
    <class name="StreamTubeConnection"
           c:symbol-prefix="stream_tube_connection"
           c:type="TpStreamTubeConnection"
           version="0.13.2"
           parent="GObject.Object"
           glib:type-name="TpStreamTubeConnection"
           glib:get-type="tp_stream_tube_connection_get_type"
           glib:type-struct="StreamTubeConnectionClass">
      <doc xml:whitespace="preserve">Data structure representing a connection on a #TpStreamTubeChannel.</doc>
      <method name="get_channel"
              c:identifier="tp_stream_tube_connection_get_channel"
              version="0.13.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeConnection:channel property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeConnection:channel</doc>
          <type name="StreamTubeChannel" c:type="TpStreamTubeChannel*"/>
        </return-value>
      </method>
      <method name="get_contact"
              c:identifier="tp_stream_tube_connection_get_contact"
              version="0.13.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeConnection:contact property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeConnection:contact</doc>
          <type name="Contact" c:type="TpContact*"/>
        </return-value>
      </method>
      <method name="get_socket_connection"
              c:identifier="tp_stream_tube_connection_get_socket_connection"
              version="0.13.2"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpStreamTubeConnection:socket-connection property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpStreamTubeConnection:socket-connection</doc>
          <type name="Gio.SocketConnection" c:type="GSocketConnection*"/>
        </return-value>
      </method>
      <property name="channel"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpStreamTubeChannel channel associated with this connection

This property can't be %NULL.</doc>
        <type name="StreamTubeChannel"/>
      </property>
      <property name="contact"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #TpContact with who we are exchanging data through this tube, or
%NULL if we can't safely identify the contact.

If not %NULL, the #TpContact objects is guaranteed to have all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <type name="Contact"/>
      </property>
      <property name="socket-connection"
                version="0.13.2"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GSocketConnection used to transfer data through this connection.
Read-only except during construction.

This property can't be %NULL.</doc>
        <type name="Gio.SocketConnection"/>
      </property>
      <glib:signal name="closed" when="last" version="0.13.2">
        <doc xml:whitespace="preserve">The ::closed signal is emitted when the connection manager reports that
a tube connection has been closed.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GError representing the error reported by the connection manager</doc>
            <type name="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamTubeConnectionClass"
            c:type="TpStreamTubeConnectionClass"
            disguised="1"
            glib:is-gtype-struct-for="StreamTubeConnection"
            version="0.13.2">
      <doc xml:whitespace="preserve">The class of a #TpStreamTubeConnection.</doc>
    </record>
    <record name="StreamTubeConnectionPrivate"
            c:type="TpStreamTubeConnectionPrivate"
            disguised="1">
    </record>
    <enumeration name="SubscriptionState" c:type="TpSubscriptionState">
      <member name="unknown"
              value="0"
              c:identifier="TP_SUBSCRIPTION_STATE_UNKNOWN"/>
      <member name="no" value="1" c:identifier="TP_SUBSCRIPTION_STATE_NO"/>
      <member name="removed_remotely"
              value="2"
              c:identifier="TP_SUBSCRIPTION_STATE_REMOVED_REMOTELY"/>
      <member name="ask" value="3" c:identifier="TP_SUBSCRIPTION_STATE_ASK"/>
      <member name="yes" value="4" c:identifier="TP_SUBSCRIPTION_STATE_YES"/>
    </enumeration>
    <enumeration name="TLSCertificateRejectReason"
                 c:type="TpTLSCertificateRejectReason">
      <member name="unknown"
              value="0"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_UNKNOWN"/>
      <member name="untrusted"
              value="1"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_UNTRUSTED"/>
      <member name="expired"
              value="2"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_EXPIRED"/>
      <member name="not_activated"
              value="3"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_NOT_ACTIVATED"/>
      <member name="fingerprint_mismatch"
              value="4"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_FINGERPRINT_MISMATCH"/>
      <member name="hostname_mismatch"
              value="5"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_HOSTNAME_MISMATCH"/>
      <member name="self_signed"
              value="6"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_SELF_SIGNED"/>
      <member name="revoked"
              value="7"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_REVOKED"/>
      <member name="insecure"
              value="8"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_INSECURE"/>
      <member name="limit_exceeded"
              value="9"
              c:identifier="TP_TLS_CERTIFICATE_REJECT_REASON_LIMIT_EXCEEDED"/>
    </enumeration>
    <enumeration name="TLSCertificateState" c:type="TpTLSCertificateState">
      <member name="pending"
              value="0"
              c:identifier="TP_TLS_CERTIFICATE_STATE_PENDING"/>
      <member name="accepted"
              value="1"
              c:identifier="TP_TLS_CERTIFICATE_STATE_ACCEPTED"/>
      <member name="rejected"
              value="2"
              c:identifier="TP_TLS_CERTIFICATE_STATE_REJECTED"/>
    </enumeration>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/gtalk-p2p"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/ice-udp"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-2009"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5"
              value="org.freedesktop.Telepathy.Channel.Interface.MediaSignalling/wlm-8.5"
              c:type="TP_TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_CONTACT_ID"
              value="org.freedesktop.Telepathy.Connection/contact-id"
              c:type="TP_TOKEN_CONNECTION_CONTACT_ID">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS"
              value="org.freedesktop.Telepathy.Connection.Interface.Aliasing/alias"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN"
              value="org.freedesktop.Telepathy.Connection.Interface.Avatars/token"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS"
              value="org.freedesktop.Telepathy.Connection.Interface.Capabilities/caps"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES"
              value="org.freedesktop.Telepathy.Connection.Interface.ClientTypes/client-types"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactBlocking/blocked"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactCapabilities/capabilities"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactGroups/groups"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactInfo/info"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/publish"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/publish-request"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE"
              value="org.freedesktop.Telepathy.Connection.Interface.ContactList/subscribe"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION"
              value="org.freedesktop.Telepathy.Connection.Interface.Location/location"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE"
              value="org.freedesktop.Telepathy.Connection.Interface.SimplePresence/presence"
              c:type="TP_TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="TextChannel"
           c:symbol-prefix="text_channel"
           c:type="TpTextChannel"
           version="0.13.10"
           parent="Channel"
           glib:type-name="TpTextChannel"
           glib:get-type="tp_text_channel_get_type"
           glib:type-struct="TextChannelClass">
      <doc xml:whitespace="preserve">Data structure representing a #TpTextChannel.</doc>
      <constructor name="new"
                   c:identifier="tp_text_channel_new"
                   version="0.13.10"
                   throws="1">
        <doc xml:whitespace="preserve">Convenient function to create a new #TpTextChannel</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #TpTextChannel</doc>
          <type name="TextChannel" c:type="TpTextChannel*"/>
        </return-value>
        <parameters>
          <parameter name="conn" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpConnection; may not be %NULL</doc>
            <type name="Connection" c:type="TpConnection*"/>
          </parameter>
          <parameter name="object_path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object path of the channel; may not be %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="immutable_properties" transfer-ownership="none">
            <doc xml:whitespace="preserve"> the immutable properties of the channel, as signalled by the NewChannel D-Bus signal or returned by the CreateChannel and EnsureChannel D-Bus methods: a mapping from strings (D-Bus interface name + "." + property name) to #GValue instances</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_feature_quark_incoming_messages"
                c:identifier="tp_text_channel_get_feature_quark_incoming_messages">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_feature_quark_sms"
                c:identifier="tp_text_channel_get_feature_quark_sms">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <method name="ack_all_pending_messages_async"
              c:identifier="tp_text_channel_ack_all_pending_messages_async"
              version="0.15.3">
        <doc xml:whitespace="preserve">Acknowledge all the pending messages. This is equivalent of calling
tp_text_channel_ack_messages_async() with the list of #TpSignalledMessage
returned by tp_text_channel_get_pending_messages().

Once the messages have been acked, @callback will be called.
You can then call tp_text_channel_ack_all_pending_messages_finish() to get
the result of the operation.

See tp_text_channel_ack_message_async() about acknowledging messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">a callback to call when the messages have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_all_pending_messages_finish"
              c:identifier="tp_text_channel_ack_all_pending_messages_finish"
              version="0.15.3"
              throws="1">
        <doc xml:whitespace="preserve">Finish an asynchronous acknowledgement operation of all messages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the messages have been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_message_async"
              c:identifier="tp_text_channel_ack_message_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Acknowledge @message. Once the message has been acked, @callback will be
called. You can then call tp_text_channel_ack_message_finish() to get the
result of the operation.

A message should be acknowledged once it has been shown to the user by the
Handler of the channel. So Observers and Approvers should NOT acknowledge
messages themselves.
Once a message has been acknowledged, it is removed from the
pending-message queue and so the #TpTextChannel::pending-message-removed
signal is fired.

You should use the #TpSignalledMessage received from
tp_text_channel_get_pending_messages() or the
#TpTextChannel::message-received signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the message have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_message_finish"
              c:identifier="tp_text_channel_ack_message_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to ack a message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message has been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_messages_async"
              c:identifier="tp_text_channel_ack_messages_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Acknowledge all the messages in @messages.
Once the messages have been acked, @callback will be called.
You can then call tp_text_channel_ack_messages_finish() to get the
result of the operation.

You should use the #TpSignalledMessage received from
tp_text_channel_get_pending_messages() or the
#TpTextChannel::message-received signal.

See tp_text_channel_ack_message_async() about acknowledging messages.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #TpSignalledMessage</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="SignalledMessage"/>
            </type>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the message have been acked</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ack_messages_finish"
              c:identifier="tp_text_channel_ack_messages_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to ack a list of messages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the messages have been acked, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_delivery_reporting_support"
              c:identifier="tp_text_channel_get_delivery_reporting_support"
              version="0.13.10"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:delivery-reporting-support property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:delivery-reporting-support property</doc>
          <type name="DeliveryReportingSupportFlags"
                c:type="TpDeliveryReportingSupportFlags"/>
        </return-value>
      </method>
      <method name="get_message_part_support_flags"
              c:identifier="tp_text_channel_get_message_part_support_flags"
              version="0.13.10"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:message-part-support-flags property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:message-part-support-flags</doc>
          <type name="MessagePartSupportFlags"
                c:type="TpMessagePartSupportFlags"/>
        </return-value>
      </method>
      <method name="get_message_types"
              c:identifier="tp_text_channel_get_message_types"
              version="0.13.16"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:message-types property

the value of #TpTextChannel:message-types</doc>
        <return-value transfer-ownership="none">
          <array name="GLib.Array" c:type="GArray*">
            <type name="ChannelTextMessageType"/>
          </array>
        </return-value>
      </method>
      <method name="get_pending_messages"
              c:identifier="tp_text_channel_get_pending_messages"
              version="0.13.10">
        <doc xml:whitespace="preserve">Return a newly allocated list of unacknowledged #TpSignalledMessage
objects.

It is guaranteed that the #TpSignalledMessage:sender of each
#TpSignalledMessage has all of the features previously passed to
tp_simple_client_factory_add_contact_features() prepared.

a #GList of borrowed #TpSignalledMessage</doc>
        <return-value transfer-ownership="container">
          <type name="GLib.List" c:type="GList*">
            <type name="SignalledMessage"/>
          </type>
        </return-value>
      </method>
      <method name="get_sms_flash"
              c:identifier="tp_text_channel_get_sms_flash"
              version="0.15.1">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:sms-flash property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:sms-flash property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_sms_length_async"
              c:identifier="tp_text_channel_get_sms_length_async"
              version="0.15.1">
        <doc xml:whitespace="preserve">Starts an async call to get the number of 140 octet chunks required to
send a #message via SMS on #self, as well as the number of remaining
characters available in the final chunk and, if possible,
an estimate of the cost.

Once the request has been satisfied, @callback will be called.
You can then call tp_text_channel_get_sms_length_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpClientMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the request has been satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sms_length_finish"
              c:identifier="tp_text_channel_get_sms_length_finish"
              version="0.15.1"
              throws="1">
        <doc xml:whitespace="preserve">Finishes an async SMS length request.

the message has been retrieved, %FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the number of 140 octet chunks required to send</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="chunks_required"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL used to return the number of 140 octet chunks required to send the message.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="remaining_characters"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL used to return the number of further characters that can be fit in the final chunk. A negative value indicates that the message will be truncated by abs(@remaining_characters). The value #G_MININT32 indicates the message will be truncated by an unknown amount.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="estimated_cost"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL used to return the estimated cost of sending this message. The currency and scale of this value are the same as the values of the #TpConnection:balance-scale and #TpConnection:balance-currency properties. A value of -1 indicates the cost could not be estimated.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_supported_content_types"
              c:identifier="tp_text_channel_get_supported_content_types"
              version="0.13.10"
              introspectable="0">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:supported-content-types property

the value of #TpTextChannel:supported-content-types</doc>
        <return-value transfer-ownership="none">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="is_sms_channel"
              c:identifier="tp_text_channel_is_sms_channel"
              version="0.15.1">
        <doc xml:whitespace="preserve">Return the #TpTextChannel:is-sms-channel property</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value of #TpTextChannel:is-sms-channel property</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="send_message_async"
              c:identifier="tp_text_channel_send_message_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Submit a message to the server for sending. Once the message has been
submitted to the sever, @callback will be called. You can then call
tp_text_channel_send_message_finish() to get the result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpClientMessage</doc>
            <type name="Message" c:type="TpMessage*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags affecting how the message is sent</doc>
            <type name="MessageSendingFlags" c:type="TpMessageSendingFlags"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:whitespace="preserve">a callback to call when the message has been submitted to the server</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_message_finish"
              c:identifier="tp_text_channel_send_message_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to send a message.

@token can be used to match any incoming delivery or failure reports
against the sent message. If the returned token is %NULL the
message is not readily identifiable.

otherwise.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message has been submitted to the server, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="token"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if not %NULL, used to return the token of the sent message</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chat_state_async"
              c:identifier="tp_text_channel_set_chat_state_async"
              version="0.13.10">
        <doc xml:whitespace="preserve">Set the local state on channel @self to @state.
Once the state has been set, @callback will be called.
You can then call tp_text_channel_set_chat_state_finish() to get the
result of the operation.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannelChatState to set</doc>
            <type name="ChannelChatState" c:type="TpChannelChatState"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:whitespace="preserve">a callback to call when the chat state has been set</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chat_state_finish"
              c:identifier="tp_text_channel_set_chat_state_finish"
              version="0.13.10"
              throws="1">
        <doc xml:whitespace="preserve">Finishes to set chat state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the chat state has been changed, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GAsyncResult</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_message_type"
              c:identifier="tp_text_channel_supports_message_type"
              version="0.13.16">
        <doc xml:whitespace="preserve">Check if message of type @message_type can be sent on this channel.

otherwise</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if message of type @message_type can be sent on @self, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpChannelTextMessageType</doc>
            <type name="ChannelTextMessageType"
                  c:type="TpChannelTextMessageType"/>
          </parameter>
        </parameters>
      </method>
      <property name="delivery-reporting-support"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpDeliveryReportingSupportFlags indicating features supported
by this channel.</doc>
        <type name="guint"/>
      </property>
      <property name="is-sms-channel"
                version="0.15.1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if messages sent and received on this channel are transmitted
via SMS.

This property is not guaranteed to have a meaningful value until
TP_TEXT_CHANNEL_FEATURE_SMS has been prepared.</doc>
        <type name="gboolean"/>
      </property>
      <property name="message-part-support-flags"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #TpMessagePartSupportFlags indicating the level of support for
message parts on this channel.</doc>
        <type name="guint"/>
      </property>
      <property name="message-types"
                version="0.13.16"
                introspectable="0"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GArray containing the #TpChannelTextMessageType which may be sent on
this channel.</doc>
        <type/>
      </property>
      <property name="sms-flash" version="0.15.1" transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if this channel is exclusively for receiving class 0 SMSes
(and no SMSes can be sent using tp_text_channel_send_message_async()
on this channel). If %FALSE, no incoming class 0 SMSes will appear
on this channel.</doc>
        <type name="gboolean"/>
      </property>
      <property name="supported-content-types"
                version="0.13.10"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">A #GStrv containing the MIME types supported by this channel, with more
preferred MIME types appearing earlier in the array.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent" readable="0" private="1">
        <type name="Channel" c:type="TpChannel"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TextChannelPrivate" c:type="TpTextChannelPrivate*"/>
      </field>
      <glib:signal name="message-received" when="last" version="0.13.10">
        <doc xml:whitespace="preserve">The ::message-received signal is emitted when a new message has been
received on @self.

The same @message object will be used by the
#TpTextChannel::pending-message-removed signal once @message has been
acked so you can simply compare pointers to identify the message.

Note that this signal is only fired once the
#TP_TEXT_CHANNEL_FEATURE_INCOMING_MESSAGES has been prepared.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="message-sent" when="last" version="0.13.10">
        <doc xml:whitespace="preserve">The ::message-sent signal is emitted when @message
has been submitted for sending.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #TpMessageSendingFlags affecting how the message was sent</doc>
            <type name="guint"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">an opaque token used to match any incoming delivery or failure reports against this message, or %NULL if the message is not readily identifiable.</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="pending-message-removed"
                   when="last"
                   version="0.13.10">
        <doc xml:whitespace="preserve">The ::pending-message-removed signal is emitted when @message
has been acked and so removed from the pending messages list.

Note that this signal is only fired once the
#TP_TEXT_CHANNEL_FEATURE_INCOMING_MESSAGES has been prepared.

It is guaranteed that @message's #TpSignalledMessage:sender has all of the
features previously passed to
tp_simple_client_factory_add_contact_features() prepared.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #TpSignalledMessage</doc>
            <type name="SignalledMessage"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TextChannelClass"
            c:type="TpTextChannelClass"
            glib:is-gtype-struct-for="TextChannel"
            version="0.13.10">
      <doc xml:whitespace="preserve">The class of a #TpTextChannel.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="ChannelClass" c:type="TpChannelClass"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="GCallback" fixed-size="7">
          <type name="GObject.Callback" c:type="GCallback"/>
        </array>
      </field>
    </record>
    <record name="TextChannelPrivate"
            c:type="TpTextChannelPrivate"
            disguised="1">
    </record>
    <enumeration name="TubeChannelState" c:type="TpTubeChannelState">
      <member name="local_pending"
              value="0"
              c:identifier="TP_TUBE_CHANNEL_STATE_LOCAL_PENDING"/>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_TUBE_CHANNEL_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_CHANNEL_STATE_OPEN"/>
      <member name="not_offered"
              value="3"
              c:identifier="TP_TUBE_CHANNEL_STATE_NOT_OFFERED"/>
    </enumeration>
    <enumeration name="TubeState" c:type="TpTubeState">
      <member name="local_pending"
              value="0"
              c:identifier="TP_TUBE_STATE_LOCAL_PENDING"/>
      <member name="remote_pending"
              value="1"
              c:identifier="TP_TUBE_STATE_REMOTE_PENDING"/>
      <member name="open" value="2" c:identifier="TP_TUBE_STATE_OPEN"/>
    </enumeration>
    <enumeration name="TubeType" c:type="TpTubeType">
      <member name="dbus" value="0" c:identifier="TP_TUBE_TYPE_DBUS"/>
      <member name="stream" value="1" c:identifier="TP_TUBE_TYPE_STREAM"/>
    </enumeration>
    <constant name="UNKNOWN_CONNECTION_STATUS"
              value="-1"
              c:type="TP_UNKNOWN_CONNECTION_STATUS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="UNKNOWN_HANDLE_TYPE"
              value="-1"
              c:type="TP_UNKNOWN_HANDLE_TYPE">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="_DBusPropertiesMixinClass"
            c:type="_TpDBusPropertiesMixinClass">
      <field name="interfaces" writable="1">
        <type name="DBusPropertiesMixinIfaceImpl"
              c:type="TpDBusPropertiesMixinIfaceImpl*"/>
      </field>
      <field name="_1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="_7" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <function name="asv_dump" c:identifier="tp_asv_dump" introspectable="0">
      <doc xml:whitespace="preserve">Dumps the a{sv} map to the debugging console.

The purpose of this function is give the programmer the ability to easily
inspect the contents of an a{sv} map for debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boolean"
              c:identifier="tp_asv_get_boolean"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and boolean, return it,
and set *@valid to %TRUE if @valid is not %NULL.

Otherwise return %FALSE, and set *@valid to %FALSE if @valid is not %NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a boolean value for @key</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location to store %TRUE if the key actually exists and has a boolean value</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_boxed"
              c:identifier="tp_asv_get_boxed"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is of the desired type,
return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it, for instance with
g_boxed_copy(), if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value of @key, or %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type that the key's value should have, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_bytes"
              c:identifier="tp_asv_get_bytes"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an array of bytes
(its GType is %DBUS_TYPE_G_UCHAR_ARRAY), return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with
g_boxed_copy (DBUS_TYPE_G_UCHAR_ARRAY, ...) if you need to keep
it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string value of @key, or %NULL</doc>
        <array name="GLib.Array" c:type="GArray*">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_double"
              c:identifier="tp_asv_get_double"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and has any numeric type used by
dbus-glib (guchar, gint, guint, gint64, guint64 or gdouble),
return it as a double, and if @valid is not %NULL, set *@valid to %TRUE.

Otherwise, return 0.0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the double precision floating-point value of @key, or 0.0</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int32"
              c:identifier="tp_asv_get_int32"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 32-bit signed integer value of @key, or 0</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_int64"
              c:identifier="tp_asv_get_int64"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a gint64, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 64-bit signed integer value of @key, or 0</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_object_path"
              c:identifier="tp_asv_get_object_path"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an object path, return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.

%NULL</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the object-path value of @key, or</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_string"
              c:identifier="tp_asv_get_string"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is a string, return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdup() if you
need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string value of @key, or %NULL</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_strv"
              c:identifier="tp_asv_get_strv"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present and is an array of strings (strv),
return it.

Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with g_strdupv() if you
need to keep it for longer.

value of @key, or %NULL</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the %NULL-terminated string-array</doc>
        <array c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint32"
              c:identifier="tp_asv_get_uint32"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and fits in the
range of a guint32, return it, and if @valid is not %NULL, set *@valid to
%TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 32-bit unsigned integer value of @key, or 0</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_get_uint64"
              c:identifier="tp_asv_get_uint64"
              version="0.7.9">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, has an integer type used by
dbus-glib (guchar, gint, guint, gint64 or guint64) and is non-negative,
return it, and if @valid is not %NULL, set *@valid to %TRUE.

Otherwise, return 0, and if @valid is not %NULL, set *@valid to %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the 64-bit unsigned integer value of @key, or 0</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="valid"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Either %NULL, or a location in which to store %TRUE on success or %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_lookup"
              c:identifier="tp_asv_lookup"
              version="0.7.9"
              introspectable="0">
      <doc xml:whitespace="preserve">If a value for @key in @asv is present, return it. Otherwise return %NULL.

The returned value is not copied, and is only valid as long as the value
for @key in @asv is not removed or altered. Copy it with (for instance)
g_value_copy() if you need to keep it for longer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the value of @key, or %NULL</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GHashTable where the keys are strings and the values are GValues</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">The key to look up</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_new"
              c:identifier="tp_asv_new"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Creates a new #GHashTable for use with a{sv} maps, containing the values
passed in as parameters.

The #GHashTable is synonymous with:
&lt;informalexample&gt;&lt;programlisting&gt;
GHashTable *asv = g_hash_table_new_full (g_str_hash, g_str_equal,
NULL, (GDestroyNotify) tp_g_value_slice_free);
&lt;/programlisting&gt;&lt;/informalexample&gt;
Followed by manual insertion of each of the parameters.

Parameters are stored in slice-allocated GValues and should be set using
tp_asv_set_*() and retrieved using tp_asv_get_*().

tp_g_value_slice_new() and tp_g_value_slice_dup() may also be used to insert
into the map if required.
&lt;informalexample&gt;&lt;programlisting&gt;
g_hash_table_insert (parameters, "account",
tp_g_value_slice_new_string ("bob@mcbadgers.com"));
&lt;/programlisting&gt;&lt;/informalexample&gt;

&lt;example&gt;
&lt;title&gt;Using tp_asv_new()&lt;/title&gt;
&lt;programlisting&gt;
GHashTable *parameters = tp_asv_new (
"answer", G_TYPE_INT, 42,
"question", G_TYPE_STRING, "We just don't know",
NULL);&lt;/programlisting&gt;
&lt;/example&gt;

Allocated values will be automatically free'd when overwritten, removed or
the hash table destroyed with g_hash_table_unref().

g_hash_table_unref().</doc>
      <return-value>
        <doc xml:whitespace="preserve">a newly created #GHashTable for storing a{sv} maps, free with</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="first_key" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first key (or NULL)</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boolean"
              c:identifier="tp_asv_set_boolean"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boolean(), tp_g_value_slice_new_boolean()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_boxed"
              c:identifier="tp_asv_set_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(), tp_g_value_slice_new_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_bytes"
              c:identifier="tp_asv_set_bytes"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_bytes(), tp_g_value_slice_new_bytes()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of bytes to copy</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:whitespace="preserve">location of an array of bytes to be copied (this may be %NULL if and only if length is 0)</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_double"
              c:identifier="tp_asv_set_double"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_double(), tp_g_value_slice_new_double()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int32"
              c:identifier="tp_asv_set_int32"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_int32(), tp_g_value_slice_new_int()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gint32" c:type="gint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_int64"
              c:identifier="tp_asv_set_int64"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_int64(), tp_g_value_slice_new_int64()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_object_path"
              c:identifier="tp_asv_set_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_boxed"
              c:identifier="tp_asv_set_static_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(),
tp_g_value_slice_new_static_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_object_path"
              c:identifier="tp_asv_set_static_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_static_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_static_string"
              c:identifier="tp_asv_set_static_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(),
tp_g_value_slice_new_static_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_string"
              c:identifier="tp_asv_set_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(), tp_g_value_slice_new_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_strv"
              c:identifier="tp_asv_set_strv"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_strv()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a %NULL-terminated string array</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint32"
              c:identifier="tp_asv_set_uint32"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_uint32(), tp_g_value_slice_new_uint()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_set_uint64"
              c:identifier="tp_asv_set_uint64"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_uint64(), tp_g_value_slice_new_uint64()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_boxed"
              c:identifier="tp_asv_take_boxed"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_boxed(), tp_g_value_slice_new_take_boxed()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the key's value, which must be derived from %G_TYPE_BOXED</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_bytes"
              c:identifier="tp_asv_take_bytes"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_bytes(), tp_g_value_slice_new_take_bytes()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a non-NULL #GArray of %guchar, ownership of which will be taken by the #GValue</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_object_path"
              c:identifier="tp_asv_take_object_path"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_object_path(),
tp_g_value_slice_new_take_object_path()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="asv_take_string"
              c:identifier="tp_asv_take_string"
              version="0.7.29"
              introspectable="0">
      <doc xml:whitespace="preserve">Stores the value in the map.

The value is stored as a slice-allocated GValue.

See Also: tp_asv_new(), tp_asv_get_string(),
tp_g_value_slice_new_take_string()</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="asv" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GHashTable created with tp_asv_new()</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="key" transfer-ownership="none">
          <doc xml:whitespace="preserve">string key</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">value</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_list_copy"
              c:identifier="tp_contact_info_list_copy"
              moved-to="ContactInfoList.copy"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

tp_contact_info_list_free()</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoField, free it with</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_list_free"
              c:identifier="tp_contact_info_list_free"
              moved-to="ContactInfoList.free"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoField</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_spec_list_copy"
              c:identifier="tp_contact_info_spec_list_copy"
              moved-to="ContactInfoSpecList.copy"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

free it with tp_contact_info_spec_list_free()</doc>
      <return-value>
        <doc xml:whitespace="preserve">a new #GList of newly allocated #TpContactInfoFieldSpec,</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contact_info_spec_list_free"
              c:identifier="tp_contact_info_spec_list_free"
              moved-to="ContactInfoSpecList.free"
              version="0.11.7"
              introspectable="0">
      <doc xml:whitespace="preserve">Free all memory used by the #GList and its elements.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GList of #TpContactInfoFieldSpec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_add_contact_attributes_iface"
              c:identifier="tp_contacts_mixin_add_contact_attributes_iface"
              moved-to="ContactsMixin.add_contact_attributes_iface"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Declare that the given interface has contact attributes which can be added
to the attributes hash using the filler function. All the handles in the
handle array passed to the filler function are guaranteed to be valid and
referenced.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Name of the interface that has ContactAttributes</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="fill_contact_attributes" transfer-ownership="none">
          <doc xml:whitespace="preserve">Contact attribute filler function</doc>
          <type name="ContactsMixinFillContactAttributesFunc"
                c:type="TpContactsMixinFillContactAttributesFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_class_get_offset_quark"
              c:identifier="tp_contacts_mixin_class_get_offset_quark"
              moved-to="ContactsMixinClass.get_offset_quark"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_class_init"
              c:identifier="tp_contacts_mixin_class_init"
              moved-to="ContactsMixinClass.init"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_class_init ((GObjectClass *) klass,
G_STRUCT_OFFSET (SomeObjectClass, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpContactsMixinClass within the class structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_finalize"
              c:identifier="tp_contacts_mixin_finalize"
              moved-to="ContactsMixin.finalize"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Free resources held by the contacts mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_get_contact_attributes"
              c:identifier="tp_contacts_mixin_get_contact_attributes"
              moved-to="ContactsMixin.get_contact_attributes"
              introspectable="0">
      <doc xml:whitespace="preserve">Get contact attributes for the given contacts. Provide attributes for all requested
interfaces. If contact attributes are not immediately known, the behaviour is defined
by the interface; the attribute should either be omitted from the result or replaced
with a default value.</doc>
      <return-value>
        <doc xml:whitespace="preserve">A dictionary mapping the contact handles to contact attributes.</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection instance that uses this mixin. The connection must be connected.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">List of handles to retrieve contacts for. Any invalid handles will be dropped from the returned mapping.</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="interfaces" transfer-ownership="none">
          <doc xml:whitespace="preserve">A list of interfaces to retrieve attributes from.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="assumed_interfaces" transfer-ownership="none">
          <doc xml:whitespace="preserve">A list of additional interfaces to retrieve attributes from. This can be used for interfaces documented as automatically included, like %TP_IFACE_CONNECTION for GetContactAttributes, or %TP_IFACE_CONNECTION and %TP_IFACE_CONNECTION_INTERFACE_CONTACT_LIST for GetContactListAttributes.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
        <parameter name="sender" transfer-ownership="none">
          <doc xml:whitespace="preserve">The DBus client's unique name. If this is not NULL, the requested handles will be held on behalf of this client.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_get_offset_quark"
              c:identifier="tp_contacts_mixin_get_offset_quark"
              moved-to="ContactsMixin.get_offset_quark"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="contacts_mixin_iface_init"
              c:identifier="tp_contacts_mixin_iface_init"
              moved-to="ContactsMixin.iface_init"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the contacts interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceContacts in an object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_init"
              c:identifier="tp_contacts_mixin_init"
              moved-to="ContactsMixin.init"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the contacts mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_contacts_mixin_init ((GObject *) self,
G_STRUCT_OFFSET (SomeObject, contacts_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpContactsMixin within the object structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="contacts_mixin_set_contact_attribute"
              c:identifier="tp_contacts_mixin_set_contact_attribute"
              moved-to="ContactsMixin.set_contact_attribute"
              version="0.7.14"
              introspectable="0">
      <doc xml:whitespace="preserve">Utility function to set attribute for handle to value in the attributes hash
as passed to a TpContactsMixinFillContactAttributesFunc.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="contact_attributes" transfer-ownership="none">
          <doc xml:whitespace="preserve">contacts attribute hash as passed to TpContactsMixinFillContactAttributesFunc</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">Handle to set the attribute on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:whitespace="preserve">attribute name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">slice allocated GValue containing the value of the attribute, for instance with tp_g_value_slice_new. Ownership of the GValue is taken over by the mixin</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_bus_name"
              c:identifier="tp_dbus_check_valid_bus_name"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus bus name of an appropriate
type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible bus name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="allow_types" transfer-ownership="none">
          <doc xml:whitespace="preserve">some combination of %TP_DBUS_NAME_TYPE_UNIQUE, %TP_DBUS_NAME_TYPE_WELL_KNOWN or %TP_DBUS_NAME_TYPE_BUS_DAEMON (often this will be %TP_DBUS_NAME_TYPE_NOT_BUS_DAEMON or %TP_DBUS_NAME_TYPE_ANY)</doc>
          <type name="DBusNameType" c:type="TpDBusNameType"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_interface_name"
              c:identifier="tp_dbus_check_valid_interface_name"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus interface name. This is
also appropriate to use to check for valid error names.

Since GIO 2.26, g_dbus_is_interface_name() should always return the same
thing, although the GLib function does not raise an error explaining why
the interface name is incorrect.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible interface name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_member_name"
              c:identifier="tp_dbus_check_valid_member_name"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus member (method or signal) name.

Since GIO 2.26, g_dbus_is_member_name() should always return the same
thing, although the GLib function does not raise an error explaining why
the interface name is incorrect.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @name is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible member name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_check_valid_object_path"
              c:identifier="tp_dbus_check_valid_object_path"
              version="0.7.1"
              throws="1">
      <doc xml:whitespace="preserve">Check that the given string is a valid D-Bus object path. Since GLib 2.24,
g_variant_is_object_path() should always return the same thing as this
function, although it doesn't provide an error explaining why the object
path is invalid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @path is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:whitespace="preserve">a possible object path</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_errors_quark" c:identifier="tp_dbus_errors_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="dbus_g_method_return_not_implemented"
              c:identifier="tp_dbus_g_method_return_not_implemented"
              introspectable="0">
      <doc xml:whitespace="preserve">Return the Telepathy error NotImplemented from the method invocation
given by @context.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">The D-Bus method invocation context</doc>
          <type c:type="DBusGMethodInvocation*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_class_init"
              c:identifier="tp_dbus_properties_mixin_class_init"
              version="0.7.3">
      <doc xml:whitespace="preserve">Initialize the class @cls to use the D-Bus Properties mixin.
The given struct member, of size sizeof(TpDBusPropertiesMixinClass),
will be used to store property implementation information.

Each property and each interface must have been declared as a member of
a GInterface implemented by @cls, using
tp_svc_interface_set_dbus_properties_info().

Before calling this function, the array @interfaces must have been
placed in the #TpDBusPropertiesMixinClass structure; if it would be empty,
it may instead be %NULL.

This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.

Changed in 0.7.9: TpDBusPropertiesMixinClass::interfaces may now be %NULL,
which means that only interfaces whose properties are set up using
tp_dbus_properties_mixin_implement_interface() will be used.

Changed in 0.7.15: @offset may now be 0, in which case the
#TpDBusPropertiesMixinClass can be omitted from @cls.  It is treated as if
it were present, but with all fields (including
TpDBusPropertiesMixinClass::interfaces) being %NULL, so only interfaces
whose properties are set using
tp_dbus_properties_mixin_implement_interface() will be used.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset within @cls of a TpDBusPropertiesMixinClass structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_emit_properties_changed"
              c:identifier="tp_dbus_properties_mixin_emit_properties_changed"
              version="0.15.6">
      <doc xml:whitespace="preserve">Emits the PropertiesChanged signal for the provided properties. Depending on
the EmitsChangedSignal annotations in the introspection XML, either the new
value of the property will be included in the signal, or merely the fact
that the property has changed.

For example, the MPRIS specification defines a TrackList interface with two
properties, one of which is annotated with EmitsChangedSignal=true and one
annotated with EmitsChangedSignal=invalidates. The following call would
include the new value of CanEditTracks and list Tracks as invalidated:

|[
const gchar *properties[] = { "CanEditTracks", "Tracks", NULL };

tp_dbus_properties_mixin_emit_properties_changed (G_OBJECT (self),
"org.mpris.MediaPlayer2.TrackList", properties);
]|

It is an error to pass a property to this
function if the property is annotated with EmitsChangedSignal=false, or is
unannotated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface on which properties have changed</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="properties" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a %NULL-terminated array of (unqualified) property names whose values have changed.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_emit_properties_changed_varargs"
              c:identifier="tp_dbus_properties_mixin_emit_properties_changed_varargs"
              version="0.15.6"
              introspectable="0">
      <doc xml:whitespace="preserve">A shortcut for calling tp_dbus_properties_mixin_emit_properties_changed().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface on which properties have changed</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_fill_properties_hash"
              c:identifier="tp_dbus_properties_mixin_fill_properties_hash"
              version="0.11.11"
              introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the values of several D-Bus properties from an object, and adds
them to a hash mapping the fully-qualified name of the property to its
value. This is equivalent to calling tp_dbus_properties_mixin_get() for
each property and adding it to the table yourself, with the proviso that
this function will g_assert() if retrieving a property fails (for instance,
because it does not exist).

Note that in particular, @table does not have the same memory-allocation
model as the hash tables required by tp_asv_set_string() and similar
functions.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="table" transfer-ownership="none">
          <doc xml:whitespace="preserve">a hash table where the keys are strings copied with g_strdup() and the values are slice-allocated #GValue&lt;!-- --&gt;s</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="GObject.Value"/>
          </type>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_get"
              c:identifier="tp_dbus_properties_mixin_get"
              version="0.7.13"
              throws="1">
      <doc xml:whitespace="preserve">Initialize @value with the type of the property @property_name on
@interface_name, and write the value of that property into it as if
by calling the D-Bus method org.freedesktop.DBus.Properties.Get.

If Get would return a D-Bus error, @value remains unset and @error
is filled in instead.

on failure</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE (filling @value) on success, %FALSE (setting @error)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus property name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">an unset GValue (initialized to all zeroes)</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_getter_gobject_properties"
              c:identifier="tp_dbus_properties_mixin_getter_gobject_properties">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that
the @getter_data is the name of a readable #GObject property of an
appropriate type, and uses it for the value of the D-Bus property.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="getter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The getter_data from the #TpDBusPropertiesMixinPropImpl, which must be a string containing the GObject property's name</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_iface_init"
              c:identifier="tp_dbus_properties_mixin_iface_init">
      <doc xml:whitespace="preserve">Declare that the DBus.Properties interface represented by @g_iface
is implemented using this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #TpSvcDBusPropertiesClass structure</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_implement_interface"
              c:identifier="tp_dbus_properties_mixin_implement_interface"
              introspectable="0">
      <doc xml:whitespace="preserve">Declare that, in addition to any interfaces set in
tp_dbus_properties_mixin_class_init(), the given class (and its subclasses)
will implement the properties of the interface @iface using the callbacks
@getter and @setter and the properties given by @props.

This function should be called from the class_init callback in such a way
that it will only be called once, even if the class is subclassed.

Typically, the static array @interfaces in the #TpDBusPropertiesMixinClass
should be used for interfaces whose properties are implemented directly by
the class @cls, and this function should be used for interfaces whose
properties are implemented by mixins.

It is an error for the same interface to appear in the array @interfaces
in the #TpDBusPropertiesMixinClass, and also be set up by this function.

If a class C and a subclass S both implement the properties of the same
interface, only the implementations from the subclass S will be used,
regardless of whether the implementations in C and/or S were set up by
this function or via the array @interfaces in the
#TpDBusPropertiesMixinClass.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">a subclass of #GObjectClass</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">a quark representing the the name of the interface to implement</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="getter" transfer-ownership="none">
          <doc xml:whitespace="preserve">a callback to get properties on this interface, or %NULL if they are all write-only</doc>
          <type name="DBusPropertiesMixinGetter"
                c:type="TpDBusPropertiesMixinGetter"/>
        </parameter>
        <parameter name="setter" transfer-ownership="none">
          <doc xml:whitespace="preserve">a callback to set properties on this interface, or %NULL if they are all read-only</doc>
          <type name="DBusPropertiesMixinSetter"
                c:type="TpDBusPropertiesMixinSetter"/>
        </parameter>
        <parameter name="props" transfer-ownership="none">
          <doc xml:whitespace="preserve">an array of #TpDBusPropertiesMixinPropImpl representing individual properties, terminated by one with @name == %NULL</doc>
          <type name="DBusPropertiesMixinPropImpl"
                c:type="TpDBusPropertiesMixinPropImpl*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_make_properties_hash"
              c:identifier="tp_dbus_properties_mixin_make_properties_hash"
              introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the values of several D-Bus properties from an object, and builds
a hash mapping the fully-qualified name of the property to its value.  This
is equivalent to calling tp_dbus_properties_mixin_get() for each property
and building the table yourself, with the proviso that this function will
g_assert() if retrieving a property fails (for instance, because it does not
exist).

Additional keys and values can be inserted into the returned hash table;
if this is done, the inserted keys and values will be freed when the
hash table is destroyed. The keys must be allocated with g_strdup() or
equivalent, and the values must be slice-allocated (for instance with
tp_g_value_slice_new_string() or a similar function).

Note that in particular, tp_asv_set_string() and similar functions should
not be used with this hash table.

GValues, which must be freed by the caller (at which point its
contents will also be freed).</doc>
      <return-value>
        <doc xml:whitespace="preserve">a hash table mapping (gchar *) fully-qualified property names to</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object which uses the D-Bus properties mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="first_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">the interface of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="first_property" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the first property to be retrieved</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_set"
              c:identifier="tp_dbus_properties_mixin_set"
              version="0.15.8"
              throws="1">
      <doc xml:whitespace="preserve">Sets a property to the value specified by @value, as if by
calling the D-Bus method org.freedesktop.DBus.Properties.Set.

If Set would return a D-Bus error, sets @error and returns %FALSE</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success; %FALSE (setting @error) on failure</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">an object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus interface name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="property_name" transfer-ownership="none">
          <doc xml:whitespace="preserve">a D-Bus property name</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue containing the new value for this property.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="dbus_properties_mixin_setter_gobject_properties"
              c:identifier="tp_dbus_properties_mixin_setter_gobject_properties"
              throws="1">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinSetter which assumes that the
@setter_data is the name of a writable #GObject property of an appropriate
type, and sets that property to the given value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">The exported object with the properties</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus interface name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new value for the property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="setter_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">The setter_data from the #TpDBusPropertiesMixinPropImpl, which must be a string containing the GObject property's name</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_divert_messages"
              c:identifier="tp_debug_divert_messages"
              version="0.7.1">
      <doc xml:whitespace="preserve">Open the given file for writing and duplicate its file descriptor to
be used for stdout and stderr. This has the effect of closing the previous
stdout and stderr, and sending all messages that would have gone there
to the given file instead.

By default the file is truncated and hence overwritten each time the
process is executed.
Since version 0.7.14, if the filename is prefixed with '+' then the
file is not truncated and output is added at the end of the file.

Passing %NULL to this function is guaranteed to have no effect. This is
so you can call it with the recommended usage
&lt;literal&gt;tp_debug_divert_messages (g_getenv ("MYAPP_LOGFILE"))&lt;/literal&gt;
and it won't do anything if the environment variable is not set.

This function still works if telepathy-glib was compiled without debug
support.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">A file to which to divert stdout and stderr, or %NULL to do nothing</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_all_flags"
              c:identifier="tp_debug_set_all_flags"
              introspectable="0"
              deprecated="since 0.6.1. Use tp_debug_set_flags (&quot;all&quot;) and">
      <doc xml:whitespace="preserve">Activate all possible debug modes. This also activates persistent mode,
which should have been orthogonal.

tp_debug_set_persistent() instead.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_set_flags"
              c:identifier="tp_debug_set_flags"
              version="0.6.1">
      <doc xml:whitespace="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set.

The parsing matches that of g_parse_debug_string().

If telepathy-glib was compiled with --disable-debug (not recommended),
this function has no practical effect, since the debug messages it would
enable were removed at compile time.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The flags to set, comma-separated. If %NULL or empty, no additional flags are set.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_env"
              c:identifier="tp_debug_set_flags_from_env"
              introspectable="0"
              deprecated="since 0.6.1. Use tp_debug_set_flags(g_getenv(...)) and">
      <doc xml:whitespace="preserve">Equivalent to
&lt;literal&gt;tp_debug_set_flags_from_string (g_getenv (var))&lt;/literal&gt;,
and has the same problem with persistence being included in "all".

tp_debug_set_persistent() instead</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="var" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the environment variable to parse</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_flags_from_string"
              c:identifier="tp_debug_set_flags_from_string"
              introspectable="0"
              deprecated="since 0.6.1. Use tp_debug_set_flags() and">
      <doc xml:whitespace="preserve">Set the debug flags indicated by @flags_string, in addition to any already
set. Unlike tp_debug_set_flags(), this enables persistence like
tp_debug_set_persistent() if the "persist" flag is present or the string
is "all" - this turns out to be unhelpful, as persistence should be
orthogonal.

The parsing matches that of g_parse_debug_string().

tp_debug_set_persistent() instead</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags_string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The flags to set, comma-separated. If %NULL or empty, no additional flags are set.</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_persistent"
              c:identifier="tp_debug_set_persistent">
      <doc xml:whitespace="preserve">Used to enable persistent operation of the connection manager process for
debugging purposes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="persistent" transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE prevents the connection manager mainloop from exiting, FALSE enables exiting if there are no connections (the default behavior).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_timestamped_log_handler"
              c:identifier="tp_debug_timestamped_log_handler"
              version="0.7.1">
      <doc xml:whitespace="preserve">A #GLogFunc that prepends the UTC time (currently in ISO 8601 format,
with microsecond resolution) to the message, then calls
g_log_default_handler.

Intended usage is:

&lt;informalexample&gt;&lt;programlisting&gt;if (g_getenv ("MYPROG_TIMING") != NULL)
g_log_set_default_handler (tp_debug_timestamped_log_handler, NULL);
&lt;/programlisting&gt;&lt;/informalexample&gt;

If telepathy-glib was compiled with --disable-debug (not recommended),
this function is equivalent to g_log_default_handler().

Changed in 0.9.0: timestamps are now printed in UTC, in
RFC-3339 format. Previously, they were printed in local time, in a
format similar to RFC-3339.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="log_domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message's log domain</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="log_level" transfer-ownership="none">
          <doc xml:whitespace="preserve">the log level of the message</doc>
          <type name="GLib.LogLevelFlags" c:type="GLogLevelFlags"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message to process</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="ignored" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_get_dbus_name"
              c:identifier="tp_error_get_dbus_name"
              version="0.7.31">
      <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the D-Bus error name corresponding to @error.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">a member of the #TpError enum.</doc>
          <type name="Error" c:type="TpError"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark"
              c:identifier="tp_error_quark"
              version="0.11.13">
      <doc xml:whitespace="preserve">Return the error domain quark for #TpError.</doc>
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_disconnected_quark"
              c:identifier="tp_errors_disconnected_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_quark"
              c:identifier="tp_errors_quark"
              introspectable="0"
              deprecated="Use tp_error_quark() instead.">
      <doc xml:whitespace="preserve">&lt;!-- --&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="errors_removed_from_group_quark"
              c:identifier="tp_errors_removed_from_group_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="external_group_mixin_finalize"
              c:identifier="tp_external_group_mixin_finalize"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Remove the external group mixin. This function should usually be called
in the dispose or finalize function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using an external group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_get_dbus_property"
              c:identifier="tp_external_group_mixin_get_dbus_property"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the external group mixin. It can only be used for the Group
interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_iface_init"
              c:identifier="tp_external_group_mixin_iface_init"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
the group mixin of another object. This function should usually be called
via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init"
              c:identifier="tp_external_group_mixin_init"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the qdata needed to implement the group interface using
the group mixin of another object. This function should usually be called
in the instance constructor.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using an external group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="obj_with_mixin" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject with the group mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="external_group_mixin_init_dbus_properties"
              c:identifier="tp_external_group_mixin_init_dbus_properties"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to channels containing the
mixin used by this class with tp_group_mixin_change_flags() to indicate that
the DBus properties are available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_invalid_handle_type"
              c:identifier="tp_g_set_error_invalid_handle_type"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the error NotImplemented for an invalid handle type,
with an appropriate message.

Changed in version 0.7.23: previously, the error was
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An invalid handle type</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="g_set_error_unsupported_handle_type"
              c:identifier="tp_g_set_error_unsupported_handle_type"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the error NotImplemented for a handle type which is valid but is not
supported by this connection manager, with an appropriate message.

Changed in version 0.7.23: previously, the error was
InvalidArgument.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">An unsupported handle type</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_bus" c:identifier="tp_get_bus" introspectable="0">
      <doc xml:whitespace="preserve">Returns a connection to the D-Bus daemon on which this process was
activated if it was launched by D-Bus service activation, or the session
bus otherwise.

If dbus_g_bus_get() fails, exit with error code 1.

Note that this function is not suitable for use in applications which can
be useful even in the absence of D-Bus - it is designed for use in
connection managers, which are not at all useful without a D-Bus
connection. See &amp;lt;https://bugs.freedesktop.org/show_bug.cgi?id=18832&amp;gt;.
Most processes should use tp_dbus_daemon_dup() instead.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a connection to the starter or session D-Bus daemon.</doc>
        <type c:type="DBusGConnection*"/>
      </return-value>
    </function>
    <function name="get_bus_proxy"
              c:identifier="tp_get_bus_proxy"
              introspectable="0"
              deprecated="Use tp_dbus_daemon_dup() in new code."
              deprecated-version="0.7.26">
      <doc xml:whitespace="preserve">Return a #DBusGProxy for the bus daemon object. The same caveats as for
tp_get_bus() apply.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a proxy for the bus daemon object on the starter or session bus.</doc>
        <type c:type="DBusGProxy*"/>
      </return-value>
    </function>
    <function name="group_mixin_add_handle_owner"
              c:identifier="tp_group_mixin_add_handle_owner"
              moved-to="GroupMixin.add_handle_owner"
              introspectable="0">
      <doc xml:whitespace="preserve">Note that the given local handle is an alias within this group
for the given globally-valid handle. It will be returned from subsequent
GetHandleOwner queries where appropriate.

Changed in 0.7.10: The @owner_handle may be 0. To comply with telepathy-spec
0.17.6, before adding any channel-specific handle to the members,
local-pending members or remote-pending members, you must call either
this function or tp_group_mixin_add_handle_owners().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A contact handle valid within this group (may not be 0)</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="owner_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A contact handle valid globally, or 0 if the owner of the @local_handle is unknown</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_handle_owners"
              c:identifier="tp_group_mixin_add_handle_owners"
              moved-to="GroupMixin.add_handle_owners"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Note that the given local handles are aliases within this group
for the given globally-valid handles.

To comply with telepathy-spec 0.17.6, before adding any channel-specific
handle to the members, local-pending members or remote-pending members, you
must call either this function or tp_group_mixin_add_handle_owner().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GObject implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="local_to_owner_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A map from contact handles valid within this group (which may not be 0) to either contact handles valid globally, or 0 if the owner of the corresponding key is unknown; all handles are stored using GUINT_TO_POINTER</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_add_members"
              c:identifier="tp_group_mixin_add_members"
              moved-to="GroupMixin.add_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be added to the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
Otherwise attempt to add the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message associated with the addition request, if supported</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_flags"
              c:identifier="tp_group_mixin_change_flags"
              moved-to="GroupMixin.change_flags"
              introspectable="0">
      <doc xml:whitespace="preserve">Request a change to be made to the flags. If any flags were actually
set or cleared, emits the GroupFlagsChanged signal with the changes.

It is an error to set any of the same bits in both @add and @del.

Changed in 0.7.7: the signal is not emitted if adding @add and
removing @del had no effect on the existing group flags.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the groups interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags to be added</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">Flags to be removed</doc>
          <type name="ChannelGroupFlags" c:type="TpChannelGroupFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members"
              c:identifier="tp_group_mixin_change_members"
              moved-to="GroupMixin.change_members"
              introspectable="0">
      <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

signals were emitted; %FALSE if nothing actually changed and the signals
were suppressed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to the affected contacts if possible; %NULL is allowed, and is mapped to an empty string</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="actor" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact responsible for this change</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">The reason for this change</doc>
          <type name="ChannelGroupChangeReason"
                c:type="TpChannelGroupChangeReason"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_members_detailed"
              c:identifier="tp_group_mixin_change_members_detailed"
              moved-to="GroupMixin.change_members_detailed"
              version="0.7.21"
              introspectable="0">
      <doc xml:whitespace="preserve">Change the sets of members as given by the arguments, and emit the
MembersChanged and MembersChangedDetailed signals if the changes were not a
no-op.

This function must be called in response to events on the underlying
IM protocol, and must not be called in direct response to user input;
it does not respect the permissions flags, but changes the group directly.

If any two of add, del, add_local_pending and add_remote_pending have
a non-empty intersection, the result is undefined. Don't do that.

Each of the TpIntset arguments may be %NULL, which is treated as
equivalent to an empty set.

details may contain, among other entries, the well-known
keys (and corresponding type, wrapped in a GValue) defined by the
Group.MembersChangedDetailed signal's specification; these include "actor"
(a handle as G_TYPE_UINT), "change-reason" (an element of
#TpChannelGroupChangeReason as G_TYPE_UINT), "message" (G_TYPE_STRING),
"error" (G_TYPE_STRING), "debug-message" (G_TYPE_STRING).

If all of the information in details could be passed to
tp_group_mixin_change_members() then calling this function instead provides
no benefit. Calling this function without setting
#TP_CHANNEL_GROUP_FLAG_MEMBERS_CHANGED_DETAILED with
tp_group_mixin_change_members() first is not very useful, as clients will
not know to listen for MembersChangedDetailed and thus will miss the
details.

signals were emitted; %FALSE if nothing actually changed and the signals
were suppressed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the group was changed and the MembersChanged(Detailed)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="add" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to the members (if not already present) and removed from local pending and remote pending (if present)</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="del" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be removed from members, local pending or remote pending, wherever they are present</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="add_local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to local pending, and removed from members and remote pending</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="add_remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">A set of contact handles to be added to remote pending, and removed from members and local pending</doc>
          <type name="Intset" c:type="TpIntset*"/>
        </parameter>
        <parameter name="details" transfer-ownership="none">
          <doc xml:whitespace="preserve">a map from strings to GValues detailing the change</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_change_self_handle"
              c:identifier="tp_group_mixin_change_self_handle"
              moved-to="GroupMixin.change_self_handle"
              introspectable="0">
      <doc xml:whitespace="preserve">Change the self-handle for this group to the given value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="new_self_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new self-handle for this group</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_allow_self_removal"
              c:identifier="tp_group_mixin_class_allow_self_removal"
              moved-to="GroupMixinClass.allow_self_removal"
              version="0.7.27"
              introspectable="0">
      <doc xml:whitespace="preserve">Configure the mixin to allow attempts to remove the SelfHandle from this
Group, even if the group flags would otherwise disallow this. The
channel's #TpGroupMixinRemMemberFunc or
#TpGroupMixinRemMemberWithReasonFunc will be called as usual for such
attempts, and may make them fail with %TP_ERROR_PERMISSION_DENIED if
required.

This function should be called from the GObject @class_init callback,
after calling tp_group_mixin_class_init().

(Recent telepathy-spec changes make it valid to try to remove the
self-handle at all times, regardless of group flags. However, if this was
implemented automatically in TpGroupMixin, this would risk crashing
connection manager implementations that assume that TpGroupMixin will
enforce the group flags strictly. As a result, connection managers should
call this function to indicate to the TpGroupMixin that it may call their
removal callback with the self-handle regardless of flag settings.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_get_offset_quark"
              c:identifier="tp_group_mixin_class_get_offset_quark"
              moved-to="GroupMixinClass.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_class_init"
              c:identifier="tp_group_mixin_class_init"
              moved-to="GroupMixinClass.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Configure the mixin for use with the given class.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of the TpGroupMixinClass structure within the class structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="add_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to add contacts to this group</doc>
          <type name="GroupMixinAddMemberFunc"
                c:type="TpGroupMixinAddMemberFunc"/>
        </parameter>
        <parameter name="rem_func" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group. This must be %NULL if you will subsequently call tp_group_mixin_class_set_remove_with_reason_func().</doc>
          <type name="GroupMixinRemMemberFunc"
                c:type="TpGroupMixinRemMemberFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_class_set_remove_with_reason_func"
              c:identifier="tp_group_mixin_class_set_remove_with_reason_func"
              moved-to="GroupMixinClass.set_remove_with_reason_func"
              version="0.5.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Set a callback to be used to implement RemoveMembers() and
RemoveMembersWithReason(). If this function is called during class
initialization, the given callback will be used instead of the remove
callback passed to tp_group_mixin_class_init() (which must be %NULL
in this case).</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object implementing the group interface using this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to remove contacts from this group with a specified reason.</doc>
          <type name="GroupMixinRemMemberWithReasonFunc"
                c:type="TpGroupMixinRemMemberWithReasonFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_finalize"
              c:identifier="tp_group_mixin_finalize"
              moved-to="GroupMixin.finalize"
              introspectable="0">
      <doc xml:whitespace="preserve">Unreference handles and free resources used by this mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_all_members"
              c:identifier="tp_group_mixin_get_all_members"
              moved-to="GroupMixin.get_all_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's current and pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="members" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="local_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's local pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="remote_pending" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_dbus_property"
              c:identifier="tp_group_mixin_get_dbus_property"
              moved-to="GroupMixin.get_dbus_property"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">An implementation of #TpDBusPropertiesMixinGetter which assumes that the
@object has the group mixin. It can only be used for the Group interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">Must be %TP_IFACE_QUARK_CHANNEL_INTERFACE_GROUP</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">A quark representing the D-Bus property name, either "GroupFlags", "HandleOwners", "LocalPendingMembers", "Members", "RemotePendingMembers" or "SelfHandle"</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GValue pre-initialized to the right type, into which to put the value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_group_flags"
              c:identifier="tp_group_mixin_get_group_flags"
              moved-to="GroupMixin.get_group_flags"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the guint pointed to by ret to this group's flags, to be
interpreted according to TpChannelGroupFlags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return the flags</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_handle_owners"
              c:identifier="tp_group_mixin_get_handle_owners"
              moved-to="GroupMixin.get_handle_owners"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">If the mixin has the flag %TP_CHANNEL_GROUP_FLAG_CHANNEL_SPECIFIC_HANDLES,
return the global owners of the given local handles, or 0 where
unavailable.

failure</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE (setting @ret) on success, %FALSE (setting @error) on</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of guint representing locally valid handles</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return an array of guint representing globally valid handles, or 0 where unavailable, if %TRUE is returned</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members"
              c:identifier="tp_group_mixin_get_local_pending_members"
              moved-to="GroupMixin.get_local_pending_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's local-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_local_pending_members_with_info"
              c:identifier="tp_group_mixin_get_local_pending_members_with_info"
              moved-to="GroupMixin.get_local_pending_members_with_info"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's local-pending members and information about their
requests to join the channel.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GPtrArray of D-Bus structures each containing the handle of a local-pending contact, the handle of a contact responsible for adding them to the group (or 0), the reason code and a related message (e.g. their request to join the group)</doc>
          <array name="GLib.PtrArray" c:type="GPtrArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_members"
              c:identifier="tp_group_mixin_get_members"
              moved-to="GroupMixin.get_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's current members</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint contact handles</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_offset_quark"
              c:identifier="tp_group_mixin_get_offset_quark"
              moved-to="GroupMixin.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="group_mixin_get_remote_pending_members"
              c:identifier="tp_group_mixin_get_remote_pending_members"
              moved-to="GroupMixin.get_remote_pending_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Get the group's remote-pending members.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return a newly-allocated GArray of guint representing the handles of the group's remote pending members</doc>
          <array name="GLib.Array" c:type="GArray**">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_get_self_handle"
              c:identifier="tp_group_mixin_get_self_handle"
              moved-to="GroupMixin.get_self_handle"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Set the guint pointed to by ret to the local user's handle in this
group, or to 0 if the local user is not present in this group.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group mixin using this interface</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">Used to return the local user's handle in this group</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_iface_init"
              c:identifier="tp_group_mixin_iface_init"
              moved-to="GroupMixin.iface_init"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the group interface using
this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpSvcChannelInterfaceGroupClass</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Unused</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init"
              c:identifier="tp_group_mixin_init"
              moved-to="GroupMixin.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The offset of the TpGroupMixin structure within the instance structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="handle_repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">The connection's handle repository for contacts</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="self_handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the local user in this group, if any</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_init_dbus_properties"
              c:identifier="tp_group_mixin_init_dbus_properties"
              moved-to="GroupMixin.init_dbus_properties"
              version="0.7.10"
              introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the Group interface's properties.

This uses tp_group_mixin_get_dbus_property() as the property getter and
sets up a list of the supported properties for it.  Having called this, you
should add #TP_CHANNEL_GROUP_FLAG_PROPERTIES to any channels of this class
with tp_group_mixin_change_flags() to indicate that the DBus properties are
available.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members"
              c:identifier="tp_group_mixin_remove_members"
              moved-to="GroupMixin.remove_members"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="group_mixin_remove_members_with_reason"
              c:identifier="tp_group_mixin_remove_members_with_reason"
              moved-to="GroupMixin.remove_members_with_reason"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Request that the given contacts be removed from the group as if in response
to user action. If the group's flags prohibit this, raise
PermissionDenied. If any of the handles is invalid, raise InvalidHandle.
If any of the handles is absent from the group, raise NotAvailable.
Otherwise attempt to remove the contacts by calling the callbacks provided
by the channel implementation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object implementing the group interface using this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contacts" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing contacts</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">A message to be sent to those contacts, if supported</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="reason" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #TpChannelGroupChangeReason</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_hold"
              c:identifier="tp_handle_client_hold"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_client_release"
              c:identifier="tp_handle_client_release"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ensure" c:identifier="tp_handle_ensure" throws="1">
      <doc xml:whitespace="preserve">Return a handle for the given string, creating one if necessary. The string
is normalized, if possible.

is invalid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handle corresponding to the given string, or 0 if it</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_get_qdata"
              c:identifier="tp_handle_get_qdata"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

if there is no associated data.</doc>
      <return-value>
        <doc xml:whitespace="preserve">the data associated with a given key on a given handle; %NULL</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle to get data from</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Key id of data to fetch</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_inspect"
              c:identifier="tp_handle_inspect"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

handle is absent from the repository. The string is owned by the
handle repository and will remain valid as long as a reference to
the handle exists.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the string represented by the given handle, or NULL if the</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_is_valid"
              c:identifier="tp_handle_is_valid"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;

else %FALSE</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is nonzero and is present in the repository,</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository @self</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_lookup"
              c:identifier="tp_handle_lookup"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Return the handle for the given string. The string is normalized if
possible. If no handle already exists for the string, none is created.

does not exist or is invalid</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the handle corresponding to the given string, or 0 if it</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string whose handle is required</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none">
          <doc xml:whitespace="preserve">User data to be passed to the normalization callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_ref"
              c:identifier="tp_handle_ref"
              introspectable="0">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.

Changed in 0.13.6: @handle is now returned; previously,
this function didn't return anything.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the same @handle</doc>
        <type name="Handle" c:type="TpHandle"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_set_qdata"
              c:identifier="tp_handle_set_qdata"
              moved-to="HandleSet.qdata"
              introspectable="0">
      <doc xml:whitespace="preserve">Associates a blob of data with a given handle and a given key

If @destroy is set, then the data is freed when the handle is freed.

Since version 0.13.8, handles always last as long as the
connection, so @destroy will not be called until the connection
disconnects.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="repo" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle to set data on</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="key_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">Key id to associate data with</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to associate with handle</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">A #GDestroyNotify to call to destroy the data, or NULL if not needed.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_is_valid"
              c:identifier="tp_handle_type_is_valid"
              throws="1">
      <doc xml:whitespace="preserve">If the given handle type is valid, return %TRUE. If not, set @error
and return %FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle type is valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle type, valid or not, to be checked</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_type_to_string"
              c:identifier="tp_handle_type_to_string">
      <doc xml:whitespace="preserve">&lt;!----&gt;

For invalid handle types, returns "(no handle)" for 0 or
"(invalid handle type)" for others.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a human-readable string describing the handle type, e.g. "contact".</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle type, which need not be valid</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref"
              c:identifier="tp_handle_unref"
              introspectable="0">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle of the type stored in the repository</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_are_valid"
              c:identifier="tp_handles_are_valid"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle is present in the repository, else %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">A handle repository implementation</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">Array of TpHandle representing handles of the type stored in the repository @self</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_hold"
              c:identifier="tp_handles_client_hold"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_client_release"
              c:identifier="tp_handles_client_release"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="client" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">ignored</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_ref"
              c:identifier="tp_handles_ref"
              introspectable="0">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="handles_supported_and_valid"
              c:identifier="tp_handles_supported_and_valid"
              introspectable="0"
              throws="1">
      <doc xml:whitespace="preserve">Return %TRUE if the given handle type is supported (i.e. repos[handle_type]
is not %NULL) and the given handles are all valid in that repository.
If not, set @error and return %FALSE.

valid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the handle type is supported and the handles are all</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="repos" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of possibly null pointers to handle repositories, indexed by handle type, where a null pointer means an unsupported handle type</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handle_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle type</doc>
          <type name="HandleType" c:type="TpHandleType"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">A GArray of guint representing handles of the given type</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
        <parameter name="allow_zero" transfer-ownership="none">
          <doc xml:whitespace="preserve">If %TRUE, zero is treated like a valid handle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="handles_unref"
              c:identifier="tp_handles_unref"
              introspectable="0">
      <doc xml:whitespace="preserve">Do nothing. Since version 0.13.8, handles always last as long as
the connection; previously, this function provided refcounting for handles.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <type name="HandleRepoIface" c:type="TpHandleRepoIface*"/>
        </parameter>
        <parameter name="handles" transfer-ownership="none">
          <doc xml:whitespace="preserve">not used</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="iface_quark_account" c:identifier="tp_iface_quark_account">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_addressing"
              c:identifier="tp_iface_quark_account_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_avatar"
              c:identifier="tp_iface_quark_account_interface_avatar">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_interface_storage"
              c:identifier="tp_iface_quark_account_interface_storage">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_account_manager"
              c:identifier="tp_iface_quark_account_manager">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_authentication_tls_certificate"
              c:identifier="tp_iface_quark_authentication_tls_certificate">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel" c:identifier="tp_iface_quark_channel">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatch_operation"
              c:identifier="tp_iface_quark_channel_dispatch_operation">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher"
              c:identifier="tp_iface_quark_channel_dispatcher">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_dispatcher_interface_operation_list"
              c:identifier="tp_iface_quark_channel_dispatcher_interface_operation_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_anonymity"
              c:identifier="tp_iface_quark_channel_interface_anonymity">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_call_state"
              c:identifier="tp_iface_quark_channel_interface_call_state">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_chat_state"
              c:identifier="tp_iface_quark_channel_interface_chat_state">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_conference"
              c:identifier="tp_iface_quark_channel_interface_conference">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_destroyable"
              c:identifier="tp_iface_quark_channel_interface_destroyable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_dtmf"
              c:identifier="tp_iface_quark_channel_interface_dtmf">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_file_transfer_metadata"
              c:identifier="tp_iface_quark_channel_interface_file_transfer_metadata">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_group"
              c:identifier="tp_iface_quark_channel_interface_group">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_hold"
              c:identifier="tp_iface_quark_channel_interface_hold">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_media_signalling"
              c:identifier="tp_iface_quark_channel_interface_media_signalling">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_messages"
              c:identifier="tp_iface_quark_channel_interface_messages">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_password"
              c:identifier="tp_iface_quark_channel_interface_password">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_room"
              c:identifier="tp_iface_quark_channel_interface_room">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_room_config"
              c:identifier="tp_iface_quark_channel_interface_room_config">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_sasl_authentication"
              c:identifier="tp_iface_quark_channel_interface_sasl_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_securable"
              c:identifier="tp_iface_quark_channel_interface_securable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_service_point"
              c:identifier="tp_iface_quark_channel_interface_service_point">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_sms"
              c:identifier="tp_iface_quark_channel_interface_sms">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_subject"
              c:identifier="tp_iface_quark_channel_interface_subject">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_interface_tube"
              c:identifier="tp_iface_quark_channel_interface_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_request"
              c:identifier="tp_iface_quark_channel_request">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_list"
              c:identifier="tp_iface_quark_channel_type_contact_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_contact_search"
              c:identifier="tp_iface_quark_channel_type_contact_search">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_dbus_tube"
              c:identifier="tp_iface_quark_channel_type_dbus_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_file_transfer"
              c:identifier="tp_iface_quark_channel_type_file_transfer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_room_list"
              c:identifier="tp_iface_quark_channel_type_room_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_server_authentication"
              c:identifier="tp_iface_quark_channel_type_server_authentication">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_server_tls_connection"
              c:identifier="tp_iface_quark_channel_type_server_tls_connection">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_stream_tube"
              c:identifier="tp_iface_quark_channel_type_stream_tube">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_streamed_media"
              c:identifier="tp_iface_quark_channel_type_streamed_media">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_text"
              c:identifier="tp_iface_quark_channel_type_text">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_channel_type_tubes"
              c:identifier="tp_iface_quark_channel_type_tubes">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client" c:identifier="tp_iface_quark_client">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_approver"
              c:identifier="tp_iface_quark_client_approver">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_handler"
              c:identifier="tp_iface_quark_client_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_interface_requests"
              c:identifier="tp_iface_quark_client_interface_requests">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_client_observer"
              c:identifier="tp_iface_quark_client_observer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection"
              c:identifier="tp_iface_quark_connection">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_aliasing"
              c:identifier="tp_iface_quark_connection_interface_aliasing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_anonymity"
              c:identifier="tp_iface_quark_connection_interface_anonymity">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_avatars"
              c:identifier="tp_iface_quark_connection_interface_avatars">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_balance"
              c:identifier="tp_iface_quark_connection_interface_balance">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_capabilities"
              c:identifier="tp_iface_quark_connection_interface_capabilities">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_cellular"
              c:identifier="tp_iface_quark_connection_interface_cellular">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_client_types"
              c:identifier="tp_iface_quark_connection_interface_client_types">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_blocking"
              c:identifier="tp_iface_quark_connection_interface_contact_blocking">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_capabilities"
              c:identifier="tp_iface_quark_connection_interface_contact_capabilities">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_groups"
              c:identifier="tp_iface_quark_connection_interface_contact_groups">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_info"
              c:identifier="tp_iface_quark_connection_interface_contact_info">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contact_list"
              c:identifier="tp_iface_quark_connection_interface_contact_list">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_contacts"
              c:identifier="tp_iface_quark_connection_interface_contacts">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_location"
              c:identifier="tp_iface_quark_connection_interface_location">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_mail_notification"
              c:identifier="tp_iface_quark_connection_interface_mail_notification">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_power_saving"
              c:identifier="tp_iface_quark_connection_interface_power_saving">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_presence"
              c:identifier="tp_iface_quark_connection_interface_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_requests"
              c:identifier="tp_iface_quark_connection_interface_requests">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_service_point"
              c:identifier="tp_iface_quark_connection_interface_service_point">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_interface_simple_presence"
              c:identifier="tp_iface_quark_connection_interface_simple_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_connection_manager"
              c:identifier="tp_iface_quark_connection_manager">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_daemon"
              c:identifier="tp_iface_quark_dbus_daemon">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_introspectable"
              c:identifier="tp_iface_quark_dbus_introspectable">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_peer"
              c:identifier="tp_iface_quark_dbus_peer">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_dbus_properties"
              c:identifier="tp_iface_quark_dbus_properties">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_debug" c:identifier="tp_iface_quark_debug">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_session_handler"
              c:identifier="tp_iface_quark_media_session_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_media_stream_handler"
              c:identifier="tp_iface_quark_media_stream_handler">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_properties_interface"
              c:identifier="tp_iface_quark_properties_interface">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol"
              c:identifier="tp_iface_quark_protocol">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_addressing"
              c:identifier="tp_iface_quark_protocol_interface_addressing">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_avatars"
              c:identifier="tp_iface_quark_protocol_interface_avatars">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="iface_quark_protocol_interface_presence"
              c:identifier="tp_iface_quark_protocol_interface_presence">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="intset_from_array"
              c:identifier="tp_intset_from_array"
              moved-to="Intset.from_array">
      <doc xml:whitespace="preserve">&lt;!--Returns: says it all--&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A set containing the same integers as @array.</doc>
        <type name="Intset" c:type="TpIntset*"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of guint</doc>
          <array name="GLib.Array" c:type="GArray*">
            <type name="guint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_managers"
              c:identifier="tp_list_connection_managers"
              version="0.7.1">
      <doc xml:whitespace="preserve">List the available (running or installed) connection managers. Call the
callback when done.

Since 0.7.26, this function will wait for each #TpConnectionManager
to be ready, so all connection managers passed to @callback will be ready
(tp_connection_manager_is_ready() will return %TRUE) unless an error
occurred while launching that connection manager.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="notified"
                   closure="2"
                   destroy="3">
          <doc xml:whitespace="preserve">callback to be called when listing the CMs succeeds or fails; not called if the @weak_object goes away</doc>
          <type name="ConnectionManagerListCb"
                c:type="TpConnectionManagerListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">callback to destroy the user-supplied data, called after @callback, but also if the @weak_object goes away</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">if not %NULL, will be weakly referenced; the callback will not be called, and the call will be cancelled, if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="list_connection_names"
              c:identifier="tp_list_connection_names"
              version="0.7.1">
      <doc xml:whitespace="preserve">List the bus names of all the connections that currently exist, together
with the connection manager name and the protocol name for each connection.
Call the callback when done.

The bus names passed to the callback can be used to construct #TpConnection
objects for any connections that are of interest.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bus_daemon" transfer-ownership="none">
          <doc xml:whitespace="preserve">proxy for the D-Bus daemon</doc>
          <type name="DBusDaemon" c:type="TpDBusDaemon*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="notified"
                   closure="2"
                   destroy="3">
          <doc xml:whitespace="preserve">callback to be called when listing the connections succeeds or fails; not called if the D-Bus connection fails completely or if the @weak_object goes away</doc>
          <type name="ConnectionNameListCb" c:type="TpConnectionNameListCb"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user-supplied data for the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">callback to destroy the user-supplied data, called after @callback, but also if the D-Bus connection fails or if the @weak_object goes away</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">if not %NULL, will be weakly referenced; the callback will not be called if the object has vanished</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_class_get_offset_quark"
              c:identifier="tp_presence_mixin_class_get_offset_quark"
              moved-to="PresenceMixinClass.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObjectClass</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_class_init"
              c:identifier="tp_presence_mixin_class_init"
              moved-to="PresenceMixinClass.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
class_init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_class_init ((GObjectClass *) klass,
G_STRUCT_OFFSET (SomeObjectClass,
presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj_cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of the implementation that uses this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixinClass within the class structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
        <parameter name="status_available" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to determine if a given presence status can be set on a particular connection. Should usually be %NULL, to consider all statuses with #TpPresenceStatusSpec.self set to %TRUE to be settable.</doc>
          <type name="PresenceMixinStatusAvailableFunc"
                c:type="TpPresenceMixinStatusAvailableFunc"/>
        </parameter>
        <parameter name="get_contact_statuses" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used get the current presence status for contacts. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
          <type name="PresenceMixinGetContactStatusesFunc"
                c:type="TpPresenceMixinGetContactStatusesFunc"/>
        </parameter>
        <parameter name="set_own_status" transfer-ownership="none">
          <doc xml:whitespace="preserve">A callback to be used to commit changes to the user's own presence status to the server. This is used in implementations of various D-Bus methods and hence must be provided.</doc>
          <type name="PresenceMixinSetOwnStatusFunc"
                c:type="TpPresenceMixinSetOwnStatusFunc"/>
        </parameter>
        <parameter name="statuses" transfer-ownership="none">
          <doc xml:whitespace="preserve">An array of #TpPresenceStatusSpec structures representing all presence statuses supported by the protocol, terminated by a NULL name.</doc>
          <type name="PresenceStatusSpec" c:type="TpPresenceStatusSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_one_presence_update"
              c:identifier="tp_presence_mixin_emit_one_presence_update"
              moved-to="PresenceMixin.emit_one_presence_update"
              introspectable="0">
      <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for a single contact. This method is just a
convenience wrapper around #tp_presence_mixin_emit_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:whitespace="preserve">The handle of the contact to emit the signal for</doc>
          <type name="Handle" c:type="TpHandle"/>
        </parameter>
        <parameter name="status" transfer-ownership="none">
          <doc xml:whitespace="preserve">The new status to emit</doc>
          <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_emit_presence_update"
              c:identifier="tp_presence_mixin_emit_presence_update"
              moved-to="PresenceMixin.emit_presence_update"
              introspectable="0">
      <doc xml:whitespace="preserve">Emit the PresenceUpdate signal for multiple contacts. For emitting
PresenceUpdate for a single contact, there is a convenience wrapper called
#tp_presence_mixin_emit_one_presence_update.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">A connection object with this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="contact_presences" transfer-ownership="none">
          <doc xml:whitespace="preserve">A mapping of contact handles to #TpPresenceStatus structures with the presence data to emit</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_finalize"
              c:identifier="tp_presence_mixin_finalize"
              moved-to="PresenceMixin.finalize"
              introspectable="0">
      <doc xml:whitespace="preserve">Free resources held by the presence mixin.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An object with this mixin.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_get_offset_quark"
              c:identifier="tp_presence_mixin_get_offset_quark"
              moved-to="PresenceMixin.get_offset_quark"
              introspectable="0">
      <doc xml:whitespace="preserve">&lt;!--no documentation beyond Returns: needed--&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark used for storing mixin offset on a GObject</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="presence_mixin_iface_init"
              c:identifier="tp_presence_mixin_iface_init"
              moved-to="PresenceMixin.iface_init"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the presence interface using
this mixin. This function should usually be called via G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfacePresenceClass in an object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_init"
              c:identifier="tp_presence_mixin_init"
              moved-to="PresenceMixin.init"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize the presence mixin. Should be called from the implementation's
instance init function like so:

&lt;informalexample&gt;&lt;programlisting&gt;
tp_presence_mixin_init ((GObject *) self,
G_STRUCT_OFFSET (SomeObject, presence_mixin));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance of the implementation that uses this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">The byte offset of the TpPresenceMixin within the object structure</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_iface_init"
              c:identifier="tp_presence_mixin_simple_presence_iface_init"
              moved-to="PresenceMixin.simple_presence_iface_init"
              version="0.7.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Fill in the vtable entries needed to implement the simple presence interface
using this mixin. This function should usually be called via
G_IMPLEMENT_INTERFACE.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_iface" transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the #TpSvcConnectionInterfaceSimplePresenceClass in an object class</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="iface_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Ignored</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_init_dbus_properties"
              c:identifier="tp_presence_mixin_simple_presence_init_dbus_properties"
              moved-to="PresenceMixin.simple_presence_init_dbus_properties"
              version="0.7.13"
              introspectable="0">
      <doc xml:whitespace="preserve">Set up #TpDBusPropertiesMixinClass to use this mixin's implementation of
the SimplePresence interface's properties.

This automatically sets up a list of the supported properties for the
SimplePresence interface.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="cls" transfer-ownership="none">
          <doc xml:whitespace="preserve">The class of an object with this mixin</doc>
          <type name="GObject.ObjectClass" c:type="GObjectClass*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_mixin_simple_presence_register_with_contacts_mixin"
              c:identifier="tp_presence_mixin_simple_presence_register_with_contacts_mixin"
              moved-to="PresenceMixin.simple_presence_register_with_contacts_mixin"
              introspectable="0">
      <doc xml:whitespace="preserve">Register the SimplePresence interface with the Contacts interface to make it
inspectable. The Contacts mixin should be initialized before this function
is called</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">An instance that of the implementation that uses both the Contacts mixin and this mixin</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="presence_status_new"
              c:identifier="tp_presence_status_new"
              moved-to="PresenceStatus.new"
              introspectable="0">
      <doc xml:whitespace="preserve">Construct a presence status structure. You should free the returned
structure with #tp_presence_status_free.</doc>
      <return-value>
        <doc xml:whitespace="preserve">A pointer to the newly allocated presence status structure.</doc>
        <type name="PresenceStatus" c:type="TpPresenceStatus*"/>
      </return-value>
      <parameters>
        <parameter name="which" transfer-ownership="none">
          <doc xml:whitespace="preserve">Index of the presence status in the provided supported presence statuses array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="optional_arguments" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optional arguments for the presence statuses. Can be NULL if there are no optional arguments. The presence status object makes a copy of the hashtable, so you should free the original.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="svc_interface_get_dbus_properties_info"
              c:identifier="tp_svc_interface_get_dbus_properties_info"
              version="0.15.8"
              introspectable="0">
      <doc xml:whitespace="preserve">Retrieves the D-Bus property metadata for the given interface, if any.
This function is typically not useful outside telepathy-glib itself, but may
be useful for domain-specific variations on the theme of SetProperty. If in
doubt, you probably don't need this function.

none.</doc>
      <return-value>
        <doc xml:whitespace="preserve">D-Bus property metadata for @g_interface, or %NULL if it has</doc>
        <type name="DBusPropertiesMixinIfaceInfo"
              c:type="TpDBusPropertiesMixinIfaceInfo*"/>
      </return-value>
      <parameters>
        <parameter name="g_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GType of a service interface</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="svc_interface_set_dbus_properties_info"
              c:identifier="tp_svc_interface_set_dbus_properties_info"
              version="0.7.3">
      <doc xml:whitespace="preserve">Declare that @g_interface implements the given D-Bus interface, with the
given properties. This may only be called once per GInterface, usually from
a section of its base_init function that only runs once.

This is typically only used within generated code; there is normally no
reason to call it manually.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="g_interface" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GType of a service interface</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">an interface description</doc>
          <type name="DBusPropertiesMixinIfaceInfo"
                c:type="TpDBusPropertiesMixinIfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
