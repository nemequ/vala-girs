<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="nice"/>
  <namespace name="Nice"
             version="0.1"
             shared-library=""
             c:identifier-prefixes="Nice"
             c:symbol-prefixes="nice">
    <constant name="AGENT_MAX_REMOTE_CANDIDATES"
              value="25"
              c:type="NICE_AGENT_MAX_REMOTE_CANDIDATES">
      <doc xml:space="preserve">A hard limit for the number of remote candidates. This
limit is enforced to protect against malevolent remote
clients.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Address" c:type="NiceAddress">
      <doc xml:space="preserve">The #NiceAddress structure that represents an IPv4 or IPv6 address.</doc>
      <union name="s" c:type="s">
        <field name="addr" writable="1">
          <type name="gpointer" c:type="sockaddr"/>
        </field>
        <field name="ip4" writable="1">
          <type name="gpointer" c:type="sockaddr_in"/>
        </field>
        <field name="ip6" writable="1">
          <type name="gpointer" c:type="sockaddr_in6"/>
        </field>
      </union>
      <method name="copy_to_sockaddr"
              c:identifier="nice_address_copy_to_sockaddr">
        <doc xml:space="preserve">Fills the sockaddr structure @sin with the address contained in @addr</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="sin" transfer-ownership="none">
            <doc xml:space="preserve">The sockaddr to fill</doc>
            <type name="gpointer" c:type="sockaddr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="nice_address_dup" introspectable="0">
        <doc xml:space="preserve">Creates a new #NiceAddress with the same address as @addr</doc>
        <return-value>
          <doc xml:space="preserve">The new #NiceAddress</doc>
          <type name="Address" c:type="NiceAddress*"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to dup</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="nice_address_equal">
        <doc xml:space="preserve">Compares two #NiceAddress structures to see if they contain the same address
and the same port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @a and @b are the same address, %FALSE if they are different</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">First #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">Second #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_no_port"
              c:identifier="nice_address_equal_no_port"
              version="0.1.8">
        <doc xml:space="preserve">Compares two #NiceAddress structures to see if they contain the same address,
ignoring the port.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @a and @b are the same address, %FALSE if they
are different</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">First #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">Second #NiceAddress to compare</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="nice_address_free">
        <doc xml:space="preserve">Frees a #NiceAddress created with nice_address_new() or nice_address_dup()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to free</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_port" c:identifier="nice_address_get_port">
        <doc xml:space="preserve">Retreive the port of @addr</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The port of @addr</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="nice_address_init">
        <doc xml:space="preserve">Initialize a #NiceAddress into an undefined address</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to init</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ip_version" c:identifier="nice_address_ip_version">
        <doc xml:space="preserve">Returns the IP version of the address</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">4 for IPv4, 6 for IPv6 and 0 for undefined address</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_private" c:identifier="nice_address_is_private">
        <doc xml:space="preserve">Verifies if the address in @addr is a private address or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @addr is a private address, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_valid" c:identifier="nice_address_is_valid">
        <doc xml:space="preserve">Validate whether the #NiceAddress @addr is a valid IPv4 or IPv6 address</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @addr is valid, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_from_sockaddr"
              c:identifier="nice_address_set_from_sockaddr">
        <doc xml:space="preserve">Sets an IPv4 or IPv6 address from the sockaddr structure @sin</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="sin" transfer-ownership="none">
            <doc xml:space="preserve">The sockaddr to set</doc>
            <type name="gpointer" c:type="const sockaddr*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_string"
              c:identifier="nice_address_set_from_string">
        <doc xml:space="preserve">Sets an IPv4 or IPv6 address from the string @str</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if success, %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve">The string to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ipv4" c:identifier="nice_address_set_ipv4">
        <doc xml:space="preserve">Set @addr to an IPv4 address using the data from @addr_ipv4

 &lt;note&gt;
  &lt;para&gt;
   This function will reset the port to 0, so make sure you call it before
   nice_address_set_port()
  &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="addr_ipv4" transfer-ownership="none">
            <doc xml:space="preserve">The IPv4 address</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ipv6" c:identifier="nice_address_set_ipv6">
        <doc xml:space="preserve">Set @addr to an IPv6 address using the data from @addr_ipv6

 &lt;note&gt;
  &lt;para&gt;
   This function will reset the port to 0, so make sure you call it before
   nice_address_set_port()
  &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="addr_ipv6" transfer-ownership="none">
            <doc xml:space="preserve">The IPv6 address</doc>
            <type name="guint8" c:type="const guchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_port" c:identifier="nice_address_set_port">
        <doc xml:space="preserve">Set the port of @addr to @port</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to modify</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </instance-parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">The port to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="nice_address_to_string">
        <doc xml:space="preserve">Transforms the address @addr into a human readable string</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAddress to query</doc>
            <type name="Address" c:type="const NiceAddress*"/>
          </instance-parameter>
          <parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve">The string to fill</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="nice_address_new" introspectable="0">
        <doc xml:space="preserve">Create a new #NiceAddress with undefined address
You must free it with nice_address_free()</doc>
        <return-value>
          <doc xml:space="preserve">The new #NiceAddress</doc>
          <type name="Address" c:type="NiceAddress*"/>
        </return-value>
      </function>
    </record>
    <class name="Agent"
           c:symbol-prefix="agent"
           c:type="NiceAgent"
           parent="GObject.Object"
           glib:type-name="NiceAgent"
           glib:get-type="nice_agent_get_type"
           glib:type-struct="AgentClass">
      <doc xml:space="preserve">The #NiceAgent is the main GObject of the libnice library and represents
the ICE agent.</doc>
      <constructor name="new" c:identifier="nice_agent_new">
        <doc xml:space="preserve">Create a new #NiceAgent.
The returned object must be freed with g_object_unref()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new agent GObject</doc>
          <type name="Agent" c:type="NiceAgent*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve">The Glib Mainloop Context to use for timers</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="compat" transfer-ownership="none">
            <doc xml:space="preserve">The compatibility mode of the agent</doc>
            <type name="Compatibility" c:type="NiceCompatibility"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_reliable"
                   c:identifier="nice_agent_new_reliable"
                   version="0.0.11">
        <doc xml:space="preserve">Create a new #NiceAgent in reliable mode. If the connectivity is established
through ICE-UDP, then a #PseudoTcpSocket will be transparently used to
ensure reliability of the messages.
The returned object must be freed with g_object_unref()
&lt;para&gt; See also: #NiceAgent::reliable-transport-writable &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new agent GObject</doc>
          <type name="Agent" c:type="NiceAgent*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve">The Glib Mainloop Context to use for timers</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="compat" transfer-ownership="none">
            <doc xml:space="preserve">The compatibility mode of the agent</doc>
            <type name="Compatibility" c:type="NiceCompatibility"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_local_address"
              c:identifier="nice_agent_add_local_address">
        <doc xml:space="preserve">Add a local address from which to derive local host candidates for
candidate gathering.
&lt;para&gt;
Since 0.0.5, if this method is not called, libnice will automatically
discover the local addresses available
&lt;/para&gt;

See also: nice_agent_gather_candidates()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on fatal (memory allocation) errors</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="addr" transfer-ownership="none">
            <doc xml:space="preserve">The address to listen to
If the port is 0, then a random port will be chosen by the system</doc>
            <type name="Address" c:type="NiceAddress*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_stream" c:identifier="nice_agent_add_stream">
        <doc xml:space="preserve">Adds a data stream to @agent containing @n_components components. The
returned stream ID is guaranteed to be positive on success.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The ID of the new stream, 0 on failure</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve">The number of components to add to the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="attach_recv"
              c:identifier="nice_agent_attach_recv"
              introspectable="0">
        <doc xml:space="preserve">Attaches the stream's component's sockets to the Glib Mainloop Context in
order to be notified whenever data becomes available for a component,
and to enable #NiceAgent to receive STUN messages (during the
establishment of ICE connectivity).

This must not be used in combination with nice_agent_recv_messages() (or
#NiceIOStream or #NiceInputStream) on the same stream/component pair.

Calling nice_agent_attach_recv() with a %NULL @func will detach any existing
callback and cause reception to be paused for the given stream/component
pair. You must iterate the previously specified #GMainContext sufficiently to
ensure all pending I/O callbacks have been received before calling this
function to unset @func, otherwise data loss of received packets may occur.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if the stream or component IDs are invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve">The Glib Mainloop Context to use for listening on the component</doc>
            <type name="GLib.MainContext" c:type="GMainContext*"/>
          </parameter>
          <parameter name="func" transfer-ownership="none" closure="4">
            <doc xml:space="preserve">The callback function to be called when data is received on
the stream's component (will not be called for STUN messages that
should be handled by #NiceAgent itself)</doc>
            <type name="AgentRecvFunc" c:type="NiceAgentRecvFunc"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">user data associated with the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="forget_relays"
              c:identifier="nice_agent_forget_relays"
              version="0.1.6">
        <doc xml:space="preserve">Forget all the relay servers previously added using
nice_agent_set_relay_info(). Currently connected streams will keep
using the relay as long as they have not been restarted and haven't
succesfully negotiated a different path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the component could not be found, %TRUE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="gather_candidates"
              c:identifier="nice_agent_gather_candidates">
        <doc xml:space="preserve">Allocate and start listening on local candidate ports and start the remote
candidate gathering process.
Once done, #NiceAgent::candidate-gathering-done is called for the stream.
As soon as this function is called, #NiceAgent::new-candidate signals may be
emitted, even before this function returns.

nice_agent_get_local_candidates() will only return non-empty results after
calling this function.

&lt;para&gt;See also: nice_agent_add_local_address()&lt;/para&gt;
&lt;para&gt;See also: nice_agent_set_port_range()&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the stream ID is invalid or if a host candidate couldn't
be allocated on the requested interfaces/ports; %TRUE otherwise

 &lt;note&gt;
   &lt;para&gt;
    Local addresses can be previously set with nice_agent_add_local_address()
  &lt;/para&gt;
  &lt;para&gt;
    Since 0.0.5, If no local address was previously added, then the nice agent
    will automatically detect the local address using
    nice_interfaces_get_local_ips()
   &lt;/para&gt;
 &lt;/note&gt;</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to start</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_local_candidate_sdp"
              c:identifier="nice_agent_generate_local_candidate_sdp"
              version="0.1.4">
        <doc xml:space="preserve">Generate an SDP string representing a local candidate.

&lt;para&gt;See also: nice_agent_parse_remote_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_stream_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string representing the SDP for the candidate. Must be freed
with g_free() once done.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The candidate to generate</doc>
            <type name="Candidate" c:type="NiceCandidate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="generate_local_sdp"
              c:identifier="nice_agent_generate_local_sdp"
              version="0.1.4">
        <doc xml:space="preserve">Generate an SDP string containing the local candidates and credentials for
all streams and components in the agent.

 &lt;note&gt;
   &lt;para&gt;
     The SDP will not contain any codec lines and the 'm' line will not list
     any payload types.
   &lt;/para&gt;
   &lt;para&gt;
    It is highly recommended to set names on the streams prior to calling this
    function. Unnamed streams will show up as '-' in the 'm' line, but the SDP
    will not be parseable with nice_agent_parse_remote_sdp() if a stream is
    unnamed.
   &lt;/para&gt;
   &lt;para&gt;
     The default candidate in the SDP will be selected based on the lowest
     priority candidate for the first component.
   &lt;/para&gt;
 &lt;/note&gt;

&lt;para&gt;See also: nice_agent_set_stream_name() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_get_default_local_candidate() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string representing the local SDP. Must be freed with g_free()
once done.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="generate_local_stream_sdp"
              c:identifier="nice_agent_generate_local_stream_sdp"
              version="0.1.4">
        <doc xml:space="preserve">Generate an SDP string containing the local candidates and credentials
for a stream.

 &lt;note&gt;
   &lt;para&gt;
     The SDP will not contain any codec lines and the 'm' line will not list
     any payload types.
   &lt;/para&gt;
   &lt;para&gt;
    It is highly recommended to set the name of the stream prior to calling this
    function. Unnamed streams will show up as '-' in the 'm' line.
   &lt;/para&gt;
   &lt;para&gt;
     The default candidate in the SDP will be selected based on the lowest
     priority candidate.
   &lt;/para&gt;
 &lt;/note&gt;

&lt;para&gt;See also: nice_agent_set_stream_name() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_get_default_local_candidate() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A string representing the local SDP for the stream. Must be freed
with g_free() once done.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="include_non_ice" transfer-ownership="none">
            <doc xml:space="preserve">Whether or not to include non ICE specific lines
(m=, c= and a=rtcp: lines)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_component_state"
              c:identifier="nice_agent_get_component_state"
              version="0.1.8">
        <doc xml:space="preserve">Retrieves the current state of a component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #NiceComponentState of the component and
%NICE_COMPONENT_STATE_FAILED if the component was invalid.</doc>
          <type name="ComponentState" c:type="NiceComponentState"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_default_local_candidate"
              c:identifier="nice_agent_get_default_local_candidate">
        <doc xml:space="preserve">This helper function will return the recommended default candidate to be
used for non-ICE compatible clients. This will usually be the candidate
with the lowest priority, since it will be the longest path but the one with
the most chances of success.
&lt;note&gt;
     &lt;para&gt;
     This function is only useful in order to manually generate the
     local SDP
     &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The candidate to be used as the default candidate, or %NULL in case
of error. Must be freed with nice_candidate_free() once done.</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_io_stream"
              c:identifier="nice_agent_get_io_stream"
              version="0.1.5">
        <doc xml:space="preserve">Gets a #GIOStream wrapper around the given stream and component in
@agent. The I/O stream will be valid for as long as @stream_id is valid.
The #GInputStream and #GOutputStream implement #GPollableInputStream and
#GPollableOutputStream.

This function may only be called on reliable #NiceAgents. It is a
programming error to try and create an I/O stream wrapper for an
unreliable stream.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GIOStream.</doc>
          <type name="Gio.IOStream" c:type="GIOStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">A #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to wrap</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component to wrap</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_local_candidates"
              c:identifier="nice_agent_get_local_candidates">
        <doc xml:space="preserve">Retrieve from the agent the list of all local candidates
for a stream's component

 &lt;note&gt;
   &lt;para&gt;
     The caller owns the returned GSList as well as the candidates contained
     within it.
     To get full results, the client should wait for the
     #NiceAgent::candidate-gathering-done signal.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList of
#NiceCandidate objects representing the local candidates of @agent</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Candidate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_local_credentials"
              c:identifier="nice_agent_get_local_credentials">
        <doc xml:space="preserve">Gets the local credentials for stream @stream_id. This may be called any time
after creating a stream using nice_agent_add_stream().

An error will be returned if this is called for a non-existent stream, or if
either of @ufrag or @pwd are %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ufrag"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for a nul-terminated string
containing an ICE username fragment; must be freed with g_free()</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="pwd"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for a nul-terminated string
containing an ICE password; must be freed with g_free()</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_remote_candidates"
              c:identifier="nice_agent_get_remote_candidates">
        <doc xml:space="preserve">Get a list of the remote candidates set on a stream's component

 &lt;note&gt;
   &lt;para&gt;
     The caller owns the returned GSList as well as the candidates contained
     within it.
   &lt;/para&gt;
   &lt;para&gt;
     The list of remote candidates can change during processing.
     The client should register for the #NiceAgent::new-remote-candidate signal
     to get notified of new remote candidates.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GSList of
#NiceCandidates objects representing the remote candidates set on the @agent</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Candidate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_selected_pair"
              c:identifier="nice_agent_get_selected_pair">
        <doc xml:space="preserve">Retreive the selected candidate pair for media transmission
for a given stream's component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if there is no selected candidate pair</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="local" transfer-ownership="none">
            <doc xml:space="preserve">The local selected candidate</doc>
            <type name="Candidate" c:type="NiceCandidate**"/>
          </parameter>
          <parameter name="remote" transfer-ownership="none">
            <doc xml:space="preserve">The remote selected candidate</doc>
            <type name="Candidate" c:type="NiceCandidate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_selected_socket"
              c:identifier="nice_agent_get_selected_socket"
              version="0.1.5">
        <doc xml:space="preserve">Retreive the local socket associated with the selected candidate pair
for media transmission for a given stream's component.

This is useful for adding ICE support to legacy applications that already
have a protocol that maintains a connection. If the socket is duplicated
before unrefing the agent, the application can take over and continue to use
it. New applications are encouraged to use the built in libnice stream
handling instead and let libnice handle the connection maintenance.

Users of this method are encouraged to not use a TURN relay or any kind
of proxy, as in this case, the socket will not be available to the
application because the packets are encapsulated.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">pointer to the #GSocket, or %NULL if
there is no selected candidate or if the selected candidate is a relayed
candidate.</doc>
          <type name="Gio.Socket" c:type="GSocket*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_stream_name"
              c:identifier="nice_agent_get_stream_name"
              version="0.1.4">
        <doc xml:space="preserve">This function will return the name assigned to a stream.

&lt;para&gt;See also: nice_agent_set_stream_name()&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The name of the stream. The name is only valid while the stream
exists or until it changes through a call to nice_agent_set_stream_name().</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_remote_candidate_sdp"
              c:identifier="nice_agent_parse_remote_candidate_sdp"
              version="0.1.4">
        <doc xml:space="preserve">Parse an SDP string and extracts the candidate from it.

&lt;para&gt;See also: nice_agent_generate_local_candidate_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_stream_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The parsed candidate or %NULL if there was an error.</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream the candidate belongs to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="sdp" transfer-ownership="none">
            <doc xml:space="preserve">The remote SDP to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_remote_sdp"
              c:identifier="nice_agent_parse_remote_sdp"
              version="0.1.4">
        <doc xml:space="preserve">Parse an SDP string and extracts candidates and credentials from it and sets
them on the agent.

 &lt;note&gt;
   &lt;para&gt;
    This function will return an error if a stream has not been assigned a name
    with nice_agent_set_stream_name() as it becomes troublesome to assign the
    streams from the agent to the streams in the SDP.
   &lt;/para&gt;
 &lt;/note&gt;


&lt;para&gt;See also: nice_agent_set_stream_name() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_generate_local_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_candidate_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of candidates added, negative on errors</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="sdp" transfer-ownership="none">
            <doc xml:space="preserve">The remote SDP to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_remote_stream_sdp"
              c:identifier="nice_agent_parse_remote_stream_sdp"
              version="0.1.4">
        <doc xml:space="preserve">Parse an SDP string representing a single stream and extracts candidates
and credentials from it.

&lt;para&gt;See also: nice_agent_generate_local_stream_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp() &lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_candidate_sdp() &lt;/para&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A #GSList of
candidates parsed from the SDP, or %NULL in case of errors</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Candidate"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to parse</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="sdp" transfer-ownership="none">
            <doc xml:space="preserve">The remote SDP to parse</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="ufrag" transfer-ownership="none">
            <doc xml:space="preserve">Pointer to store the ice ufrag if non %NULL. Must be freed with
g_free() after use</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="pwd" transfer-ownership="none">
            <doc xml:space="preserve">Pointer to store the ice password if non %NULL. Must be freed with
g_free() after use</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv"
              c:identifier="nice_agent_recv"
              version="0.1.5"
              throws="1">
        <doc xml:space="preserve">A single-message version of nice_agent_recv_messages().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes written to @buf on success (guaranteed to be
greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote
peer closed the stream, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated buffer
to write the received data into, of length at least @buf_len</doc>
            <array length="3" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="buf_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">length of @buf</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv_messages"
              c:identifier="nice_agent_recv_messages"
              version="0.1.5"
              throws="1">
        <doc xml:space="preserve">Block on receiving data from the given stream/component combination on
@agent, returning only once exactly @n_messages messages have been received
and written into @messages, the stream is closed by the other end or by
calling nice_agent_remove_stream(), or @cancellable is cancelled.

Any STUN packets received will not be added to @messages; instead,
they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
does not poll for messages on its own, it's therefore essential to keep
calling this function for ICE connection establishment to work.

In the non-error case, in reliable mode, this will block until all buffers in
all @n_messages have been filled with received data (i.e. @messages is
treated as a large, flat array of buffers). In non-reliable mode, it will
block until @n_messages messages have been received, each of which does not
have to fill all the buffers in its #NiceInputMessage. In the non-reliable
case, each #NiceInputMessage must have enough buffers to contain an entire
message (65536 bytes), or any excess data may be silently dropped.

For each received message, #NiceInputMessage::length will be set to the
number of valid bytes stored in the messages buffers. The bytes are stored
sequentially in the buffers; there are no gaps apart from at the end of the
buffer array (in non-reliable mode). If non-%NULL on input,
#NiceInputMessage::from will have the address of the sending peer stored in
it. The base addresses, sizes, and number of buffers in each message will not
be modified in any case.

This must not be used in combination with nice_agent_attach_recv() on the
same stream/component pair.

If the stream/component pair doesnt exist, or if a suitable candidate socket
hasnt yet been selected for it, a %G_IO_ERROR_BROKEN_PIPE error will be
returned. A %G_IO_ERROR_CANCELLED error will be returned if the operation was
cancelled. %G_IO_ERROR_FAILED will be returned for other errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of valid messages written to @messages on success
(guaranteed to be greater than 0 unless @n_messages is 0), 0 if the remote
peer closed the stream, or -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="messages"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated
array of #NiceInputMessages to write the received messages into, of length at
least @n_messages</doc>
            <array length="3" zero-terminated="0" c:type="NiceInputMessage*">
              <type name="InputMessage" c:type="NiceInputMessage"/>
            </array>
          </parameter>
          <parameter name="n_messages"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">number of entries in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv_messages_nonblocking"
              c:identifier="nice_agent_recv_messages_nonblocking"
              version="0.1.5"
              throws="1">
        <doc xml:space="preserve">Try to receive data from the given stream/component combination on @agent,
without blocking. If receiving data would block, -1 is returned and
%G_IO_ERROR_WOULD_BLOCK is set in @error. If any other error occurs, -1 is
returned and @error is set accordingly. Otherwise, 0 is returned if (and only
if) @n_messages is 0. In all other cases, the number of valid messages stored
in @messages is returned, and will be greater than 0.

This function behaves similarly to nice_agent_recv_messages(), except that it
will not block on filling (in reliable mode) or receiving (in non-reliable
mode) exactly @n_messages messages. In reliable mode, it will receive bytes
into @messages until it would block; in non-reliable mode, it will receive
messages until it would block.

Any STUN packets received will not be added to @messages; instead,
they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
does not poll for messages on its own, it's therefore essential to keep
calling this function for ICE connection establishment to work.

As this function is non-blocking, @cancellable is included only for parity
with nice_agent_recv_messages(). If @cancellable is cancelled before this
function is called, a %G_IO_ERROR_CANCELLED error will be returned
immediately.

This must not be used in combination with nice_agent_attach_recv() on the
same stream/component pair.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of valid messages written to @messages on success
(guaranteed to be greater than 0 unless @n_messages is 0), 0 if in reliable
mode and the remote peer closed the stream, or -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="messages"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated
array of #NiceInputMessages to write the received messages into, of length at
least @n_messages</doc>
            <array length="3" zero-terminated="0" c:type="NiceInputMessage*">
              <type name="InputMessage" c:type="NiceInputMessage"/>
            </array>
          </parameter>
          <parameter name="n_messages"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">number of entries in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv_nonblocking"
              c:identifier="nice_agent_recv_nonblocking"
              version="0.1.5"
              throws="1">
        <doc xml:space="preserve">A single-message version of nice_agent_recv_messages_nonblocking().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes received into @buf on success (guaranteed to be
greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote
peer closed the stream, or -1 on error</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to receive on</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">caller-allocated buffer
to write the received data into, of length at least @buf_len</doc>
            <array length="3" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="buf_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">length of @buf</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable to allow the operation to be
cancelled from another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_stream" c:identifier="nice_agent_remove_stream">
        <doc xml:space="preserve">Remove and free a previously created data stream from @agent. If any I/O
streams have been created using nice_agent_get_io_stream(), they should be
closed completely using g_io_stream_close() before this is called, or they
will get broken pipe errors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="restart" c:identifier="nice_agent_restart">
        <doc xml:space="preserve">Restarts the session as defined in ICE draft 19. This function
needs to be called both when initiating (ICE spec section 9.1.1.1.
"ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
"Detecting ICE Restart") to a restart.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="restart_stream"
              c:identifier="nice_agent_restart_stream"
              version="0.1.6">
        <doc xml:space="preserve">Restarts a single stream as defined in RFC 5245. This function
needs to be called both when initiating (ICE spec section 9.1.1.1.
"ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
"Detecting ICE Restart") to a restart.

Unlike nice_agent_restart(), this applies to a single stream. It also
does not generate a new tie breaker.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success %FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="send" c:identifier="nice_agent_send">
        <doc xml:space="preserve">Sends a data payload over a stream's component.

 &lt;note&gt;
   &lt;para&gt;
     Component state MUST be NICE_COMPONENT_STATE_READY, or as a special case,
     in any state if component was in READY state before and was then restarted
   &lt;/para&gt;
   &lt;para&gt;
   In reliable mode, the -1 error value means either that you are not yet
   connected or that the send buffer is full (equivalent to EWOULDBLOCK).
   In both cases, you simply need to wait for the
   #NiceAgent::reliable-transport-writable signal to be fired before resending
   the data.
   &lt;/para&gt;
   &lt;para&gt;
   In non-reliable mode, it will virtually never happen with UDP sockets, but
   it might happen if the active candidate is a TURN-TCP connection that got
   disconnected.
   &lt;/para&gt;
   &lt;para&gt;
   In both reliable and non-reliable mode, a -1 error code could also mean that
   the stream_id and/or component_id are invalid.
   &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes sent, or negative error code</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of the buffer to send</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">The buffer of data to send</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_messages_nonblocking"
              c:identifier="nice_agent_send_messages_nonblocking"
              version="0.1.5"
              throws="1">
        <doc xml:space="preserve">Sends multiple messages on the socket identified by the given
stream/component pair. Transmission is non-blocking, so a
%G_IO_ERROR_WOULD_BLOCK error may be returned if the send buffer is full.

As with nice_agent_send(), the given component must be in
%NICE_COMPONENT_STATE_READY or, as a special case, in any state if it was
previously ready and was then restarted.

On success, the number of messages written to the socket will be returned,
which may be less than @n_messages if transmission would have blocked
part-way through. Zero will be returned if @n_messages is zero, or if
transmission would have blocked on the first message.

In reliable mode, it is instead recommended to use
nice_agent_send().  The return value can be less than @n_messages
or 0 even if it is still possible to send a partial message. In
this case, "nice-agent-writable" will never be triggered, so the
application would have to use nice_agent_sent() to fill the buffer or have
to retry sending at a later point.

On failure, -1 will be returned and @error will be set. If the #NiceAgent is
reliable and the socket is not yet connected, %G_IO_ERROR_BROKEN_PIPE will be
returned; if the write buffer is full, %G_IO_ERROR_WOULD_BLOCK will be
returned. In both cases, wait for the #NiceAgent::reliable-transport-writable
signal before trying again. If the given @stream_id or @component_id are
invalid or not yet connected, %G_IO_ERROR_BROKEN_PIPE will be returned.
%G_IO_ERROR_FAILED will be returned for other errors.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of messages sent (may be zero), or -1 on error</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">a #NiceAgent</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the stream to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the component to send to</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="messages" transfer-ownership="none">
            <doc xml:space="preserve">array of messages to send, of at least
@n_messages entries in length</doc>
            <array length="3" zero-terminated="0" c:type="NiceOutputMessage*">
              <type name="OutputMessage" c:type="NiceOutputMessage"/>
            </array>
          </parameter>
          <parameter name="n_messages" transfer-ownership="none">
            <doc xml:space="preserve">number of entries in @messages</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable to cancel the operation from
another thread, or %NULL</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_local_credentials"
              c:identifier="nice_agent_set_local_credentials">
        <doc xml:space="preserve">Sets the local credentials for stream @stream_id.

 &lt;note&gt;
   &lt;para&gt;
     This is only effective before ICE negotiation has started.
   &lt;/para&gt;
 &lt;/note&gt;

Since 0.1.11</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ufrag" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE username fragment
   (length must be between 22 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pwd" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE password
   (length must be between 4 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_port_range" c:identifier="nice_agent_set_port_range">
        <doc xml:space="preserve">Sets a preferred port range for allocating host candidates.
&lt;para&gt;
If a local host candidate cannot be created on that port
range, then the nice_agent_gather_candidates() call will fail.
&lt;/para&gt;
&lt;para&gt;
This MUST be called before nice_agent_gather_candidates()
&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_port" transfer-ownership="none">
            <doc xml:space="preserve">The minimum port to use</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_port" transfer-ownership="none">
            <doc xml:space="preserve">The maximum port to use</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_relay_info" c:identifier="nice_agent_set_relay_info">
        <doc xml:space="preserve">Sets the settings for using a relay server during the candidate discovery.
This may be called multiple times to add multiple relay servers to the
discovery process; one TCP and one UDP, for example.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the TURN settings were accepted.
%FALSE if the address was invalid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="server_ip" transfer-ownership="none">
            <doc xml:space="preserve">The IP address of the TURN server</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="server_port" transfer-ownership="none">
            <doc xml:space="preserve">The port of the TURN server</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:space="preserve">The TURN username to use for the allocate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:space="preserve">The TURN password to use for the allocate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of relay to use</doc>
            <type name="RelayType" c:type="NiceRelayType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_remote_candidates"
              c:identifier="nice_agent_set_remote_candidates">
        <doc xml:space="preserve">Sets, adds or updates the remote candidates for a component of a stream.

 &lt;note&gt;
   &lt;para&gt;
    NICE_AGENT_MAX_REMOTE_CANDIDATES is the absolute maximum limit
    for remote candidates.
   &lt;/para&gt;
   &lt;para&gt;
   You must first call nice_agent_gather_candidates() and wait for the
   #NiceAgent::candidate-gathering-done signale before
   calling nice_agent_set_remote_candidates()
   &lt;/para&gt;
   &lt;para&gt;
    Since 0.1.3, there is no need to wait for the candidate-gathering-done signal.
    Remote candidates can be set even while gathering local candidates.
    Newly discovered local candidates will automatically be paired with
    existing remote candidates.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of candidates added, negative on errors (memory
allocation error or invalid component)</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream the candidates are for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component the candidates are for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="candidates" transfer-ownership="none">
            <doc xml:space="preserve">a #GSList of
#NiceCandidate items describing each candidate to add</doc>
            <type name="GLib.SList" c:type="const GSList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_remote_credentials"
              c:identifier="nice_agent_set_remote_credentials">
        <doc xml:space="preserve">Sets the remote credentials for stream @stream_id.

 &lt;note&gt;
   &lt;para&gt;
     Stream credentials do not override per-candidate credentials if set
   &lt;/para&gt;
   &lt;para&gt;
     Due to the native of peer-reflexive candidates, any agent using a per-stream
     credentials (RFC5245, WLM2009, OC2007R2 and DRAFT19) instead of
     per-candidate credentials (GOOGLE, MSN, OC2007), must
     use the nice_agent_set_remote_credentials() API instead of setting the
     username and password on the candidates.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ufrag" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE username fragment
   (length must be between 22 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="pwd" transfer-ownership="none">
            <doc xml:space="preserve">nul-terminated string containing an ICE password
   (length must be between 4 and 256 chars)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_selected_pair"
              c:identifier="nice_agent_set_selected_pair">
        <doc xml:space="preserve">Sets the selected candidate pair for media transmission
for a given stream's component. Calling this function will
disable all further ICE processing (connection check,
state machine updates, etc). Note that keepalives will
continue to be sent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE if the candidate pair cannot be found</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lfoundation" transfer-ownership="none">
            <doc xml:space="preserve">The local foundation of the candidate to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="rfoundation" transfer-ownership="none">
            <doc xml:space="preserve">The remote foundation of the candidate to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_selected_remote_candidate"
              c:identifier="nice_agent_set_selected_remote_candidate">
        <doc xml:space="preserve">Sets the selected remote candidate for media transmission
for a given stream's component. This is used to force the selection of
a specific remote candidate even when connectivity checks are failing
(e.g. non-ICE compatible candidates).
Calling this function will disable all further ICE processing
(connection check, state machine updates, etc). Note that keepalives will
continue to be sent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the component</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceCandidate to select</doc>
            <type name="Candidate" c:type="NiceCandidate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_software"
              c:identifier="nice_agent_set_software"
              version="0.0.10">
        <doc xml:space="preserve">This function will set the value of the SOFTWARE attribute to be added to
STUN requests, responses and error responses sent during connectivity checks.
&lt;para&gt;
The SOFTWARE attribute will only be added in the #NICE_COMPATIBILITY_RFC5245
and #NICE_COMPATIBILITY_WLM2009 compatibility modes.

&lt;/para&gt;
&lt;note&gt;
     &lt;para&gt;
       The @software argument will be appended with the libnice version before
       being sent.
     &lt;/para&gt;
     &lt;para&gt;
       The @software argument must be in UTF-8 encoding and only the first
       128 characters will be sent.
     &lt;/para&gt;
   &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="software" transfer-ownership="none">
            <doc xml:space="preserve">The value of the SOFTWARE attribute to add.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stream_name"
              c:identifier="nice_agent_set_stream_name"
              version="0.1.4">
        <doc xml:space="preserve">This function will assign a media type to a stream. The only values
that can be used to produce a valid SDP are: "audio", "video",
"text", "application", "image" and "message".

This is only useful when parsing and generating an SDP of the
candidates.

&lt;para&gt;See also: nice_agent_generate_local_sdp()&lt;/para&gt;
&lt;para&gt;See also: nice_agent_parse_remote_sdp()&lt;/para&gt;
&lt;para&gt;See also: nice_agent_get_stream_name()&lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the name has been set. %FALSE in case of error
(invalid stream or duplicate name).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream to change</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The new name of the stream or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stream_tos"
              c:identifier="nice_agent_set_stream_tos"
              version="0.0.9">
        <doc xml:space="preserve">Sets the IP_TOS and/or IPV6_TCLASS field on the stream's sockets' options</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="agent" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceAgent Object</doc>
            <type name="Agent" c:type="NiceAgent*"/>
          </instance-parameter>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:space="preserve">The ID of the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="tos" transfer-ownership="none">
            <doc xml:space="preserve">The ToS to set</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <property name="bytestream-tcp" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="compatibility"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="controlling-mode" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="full-mode"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ice-tcp" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="ice-udp" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="keepalive-conncheck"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="main-context"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="max-connectivity-checks"
                writable="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="proxy-ip" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="proxy-password" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="proxy-port" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="proxy-type" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="proxy-username" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="reliable"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="stun-pacing-timer"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="stun-server" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="stun-server-port" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="upnp"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="upnp-timeout"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <glib:signal name="candidate-gathering-done" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="component-state-changed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="initial-binding-request-received" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-candidate" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-candidate-full" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-remote-candidate" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-remote-candidate-full" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-selected-pair" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-selected-pair-full" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p1" transfer-ownership="none">
            <type name="Candidate"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="reliable-transport-writable" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p0" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="streams-removed" when="last" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AgentClass"
            c:type="NiceAgentClass"
            glib:is-gtype-struct-for="Agent">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <callback name="AgentRecvFunc" c:type="NiceAgentRecvFunc">
      <doc xml:space="preserve">Callback function when data is received on a component</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="agent" transfer-ownership="none">
          <doc xml:space="preserve">The #NiceAgent Object</doc>
          <type name="Agent" c:type="NiceAgent*"/>
        </parameter>
        <parameter name="stream_id" transfer-ownership="none">
          <doc xml:space="preserve">The id of the stream</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="component_id" transfer-ownership="none">
          <doc xml:space="preserve">The id of the component of the stream
       which received the data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">The length of the data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve">The buffer containing the data received</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="5">
          <doc xml:space="preserve">The user data set in nice_agent_attach_recv()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="CANDIDATE_DIRECTION_MS_PREF_ACTIVE"
              value="5"
              c:type="NICE_CANDIDATE_DIRECTION_MS_PREF_ACTIVE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_DIRECTION_MS_PREF_PASSIVE"
              value="2"
              c:type="NICE_CANDIDATE_DIRECTION_MS_PREF_PASSIVE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_MAX_FOUNDATION"
              value="33"
              c:type="NICE_CANDIDATE_MAX_FOUNDATION">
      <doc xml:space="preserve">The maximum size a candidate foundation can have.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TRANSPORT_MS_PREF_TCP"
              value="6"
              c:type="NICE_CANDIDATE_TRANSPORT_MS_PREF_TCP">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TRANSPORT_MS_PREF_UDP"
              value="15"
              c:type="NICE_CANDIDATE_TRANSPORT_MS_PREF_UDP">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TYPE_PREF_HOST"
              value="120"
              c:type="NICE_CANDIDATE_TYPE_PREF_HOST">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TYPE_PREF_NAT_ASSISTED"
              value="105"
              c:type="NICE_CANDIDATE_TYPE_PREF_NAT_ASSISTED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TYPE_PREF_PEER_REFLEXIVE"
              value="110"
              c:type="NICE_CANDIDATE_TYPE_PREF_PEER_REFLEXIVE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TYPE_PREF_RELAYED"
              value="10"
              c:type="NICE_CANDIDATE_TYPE_PREF_RELAYED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TYPE_PREF_SERVER_REFLEXIVE"
              value="100"
              c:type="NICE_CANDIDATE_TYPE_PREF_SERVER_REFLEXIVE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CANDIDATE_TYPE_PREF_UDP_TUNNELED"
              value="75"
              c:type="NICE_CANDIDATE_TYPE_PREF_UDP_TUNNELED">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Candidate"
            c:type="NiceCandidate"
            glib:type-name="NiceCandidate"
            glib:get-type="nice_candidate_get_type"
            c:symbol-prefix="candidate">
      <doc xml:space="preserve">A structure to represent an ICE candidate
 &lt;note&gt;
   &lt;para&gt;
   The @priority is an integer as specified in the ICE draft 19. If you are
   using the MSN or the GOOGLE compatibility mode (which are based on ICE
   draft 6, which uses a floating point qvalue as priority), then the @priority
   value will represent the qvalue multiplied by 1000.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">The type of candidate</doc>
        <type name="CandidateType" c:type="NiceCandidateType"/>
      </field>
      <field name="transport" writable="1">
        <doc xml:space="preserve">The transport being used for the candidate</doc>
        <type name="CandidateTransport" c:type="NiceCandidateTransport"/>
      </field>
      <field name="addr" writable="1">
        <doc xml:space="preserve">The #NiceAddress of the candidate</doc>
        <type name="Address" c:type="NiceAddress"/>
      </field>
      <field name="base_addr" writable="1">
        <doc xml:space="preserve">The #NiceAddress of the base address used by the candidate</doc>
        <type name="Address" c:type="NiceAddress"/>
      </field>
      <field name="priority" writable="1">
        <doc xml:space="preserve">The priority of the candidate &lt;emphasis&gt; see note &lt;/emphasis&gt;</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="stream_id" writable="1">
        <doc xml:space="preserve">The ID of the stream to which belongs the candidate</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="component_id" writable="1">
        <doc xml:space="preserve">The ID of the component to which belongs the candidate</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="foundation" writable="1">
        <doc xml:space="preserve">The foundation of the candidate</doc>
        <array zero-terminated="0" c:type="gchar" fixed-size="33">
          <type name="gchar" c:type="gchar"/>
        </array>
      </field>
      <field name="username" writable="1">
        <doc xml:space="preserve">The candidate-specific username to use (overrides the one set
by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="password" writable="1">
        <doc xml:space="preserve">The candidate-specific password to use (overrides the one set
by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="turn" writable="1">
        <doc xml:space="preserve">The #TurnServer settings if the candidate is
of type %NICE_CANDIDATE_TYPE_RELAYED</doc>
        <type name="TurnServer" c:type="TurnServer*"/>
      </field>
      <field name="sockptr" writable="1">
        <doc xml:space="preserve">The underlying socket</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new" c:identifier="nice_candidate_new">
        <doc xml:space="preserve">Creates a new candidate. Must be freed with nice_candidate_free()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #NiceCandidate</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The #NiceCandidateType of the candidate to create</doc>
            <type name="CandidateType" c:type="NiceCandidateType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="nice_candidate_copy">
        <doc xml:space="preserve">Makes a copy of a #NiceCandidate</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #NiceCandidate, a copy of @candidate</doc>
          <type name="Candidate" c:type="NiceCandidate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The candidate to copy</doc>
            <type name="Candidate" c:type="const NiceCandidate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="nice_candidate_free">
        <doc xml:space="preserve">Frees a #NiceCandidate</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="candidate" transfer-ownership="none">
            <doc xml:space="preserve">The candidate to free</doc>
            <type name="Candidate" c:type="NiceCandidate*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="CandidateTransport" c:type="NiceCandidateTransport">
      <doc xml:space="preserve">An enum representing the type of transport to use</doc>
      <member name="udp" value="0" c:identifier="NICE_CANDIDATE_TRANSPORT_UDP">
        <doc xml:space="preserve">UDP transport</doc>
      </member>
      <member name="tcp_active"
              value="1"
              c:identifier="NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE">
        <doc xml:space="preserve">TCP Active transport</doc>
      </member>
      <member name="tcp_passive"
              value="2"
              c:identifier="NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE">
        <doc xml:space="preserve">TCP Passive transport</doc>
      </member>
      <member name="tcp_so"
              value="3"
              c:identifier="NICE_CANDIDATE_TRANSPORT_TCP_SO">
        <doc xml:space="preserve">TCP Simultaneous-Open transport</doc>
      </member>
    </enumeration>
    <enumeration name="CandidateType" c:type="NiceCandidateType">
      <doc xml:space="preserve">An enum represneting the type of a candidate</doc>
      <member name="host" value="0" c:identifier="NICE_CANDIDATE_TYPE_HOST">
        <doc xml:space="preserve">A host candidate</doc>
      </member>
      <member name="server_reflexive"
              value="1"
              c:identifier="NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE">
        <doc xml:space="preserve">A server reflexive candidate</doc>
      </member>
      <member name="peer_reflexive"
              value="2"
              c:identifier="NICE_CANDIDATE_TYPE_PEER_REFLEXIVE">
        <doc xml:space="preserve">A peer reflexive candidate</doc>
      </member>
      <member name="relayed"
              value="3"
              c:identifier="NICE_CANDIDATE_TYPE_RELAYED">
        <doc xml:space="preserve">A relay candidate</doc>
      </member>
    </enumeration>
    <enumeration name="Compatibility" c:type="NiceCompatibility">
      <doc xml:space="preserve">An enum to specify which compatible specifications the #NiceAgent should use.
Use with nice_agent_new()

&lt;warning&gt;@NICE_COMPATIBILITY_DRAFT19 is deprecated and should not be used
in newly-written code. It is kept for compatibility reasons and
represents the same compatibility as @NICE_COMPATIBILITY_RFC5245 &lt;/warning&gt;
 &lt;note&gt;
   &lt;para&gt;
   If @NICE_COMPATIBILITY_RFC5245 compatibility mode is used for a non-reliable
   agent, then ICE-UDP will be used with higher priority and ICE-TCP will also
   be used when the UDP connectivity fails. If it is used with a reliable agent,
   then ICE-UDP will be used with the TCP-Over-UDP (#PseudoTcpSocket) if ICE-TCP
   fails and ICE-UDP succeeds.
  &lt;/para&gt;
 &lt;/note&gt;</doc>
      <member name="rfc5245"
              value="0"
              c:identifier="NICE_COMPATIBILITY_RFC5245">
        <doc xml:space="preserve">Use compatibility with the RFC5245 ICE-UDP specs
and RFC6544 ICE-TCP specs</doc>
      </member>
      <member name="draft19"
              value="0"
              c:identifier="NICE_COMPATIBILITY_DRAFT19">
        <doc xml:space="preserve">Use compatibility for ICE Draft 19 specs</doc>
      </member>
      <member name="google" value="1" c:identifier="NICE_COMPATIBILITY_GOOGLE">
        <doc xml:space="preserve">Use compatibility for Google Talk specs</doc>
      </member>
      <member name="msn" value="2" c:identifier="NICE_COMPATIBILITY_MSN">
        <doc xml:space="preserve">Use compatibility for MSN Messenger specs</doc>
      </member>
      <member name="wlm2009"
              value="3"
              c:identifier="NICE_COMPATIBILITY_WLM2009">
        <doc xml:space="preserve">Use compatibility with Windows Live Messenger
2009</doc>
      </member>
      <member name="oc2007" value="4" c:identifier="NICE_COMPATIBILITY_OC2007">
        <doc xml:space="preserve">Use compatibility with Microsoft Office Communicator 2007</doc>
      </member>
      <member name="oc2007r2"
              value="5"
              c:identifier="NICE_COMPATIBILITY_OC2007R2">
        <doc xml:space="preserve">Use compatibility with Microsoft Office Communicator 2007 R2</doc>
      </member>
      <member name="last" value="5" c:identifier="NICE_COMPATIBILITY_LAST">
        <doc xml:space="preserve">Dummy last compatibility mode</doc>
      </member>
    </enumeration>
    <enumeration name="ComponentState" c:type="NiceComponentState">
      <doc xml:space="preserve">An enum representing the state of a component.
&lt;para&gt; See also: #NiceAgent::component-state-changed &lt;/para&gt;</doc>
      <member name="disconnected"
              value="0"
              c:identifier="NICE_COMPONENT_STATE_DISCONNECTED">
        <doc xml:space="preserve">No activity scheduled</doc>
      </member>
      <member name="gathering"
              value="1"
              c:identifier="NICE_COMPONENT_STATE_GATHERING">
        <doc xml:space="preserve">Gathering local candidates</doc>
      </member>
      <member name="connecting"
              value="2"
              c:identifier="NICE_COMPONENT_STATE_CONNECTING">
        <doc xml:space="preserve">Establishing connectivity</doc>
      </member>
      <member name="connected"
              value="3"
              c:identifier="NICE_COMPONENT_STATE_CONNECTED">
        <doc xml:space="preserve">At least one working candidate pair</doc>
      </member>
      <member name="ready" value="4" c:identifier="NICE_COMPONENT_STATE_READY">
        <doc xml:space="preserve">ICE concluded, candidate pair selection
is now final</doc>
      </member>
      <member name="failed"
              value="5"
              c:identifier="NICE_COMPONENT_STATE_FAILED">
        <doc xml:space="preserve">Connectivity checks have been completed,
but connectivity was not established</doc>
      </member>
      <member name="last" value="6" c:identifier="NICE_COMPONENT_STATE_LAST">
        <doc xml:space="preserve">Dummy state</doc>
      </member>
    </enumeration>
    <enumeration name="ComponentType" c:type="NiceComponentType">
      <doc xml:space="preserve">Convenience enum representing the type of a component for use as the
component_id for RTP/RTCP usages.
 &lt;example&gt;
   &lt;title&gt;Example of use.&lt;/title&gt;
   &lt;programlisting&gt;
   nice_agent_send (agent, stream_id, NICE_COMPONENT_TYPE_RTP, len, buf);
   &lt;/programlisting&gt;
  &lt;/example&gt;</doc>
      <member name="rtp" value="1" c:identifier="NICE_COMPONENT_TYPE_RTP">
        <doc xml:space="preserve">RTP Component type</doc>
      </member>
      <member name="rtcp" value="2" c:identifier="NICE_COMPONENT_TYPE_RTCP">
        <doc xml:space="preserve">RTCP Component type</doc>
      </member>
    </enumeration>
    <record name="InputMessage" c:type="NiceInputMessage" version="0.1.5">
      <doc xml:space="preserve">Represents a single message received off the network. For reliable
connections, this is essentially just an array of buffers (specifically,
@from can be ignored). for non-reliable connections, it represents a single
packet as received from the OS.

@n_buffers may be -1 to indicate that @buffers is terminated by a
#GInputVector with a %NULL buffer pointer.

By providing arrays of #NiceInputMessages to functions like
nice_agent_recv_messages(), multiple messages may be received with a single
call, which is more efficient than making multiple calls in a loop. In this
manner, nice_agent_recv_messages() is analogous to recvmmsg(); and
#NiceInputMessage to struct mmsghdr.</doc>
      <field name="buffers" writable="1">
        <doc xml:space="preserve">unowned array of #GInputVector buffers to
store data in for this message</doc>
        <array length="1" zero-terminated="0" c:type="GInputVector*">
          <type name="Gio.InputVector" c:type="GInputVector"/>
        </array>
      </field>
      <field name="n_buffers" writable="1">
        <doc xml:space="preserve">number of #GInputVectors in @buffers, or -1 to indicate @buffers
is %NULL-terminated</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="from" writable="1">
        <doc xml:space="preserve">return location to store the address of the peer who
transmitted the message, or %NULL</doc>
        <type name="Address" c:type="NiceAddress*"/>
      </field>
      <field name="length" writable="1">
        <doc xml:space="preserve">total number of valid bytes contiguously stored in @buffers</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
    </record>
    <record name="OutputMessage" c:type="NiceOutputMessage" version="0.1.5">
      <doc xml:space="preserve">Represents a single message to transmit on the network. For
reliable connections, this is essentially just an array of
buffer. for non-reliable connections, it represents a single packet
to send to the OS.

@n_buffers may be -1 to indicate that @buffers is terminated by a
#GOutputVector with a %NULL buffer pointer.

By providing arrays of #NiceOutputMessages to functions like
nice_agent_send_messages_nonblocking(), multiple messages may be transmitted
with a single call, which is more efficient than making multiple calls in a
loop. In this manner, nice_agent_send_messages_nonblocking() is analogous to
sendmmsg(); and #NiceOutputMessage to struct mmsghdr.</doc>
      <field name="buffers" writable="1">
        <doc xml:space="preserve">unowned array of #GOutputVector buffers
which contain data to transmit for this message</doc>
        <array length="1" zero-terminated="0" c:type="GOutputVector*">
          <type name="Gio.OutputVector" c:type="GOutputVector"/>
        </array>
      </field>
      <field name="n_buffers" writable="1">
        <doc xml:space="preserve">number of #GOutputVectors in @buffers, or -1 to indicate @buffers
is %NULL-terminated</doc>
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <enumeration name="ProxyType" version="0.0.4" c:type="NiceProxyType">
      <doc xml:space="preserve">An enum to specify which proxy type to use for relaying.
Note that the proxies will only be used with TCP TURN relaying.
&lt;para&gt; See also: #NiceAgent:proxy-type &lt;/para&gt;</doc>
      <member name="none" value="0" c:identifier="NICE_PROXY_TYPE_NONE">
        <doc xml:space="preserve">Do not use a proxy</doc>
      </member>
      <member name="socks5" value="1" c:identifier="NICE_PROXY_TYPE_SOCKS5">
        <doc xml:space="preserve">Use a SOCKS5 proxy</doc>
      </member>
      <member name="http" value="2" c:identifier="NICE_PROXY_TYPE_HTTP">
        <doc xml:space="preserve">Use an HTTP proxy</doc>
      </member>
      <member name="last" value="2" c:identifier="NICE_PROXY_TYPE_LAST">
        <doc xml:space="preserve">Dummy last proxy type</doc>
      </member>
    </enumeration>
    <record name="PseudoTcpCallbacks"
            c:type="PseudoTcpCallbacks"
            version="0.0.11">
      <doc xml:space="preserve">A structure containing callbacks functions that will be called by the
#PseudoTcpSocket when some events happen.
&lt;para&gt; See also: #PseudoTcpWriteResult &lt;/para&gt;</doc>
      <field name="user_data" writable="1">
        <doc xml:space="preserve">A user defined pointer to be passed to the callbacks</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="PseudoTcpOpened">
        <callback name="PseudoTcpOpened">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="PseudoTcpReadable">
        <callback name="PseudoTcpReadable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="PseudoTcpWritable">
        <callback name="PseudoTcpWritable">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="PseudoTcpClosed">
        <callback name="PseudoTcpClosed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="guint32" c:type="guint32"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="WritePacket">
        <callback name="WritePacket">
          <return-value transfer-ownership="none">
            <type name="PseudoTcpWriteResult" c:type="PseudoTcpWriteResult"/>
          </return-value>
          <parameters>
            <parameter name="tcp" transfer-ownership="none">
              <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <type name="guint32" c:type="guint32"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="PseudoTcpDebugLevel"
                 version="0.0.11"
                 c:type="PseudoTcpDebugLevel">
      <doc xml:space="preserve">Valid values of debug levels to be set.</doc>
      <member name="none" value="0" c:identifier="PSEUDO_TCP_DEBUG_NONE">
        <doc xml:space="preserve">Disable debug messages</doc>
      </member>
      <member name="normal" value="1" c:identifier="PSEUDO_TCP_DEBUG_NORMAL">
        <doc xml:space="preserve">Enable basic debug messages</doc>
      </member>
      <member name="verbose" value="2" c:identifier="PSEUDO_TCP_DEBUG_VERBOSE">
        <doc xml:space="preserve">Enable verbose debug messages</doc>
      </member>
    </enumeration>
    <enumeration name="PseudoTcpShutdown"
                 version="0.1.8"
                 c:type="PseudoTcpShutdown">
      <doc xml:space="preserve">Options for which parts of a connection to shut down when calling
pseudo_tcp_socket_shutdown(). These correspond to the values passed to POSIX
shutdown().</doc>
      <member name="rd" value="0" c:identifier="PSEUDO_TCP_SHUTDOWN_RD">
        <doc xml:space="preserve">Shut down the local reader only</doc>
      </member>
      <member name="wr" value="1" c:identifier="PSEUDO_TCP_SHUTDOWN_WR">
        <doc xml:space="preserve">Shut down the local writer only</doc>
      </member>
      <member name="rdwr" value="2" c:identifier="PSEUDO_TCP_SHUTDOWN_RDWR">
        <doc xml:space="preserve">Shut down both reading and writing</doc>
      </member>
    </enumeration>
    <class name="PseudoTcpSocket"
           c:symbol-prefix="pseudo_tcp_socket"
           c:type="PseudoTcpSocket"
           version="0.0.11"
           parent="GObject.Object"
           glib:type-name="PseudoTcpSocket"
           glib:get-type="pseudo_tcp_socket_get_type"
           glib:type-struct="PseudoTcpSocketClass">
      <doc xml:space="preserve">The #PseudoTcpSocket is the GObject implementing the Pseudo TCP Socket</doc>
      <constructor name="new"
                   c:identifier="pseudo_tcp_socket_new"
                   version="0.0.11">
        <doc xml:space="preserve">Creates a new #PseudoTcpSocket for the specified conversation

 &lt;note&gt;
   &lt;para&gt;
     The @callbacks must be non-NULL, in order to get notified of packets the
     socket needs to send.
   &lt;/para&gt;
   &lt;para&gt;
     If the @callbacks structure was dynamicly allocated, it can be freed
     after the call @pseudo_tcp_socket_new
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new #PseudoTcpSocket object, %NULL on error</doc>
          <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
        </return-value>
        <parameters>
          <parameter name="conversation" transfer-ownership="none">
            <doc xml:space="preserve">The conversation id for the socket.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="callbacks" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to the #PseudoTcpCallbacks structure for getting
notified of the #PseudoTcpSocket events.</doc>
            <type name="PseudoTcpCallbacks" c:type="PseudoTcpCallbacks*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="can_send"
              c:identifier="pseudo_tcp_socket_can_send"
              version="0.1.5">
        <doc xml:space="preserve">Returns if there is space in the send buffer to send any data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if data can be sent, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close"
              c:identifier="pseudo_tcp_socket_close"
              version="0.0.11">
        <doc xml:space="preserve">Close the socket for sending. If @force is set to %FALSE, the socket will
finish sending pending data before closing. If it is set to %TRUE, the socket
will discard pending data and close the connection immediately (sending a TCP
RST segment).

The socket will be closed in both directions  sending and receiving  and
any pending received data must be read before calling this function, by
calling pseudo_tcp_socket_recv() until it blocks. If any pending data is in
the receive buffer when pseudo_tcp_socket_close() is called, a TCP RST
segment will be sent to the peer to notify it of the data loss.

 &lt;note&gt;
   &lt;para&gt;
     The %PseudoTcpCallbacks:PseudoTcpClosed callback will not be called once
     the socket gets closed. It is only used for aborted connection.
     Instead, the socket gets closed when the pseudo_tcp_socket_get_next_clock()
     function returns FALSE.
   &lt;/para&gt;
 &lt;/note&gt;

&lt;para&gt; See also: pseudo_tcp_socket_get_next_clock() &lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="force" transfer-ownership="none">
            <doc xml:space="preserve">%TRUE to close the socket forcefully, %FALSE to close it gracefully</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect"
              c:identifier="pseudo_tcp_socket_connect"
              version="0.0.11">
        <doc xml:space="preserve">Connects the #PseudoTcpSocket to the peer with the same conversation id.
The connection will only be successful after the
%PseudoTcpCallbacks:PseudoTcpOpened callback is called</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on failure (not in %TCP_LISTEN state)
&lt;para&gt; See also: pseudo_tcp_socket_get_error() &lt;/para&gt;</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_available_bytes"
              c:identifier="pseudo_tcp_socket_get_available_bytes"
              version="0.1.5">
        <doc xml:space="preserve">Gets the number of bytes of data in the buffer that can be read without
receiving more packets from the network.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes or -1 if the connection is not established</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_available_send_space"
              c:identifier="pseudo_tcp_socket_get_available_send_space"
              version="0.1.5">
        <doc xml:space="preserve">Gets the number of bytes of space available in the transmission buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes, or 0 if the connection is not established.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_error"
              c:identifier="pseudo_tcp_socket_get_error"
              version="0.0.11">
        <doc xml:space="preserve">Return the last encountered error.

 &lt;note&gt;
   &lt;para&gt;
     The return value can be :
     &lt;para&gt;
       EINVAL (for pseudo_tcp_socket_connect()).
     &lt;/para&gt;
     &lt;para&gt;
       EWOULDBLOCK or ENOTCONN (for pseudo_tcp_socket_recv() and
       pseudo_tcp_socket_send()).
     &lt;/para&gt;
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The error code
&lt;para&gt; See also: pseudo_tcp_socket_connect() &lt;/para&gt;
&lt;para&gt; See also: pseudo_tcp_socket_recv() &lt;/para&gt;
&lt;para&gt; See also: pseudo_tcp_socket_send() &lt;/para&gt;</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_next_clock"
              c:identifier="pseudo_tcp_socket_get_next_clock"
              version="0.0.11">
        <doc xml:space="preserve">Call this to determine the timeout needed before the next time call
to pseudo_tcp_socket_notify_clock() should be made.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @timeout was filled, %FALSE if the socket is closed and
ready to be destroyed.

&lt;para&gt; See also: pseudo_tcp_socket_notify_clock() &lt;/para&gt;</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to be filled with the new timeout.</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_closed"
              c:identifier="pseudo_tcp_socket_is_closed"
              version="0.1.8">
        <doc xml:space="preserve">Gets whether the socket is closed, with the shutdown handshake completed,
and both peers no longer able to read or write data to the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the socket is closed in both directions, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_closed_remotely"
              c:identifier="pseudo_tcp_socket_is_closed_remotely"
              version="0.1.8">
        <doc xml:space="preserve">Gets whether the socket has been closed on the remote peers side of the
connection (i.e. whether pseudo_tcp_socket_close() has been called there).
This is guaranteed to return %TRUE if pseudo_tcp_socket_is_closed() returns
%TRUE. It will not return %TRUE after pseudo_tcp_socket_close() is called
until a FIN segment is received from the remote peer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the remote peer has closed its side of the connection,
%FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="notify_clock"
              c:identifier="pseudo_tcp_socket_notify_clock"
              version="0.0.11">
        <doc xml:space="preserve">Start the processing of receiving data, pending data or syn/acks.
Call this based on timeout value returned by
pseudo_tcp_socket_get_next_clock().
It's ok to call this too frequently.

&lt;para&gt; See also: pseudo_tcp_socket_get_next_clock() &lt;/para&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="notify_message"
              c:identifier="pseudo_tcp_socket_notify_message"
              version="0.1.5">
        <doc xml:space="preserve">Notify the #PseudoTcpSocket that a new message has arrived, and enqueue the
data in its buffers to the #PseudoTcpSockets receive buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the packet was processed successfully, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">A #NiceInputMessage containing the received data.</doc>
            <type name="InputMessage" c:type="NiceInputMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify_mtu"
              c:identifier="pseudo_tcp_socket_notify_mtu"
              version="0.0.11">
        <doc xml:space="preserve">Set the MTU of the socket</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="mtu" transfer-ownership="none">
            <doc xml:space="preserve">The new MTU of the socket</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify_packet"
              c:identifier="pseudo_tcp_socket_notify_packet"
              version="0.0.11">
        <doc xml:space="preserve">Notify the #PseudoTcpSocket when a new packet arrives</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the packet was processed successfully, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer containing the received data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="recv"
              c:identifier="pseudo_tcp_socket_recv"
              version="0.0.11">
        <doc xml:space="preserve">Receive data from the socket.

 &lt;note&gt;
   &lt;para&gt;
     Only call this on the %PseudoTcpCallbacks:PseudoTcpReadable callback.
   &lt;/para&gt;
   &lt;para&gt;
     This function should be called in a loop. If this function does not
     return -1 with EWOULDBLOCK as the error, the
     %PseudoTcpCallbacks:PseudoTcpReadable callback will not be called again.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes received or -1 in case of error
&lt;para&gt; See also: pseudo_tcp_socket_get_error() &lt;/para&gt;</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer to fill with received data</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="send"
              c:identifier="pseudo_tcp_socket_send"
              version="0.0.11">
        <doc xml:space="preserve">Send data on the socket.

 &lt;note&gt;
   &lt;para&gt;
     If this function return -1 with EWOULDBLOCK as the error, or if the return
     value is lower than @len, then the %PseudoTcpCallbacks:PseudoTcpWritable
     callback will be called when the socket will become writable.
   &lt;/para&gt;
 &lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of bytes sent or -1 in case of error
&lt;para&gt; See also: pseudo_tcp_socket_get_error() &lt;/para&gt;</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">The buffer with data to send</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">The length of @buffer</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_time"
              c:identifier="pseudo_tcp_socket_set_time"
              version="0.1.8">
        <doc xml:space="preserve">Sets the current monotonic time to be used by the TCP socket when calculating
timeouts and expiry times. If this function is not called, or is called with
@current_time as zero, g_get_monotonic_time() will be used. Otherwise, the
specified @current_time will be used until it is updated by calling this
function again.

This function is intended for testing only, and should not be used in
production code.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="current_time" transfer-ownership="none">
            <doc xml:space="preserve">Current monotonic time, in milliseconds; or zero to use the
system monotonic clock.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="shutdown"
              c:identifier="pseudo_tcp_socket_shutdown"
              version="0.1.8">
        <doc xml:space="preserve">Shut down sending, receiving, or both on the socket, depending on the value
of @how. The behaviour of pseudo_tcp_socket_send() and
pseudo_tcp_socket_recv() will immediately change after this function returns
(depending on the value of @how), though the socket may continue to process
network traffic in the background even if sending or receiving data is
forbidden.

This is equivalent to the POSIX shutdown() function. Setting @how to
%PSEUDO_TCP_SHUTDOWN_RDWR is equivalent to calling pseudo_tcp_socket_close().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #PseudoTcpSocket object.</doc>
            <type name="PseudoTcpSocket" c:type="PseudoTcpSocket*"/>
          </instance-parameter>
          <parameter name="how" transfer-ownership="none">
            <doc xml:space="preserve">The directions of the connection to shut down.</doc>
            <type name="PseudoTcpShutdown" c:type="PseudoTcpShutdown"/>
          </parameter>
        </parameters>
      </method>
      <property name="ack-delay" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="callbacks" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="conversation"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="no-delay" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="rcv-buf" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="snd-buf" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="state" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="support-fin-ack"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="PseudoTcpSocketPrivate" c:type="PseudoTcpSocketPrivate*"/>
      </field>
    </class>
    <record name="PseudoTcpSocketClass"
            c:type="PseudoTcpSocketClass"
            glib:is-gtype-struct-for="PseudoTcpSocket">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="PseudoTcpSocketPrivate"
            c:type="PseudoTcpSocketPrivate"
            disguised="1">
    </record>
    <enumeration name="PseudoTcpState"
                 version="0.0.11"
                 c:type="PseudoTcpState">
      <doc xml:space="preserve">An enum representing the state of the #PseudoTcpSocket. These states
correspond to the TCP states in RFC 793.
&lt;para&gt; See also: #PseudoTcpSocket:state &lt;/para&gt;</doc>
      <member name="listen" value="0" c:identifier="TCP_LISTEN">
        <doc xml:space="preserve">The socket's initial state. The socket isn't connected and is
listening for an incoming connection</doc>
      </member>
      <member name="syn_sent" value="1" c:identifier="TCP_SYN_SENT">
        <doc xml:space="preserve">The socket has sent a connection request (SYN) packet and is
waiting for an answer</doc>
      </member>
      <member name="syn_received" value="2" c:identifier="TCP_SYN_RECEIVED">
        <doc xml:space="preserve">The socket has received a connection request (SYN) packet.</doc>
      </member>
      <member name="established" value="3" c:identifier="TCP_ESTABLISHED">
        <doc xml:space="preserve">The socket is connected</doc>
      </member>
      <member name="closed" value="4" c:identifier="TCP_CLOSED">
        <doc xml:space="preserve">The socket has been closed</doc>
      </member>
      <member name="fin_wait_1" value="5" c:identifier="TCP_FIN_WAIT_1">
        <doc xml:space="preserve">The socket has been closed locally but not remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="fin_wait_2" value="6" c:identifier="TCP_FIN_WAIT_2">
        <doc xml:space="preserve">The socket has been closed locally but not remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="closing" value="7" c:identifier="TCP_CLOSING">
        <doc xml:space="preserve">The socket has been closed locally and remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="time_wait" value="8" c:identifier="TCP_TIME_WAIT">
        <doc xml:space="preserve">The socket has been closed locally and remotely
(Since: 0.1.8)</doc>
      </member>
      <member name="close_wait" value="9" c:identifier="TCP_CLOSE_WAIT">
        <doc xml:space="preserve">The socket has been closed remotely but not locally
(Since: 0.1.8)</doc>
      </member>
      <member name="last_ack" value="10" c:identifier="TCP_LAST_ACK">
        <doc xml:space="preserve">The socket has been closed locally and remotely
(Since: 0.1.8)</doc>
      </member>
    </enumeration>
    <enumeration name="PseudoTcpWriteResult"
                 version="0.0.11"
                 c:type="PseudoTcpWriteResult">
      <doc xml:space="preserve">An enum representing the result value of the write operation requested by
the #PseudoTcpSocket.
&lt;para&gt; See also: %PseudoTcpCallbacks:WritePacket &lt;/para&gt;</doc>
      <member name="success" value="0" c:identifier="WR_SUCCESS">
        <doc xml:space="preserve">The write operation was successful</doc>
      </member>
      <member name="too_large" value="1" c:identifier="WR_TOO_LARGE">
        <doc xml:space="preserve">The socket type requires that message be sent atomically
and the size of the message to be sent made this impossible.</doc>
      </member>
      <member name="fail" value="2" c:identifier="WR_FAIL">
        <doc xml:space="preserve">There was an error sending the message</doc>
      </member>
    </enumeration>
    <enumeration name="RelayType" c:type="NiceRelayType">
      <doc xml:space="preserve">An enum representing the type of relay to use</doc>
      <member name="udp" value="0" c:identifier="NICE_RELAY_TYPE_TURN_UDP">
        <doc xml:space="preserve">A TURN relay using UDP</doc>
      </member>
      <member name="tcp" value="1" c:identifier="NICE_RELAY_TYPE_TURN_TCP">
        <doc xml:space="preserve">A TURN relay using TCP</doc>
      </member>
      <member name="tls" value="2" c:identifier="NICE_RELAY_TYPE_TURN_TLS">
        <doc xml:space="preserve">A TURN relay using TLS over TCP</doc>
      </member>
    </enumeration>
    <record name="TurnServer" c:type="TurnServer">
      <doc xml:space="preserve">A structure to store the TURN relay settings</doc>
      <field name="ref_count" writable="1">
        <doc xml:space="preserve">Reference count for the structure.</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="server" writable="1">
        <doc xml:space="preserve">The #NiceAddress of the TURN server</doc>
        <type name="Address" c:type="NiceAddress"/>
      </field>
      <field name="username" writable="1">
        <doc xml:space="preserve">The TURN username</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="password" writable="1">
        <doc xml:space="preserve">The TURN password</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="type" writable="1">
        <doc xml:space="preserve">The #NiceRelayType of the server</doc>
        <type name="RelayType" c:type="NiceRelayType"/>
      </field>
    </record>
    <function name="component_state_to_string"
              c:identifier="nice_component_state_to_string"
              version="0.1.6">
      <doc xml:space="preserve">Returns a string representation of the state, generally to use in debug
messages.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a string representation of @state</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="state" transfer-ownership="none">
          <doc xml:space="preserve">a #NiceComponentState</doc>
          <type name="ComponentState" c:type="NiceComponentState"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_disable" c:identifier="nice_debug_disable">
      <doc xml:space="preserve">Disables libnice debug output to the terminal</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="with_stun" transfer-ownership="none">
          <doc xml:space="preserve">Also disable stun debugging messages</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_enable" c:identifier="nice_debug_enable">
      <doc xml:space="preserve">Enables libnice debug output to the terminal. Note that the
`G_MESSAGES_DEBUG` and `NICE_DEBUG` environment variables must be set to the
set of logging domains to print, in order for any output to be printed. Set
them to `all` to print all debugging messages, or any of the following
domains:
- `libnice-stun`
- `libnice-tests`
- `libnice-socket`
- `libnice`
- `libnice-pseudotcp`
- `libnice-pseudotcp-verbose`</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="with_stun" transfer-ownership="none">
          <doc xml:space="preserve">Also enable STUN debugging messages</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="interfaces_get_ip_for_interface"
              c:identifier="nice_interfaces_get_ip_for_interface">
      <doc xml:space="preserve">Retrieves the IP address of an interface by its name. If this fails, %NULL
is returned.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a newly-allocated string with the IP
address</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="interface_name" transfer-ownership="none">
          <doc xml:space="preserve">name of local interface</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interfaces_get_local_interfaces"
              c:identifier="nice_interfaces_get_local_interfaces">
      <doc xml:space="preserve">Get the list of local interfaces</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated #GList of
strings. The caller must free it.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
    </function>
    <function name="interfaces_get_local_ips"
              c:identifier="nice_interfaces_get_local_ips">
      <doc xml:space="preserve">Get a list of local ipv4 interface addresses</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly-allocated #GList of
strings. The caller must free it.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="include_loopback" transfer-ownership="none">
          <doc xml:space="preserve">Include any loopback devices</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="pseudo_tcp_set_debug_level"
              c:identifier="pseudo_tcp_set_debug_level"
              version="0.0.11">
      <doc xml:space="preserve">Sets the debug level to enable/disable normal/verbose debug messages.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="level" transfer-ownership="none">
          <doc xml:space="preserve">The level of debug to set</doc>
          <type name="PseudoTcpDebugLevel" c:type="PseudoTcpDebugLevel"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
