<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Gdk" version="4.0"/>
  <include name="Graphene" version="1.0"/>
  <package name="gtk+-4.0"/>
  <c:include name="gsk/gsk.h"/>
  <namespace name="Gsk"
             version="4.0"
             shared-library="libgtk-4.so.0.9300.0"
             c:identifier-prefixes="Gsk"
             c:symbol-prefixes="gsk">
    <enumeration name="BlendMode"
                 version="3.90"
                 glib:type-name="GskBlendMode"
                 glib:get-type="gsk_blend_mode_get_type"
                 c:type="GskBlendMode">
      <doc xml:space="preserve">The blend modes available for render nodes.

The implementation of each blend mode is deferred to the
rendering pipeline.</doc>
      <member name="default"
              value="0"
              c:identifier="GSK_BLEND_MODE_DEFAULT"
              glib:nick="default">
        <doc xml:space="preserve">The default blend mode, which specifies no blending</doc>
      </member>
      <member name="multiply"
              value="1"
              c:identifier="GSK_BLEND_MODE_MULTIPLY"
              glib:nick="multiply">
        <doc xml:space="preserve">The source color is multiplied by the destination
  and replaces the destination</doc>
      </member>
      <member name="screen"
              value="2"
              c:identifier="GSK_BLEND_MODE_SCREEN"
              glib:nick="screen">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="overlay"
              value="3"
              c:identifier="GSK_BLEND_MODE_OVERLAY"
              glib:nick="overlay">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="darken"
              value="4"
              c:identifier="GSK_BLEND_MODE_DARKEN"
              glib:nick="darken">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="lighten"
              value="5"
              c:identifier="GSK_BLEND_MODE_LIGHTEN"
              glib:nick="lighten">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="color_dodge"
              value="6"
              c:identifier="GSK_BLEND_MODE_COLOR_DODGE"
              glib:nick="color-dodge">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="color_burn"
              value="7"
              c:identifier="GSK_BLEND_MODE_COLOR_BURN"
              glib:nick="color-burn">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="hard_light"
              value="8"
              c:identifier="GSK_BLEND_MODE_HARD_LIGHT"
              glib:nick="hard-light">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="soft_light"
              value="9"
              c:identifier="GSK_BLEND_MODE_SOFT_LIGHT"
              glib:nick="soft-light">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="difference"
              value="10"
              c:identifier="GSK_BLEND_MODE_DIFFERENCE"
              glib:nick="difference">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="exclusion"
              value="11"
              c:identifier="GSK_BLEND_MODE_EXCLUSION"
              glib:nick="exclusion">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="color"
              value="12"
              c:identifier="GSK_BLEND_MODE_COLOR"
              glib:nick="color">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="hue"
              value="13"
              c:identifier="GSK_BLEND_MODE_HUE"
              glib:nick="hue">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="saturation"
              value="14"
              c:identifier="GSK_BLEND_MODE_SATURATION"
              glib:nick="saturation">
        <doc xml:space="preserve">...</doc>
      </member>
      <member name="luminosity"
              value="15"
              c:identifier="GSK_BLEND_MODE_LUMINOSITY"
              glib:nick="luminosity">
        <doc xml:space="preserve">...</doc>
      </member>
    </enumeration>
    <record name="ColorStop" c:type="GskColorStop">
      <field name="offset" writable="1">
        <type name="gdouble" c:type="double"/>
      </field>
      <field name="color" writable="1">
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
    </record>
    <enumeration name="Corner"
                 glib:type-name="GskCorner"
                 glib:get-type="gsk_corner_get_type"
                 c:type="GskCorner">
      <doc xml:space="preserve">The corner indices used by #GskRoundedRect.</doc>
      <member name="top_left"
              value="0"
              c:identifier="GSK_CORNER_TOP_LEFT"
              glib:nick="top-left">
        <doc xml:space="preserve">The top left corner</doc>
      </member>
      <member name="top_right"
              value="1"
              c:identifier="GSK_CORNER_TOP_RIGHT"
              glib:nick="top-right">
        <doc xml:space="preserve">The top right corner</doc>
      </member>
      <member name="bottom_right"
              value="2"
              c:identifier="GSK_CORNER_BOTTOM_RIGHT"
              glib:nick="bottom-right">
        <doc xml:space="preserve">The bottom right corner</doc>
      </member>
      <member name="bottom_left"
              value="3"
              c:identifier="GSK_CORNER_BOTTOM_LEFT"
              glib:nick="bottom-left">
        <doc xml:space="preserve">The bottom left corner</doc>
      </member>
    </enumeration>
    <record name="RenderNode"
            c:type="GskRenderNode"
            glib:type-name="GskRenderNode"
            glib:get-type="gsk_render_node_get_type"
            c:symbol-prefix="render_node">
      <doc xml:space="preserve">The `GskRenderNode` structure contains only private data.</doc>
      <method name="draw" c:identifier="gsk_render_node_draw">
        <doc xml:space="preserve">Draw the contents of @node to the given cairo context.

Typically, you'll use this function to implement fallback rendering
of #GskRenderNodes on an intermediate Cairo context, instead of using
the drawing context associated to a #GdkWindow's rendering buffer.

For advanced nodes that cannot be supported using Cairo, in particular
for nodes doing 3D operations, this function may fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="cr" transfer-ownership="none">
            <doc xml:space="preserve">cairo context to draw to</doc>
            <type name="cairo.Context" c:type="cairo_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounds" c:identifier="gsk_render_node_get_bounds">
        <doc xml:space="preserve">Retrieves the boundaries of the @node. The node will not draw outside
of its boundaries.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="bounds"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for the boundaries</doc>
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="gsk_render_node_get_name">
        <doc xml:space="preserve">Retrieves the name previously set via gsk_render_node_set_name().
If no name has been set, %NULL is returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The name previously set via
    gsk_render_node_set_name() or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_node_type"
              c:identifier="gsk_render_node_get_node_type">
        <doc xml:space="preserve">Returns the type of the @node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the #GskRenderNode</doc>
          <type name="RenderNodeType" c:type="GskRenderNodeType"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gsk_render_node_ref">
        <doc xml:space="preserve">Acquires a reference on the given #GskRenderNode.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GskRenderNode with an additional reference</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="gsk_render_node_serialize">
        <doc xml:space="preserve">Serializes the @node for later deserialization via
gsk_render_node_deserialize(). No guarantees are made about the format
used other than that the same version of GTK+ will be able to deserialize
the result of a call to gsk_render_node_serialize() and
gsk_render_node_deserialize() will correctly reject files it cannot open
that were created with previous versions of GTK+.

The intended use of this functions is testing, benchmarking and debugging.
The format is not meant as a permanent storage format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GBytes representing the node.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="gsk_render_node_set_name">
        <doc xml:space="preserve">Sets the name of the node.

A name is generally useful for debugging purposes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a name for the node</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gsk_render_node_unref">
        <doc xml:space="preserve">Releases a reference on the given #GskRenderNode.

If the reference was the last, the resources associated to the @node are
freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="write_to_file"
              c:identifier="gsk_render_node_write_to_file"
              throws="1">
        <doc xml:space="preserve">This function is equivalent to calling gsk_render_node_serialize()
followed by g_file_set_contents(). See those two functions for details
on the arguments.

It is mostly intended for use inside a debugger to quickly dump a render
node to a file for later inspection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if saving was successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the file to save it to.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <function name="deserialize"
                c:identifier="gsk_render_node_deserialize"
                throws="1">
        <doc xml:space="preserve">Loads data previously created via gsk_render_node_serialize(). For a
discussion of the supported format, see that function.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a new #GskRenderNode or %NULL on
    error.</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve">the bytes containing the data</doc>
            <type name="GLib.Bytes" c:type="GBytes*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="RenderNodeType"
                 version="3.90"
                 glib:type-name="GskRenderNodeType"
                 glib:get-type="gsk_render_node_type_get_type"
                 c:type="GskRenderNodeType">
      <doc xml:space="preserve">The type of a node determines what the node is rendering.</doc>
      <member name="not_a_render_node"
              value="0"
              c:identifier="GSK_NOT_A_RENDER_NODE"
              glib:nick="not-a-render-node">
        <doc xml:space="preserve">Error type. No node will ever have this type.</doc>
      </member>
      <member name="container_node"
              value="1"
              c:identifier="GSK_CONTAINER_NODE"
              glib:nick="container-node">
        <doc xml:space="preserve">A node containing a stack of children</doc>
      </member>
      <member name="cairo_node"
              value="2"
              c:identifier="GSK_CAIRO_NODE"
              glib:nick="cairo-node">
        <doc xml:space="preserve">A node drawing a #cairo_surface_t</doc>
      </member>
      <member name="color_node"
              value="3"
              c:identifier="GSK_COLOR_NODE"
              glib:nick="color-node">
        <doc xml:space="preserve">A node drawing a single color rectangle</doc>
      </member>
      <member name="linear_gradient_node"
              value="4"
              c:identifier="GSK_LINEAR_GRADIENT_NODE"
              glib:nick="linear-gradient-node">
        <doc xml:space="preserve">A node drawing a linear gradient</doc>
      </member>
      <member name="repeating_linear_gradient_node"
              value="5"
              c:identifier="GSK_REPEATING_LINEAR_GRADIENT_NODE"
              glib:nick="repeating-linear-gradient-node">
        <doc xml:space="preserve">A node drawing a repeating linear gradient</doc>
      </member>
      <member name="border_node"
              value="6"
              c:identifier="GSK_BORDER_NODE"
              glib:nick="border-node">
        <doc xml:space="preserve">A node stroking a border around an area</doc>
      </member>
      <member name="texture_node"
              value="7"
              c:identifier="GSK_TEXTURE_NODE"
              glib:nick="texture-node">
        <doc xml:space="preserve">A node drawing a #GdkTexture</doc>
      </member>
      <member name="inset_shadow_node"
              value="8"
              c:identifier="GSK_INSET_SHADOW_NODE"
              glib:nick="inset-shadow-node">
        <doc xml:space="preserve">A node drawing an inset shadow</doc>
      </member>
      <member name="outset_shadow_node"
              value="9"
              c:identifier="GSK_OUTSET_SHADOW_NODE"
              glib:nick="outset-shadow-node">
        <doc xml:space="preserve">A node drawing an outset shadow</doc>
      </member>
      <member name="transform_node"
              value="10"
              c:identifier="GSK_TRANSFORM_NODE"
              glib:nick="transform-node">
        <doc xml:space="preserve">A node that renders its child after applying a matrix transform</doc>
      </member>
      <member name="opacity_node"
              value="11"
              c:identifier="GSK_OPACITY_NODE"
              glib:nick="opacity-node">
        <doc xml:space="preserve">A node that changes the opacity of its child</doc>
      </member>
      <member name="color_matrix_node"
              value="12"
              c:identifier="GSK_COLOR_MATRIX_NODE"
              glib:nick="color-matrix-node">
        <doc xml:space="preserve">A node that applies a color matrix to every pixel</doc>
      </member>
      <member name="repeat_node"
              value="13"
              c:identifier="GSK_REPEAT_NODE"
              glib:nick="repeat-node">
        <doc xml:space="preserve">A node that repeats the child's contents</doc>
      </member>
      <member name="clip_node"
              value="14"
              c:identifier="GSK_CLIP_NODE"
              glib:nick="clip-node">
        <doc xml:space="preserve">A node that clips its child to a rectangular area</doc>
      </member>
      <member name="rounded_clip_node"
              value="15"
              c:identifier="GSK_ROUNDED_CLIP_NODE"
              glib:nick="rounded-clip-node">
        <doc xml:space="preserve">A node that clips its child to a rounded rectangle</doc>
      </member>
      <member name="shadow_node"
              value="16"
              c:identifier="GSK_SHADOW_NODE"
              glib:nick="shadow-node">
        <doc xml:space="preserve">A node that draws a shadow below its child</doc>
      </member>
      <member name="blend_node"
              value="17"
              c:identifier="GSK_BLEND_NODE"
              glib:nick="blend-node">
        <doc xml:space="preserve">A node that blends two children together</doc>
      </member>
      <member name="cross_fade_node"
              value="18"
              c:identifier="GSK_CROSS_FADE_NODE"
              glib:nick="cross-fade-node">
        <doc xml:space="preserve">A node that cross-fades between two children</doc>
      </member>
      <member name="text_node"
              value="19"
              c:identifier="GSK_TEXT_NODE"
              glib:nick="text-node">
        <doc xml:space="preserve">A node containing a glyph string</doc>
      </member>
      <member name="blur_node"
              value="20"
              c:identifier="GSK_BLUR_NODE"
              glib:nick="blur-node">
        <doc xml:space="preserve">A node that applies a blur</doc>
      </member>
    </enumeration>
    <class name="Renderer"
           c:symbol-prefix="renderer"
           c:type="GskRenderer"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GskRenderer"
           glib:get-type="gsk_renderer_get_type"
           glib:type-struct="RendererClass">
      <constructor name="new_for_window"
                   c:identifier="gsk_renderer_new_for_window">
        <doc xml:space="preserve">Creates an appropriate #GskRenderer instance for the given @window.

The renderer will be realized when it is returned.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">a #GskRenderer</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </return-value>
        <parameters>
          <parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">a #GdkWindow</doc>
            <type name="Gdk.Window" c:type="GdkWindow*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="begin_draw_frame"
              c:identifier="gsk_renderer_begin_draw_frame">
        <doc xml:space="preserve">Indicates that you are beginning the process of redrawing @region using
@renderer, and provides you with a #GdkDrawingContext to use for this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GdkDrawingContext context that should be used to
draw the contents of the @renderer. This context is owned by GDK.</doc>
          <type name="Gdk.DrawingContext" c:type="GdkDrawingContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve">the #cairo_region_t that you wish to draw</doc>
            <type name="cairo.Region" c:type="const cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="end_draw_frame" c:identifier="gsk_renderer_end_draw_frame">
        <doc xml:space="preserve">Release the drawning context returned by gsk_renderer_begin_draw_frame().

Calls to gsk_renderer_begin_draw_frame() and gsk_renderer_end_draw_frame()
must be paired.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">the drawing context returned by the matching call to
    gsk_renderer_begin_draw_frame()</doc>
            <type name="Gdk.DrawingContext" c:type="GdkDrawingContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_display" c:identifier="gsk_renderer_get_display">
        <doc xml:space="preserve">Retrieves the #GdkDisplay used when creating the #GskRenderer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GdkDisplay</doc>
          <type name="Gdk.Display" c:type="GdkDisplay*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window" c:identifier="gsk_renderer_get_window">
        <doc xml:space="preserve">Retrieves the #GdkWindow set using gsk_renderer_realize(). If the renderer
has not been realized yet, %NULL will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a #GdkWindow</doc>
          <type name="Gdk.Window" c:type="GdkWindow*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="realize" c:identifier="gsk_renderer_realize" throws="1">
        <doc xml:space="preserve">Creates the resources needed by the @renderer to render the scene
graph.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="window" transfer-ownership="none">
            <doc xml:space="preserve">the #GdkWindow renderer will be used on</doc>
            <type name="Gdk.Window" c:type="GdkWindow*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render" c:identifier="gsk_renderer_render">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
using the given #GdkDrawingContext.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve">The drawing context created via gsk_renderer_begin_draw_frame()</doc>
            <type name="Gdk.DrawingContext" c:type="GdkDrawingContext*"/>
          </parameter>
        </parameters>
      </method>
      <method name="render_texture" c:identifier="gsk_renderer_render_texture">
        <doc xml:space="preserve">Renders the scene graph, described by a tree of #GskRenderNode instances,
to a #GdkTexture.

The @renderer will acquire a reference on the #GskRenderNode tree while
the rendering is in progress, and will make the tree immutable.

If you want to apply any transformations to @root, you should put it into a
transform node and pass that node instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GdkTexture with the rendered contents of @root.</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a realized #GdkRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderNode</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="viewport"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the section to draw or %NULL to use @root's bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unrealize" c:identifier="gsk_renderer_unrealize">
        <doc xml:space="preserve">Releases all the resources created by gsk_renderer_realize().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRenderer</doc>
            <type name="Renderer" c:type="GskRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="display"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #GdkDisplay used by the #GskRenderer.</doc>
        <type name="Gdk.Display"/>
      </property>
      <property name="drawing-context" transfer-ownership="none">
        <doc xml:space="preserve">The drawing context used when rendering.</doc>
        <type name="Gdk.DrawingContext"/>
      </property>
      <property name="window" transfer-ownership="none">
        <type name="Gdk.Window"/>
      </property>
    </class>
    <record name="RendererClass"
            c:type="GskRendererClass"
            disguised="1"
            glib:is-gtype-struct-for="Renderer">
    </record>
    <record name="RoundedRect" c:type="GskRoundedRect" version="3.90">
      <doc xml:space="preserve">A rectanglular region with rounded corners.

Application code should normalize rectangles using gsk_rounded_rect_normalize();
this function will ensure that the bounds of the rectanlge are normalized
and ensure that the corner values are positive and the corners do not overlap.
All functions taking a #GskRoundedRect as an argument will internally operate on
a normalized copy; all functions returning a #GskRoundedRect will always return
a normalized one.</doc>
      <field name="bounds" writable="1">
        <doc xml:space="preserve">the bounds of the rectangle</doc>
        <type name="Graphene.Rect" c:type="graphene_rect_t"/>
      </field>
      <field name="corner" writable="1">
        <doc xml:space="preserve">the size of the 4 rounded corners</doc>
        <array zero-terminated="0" c:type="graphene_size_t" fixed-size="4">
          <type name="Graphene.Size" c:type="graphene_size_t"/>
        </array>
      </field>
      <method name="contains_point"
              c:identifier="gsk_rounded_rect_contains_point">
        <doc xml:space="preserve">Checks if the given @point is inside the rounded rectangle. This function
returns %FALSE if the point is in the rounded corner areas.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @point is inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="point" transfer-ownership="none">
            <doc xml:space="preserve">the point to check</doc>
            <type name="Graphene.Point" c:type="const graphene_point_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains_rect"
              c:identifier="gsk_rounded_rect_contains_rect">
        <doc xml:space="preserve">Checks if the given @rect is contained inside the rounded rectangle.
This function returns %FALSE if @rect extends into one of the rounded
corner areas.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect is fully contained inside the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gsk_rounded_rect_init">
        <doc xml:space="preserve">Initializes the given #GskRoundedRect with the given values.

This function will implicitly normalize the #GskRoundedRect
before returning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to initialize</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t describing the bounds</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="top_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="top_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the top right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_right" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom right corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
          <parameter name="bottom_left" transfer-ownership="none">
            <doc xml:space="preserve">the rounding radius of the bottom left corner</doc>
            <type name="Graphene.Size" c:type="const graphene_size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_copy" c:identifier="gsk_rounded_rect_init_copy">
        <doc xml:space="preserve">Initializes @self using the given @src rectangle.

This function will not normalize the #GskRoundedRect, so
make sure the source is normalized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_rect"
              c:identifier="gsk_rounded_rect_init_from_rect">
        <doc xml:space="preserve">Initializes @self to the given @bounds and sets the radius of all
four corners to @radius.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the initialized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="bounds" transfer-ownership="none">
            <doc xml:space="preserve">a #graphene_rect_t</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
          <parameter name="radius" transfer-ownership="none">
            <doc xml:space="preserve">the border radius</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersects_rect"
              c:identifier="gsk_rounded_rect_intersects_rect">
        <doc xml:space="preserve">Checks if part of the given @rect is contained inside the rounded rectangle.
This function returns %FALSE if @rect only extends into one of the rounded
corner areas but not into the rounded rectangle itself.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the @rect intersects with the rounded rectangle</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to check</doc>
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_rectilinear"
              c:identifier="gsk_rounded_rect_is_rectilinear">
        <doc xml:space="preserve">Checks if all corners of @self are right angles and the
rectangle covers all of its bounds.

This information can be used to decide if gsk_clip_node_new()
or gsk_rounded_clip_node_new() should be called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the rectangle is rectilinear</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">the #GskRoundedRect to check</doc>
            <type name="RoundedRect" c:type="const GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="gsk_rounded_rect_normalize">
        <doc xml:space="preserve">Normalizes the passed rectangle.

this function will ensure that the bounds of the rectanlge are normalized
and ensure that the corner values are positive and the corners do not overlap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the normalized rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="offset" c:identifier="gsk_rounded_rect_offset">
        <doc xml:space="preserve">Offsets the bound's origin by @dx and @dy.

The size and corners of the rectangle are unchanged.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the offset rectangle</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GskRoundedRect</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="dx" transfer-ownership="none">
            <doc xml:space="preserve">the horizontal offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="dy" transfer-ownership="none">
            <doc xml:space="preserve">the vertical offset</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="shrink" c:identifier="gsk_rounded_rect_shrink">
        <doc xml:space="preserve">Shrinks (or grows) the given rectangle by moving the 4 sides
according to the offsets given. The corner radii will be changed
in a way that tries to keep the center of the corner circle intact.
This emulates CSS behavior.

This function also works for growing rectangles if you pass
negative values for the @top, @right, @bottom or @left.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the resized #GskRoundedRect</doc>
          <type name="RoundedRect" c:type="GskRoundedRect*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">The #GskRoundedRect to shrink or grow</doc>
            <type name="RoundedRect" c:type="GskRoundedRect*"/>
          </instance-parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the top side downwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the right side to the left</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the bottom side upwards</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">How far to move the left side to the right</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="ScalingFilter"
                 version="3.90"
                 glib:type-name="GskScalingFilter"
                 glib:get-type="gsk_scaling_filter_get_type"
                 c:type="GskScalingFilter">
      <doc xml:space="preserve">The filters used when scaling texture data.

The actual implementation of each filter is deferred to the
rendering pipeline.</doc>
      <member name="linear"
              value="0"
              c:identifier="GSK_SCALING_FILTER_LINEAR"
              glib:nick="linear">
        <doc xml:space="preserve">linear interpolation filter</doc>
      </member>
      <member name="nearest"
              value="1"
              c:identifier="GSK_SCALING_FILTER_NEAREST"
              glib:nick="nearest">
        <doc xml:space="preserve">nearest neighbor interpolation filter</doc>
      </member>
      <member name="trilinear"
              value="2"
              c:identifier="GSK_SCALING_FILTER_TRILINEAR"
              glib:nick="trilinear">
        <doc xml:space="preserve">linear interpolation along each axis,
  plus mipmap generation, with linear interpolation along the mipmap
  levels</doc>
      </member>
    </enumeration>
    <enumeration name="SerializationError"
                 glib:type-name="GskSerializationError"
                 glib:get-type="gsk_serialization_error_get_type"
                 c:type="GskSerializationError"
                 glib:error-domain="gsk-serialization-error-quark">
      <doc xml:space="preserve">Errors that can happen during (de)serialization.</doc>
      <member name="unsupported_format"
              value="0"
              c:identifier="GSK_SERIALIZATION_UNSUPPORTED_FORMAT"
              glib:nick="unsupported-format">
        <doc xml:space="preserve">The format can not be
    identified</doc>
      </member>
      <member name="unsupported_version"
              value="1"
              c:identifier="GSK_SERIALIZATION_UNSUPPORTED_VERSION"
              glib:nick="unsupported-version">
        <doc xml:space="preserve">The version of the data
    is not understood</doc>
      </member>
      <member name="invalid_data"
              value="2"
              c:identifier="GSK_SERIALIZATION_INVALID_DATA"
              glib:nick="invalid-data">
        <doc xml:space="preserve">The given data may not exist in
    a proper serialization</doc>
      </member>
      <function name="quark" c:identifier="gsk_serialization_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="Shadow" c:type="GskShadow">
      <field name="color" writable="1">
        <type name="Gdk.RGBA" c:type="GdkRGBA"/>
      </field>
      <field name="dx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="dy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="radius" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <function name="node_get_child" c:identifier="gsk_shadow_node_get_child">
        <return-value transfer-ownership="full">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none">
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
        </parameters>
      </function>
      <function name="node_get_n_shadows"
                c:identifier="gsk_shadow_node_get_n_shadows">
        <return-value transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none">
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
        </parameters>
      </function>
      <function name="node_new" c:identifier="gsk_shadow_node_new">
        <doc xml:space="preserve">Creates a #GskRenderNode that will draw a @child with the given
@shadows below it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">The node to draw</doc>
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="shadows" transfer-ownership="none">
            <doc xml:space="preserve">The shadows to apply</doc>
            <array length="2" zero-terminated="0" c:type="GskShadow*">
              <type name="Shadow" c:type="GskShadow"/>
            </array>
          </parameter>
          <parameter name="n_shadows" transfer-ownership="none">
            <doc xml:space="preserve">number of entries in the @shadows array</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="node_peek_shadow"
                c:identifier="gsk_shadow_node_peek_shadow">
        <return-value transfer-ownership="none">
          <type name="Shadow" c:type="const GskShadow*"/>
        </return-value>
        <parameters>
          <parameter name="node" transfer-ownership="none">
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </parameter>
          <parameter name="i" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function name="blend_node_get_blend_mode"
              c:identifier="gsk_blend_node_get_blend_mode">
      <return-value transfer-ownership="none">
        <type name="BlendMode" c:type="GskBlendMode"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="blend_node_get_bottom_child"
              c:identifier="gsk_blend_node_get_bottom_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="blend_node_get_top_child"
              c:identifier="gsk_blend_node_get_top_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="blend_node_new" c:identifier="gsk_blend_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will use @blend_mode to blend the @top
node onto the @bottom node.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:space="preserve">The bottom node to be drawn</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">The node to be blended onto the @bottom node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="blend_mode" transfer-ownership="none">
          <doc xml:space="preserve">The blend mode to use</doc>
          <type name="BlendMode" c:type="GskBlendMode"/>
        </parameter>
      </parameters>
    </function>
    <function name="blur_node_get_child"
              c:identifier="gsk_blur_node_get_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="blur_node_get_radius"
              c:identifier="gsk_blur_node_get_radius">
      <return-value transfer-ownership="none">
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="blur_node_new" c:identifier="gsk_blur_node_new">
      <doc xml:space="preserve">Creates a render node that blurs the child.</doc>
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">the child node to blur</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="radius" transfer-ownership="none">
          <doc xml:space="preserve">the blur radius</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="border_node_new" c:identifier="gsk_border_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will stroke a border rectangle inside the
given @outline. The 4 sides of the border can have different widths and
colors.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="outline" transfer-ownership="none">
          <doc xml:space="preserve">a #GskRoundedRect describing the outline of the border</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
        <parameter name="border_width" transfer-ownership="none">
          <doc xml:space="preserve">the stroke width of the border on the top, right, bottom and
    left side respectively.</doc>
          <type name="gfloat" c:type="const float"/>
        </parameter>
        <parameter name="border_color" transfer-ownership="none">
          <doc xml:space="preserve">the color used on the top, right, bottom and left side.</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA"/>
        </parameter>
      </parameters>
    </function>
    <function name="border_node_peek_colors"
              c:identifier="gsk_border_node_peek_colors">
      <return-value transfer-ownership="none">
        <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="border_node_peek_outline"
              c:identifier="gsk_border_node_peek_outline">
      <return-value transfer-ownership="none">
        <type name="RoundedRect" c:type="const GskRoundedRect*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="border_node_peek_widths"
              c:identifier="gsk_border_node_peek_widths">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="const float*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cairo_node_get_draw_context"
              c:identifier="gsk_cairo_node_get_draw_context">
      <doc xml:space="preserve">Creates a Cairo context for drawing using the surface associated
to the render node.
If no surface exists yet, a surface will be created optimized for
rendering to @renderer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a Cairo context used for drawing; use
  cairo_destroy() when done drawing</doc>
        <type name="cairo.Context" c:type="cairo_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a cairo #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="renderer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Renderer to optimize for or %NULL for any</doc>
          <type name="Renderer" c:type="GskRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cairo_node_new" c:identifier="gsk_cairo_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render a cairo surface
into the area given by @bounds. You can draw to the cairo
surface using gsk_cairo_node_get_draw_context()</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render to</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cairo_node_peek_surface"
              c:identifier="gsk_cairo_node_peek_surface">
      <return-value transfer-ownership="none">
        <type name="cairo.Surface" c:type="const cairo_surface_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_node_get_child"
              c:identifier="gsk_clip_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting clipped</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a clip @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_node_new" c:identifier="gsk_clip_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="clip" transfer-ownership="none">
          <doc xml:space="preserve">The clip to apply</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_node_peek_clip"
              c:identifier="gsk_clip_node_peek_clip">
      <return-value transfer-ownership="none">
        <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_matrix_node_get_child"
              c:identifier="gsk_color_matrix_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting its colors modified by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting its colors modified</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a color matrix @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_matrix_node_new"
              c:identifier="gsk_color_matrix_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@color_matrix.

In particular, the node will transform the operation
  pixel = color_matrix * pixel + color_offset
for every pixel.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="color_matrix" transfer-ownership="none">
          <doc xml:space="preserve">The matrix to apply</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </parameter>
        <parameter name="color_offset" transfer-ownership="none">
          <doc xml:space="preserve">Values to add to the color</doc>
          <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_matrix_node_peek_color_matrix"
              c:identifier="gsk_color_matrix_node_peek_color_matrix">
      <return-value transfer-ownership="none">
        <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_matrix_node_peek_color_offset"
              c:identifier="gsk_color_matrix_node_peek_color_offset">
      <return-value transfer-ownership="none">
        <type name="Graphene.Vec4" c:type="const graphene_vec4_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_node_new" c:identifier="gsk_color_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render the color specified by @rgba into
the area given by @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="rgba" transfer-ownership="none">
          <doc xml:space="preserve">a #GdkRGBA specifying a color</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </parameter>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render the color into</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_node_peek_color"
              c:identifier="gsk_color_node_peek_color">
      <return-value transfer-ownership="none">
        <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="container_node_get_child"
              c:identifier="gsk_container_node_get_child">
      <doc xml:space="preserve">Gets one of the children of @container.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the @idx'th child of @container</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a container #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="idx" transfer-ownership="none">
          <doc xml:space="preserve">the position of the child to get</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="container_node_get_n_children"
              c:identifier="gsk_container_node_get_n_children">
      <doc xml:space="preserve">Retrieves the number of direct children of @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of children of the #GskRenderNode</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a container #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="container_node_new" c:identifier="gsk_container_node_new">
      <doc xml:space="preserve">Creates a new #GskRenderNode instance for holding the given @children.
The new node will acquire a reference to each of the children.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="children" transfer-ownership="none">
          <doc xml:space="preserve">The children of the node</doc>
          <array length="1" zero-terminated="0" c:type="GskRenderNode**">
            <type name="RenderNode" c:type="GskRenderNode*"/>
          </array>
        </parameter>
        <parameter name="n_children" transfer-ownership="none">
          <doc xml:space="preserve">Number of children in the @children array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cross_fade_node_get_end_child"
              c:identifier="gsk_cross_fade_node_get_end_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cross_fade_node_get_progress"
              c:identifier="gsk_cross_fade_node_get_progress">
      <return-value transfer-ownership="none">
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cross_fade_node_get_start_child"
              c:identifier="gsk_cross_fade_node_get_start_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="cross_fade_node_new"
              c:identifier="gsk_cross_fade_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will do a cross-fade between @start and @end.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">The start node to be drawn</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">The node to be cross_fadeed onto the @start node</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="progress" transfer-ownership="none">
          <doc xml:space="preserve">How far the fade has progressed from start to end. The value will
    be clamped to the range [0 ... 1]</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_get_blur_radius"
              c:identifier="gsk_inset_shadow_node_get_blur_radius">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_get_dx"
              c:identifier="gsk_inset_shadow_node_get_dx">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_get_dy"
              c:identifier="gsk_inset_shadow_node_get_dy">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_get_spread"
              c:identifier="gsk_inset_shadow_node_get_spread">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_new"
              c:identifier="gsk_inset_shadow_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render an inset shadow
into the box given by @outline.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="outline" transfer-ownership="none">
          <doc xml:space="preserve">outline of the region containing the shadow</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">color of the shadow</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </parameter>
        <parameter name="dx" transfer-ownership="none">
          <doc xml:space="preserve">horizontal offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="dy" transfer-ownership="none">
          <doc xml:space="preserve">vertical offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="spread" transfer-ownership="none">
          <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="blur_radius" transfer-ownership="none">
          <doc xml:space="preserve">how much blur to apply to the shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_peek_color"
              c:identifier="gsk_inset_shadow_node_peek_color">
      <return-value transfer-ownership="none">
        <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="inset_shadow_node_peek_outline"
              c:identifier="gsk_inset_shadow_node_peek_outline">
      <return-value transfer-ownership="none">
        <type name="RoundedRect" c:type="const GskRoundedRect*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="linear_gradient_node_get_n_color_stops"
              c:identifier="gsk_linear_gradient_node_get_n_color_stops">
      <return-value transfer-ownership="none">
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="linear_gradient_node_new"
              c:identifier="gsk_linear_gradient_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will create a linear gradient from the given
points and color stops, and render that into the area given by @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="color_stops" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient</doc>
          <array length="4" zero-terminated="0" c:type="GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </parameter>
        <parameter name="n_color_stops" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in @color_stops</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="linear_gradient_node_peek_color_stops"
              c:identifier="gsk_linear_gradient_node_peek_color_stops">
      <return-value transfer-ownership="none">
        <type name="ColorStop" c:type="const GskColorStop*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="linear_gradient_node_peek_end"
              c:identifier="gsk_linear_gradient_node_peek_end">
      <return-value transfer-ownership="none">
        <type name="Graphene.Point" c:type="const graphene_point_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="linear_gradient_node_peek_start"
              c:identifier="gsk_linear_gradient_node_peek_start">
      <return-value transfer-ownership="none">
        <type name="Graphene.Point" c:type="const graphene_point_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="opacity_node_get_child"
              c:identifier="gsk_opacity_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting opacityed by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting opacityed</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a opacity @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="opacity_node_get_opacity"
              c:identifier="gsk_opacity_node_get_opacity">
      <return-value transfer-ownership="none">
        <type name="gdouble" c:type="double"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="opacity_node_new" c:identifier="gsk_opacity_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will drawn the @child with reduced
@opacity.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="opacity" transfer-ownership="none">
          <doc xml:space="preserve">The opacity to apply</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_get_blur_radius"
              c:identifier="gsk_outset_shadow_node_get_blur_radius">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_get_dx"
              c:identifier="gsk_outset_shadow_node_get_dx">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_get_dy"
              c:identifier="gsk_outset_shadow_node_get_dy">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_get_spread"
              c:identifier="gsk_outset_shadow_node_get_spread">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_new"
              c:identifier="gsk_outset_shadow_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render an outset shadow
around the box given by @outline.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="outline" transfer-ownership="none">
          <doc xml:space="preserve">outline of the region surrounded by shadow</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">color of the shadow</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </parameter>
        <parameter name="dx" transfer-ownership="none">
          <doc xml:space="preserve">horizontal offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="dy" transfer-ownership="none">
          <doc xml:space="preserve">vertical offset of shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="spread" transfer-ownership="none">
          <doc xml:space="preserve">how far the shadow spreads towards the inside</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="blur_radius" transfer-ownership="none">
          <doc xml:space="preserve">how much blur to apply to the shadow</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_peek_color"
              c:identifier="gsk_outset_shadow_node_peek_color">
      <return-value transfer-ownership="none">
        <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="outset_shadow_node_peek_outline"
              c:identifier="gsk_outset_shadow_node_peek_outline">
      <return-value transfer-ownership="none">
        <type name="RoundedRect" c:type="const GskRoundedRect*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="render_node_deserialize"
              c:identifier="gsk_render_node_deserialize"
              moved-to="RenderNode.deserialize"
              throws="1">
      <doc xml:space="preserve">Loads data previously created via gsk_render_node_serialize(). For a
discussion of the supported format, see that function.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">a new #GskRenderNode or %NULL on
    error.</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:space="preserve">the bytes containing the data</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </parameter>
      </parameters>
    </function>
    <function name="repeat_node_get_child"
              c:identifier="gsk_repeat_node_get_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="repeat_node_new" c:identifier="gsk_repeat_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will repeat the drawing of @child across
the given @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">The bounds of the area to be painted</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The child to repeat</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="child_bounds"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">The area of the child to repeat or %NULL to
    use the child's bounds</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="repeat_node_peek_child_bounds"
              c:identifier="gsk_repeat_node_peek_child_bounds">
      <return-value transfer-ownership="none">
        <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="repeating_linear_gradient_node_new"
              c:identifier="gsk_repeating_linear_gradient_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will create a repeating linear gradient
from the given points and color stops, and render that into the area
given by @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render the linear gradient into</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">the point at which the linear gradient will begin</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">the point at which the linear gradient will finish</doc>
          <type name="Graphene.Point" c:type="const graphene_point_t*"/>
        </parameter>
        <parameter name="color_stops" transfer-ownership="none">
          <doc xml:space="preserve">a pointer to an array of #GskColorStop defining the gradient</doc>
          <array length="4" zero-terminated="0" c:type="GskColorStop*">
            <type name="ColorStop" c:type="GskColorStop"/>
          </array>
        </parameter>
        <parameter name="n_color_stops" transfer-ownership="none">
          <doc xml:space="preserve">the number of elements in @color_stops</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="rounded_clip_node_get_child"
              c:identifier="gsk_rounded_clip_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting clipped by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting clipped</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a clip @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rounded_clip_node_new"
              c:identifier="gsk_rounded_clip_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will clip the @child to the area
given by @clip.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="clip" transfer-ownership="none">
          <doc xml:space="preserve">The clip to apply</doc>
          <type name="RoundedRect" c:type="const GskRoundedRect*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rounded_clip_node_peek_clip"
              c:identifier="gsk_rounded_clip_node_peek_clip">
      <return-value transfer-ownership="none">
        <type name="RoundedRect" c:type="const GskRoundedRect*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="serialization_error_quark"
              c:identifier="gsk_serialization_error_quark"
              moved-to="SerializationError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="shadow_node_get_child"
              c:identifier="gsk_shadow_node_get_child"
              moved-to="Shadow.node_get_child">
      <return-value transfer-ownership="full">
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shadow_node_get_n_shadows"
              c:identifier="gsk_shadow_node_get_n_shadows"
              moved-to="Shadow.node_get_n_shadows">
      <return-value transfer-ownership="none">
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shadow_node_new"
              c:identifier="gsk_shadow_node_new"
              moved-to="Shadow.node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will draw a @child with the given
@shadows below it.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to draw</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="shadows" transfer-ownership="none">
          <doc xml:space="preserve">The shadows to apply</doc>
          <array length="2" zero-terminated="0" c:type="GskShadow*">
            <type name="Shadow" c:type="GskShadow"/>
          </array>
        </parameter>
        <parameter name="n_shadows" transfer-ownership="none">
          <doc xml:space="preserve">number of entries in the @shadows array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="shadow_node_peek_shadow"
              c:identifier="gsk_shadow_node_peek_shadow"
              moved-to="Shadow.node_peek_shadow">
      <return-value transfer-ownership="none">
        <type name="Shadow" c:type="const GskShadow*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="i" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_node_get_num_glyphs"
              c:identifier="gsk_text_node_get_num_glyphs">
      <return-value transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_node_get_x" c:identifier="gsk_text_node_get_x">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_node_get_y" c:identifier="gsk_text_node_get_y">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_node_new" c:identifier="gsk_text_node_new">
      <doc xml:space="preserve">Creates a render node that renders the given glyphs,
Note that @color may not be used if the font contains
color glyphs.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new text node, or %NULL</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="font" transfer-ownership="none">
          <doc xml:space="preserve">the #PangoFont containing the glyphs</doc>
          <type name="Pango.Font" c:type="PangoFont*"/>
        </parameter>
        <parameter name="glyphs" transfer-ownership="none">
          <doc xml:space="preserve">the #PangoGlyphString to render</doc>
          <type name="Pango.GlyphString" c:type="PangoGlyphString*"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">the foreground color to render with</doc>
          <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">the x coordinate at which to put the baseline</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">the y coordinate at wihch to put the baseline</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_node_peek_color"
              c:identifier="gsk_text_node_peek_color">
      <return-value transfer-ownership="none">
        <type name="Gdk.RGBA" c:type="const GdkRGBA*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_node_peek_font"
              c:identifier="gsk_text_node_peek_font">
      <return-value transfer-ownership="none">
        <type name="Pango.Font" c:type="const PangoFont*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="text_node_peek_glyphs"
              c:identifier="gsk_text_node_peek_glyphs">
      <return-value transfer-ownership="none">
        <type name="Pango.GlyphInfo" c:type="const PangoGlyphInfo*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_node_get_texture"
              c:identifier="gsk_texture_node_get_texture">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GdkTexture</doc>
        <type name="Gdk.Texture" c:type="GdkTexture*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a #GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_node_new" c:identifier="gsk_texture_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will render the given
@texture into the area given by @bounds.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:space="preserve">the #GdkTexture</doc>
          <type name="Gdk.Texture" c:type="GdkTexture*"/>
        </parameter>
        <parameter name="bounds" transfer-ownership="none">
          <doc xml:space="preserve">the rectangle to render the texture into</doc>
          <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform_node_get_child"
              c:identifier="gsk_transform_node_get_child">
      <doc xml:space="preserve">Gets the child node that is getting transformed by the given @node.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The child that is getting transformed</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">a transform @GskRenderNode</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform_node_new" c:identifier="gsk_transform_node_new">
      <doc xml:space="preserve">Creates a #GskRenderNode that will transform the given @child
with the given @transform.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A new #GskRenderNode</doc>
        <type name="RenderNode" c:type="GskRenderNode*"/>
      </return-value>
      <parameters>
        <parameter name="child" transfer-ownership="none">
          <doc xml:space="preserve">The node to transform</doc>
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
        <parameter name="transform" transfer-ownership="none">
          <doc xml:space="preserve">The transform to apply</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform_node_peek_transform"
              c:identifier="gsk_transform_node_peek_transform">
      <return-value transfer-ownership="none">
        <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="RenderNode" c:type="GskRenderNode*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
