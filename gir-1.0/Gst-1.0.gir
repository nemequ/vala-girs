<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <package name="gstreamer-1.0"/>
  <c:include name="gst/gst.h"/>
  <namespace name="Gst"
             version="1.0"
             shared-library="libgstreamer-1.0.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <alias name="ClockID" c:type="GstClockID">
      <doc xml:whitespace="preserve">A datatype to hold the handle to an outstanding sync or async clock callback.</doc>
      <type name="gpointer" c:type="gpointer"/>
    </alias>
    <alias name="ClockTime" c:type="GstClockTime">
      <doc xml:whitespace="preserve">A datatype to hold a time, measured in nanoseconds.</doc>
      <type name="guint64" c:type="guint64"/>
    </alias>
    <alias name="ClockTimeDiff" c:type="GstClockTimeDiff">
      <doc xml:whitespace="preserve">A datatype to hold a time difference, measured in nanoseconds.</doc>
      <type name="gint64" c:type="gint64"/>
    </alias>
    <alias name="ElementFactoryListType" c:type="GstElementFactoryListType">
      <type name="guint64" c:type="guint64"/>
    </alias>
    <constant name="ALLOCATOR_SYSMEM"
              value="SystemMemory"
              c:type="GST_ALLOCATOR_SYSMEM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="AllocationParams"
            c:type="GstAllocationParams"
            glib:type-name="GstAllocationParams"
            glib:get-type="gst_allocation_params_get_type"
            c:symbol-prefix="allocation_params">
      <doc xml:whitespace="preserve">Parameters to control the allocation of memory</doc>
      <field name="flags" writable="1">
        <type name="MemoryFlags" c:type="GstMemoryFlags"/>
      </field>
      <field name="align" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="prefix" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="padding" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="copy" c:identifier="gst_allocation_params_copy">
        <doc xml:whitespace="preserve">Create a copy of @params.

Free-function: gst_allocation_params_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new ##GstAllocationParams, free with gst_allocation_params_free().</doc>
          <type name="AllocationParams" c:type="GstAllocationParams*"/>
        </return-value>
      </method>
      <method name="free" c:identifier="gst_allocation_params_free">
        <doc xml:whitespace="preserve">Free @params</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init" c:identifier="gst_allocation_params_init">
        <doc xml:whitespace="preserve">Initialize @params to its default values</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <class name="Allocator"
           c:symbol-prefix="allocator"
           c:type="GstAllocator"
           parent="Object"
           abstract="1"
           glib:type-name="GstAllocator"
           glib:get-type="gst_allocator_get_type"
           glib:type-struct="AllocatorClass">
      <doc xml:whitespace="preserve">Memory is usually created by allocators with a gst_allocator_alloc()
method call. When NULL is used as the allocator, the default allocator will
be used.

New allocators can be registered with gst_allocator_register().
Allocators are identified by name and can be retrieved with
gst_allocator_find(). gst_allocator_set_default() can be used to change the
default allocator.

New memory can be created with gst_memory_new_wrapped() that wraps the memory
allocated elsewhere.

Last reviewed on 2012-07-09 (0.11.3)</doc>
      <function name="find" c:identifier="gst_allocator_find">
        <doc xml:whitespace="preserve">Find a previously registered allocator with @name. When @name is NULL, the
default allocator will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstAllocator or NULL when the allocator with @name was not registered. Use gst_object_unref() to release the allocator after usage.</doc>
          <type name="Allocator" c:type="GstAllocator*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the allocator</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register" c:identifier="gst_allocator_register">
        <doc xml:whitespace="preserve">Registers the memory @allocator with @name. This function takes ownership of
@allocator.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the allocator</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="allocator" transfer-ownership="full">
            <doc xml:whitespace="preserve">#GstAllocator</doc>
            <type name="Allocator" c:type="GstAllocator*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="alloc" invoker="alloc">
        <doc xml:whitespace="preserve">Use @allocator to allocate a new memory block with memory that is at least
@size big.

The optional @params can specify the prefix and padding for the memory. If
NULL is passed, no flags, no extra prefix/padding and a default alignment is
used.

The prefix/padding will be filled with 0 if flags contains
#GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.

When @allocator is NULL, the default allocator will be used.

The alignment in @params is given as a bitmask so that @align + 1 equals
the amount of bytes to align to. For example, to align to 8 bytes,
use an alignment of 7.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstMemory.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">size of the visible memory area</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional parameters</doc>
            <type name="AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="free" invoker="free">
        <doc xml:whitespace="preserve">Free @memory that was previously allocated with gst_allocator_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="memory" transfer-ownership="full">
            <doc xml:whitespace="preserve">the memory to free</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="alloc" c:identifier="gst_allocator_alloc">
        <doc xml:whitespace="preserve">Use @allocator to allocate a new memory block with memory that is at least
@size big.

The optional @params can specify the prefix and padding for the memory. If
NULL is passed, no flags, no extra prefix/padding and a default alignment is
used.

The prefix/padding will be filled with 0 if flags contains
#GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.

When @allocator is NULL, the default allocator will be used.

The alignment in @params is given as a bitmask so that @align + 1 equals
the amount of bytes to align to. For example, to align to 8 bytes,
use an alignment of 7.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstMemory.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">size of the visible memory area</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional parameters</doc>
            <type name="AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_allocator_free">
        <doc xml:whitespace="preserve">Free @memory that was previously allocated with gst_allocator_alloc().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="memory" transfer-ownership="full">
            <doc xml:whitespace="preserve">the memory to free</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default" c:identifier="gst_allocator_set_default">
        <doc xml:whitespace="preserve">Set the default allocator. This function takes ownership of @allocator.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="mem_type">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="mem_map" introspectable="0">
        <type name="MemoryMapFunction" c:type="GstMemoryMapFunction"/>
      </field>
      <field name="mem_unmap">
        <type name="MemoryUnmapFunction" c:type="GstMemoryUnmapFunction"/>
      </field>
      <field name="mem_copy">
        <type name="MemoryCopyFunction" c:type="GstMemoryCopyFunction"/>
      </field>
      <field name="mem_share">
        <type name="MemoryShareFunction" c:type="GstMemoryShareFunction"/>
      </field>
      <field name="mem_is_span">
        <type name="MemoryIsSpanFunction" c:type="GstMemoryIsSpanFunction"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AllocatorPrivate" c:type="GstAllocatorPrivate*"/>
      </field>
    </class>
    <record name="AllocatorClass"
            c:type="GstAllocatorClass"
            glib:is-gtype-struct-for="Allocator">
      <field name="object_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="alloc">
        <callback name="alloc">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">a new #GstMemory.</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </return-value>
          <parameters>
            <parameter name="allocator" transfer-ownership="none">
              <type name="Allocator" c:type="GstAllocator*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <doc xml:whitespace="preserve">size of the visible memory area</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="params" transfer-ownership="none" allow-none="1">
              <doc xml:whitespace="preserve">optional parameters</doc>
              <type name="AllocationParams" c:type="GstAllocationParams*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="free">
        <callback name="free">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="allocator" transfer-ownership="none">
              <type name="Allocator" c:type="GstAllocator*"/>
            </parameter>
            <parameter name="memory" transfer-ownership="full">
              <doc xml:whitespace="preserve">the memory to free</doc>
              <type name="Memory" c:type="GstMemory*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="AllocatorFlags" c:type="GstAllocatorFlags">
      <doc xml:whitespace="preserve">Flags for allocators.</doc>
      <member name="custom_alloc"
              value="16"
              c:identifier="GST_ALLOCATOR_FLAG_CUSTOM_ALLOC">
        <doc xml:whitespace="preserve">The allocator has a custom alloc function.</doc>
      </member>
      <member name="last"
              value="1048576"
              c:identifier="GST_ALLOCATOR_FLAG_LAST">
        <doc xml:whitespace="preserve">first flag that can be used for custom purposes</doc>
      </member>
    </bitfield>
    <record name="AllocatorPrivate" c:type="GstAllocatorPrivate" disguised="1">
    </record>
    <record name="AtomicQueue"
            c:type="GstAtomicQueue"
            glib:type-name="GstAtomicQueue"
            glib:get-type="gst_atomic_queue_get_type"
            c:symbol-prefix="atomic_queue">
      <doc xml:whitespace="preserve">The #GstAtomicQueue object implements a queue that can be used from multiple
threads without performing any blocking operations.</doc>
      <constructor name="new" c:identifier="gst_atomic_queue_new">
        <doc xml:whitespace="preserve">Create a new atomic queue instance. @initial_size will be rounded up to the
nearest power of 2 and used as the initial size of the queue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstAtomicQueue</doc>
          <type name="AtomicQueue" c:type="GstAtomicQueue*"/>
        </return-value>
        <parameters>
          <parameter name="initial_size" transfer-ownership="none">
            <doc xml:whitespace="preserve">initial queue size</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="length" c:identifier="gst_atomic_queue_length">
        <doc xml:whitespace="preserve">Get the amount of items in the queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of elements in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="gst_atomic_queue_peek">
        <doc xml:whitespace="preserve">Peek the head element of the queue without removing it from the queue.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the head element of @queue or NULL when the queue is empty.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="pop" c:identifier="gst_atomic_queue_pop">
        <doc xml:whitespace="preserve">Get the head element of the queue.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the head element of @queue or NULL when the queue is empty.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="push" c:identifier="gst_atomic_queue_push">
        <doc xml:whitespace="preserve">Append @data to the tail of the queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gst_atomic_queue_ref">
        <doc xml:whitespace="preserve">Increase the refcount of @queue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="gst_atomic_queue_unref">
        <doc xml:whitespace="preserve">Unref @queue and free the memory when the refcount reaches 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <constant name="BUFFER_COPY_ALL" value="0" c:type="GST_BUFFER_COPY_ALL">
      <type name="BufferCopyFlags" c:type="GstBufferCopyFlags"/>
    </constant>
    <constant name="BUFFER_COPY_METADATA"
              value="0"
              c:type="GST_BUFFER_COPY_METADATA">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="BUFFER_OFFSET_NONE"
              value="18446744073709551615"
              c:type="GST_BUFFER_OFFSET_NONE">
      <type name="guint64" c:type="guint64"/>
    </constant>
    <class name="Bin"
           c:symbol-prefix="bin"
           c:type="GstBin"
           parent="Element"
           glib:type-name="GstBin"
           glib:get-type="gst_bin_get_type"
           glib:type-struct="BinClass">
      <doc xml:whitespace="preserve">#GstBin is an element that can contain other #GstElement, allowing them to be
managed as a group.
Pads from the child elements can be ghosted to the bin, see #GstGhostPad.
This makes the bin look like any other elements and enables creation of
higher-level abstraction elements.

A new #GstBin is created with gst_bin_new(). Use a #GstPipeline instead if you
want to create a toplevel bin because a normal bin doesn't have a bus or
handle clock distribution of its own.

After the bin has been created you will typically add elements to it with
gst_bin_add(). You can remove elements with gst_bin_remove().

An element can be retrieved from a bin with gst_bin_get_by_name(), using the
elements name. gst_bin_get_by_name_recurse_up() is mainly used for internal
purposes and will query the parent bins when the element is not found in the
current bin.

An iterator of elements in a bin can be retrieved with
gst_bin_iterate_elements(). Various other iterators exist to retrieve the
elements in a bin.

gst_object_unref() is used to drop your reference to the bin.

The #GstBin::element-added signal is fired whenever a new element is added to
the bin. Likewise the #GstBin::element-removed signal is fired whenever an
element is removed from the bin.

&lt;refsect2&gt;&lt;title&gt;Notes&lt;/title&gt;
&lt;para&gt;
A #GstBin internally intercepts every #GstMessage posted by its children and
implements the following default behaviour for each of them:
&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_MESSAGE_EOS&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;This message is only posted by sinks in the PLAYING
    state. If all sinks posted the EOS message, this bin will post and EOS
    message upwards.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_MESSAGE_SEGMENT_START&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;just collected and never forwarded upwards.
    The messages are used to decide when all elements have completed playback
    of their segment.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_MESSAGE_SEGMENT_DONE&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt; Is posted by #GstBin when all elements that posted
    a SEGMENT_START have posted a SEGMENT_DONE.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_MESSAGE_DURATION_CHANGED&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt; Is posted by an element that detected a change
    in the stream duration. The default bin behaviour is to clear any
    cached duration values so that the next duration query will perform
    a full duration recalculation. The duration change is posted to the
    application so that it can refetch the new duration with a duration
    query. Note that these messages can be posted before the bin is
    prerolled, in which case the duration query might fail.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_MESSAGE_CLOCK_LOST&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt; This message is posted by an element when it
    can no longer provide a clock. The default bin behaviour is to
    check if the lost clock was the one provided by the bin. If so and
    the bin is currently in the PLAYING state, the message is forwarded to
    the bin parent.
    This message is also generated when a clock provider is removed from
    the bin. If this message is received by the application, it should
    PAUSE the pipeline and set it back to PLAYING to force a new clock
    distribution.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_MESSAGE_CLOCK_PROVIDE&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt; This message is generated when an element
    can provide a clock. This mostly happens when a new clock
    provider is added to the bin. The default behaviour of the bin is to
    mark the currently selected clock as dirty, which will perform a clock
    recalculation the next time the bin is asked to provide a clock.
    This message is never sent tot the application but is forwarded to
    the parent of the bin.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;OTHERS&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt; posted upwards.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;


A #GstBin implements the following default behaviour for answering to a
#GstQuery:
&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_QUERY_DURATION&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;If the query has been asked before with the same format
    and the bin is a toplevel bin (ie. has no parent),
    use the cached previous value. If no previous value was cached, the
    query is sent to all sink elements in the bin and the MAXIMUM of all
    values is returned. If the bin is a toplevel bin the value is cached.
    If no sinks are available in the bin, the query fails.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;GST_QUERY_POSITION&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;The query is sent to all sink elements in the bin and the
    MAXIMUM of all values is returned. If no sinks are available in the bin,
    the query fails.
    &lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;OTHERS&lt;/term&gt;
    &lt;listitem&gt;&lt;para&gt;the query is forwarded to all sink elements, the result
    of the first sink that answers the query successfully is returned. If no
    sink is in the bin, the query fails.&lt;/para&gt;&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

A #GstBin will by default forward any event sent to it to all sink elements.
If all the sinks return TRUE, the bin will also return TRUE, else FALSE is
returned. If no sinks are in the bin, the event handler will return TRUE.

&lt;/para&gt;
&lt;/refsect2&gt;

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <implements name="ChildProxy"/>
      <constructor name="new" c:identifier="gst_bin_new">
        <doc xml:whitespace="preserve">Creates a new bin with the given name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #GstBin</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the new bin</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="add_element">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="do_latency">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="element_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="element_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_element">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add" c:identifier="gst_bin_add">
        <doc xml:whitespace="preserve">Adds the given element to the bin.  Sets the element's parent, and thus
takes ownership of the element. An element can only be added to one bin.

If the element's pads are linked to other pads, the pads will be unlinked
before the element is added to the bin.

&lt;note&gt;
When you add an element to an already-running pipeline, you will have to
take care to set the state of the newly-added element to the desired
state (usually PLAYING or PAUSED, same you set the pipeline to originally)
with gst_element_set_state(), or use gst_element_sync_state_with_parent().
The bin or pipeline will not take care of this for you.
&lt;/note&gt;

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the element could be added, FALSE if the bin does not want to accept the element.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstElement to add</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_many"
              c:identifier="gst_bin_add_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a NULL-terminated list of elements to a bin.  This function is
equivalent to calling gst_bin_add() for each member of the list. The return
value of each gst_bin_add() is ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element_1" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstElement element to add to the bin</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="find_unlinked_pad"
              c:identifier="gst_bin_find_unlinked_pad">
        <doc xml:whitespace="preserve">Recursively looks for elements with an unlinked pad of the given
direction within the specified bin and returns an unlinked pad
if one is found, or NULL otherwise. If a pad is found, the caller
owns a reference to it and should use gst_object_unref() on the
pad when it is not needed any longer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">unlinked pad of the given direction, or NULL.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to look for an unlinked source or sink pad</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_by_interface" c:identifier="gst_bin_get_by_interface">
        <doc xml:whitespace="preserve">Looks for an element inside the bin that implements the given
interface. If such an element is found, it returns the element.
You can cast this element to the given interface afterwards.  If you want
all elements that implement the interface, use
gst_bin_iterate_all_by_interface(). This function recurses into child bins.

MT safe.  Caller owns returned reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A #GstElement inside the bin implementing the interface</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of an interface</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_by_name" c:identifier="gst_bin_get_by_name">
        <doc xml:whitespace="preserve">Gets the element with the given name from a bin. This
function recurses into child bins.

Returns NULL if no element with the given name is found in the bin.

MT safe.  Caller owns returned reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstElement with the given name, or NULL</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element name to search for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_by_name_recurse_up"
              c:identifier="gst_bin_get_by_name_recurse_up">
        <doc xml:whitespace="preserve">Gets the element with the given name from this bin. If the
element is not found, a recursion is performed on the parent bin.

Returns NULL if:
- no element with the given name is found in the bin

MT safe.  Caller owns returned reference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstElement with the given name, or NULL</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element name to search for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_all_by_interface"
              c:identifier="gst_bin_iterate_all_by_interface">
        <doc xml:whitespace="preserve">Looks for all elements inside the bin that implements the given
interface. You can safely cast all returned elements to the given interface.
The function recurses inside child bins. The iterator will yield a series
of #GstElement that should be unreffed after use.

Each element yielded by the iterator will have its refcount increased, so
unref after use.

MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement for all elements in the bin implementing the given interface, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="iface" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of an interface</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_elements" c:identifier="gst_bin_iterate_elements">
        <doc xml:whitespace="preserve">Gets an iterator for the elements in this bin.

Each element yielded by the iterator will have its refcount increased, so
unref after use.

MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_recurse" c:identifier="gst_bin_iterate_recurse">
        <doc xml:whitespace="preserve">Gets an iterator for the elements in this bin.
This iterator recurses into GstBin children.

Each element yielded by the iterator will have its refcount increased, so
unref after use.

MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sinks" c:identifier="gst_bin_iterate_sinks">
        <doc xml:whitespace="preserve">Gets an iterator for all elements in the bin that have the
#GST_ELEMENT_FLAG_SINK flag set.

Each element yielded by the iterator will have its refcount increased, so
unref after use.

MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sorted" c:identifier="gst_bin_iterate_sorted">
        <doc xml:whitespace="preserve">Gets an iterator for the elements in this bin in topologically
sorted order. This means that the elements are returned from
the most downstream elements (sinks) to the sources.

This function is used internally to perform the state changes
of the bin elements and for clock selection.

Each element yielded by the iterator will have its refcount increased, so
unref after use.

MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sources" c:identifier="gst_bin_iterate_sources">
        <doc xml:whitespace="preserve">Gets an iterator for all elements in the bin that have the
#GST_ELEMENT_FLAG_SOURCE flag set.

Each element yielded by the iterator will have its refcount increased, so
unref after use.

MT safe.  Caller owns returned value.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstElement, or NULL</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="recalculate_latency"
              c:identifier="gst_bin_recalculate_latency">
        <doc xml:whitespace="preserve">Query @bin for the current latency using and reconfigures this latency to all the
elements with a LATENCY event.

This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
is posted on the bus.

This function simply emits the 'do-latency' signal so any custom latency
calculations will be performed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the latency could be queried and reconfigured.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove" c:identifier="gst_bin_remove">
        <doc xml:whitespace="preserve">Removes the element from the bin, unparenting it as well.
Unparenting the element means that the element will be dereferenced,
so if the bin holds the only reference to the element, the element
will be freed in the process of removing it from the bin.  If you
want the element to still exist after removing, you need to call
gst_object_ref() before removing it from the bin.

If the element's pads are linked to other pads, the pads will be unlinked
before the element is removed from the bin.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the element could be removed, FALSE if the bin does not want to remove the element.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement to remove</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_many"
              c:identifier="gst_bin_remove_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Remove a list of elements from a bin. This function is equivalent
to calling gst_bin_remove() with each member of the list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element_1" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first #GstElement to remove from the bin</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <property name="async-handling" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">If set to #TRUE, the bin will handle asynchronous state changes.
This should be used only if the bin subclass is modifying the state
of its children on its own.</doc>
        <type name="gboolean"/>
      </property>
      <property name="message-forward" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Forward all children messages, even those that would normally be filtered by
the bin. This can be interesting when one wants to be notified of the EOS
state of individual elements, for example.

The messages are converted to an ELEMENT message with the bin as the
source. The structure of the message is named 'GstBinForwarded' and contains
a field named 'message' of type GST_TYPE_MESSAGE that contains the original
forwarded message.</doc>
        <type name="gboolean"/>
      </property>
      <field name="element">
        <type name="Element" c:type="GstElement"/>
      </field>
      <field name="numchildren">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="children">
        <type name="GLib.List" c:type="GList*">
          <type name="Element"/>
        </type>
      </field>
      <field name="children_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="child_bus">
        <type name="Bus" c:type="GstBus*"/>
      </field>
      <field name="messages">
        <type name="GLib.List" c:type="GList*">
          <type name="Message"/>
        </type>
      </field>
      <field name="polling">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="state_dirty">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="clock_dirty">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="provided_clock">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="clock_provider">
        <type name="Element" c:type="GstElement*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BinPrivate" c:type="GstBinPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="do-latency" when="last">
        <doc xml:whitespace="preserve">Will be emitted when the bin needs to perform latency calculations. This
signal is only emited for toplevel bins or when async-handling is
enabled.

Only one signal handler is invoked. If no signals are connected, the
default handler is invoked, which will query and distribute the lowest
possible latency to all sinks.

Connect to this signal if the default latency calculations are not
sufficient, like when you need different latencies for different sinks in
the same pipeline.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean"/>
        </return-value>
      </glib:signal>
      <glib:signal name="element-added" when="first">
        <doc xml:whitespace="preserve">Will be emitted after the element was added to the bin.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement that was added to the bin</doc>
            <type name="Element"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="element-removed" when="first">
        <doc xml:whitespace="preserve">Will be emitted after the element was removed from the bin.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="element" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement that was removed from the bin</doc>
            <type name="Element"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BinClass"
            c:type="GstBinClass"
            glib:is-gtype-struct-for="Bin">
      <doc xml:whitespace="preserve">Subclasses can override the @add_element and @remove_element to
update the list of children in the bin.

The @handle_message method can be overridden to implement custom
message handling.  @handle_message takes ownership of the message, just like
#gst_element_post_message.</doc>
      <field name="parent_class">
        <type name="ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="pool" readable="0" private="1">
        <type name="GLib.ThreadPool" c:type="GThreadPool*"/>
      </field>
      <field name="element_added">
        <callback name="element_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="element_removed">
        <callback name="element_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_element">
        <callback name="add_element">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_element">
        <callback name="remove_element">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_message">
        <callback name="handle_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="GstMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_latency">
        <callback name="do_latency">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="bin" transfer-ownership="none">
              <type name="Bin" c:type="GstBin*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BinFlags" c:type="GstBinFlags">
      <doc xml:whitespace="preserve">GstBinFlags are a set of flags specific to bins. Most are set/used
internally. They can be checked using the GST_OBJECT_FLAG_IS_SET () macro,
and (un)set using GST_OBJECT_FLAG_SET () and GST_OBJECT_FLAG_UNSET ().</doc>
      <member name="no_resync"
              value="16384"
              c:identifier="GST_BIN_FLAG_NO_RESYNC">
        <doc xml:whitespace="preserve">don't resync a state change when elements are added or linked in the bin (Since 1.0.5)</doc>
      </member>
      <member name="last" value="524288" c:identifier="GST_BIN_FLAG_LAST">
        <doc xml:whitespace="preserve">the last enum in the series of flags for bins. Derived classes can use this as first value in a list of flags.</doc>
      </member>
    </bitfield>
    <record name="BinPrivate" c:type="GstBinPrivate" disguised="1">
    </record>
    <class name="Bitmask"
           c:symbol-prefix="bitmask"
           glib:type-name="GstBitmask"
           glib:get-type="gst_bitmask_get_type"
           glib:fundamental="1">
    </class>
    <record name="Buffer"
            c:type="GstBuffer"
            glib:type-name="GstBuffer"
            glib:get-type="gst_buffer_get_type"
            c:symbol-prefix="buffer">
      <doc xml:whitespace="preserve">Buffers are the basic unit of data transfer in GStreamer. They contain the
timing and offset along with other arbitrary metadata that is associated
with the #GstMemory blocks that the buffer contains.

Buffers are usually created with gst_buffer_new(). After a buffer has been
created one will typically allocate memory for it and add it to the buffer.
The following example creates a buffer that can hold a given video frame
with a given width, height and bits per plane.
&lt;example&gt;
&lt;title&gt;Creating a buffer for a video frame&lt;/title&gt;
  &lt;programlisting&gt;
  GstBuffer *buffer;
  GstMemory *memory;
  gint size, width, height, bpp;
  ...
  size = width * height * bpp;
  buffer = gst_buffer_new ();
  memory = gst_allocator_alloc (NULL, size, NULL);
  gst_buffer_insert_memory (buffer, -1, memory);
  ...
  &lt;/programlisting&gt;
&lt;/example&gt;

Alternatively, use gst_buffer_new_allocate()
to create a buffer with preallocated data of a given size.

Buffers can contain a list of #GstMemory objects. You can retrieve how many
memory objects with gst_buffer_n_memory() and you can get a pointer
to memory with gst_buffer_peek_memory()

A buffer will usually have timestamps, and a duration, but neither of these
are guaranteed (they may be set to #GST_CLOCK_TIME_NONE). Whenever a
meaningful value can be given for these, they should be set. The timestamps
and duration are measured in nanoseconds (they are #GstClockTime values).

The buffer DTS refers to the timestamp when the buffer should be decoded and
is usually monotonically increasing. The buffer PTS refers to the timestamp when
the buffer content should be presented to the user and is not always
monotonically increasing.

A buffer can also have one or both of a start and an end offset. These are
media-type specific. For video buffers, the start offset will generally be
the frame number. For audio buffers, it will be the number of samples
produced so far. For compressed data, it could be the byte offset in a
source or destination file. Likewise, the end offset will be the offset of
the end of the buffer. These can only be meaningfully interpreted if you
know the media type of the buffer (the preceeding CAPS event). Either or both
can be set to #GST_BUFFER_OFFSET_NONE.

gst_buffer_ref() is used to increase the refcount of a buffer. This must be
done when you want to keep a handle to the buffer after pushing it to the
next element. The buffer refcount determines the writability of the buffer, a
buffer is only writable when the refcount is exactly 1, i.e. when the caller
has the only reference to the buffer.

To efficiently create a smaller buffer out of an existing one, you can
use gst_buffer_copy_region(). This method tries to share the memory objects
between the two buffers.

If a plug-in wants to modify the buffer data or metadata in-place, it should
first obtain a buffer that is safe to modify by using
gst_buffer_make_writable().  This function is optimized so that a copy will
only be made when it is necessary.

Several flags of the buffer can be set and unset with the
GST_BUFFER_FLAG_SET() and GST_BUFFER_FLAG_UNSET() macros. Use
GST_BUFFER_FLAG_IS_SET() to test if a certain #GstBufferFlag is set.

Buffers can be efficiently merged into a larger buffer with
gst_buffer_append(). Copying of memory will only be done when absolutely
needed.

Arbitrary extra metadata can be set on a buffer with gst_buffer_add_meta().
Metadata can be retrieved with gst_buffer_get_meta(). See also #GstMeta

An element should either unref the buffer or push it out on a src pad
using gst_pad_push() (see #GstPad).

Buffers are usually freed by unreffing them with gst_buffer_unref(). When
the refcount drops to 0, any memory and metadata pointed to by the buffer is
unreffed as well. Buffers allocated from a #GstBufferPool will be returned to
the pool when the refcount drops to 0.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <field name="mini_object" writable="1">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="pool" writable="1">
        <type name="BufferPool" c:type="GstBufferPool*"/>
      </field>
      <field name="pts" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="dts" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="duration" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="offset" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="offset_end" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <constructor name="new" c:identifier="gst_buffer_new">
        <doc xml:whitespace="preserve">Creates a newly allocated buffer without any data.

MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </constructor>
      <constructor name="new_allocate" c:identifier="gst_buffer_new_allocate">
        <doc xml:whitespace="preserve">Tries to create a newly allocated buffer with data of the given size and
extra parameters from @allocator. If the requested amount of memory can't be
allocated, NULL will be returned. The allocated buffer memory is not cleared.

When @allocator is NULL, the default memory allocator will be used.

Note that when @size == 0, the buffer will not have memory associated with it.

MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBuffer, or NULL if the memory couldn't be allocated.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="allocator" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the #GstAllocator to use, or NULL to use the default allocator</doc>
            <type name="Allocator" c:type="GstAllocator*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size in bytes of the new buffer's data.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">optional parameters</doc>
            <type name="AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_wrapped" c:identifier="gst_buffer_new_wrapped">
        <doc xml:whitespace="preserve">Creates a new buffer that wraps the given @data. The memory will be freed
with g_free and will be marked writable.

MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to wrap</doc>
            <array length="1" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">allocated size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_wrapped_full"
                   c:identifier="gst_buffer_new_wrapped_full">
        <doc xml:whitespace="preserve">Allocate a new buffer that wraps the given memory. @data must point to
@maxsize of memory, the wrapped buffer will have the region from @offset and
@size visible.

When the buffer is destroyed, @notify will be called with @user_data.

The prefix/padding must be filled with 0 if @flags contains
#GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstMemoryFlags</doc>
            <type name="MemoryFlags" c:type="GstMemoryFlags"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to wrap</doc>
            <array length="4" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="maxsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">allocated size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset in @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">size of valid data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data when the memory is freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_meta" c:identifier="gst_buffer_add_meta">
        <doc xml:whitespace="preserve">Add metadata for @info to @buffer using the parameters in @params.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the metadata for the api in @info on @buffer.</doc>
          <type name="Meta" c:type="GstMeta*"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstMetaInfo</doc>
            <type name="MetaInfo" c:type="const GstMetaInfo*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:whitespace="preserve">params for @info</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="append" c:identifier="gst_buffer_append">
        <doc xml:whitespace="preserve">Append all the memory from @buf2 to @buf1. The result buffer will contain a
concatenation of the memory of @buf1 and @buf2.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer that contains the memory of the two source buffers.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="buf2" transfer-ownership="full">
            <doc xml:whitespace="preserve">the second source #GstBuffer to append.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_memory" c:identifier="gst_buffer_append_memory">
        <doc xml:whitespace="preserve">Append the memory block @mem to @buffer. This function takes
ownership of @mem and thus doesn't increase its refcount.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mem" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMemory.</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_region" c:identifier="gst_buffer_append_region">
        <doc xml:whitespace="preserve">Append @size bytes at @offset from @buf2 to @buf1. The result buffer will
contain a concatenation of the memory of @buf1 and the requested region of
@buf2.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer that contains the memory of the two source buffers.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="buf2" transfer-ownership="full">
            <doc xml:whitespace="preserve">the second source #GstBuffer to append.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset in @buf2</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size or -1 of @buf2</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_into" c:identifier="gst_buffer_copy_into">
        <doc xml:whitespace="preserve">Copies the information from @src into @dest.

If @dest already contains memory and @flags contains GST_BUFFER_COPY_MEMORY,
the memory from @src will be appended to @dest.

@flags indicate which fields will be copied.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">a source #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags indicating what metadata fields should be copied.</doc>
            <type name="BufferCopyFlags" c:type="GstBufferCopyFlags"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset to copy from</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">total size to copy. If -1, all data is copied.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_region" c:identifier="gst_buffer_copy_region">
        <doc xml:whitespace="preserve">Creates a sub-buffer from @parent at @offset and @size.
This sub-buffer uses the actual memory space of the parent buffer.
This function will copy the offset and timestamp fields when the
offset is 0. If not, they will be set to #GST_CLOCK_TIME_NONE and 
#GST_BUFFER_OFFSET_NONE.
If @offset equals 0 and @size equals the total size of @buffer, the
duration and offset end fields are also copied. If not they will be set
to #GST_CLOCK_TIME_NONE and #GST_BUFFER_OFFSET_NONE.

MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBuffer or NULL if the arguments were invalid.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstBufferCopyFlags</doc>
            <type name="BufferCopyFlags" c:type="GstBufferCopyFlags"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset into parent #GstBuffer at which the new sub-buffer begins.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the new #GstBuffer sub-buffer, in bytes.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="extract" c:identifier="gst_buffer_extract">
        <doc xml:whitespace="preserve">Copy @size bytes starting from @offset in @buffer to @dest.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The amount of bytes extracted. This value can be lower than @size when @buffer did not contain enough data.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset to extract</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination address</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size to extract</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill" c:identifier="gst_buffer_fill">
        <doc xml:whitespace="preserve">Copy @size bytes from @src to @buffer at @offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The amount of bytes copied. This value can be lower than @size when @buffer did not contain enough data.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset to fill</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source address</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size to fill</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_memory" c:identifier="gst_buffer_find_memory">
        <doc xml:whitespace="preserve">Find the memory blocks that span @size bytes starting from @offset
in @buffer.

When this function returns %TRUE, @idx will contain the index of the first
memory bock where the byte for @offset can be found and @length contains the
number of memory blocks containing the @size remaining bytes. @skip contains
the number of bytes to skip in the memory bock at @idx to get to the byte
for @offset.

@size can be -1 to get all the memory blocks after @idx.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE when @size bytes starting from @offset could be found in @buffer and @idx, @length and @skip will be filled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">an offset</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">a size</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="idx"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to index</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to length</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="skip"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to skip</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_meta" c:identifier="gst_buffer_foreach_meta">
        <doc xml:whitespace="preserve">Call @func with @user_data for each meta in @buffer.

@func can modify the passed meta pointer or its contents. The return value
of @func define if this function returns or if the remaining metadata items
in the buffer should be skipped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE when @func returned %FALSE for one of the metadata.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a #GstBufferForeachMetaFunc to call</doc>
            <type name="BufferForeachMetaFunc"
                  c:type="GstBufferForeachMetaFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_all_memory" c:identifier="gst_buffer_get_all_memory">
        <doc xml:whitespace="preserve">Get all the memory block in @buffer. The memory blocks will be merged
into one large #GstMemory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstMemory that contains the merged memory. Use gst_memory_unref () after usage.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
      </method>
      <method name="get_memory" c:identifier="gst_buffer_get_memory">
        <doc xml:whitespace="preserve">Get the memory block at index @idx in @buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstMemory that contains the data of the memory block at @idx. Use gst_memory_unref () after usage.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_memory_range"
              c:identifier="gst_buffer_get_memory_range">
        <doc xml:whitespace="preserve">Get @length memory blocks in @buffer starting at @idx. The memory blocks will
be merged into one large #GstMemory.

If @length is -1, all memory starting from @idx is merged.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstMemory that contains the merged data of @length blocks starting at @idx. Use gst_memory_unref () after usage.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_meta" c:identifier="gst_buffer_get_meta">
        <doc xml:whitespace="preserve">Get the metadata for @api on buffer. When there is no such
metadata, NULL is returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the metadata for @api on @buffer.</doc>
          <type name="Meta" c:type="GstMeta*"/>
        </return-value>
        <parameters>
          <parameter name="api" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of an API</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="gst_buffer_get_size">
        <doc xml:whitespace="preserve">Get the total size of the memory blocks in @buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">total size of the memory blocks in @buffer.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
      </method>
      <method name="get_sizes" c:identifier="gst_buffer_get_sizes">
        <doc xml:whitespace="preserve">Get the total size of the memory blocks in @b.

When not %NULL, @offset will contain the offset of the data in the
first memory block in @buffer and @maxsize will contain the sum of
the size and @offset and the amount of extra padding on the last
memory block.  @offset and @maxsize can be used to resize the
buffer memory blocks with gst_buffer_resize().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">total size of the memory blocks in @buffer.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="offset"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the offset</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="maxsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the maxsize</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sizes_range" c:identifier="gst_buffer_get_sizes_range">
        <doc xml:whitespace="preserve">Get the total size of @length memory blocks stating from @idx in @buffer.

When not %NULL, @offset will contain the offset of the data in the
memory block in @buffer at @idx and @maxsize will contain the sum of the size
and @offset and the amount of extra padding on the memory block at @idx +
@length -1.
@offset and @maxsize can be used to resize the buffer memory blocks with
gst_buffer_resize_range().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">total size of @length memory blocks starting at @idx in @buffer.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="offset"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the offset</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="maxsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the maxsize</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert_memory" c:identifier="gst_buffer_insert_memory">
        <doc xml:whitespace="preserve">Insert the memory block @mem to @buffer at @idx. This function takes ownership
of @mem and thus doesn't increase its refcount.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index to add the memory at, or -1 to append it to the end</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="mem" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMemory.</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_meta" c:identifier="gst_buffer_iterate_meta">
        <doc xml:whitespace="preserve">Retrieve the next #GstMeta after @current. If @state points
to %NULL, the first metadata is returned.

@state will be updated with an opage state pointer</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The next #GstMeta or %NULL when there are no more items.</doc>
          <type name="Meta" c:type="GstMeta*"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">an opaque state pointer</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="gst_buffer_map">
        <doc xml:whitespace="preserve">This function fills @info with the #GstMapInfo of all merged memory
blocks in @buffer.

@flags describe the desired access of the memory. When @flags is
#GST_MAP_WRITE, @buffer should be writable (as returned from
gst_buffer_is_writable()).

When @buffer is writable but the memory isn't, a writable copy will
automatically be created and returned. The readonly copy of the
buffer memory will then also be replaced with this writable copy.

The memory in @info should be unmapped with gst_buffer_unmap() after
usage.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the map succeeded and @info contains valid data.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="info"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">info about the mapping</doc>
            <type name="MapInfo" c:type="GstMapInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags for the mapping</doc>
            <type name="MapFlags" c:type="GstMapFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="map_range" c:identifier="gst_buffer_map_range">
        <doc xml:whitespace="preserve">This function fills @info with the #GstMapInfo of @length merged memory blocks
starting at @idx in @buffer. When @length is -1, all memory blocks starting
from @idx are merged and mapped.

@flags describe the desired access of the memory. When @flags is
#GST_MAP_WRITE, @buffer should be writable (as returned from
gst_buffer_is_writable()).

When @buffer is writable but the memory isn't, a writable copy will
automatically be created and returned. The readonly copy of the buffer memory
will then also be replaced with this writable copy.

The memory in @info should be unmapped with gst_buffer_unmap() after usage.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the map succeeded and @info contains valid data.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="info"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">info about the mapping</doc>
            <type name="MapInfo" c:type="GstMapInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags for the mapping</doc>
            <type name="MapFlags" c:type="GstMapFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="memcmp" c:identifier="gst_buffer_memcmp">
        <doc xml:whitespace="preserve">Compare @size bytes starting from @offset in @buffer with the memory in @mem.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">0 if the memory is equal.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset in @buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="mem" transfer-ownership="none">
            <doc xml:whitespace="preserve">the memory to compare</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size to compare</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="memset" c:identifier="gst_buffer_memset">
        <doc xml:whitespace="preserve">Fill @buf with @size bytes with @val starting from @offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The amount of bytes filled. This value can be lower than @size when @buffer did not contain enough data.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset in @buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to set</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size to set</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="n_memory" c:identifier="gst_buffer_n_memory">
        <doc xml:whitespace="preserve">Get the amount of memory blocks that this buffer has.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the amount of memory block in this buffer.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="peek_memory" c:identifier="gst_buffer_peek_memory">
        <doc xml:whitespace="preserve">Get the memory block at @idx in @buffer. The memory block stays valid until
the memory block in @buffer is removed, replaced or merged, typically with
any call that modifies the memory in @buffer.

Since this call does not influence the refcount of the memory,
gst_memory_is_writable() can be used to check if @buffer is the sole owner
of the returned memory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstMemory at @idx.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_memory" c:identifier="gst_buffer_prepend_memory">
        <doc xml:whitespace="preserve">Prepend the memory block @mem to @buffer. This function takes
ownership of @mem and thus doesn't increase its refcount.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mem" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMemory.</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_all_memory"
              c:identifier="gst_buffer_remove_all_memory">
        <doc xml:whitespace="preserve">Remove all the memory blocks in @buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="remove_memory" c:identifier="gst_buffer_remove_memory">
        <doc xml:whitespace="preserve">Remove the memory block in @b at index @i.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_memory_range"
              c:identifier="gst_buffer_remove_memory_range">
        <doc xml:whitespace="preserve">Remove @length memory blocks in @buffer starting from @idx.

@length can be -1, in which case all memory starting from @idx is removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_meta" c:identifier="gst_buffer_remove_meta">
        <doc xml:whitespace="preserve">Remove the metadata for @meta on @buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the metadata existed and was removed, %FALSE if no such metadata was on @buffer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="meta" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstMeta</doc>
            <type name="Meta" c:type="GstMeta*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_all_memory"
              c:identifier="gst_buffer_replace_all_memory">
        <doc xml:whitespace="preserve">Replaces all memory in @buffer with @mem.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mem" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMemory</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_memory" c:identifier="gst_buffer_replace_memory">
        <doc xml:whitespace="preserve">Replaces the memory block at index @idx in @buffer with @mem.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="mem" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMemory</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_memory_range"
              c:identifier="gst_buffer_replace_memory_range">
        <doc xml:whitespace="preserve">Replaces @length memory blocks in @buffer starting at @idx with @mem.

If @length is -1, all memory starting from @idx will be removed and
replaced with @mem.

@buffer should be writable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a length should not be 0</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="mem" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMemory</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resize" c:identifier="gst_buffer_resize">
        <doc xml:whitespace="preserve">Set the offset and total size of the memory blocks in @buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset adjustement</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new size or -1 to just adjust the offset</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="resize_range" c:identifier="gst_buffer_resize_range">
        <doc xml:whitespace="preserve">Set the total size of the @length memory blocks starting at @idx in
@buffer</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">an index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a length</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset adjustement</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new size or -1 to just adjust the offset</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_size" c:identifier="gst_buffer_set_size">
        <doc xml:whitespace="preserve">Set the total size of the memory blocks in @buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new size</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmap" c:identifier="gst_buffer_unmap">
        <doc xml:whitespace="preserve">Release the memory previously mapped with gst_buffer_map().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstMapInfo</doc>
            <type name="MapInfo" c:type="GstMapInfo*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="BufferCopyFlags" c:type="GstBufferCopyFlags">
      <doc xml:whitespace="preserve">A set of flags that can be provided to the gst_buffer_copy_into()
function to specify which items should be copied.</doc>
      <member name="none" value="0" c:identifier="GST_BUFFER_COPY_NONE">
        <doc xml:whitespace="preserve">copy nothing</doc>
      </member>
      <member name="flags" value="1" c:identifier="GST_BUFFER_COPY_FLAGS">
        <doc xml:whitespace="preserve">flag indicating that buffer flags should be copied</doc>
      </member>
      <member name="timestamps"
              value="2"
              c:identifier="GST_BUFFER_COPY_TIMESTAMPS">
        <doc xml:whitespace="preserve">flag indicating that buffer pts, dts, duration, offset and offset_end should be copied</doc>
      </member>
      <member name="meta" value="4" c:identifier="GST_BUFFER_COPY_META">
        <doc xml:whitespace="preserve">flag indicating that buffer meta should be copied</doc>
      </member>
      <member name="memory" value="8" c:identifier="GST_BUFFER_COPY_MEMORY">
        <doc xml:whitespace="preserve">flag indicating that buffer memory should be copied and appended to already existing memory</doc>
      </member>
      <member name="merge" value="16" c:identifier="GST_BUFFER_COPY_MERGE">
        <doc xml:whitespace="preserve">flag indicating that buffer memory should be merged</doc>
      </member>
    </bitfield>
    <bitfield name="BufferFlags" c:type="GstBufferFlags">
      <doc xml:whitespace="preserve">A set of buffer flags used to describe properties of a #GstBuffer.</doc>
      <member name="live" value="16" c:identifier="GST_BUFFER_FLAG_LIVE">
        <doc xml:whitespace="preserve">the buffer is live data and should be discarded in the PAUSED state.</doc>
      </member>
      <member name="decode_only"
              value="32"
              c:identifier="GST_BUFFER_FLAG_DECODE_ONLY">
        <doc xml:whitespace="preserve">the buffer contains data that should be dropped because it will be clipped against the segment boundaries or because it does not contain data that should be shown to the user.</doc>
      </member>
      <member name="discont" value="64" c:identifier="GST_BUFFER_FLAG_DISCONT">
        <doc xml:whitespace="preserve">the buffer marks a data discontinuity in the stream. This typically occurs after a seek or a dropped buffer from a live or network source.</doc>
      </member>
      <member name="resync" value="128" c:identifier="GST_BUFFER_FLAG_RESYNC">
        <doc xml:whitespace="preserve">the buffer timestamps might have a discontinuity and this buffer is a good point to resynchronize.</doc>
      </member>
      <member name="corrupted"
              value="256"
              c:identifier="GST_BUFFER_FLAG_CORRUPTED">
        <doc xml:whitespace="preserve">the buffer data is corrupted.</doc>
      </member>
      <member name="marker" value="512" c:identifier="GST_BUFFER_FLAG_MARKER">
        <doc xml:whitespace="preserve">the buffer contains a media specific marker. for video this is typically the end of a frame boundary, for audio this is usually the start of a talkspurt.</doc>
      </member>
      <member name="header" value="1024" c:identifier="GST_BUFFER_FLAG_HEADER">
        <doc xml:whitespace="preserve">the buffer contains header information that is needed to decode the following data.</doc>
      </member>
      <member name="gap" value="2048" c:identifier="GST_BUFFER_FLAG_GAP">
        <doc xml:whitespace="preserve">the buffer has been created to fill a gap in the stream and contains media neutral data (elements can switch to optimized code path that ignores the buffer content).</doc>
      </member>
      <member name="droppable"
              value="4096"
              c:identifier="GST_BUFFER_FLAG_DROPPABLE">
        <doc xml:whitespace="preserve">the buffer can be dropped without breaking the stream, for example to reduce bandwidth.</doc>
      </member>
      <member name="delta_unit"
              value="8192"
              c:identifier="GST_BUFFER_FLAG_DELTA_UNIT">
        <doc xml:whitespace="preserve">this unit cannot be decoded independently.</doc>
      </member>
      <member name="last" value="1048576" c:identifier="GST_BUFFER_FLAG_LAST">
        <doc xml:whitespace="preserve">additional media specific flags can be added starting from this flag.</doc>
      </member>
    </bitfield>
    <callback name="BufferForeachMetaFunc" c:type="GstBufferForeachMetaFunc">
      <doc xml:whitespace="preserve">A function that will be called from gst_buffer_foreach_meta(). The @meta
field will point to a the reference of the meta.

@buffer should not be modified from this callback.

When this function returns %TRUE, the next meta will be
returned. When %FALSE is returned, gst_buffer_foreach_meta() will return.

When @meta is set to NULL, the item will be removed from the buffer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE when gst_buffer_foreach_meta() should stop</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="meta" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a #GstMeta</doc>
          <type name="Meta" c:type="GstMeta**"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data passed to gst_buffer_foreach_meta()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BufferList"
            c:type="GstBufferList"
            glib:type-name="GstBufferList"
            glib:get-type="gst_buffer_list_get_type"
            c:symbol-prefix="buffer_list">
      <doc xml:whitespace="preserve">Buffer lists are an object containing a list of buffers.

Buffer lists are created with gst_buffer_list_new() and filled with data
using a gst_buffer_list_insert().

Buffer lists can be pushed on a srcpad with gst_pad_push_list(). This is
interesting when multiple buffers need to be pushed in one go because it
can reduce the amount of overhead for pushing each buffer individually.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <constructor name="new" c:identifier="gst_buffer_list_new">
        <doc xml:whitespace="preserve">Creates a new, empty #GstBufferList. The caller is responsible for unreffing
the returned #GstBufferList.

Free-function: gst_buffer_list_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBufferList. gst_buffer_list_unref() after usage.</doc>
          <type name="BufferList" c:type="GstBufferList*"/>
        </return-value>
      </constructor>
      <constructor name="new_sized" c:identifier="gst_buffer_list_new_sized">
        <doc xml:whitespace="preserve">Creates a new, empty #GstBufferList. The caller is responsible for unreffing
the returned #GstBufferList. The list will have @size space preallocated so
that memory reallocations can be avoided.

Free-function: gst_buffer_list_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstBufferList. gst_buffer_list_unref() after usage.</doc>
          <type name="BufferList" c:type="GstBufferList*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">an initial reserved size</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="foreach" c:identifier="gst_buffer_list_foreach">
        <doc xml:whitespace="preserve">Call @func with @data for each buffer in @list.

@func can modify the passed buffer pointer or its contents. The return value
of @func define if this function returns or if the remaining buffers in
the list should be skipped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE when @func returned %TRUE for each buffer in @list or when @list is empty.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a #GstBufferListFunc to call</doc>
            <type name="BufferListFunc" c:type="GstBufferListFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="gst_buffer_list_get">
        <doc xml:whitespace="preserve">Get the buffer at @idx.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the buffer at @idx in @group or NULL when there is no buffer. The buffer remains valid as long as @list is valid.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="gst_buffer_list_insert">
        <doc xml:whitespace="preserve">Insert @buffer at @idx in @list. Other buffers are moved to make room for
this new buffer.

A -1 value for @idx will append the buffer at the end.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="length" c:identifier="gst_buffer_list_length">
        <doc xml:whitespace="preserve">Returns the number of buffers in @list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of buffers in the buffer list</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="remove" c:identifier="gst_buffer_list_remove">
        <doc xml:whitespace="preserve">Remove @length buffers starting from @idx in @list. The following buffers are
moved to close the gap.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="BufferListFunc" c:type="GstBufferListFunc">
      <doc xml:whitespace="preserve">A function that will be called from gst_buffer_list_foreach(). The @buffer
field will point to a the reference of the buffer at @idx.

When this function returns %TRUE, the next buffer will be
returned. When %FALSE is returned, gst_buffer_list_foreach() will return.

When @buffer is set to NULL, the item will be removed from the bufferlist.
When @buffer has been made writable, the new buffer reference can be assigned
to @buffer. This function is responsible for unreffing the old buffer when
removing or modifying.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE when gst_buffer_list_foreach() should stop</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer the buffer</doc>
          <type name="Buffer" c:type="GstBuffer**"/>
        </parameter>
        <parameter name="idx" transfer-ownership="none">
          <doc xml:whitespace="preserve">the index of @buffer</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data passed to gst_buffer_list_foreach()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="BufferPool"
           c:symbol-prefix="buffer_pool"
           c:type="GstBufferPool"
           parent="Object"
           glib:type-name="GstBufferPool"
           glib:get-type="gst_buffer_pool_get_type"
           glib:type-struct="BufferPoolClass">
      <doc xml:whitespace="preserve">a #GstBufferPool is an object that can be used to pre-allocate and recycle
buffers of the same size and with the same properties.

A #GstBufferPool is created with gst_buffer_pool_new().

After the buffer is created, it needs to be configured.
gst_buffer_pool_get_config() get the current configuration structure from the
pool. With gst_buffer_pool_config_set_params() and
gst_buffer_pool_config_set_allocator() the bufferpool parameters and allocator
can be configured. Other properties can be configured in the pool depending
on the pool implementation.

A bufferpool can have extra options that can be enabled with
gst_buffer_pool_config_add_option(). The available options can be retrieved
with gst_buffer_pool_get_options(). Some options allow for additional
configuration properties to be set.

After the configuration structure has been configured,
gst_buffer_pool_set_config() updates the configuration in the pool. This can
fail when the configuration structure is not accepted.

After the a pool has been configured, it can be activated with
gst_buffer_pool_set_active(). This will preallocate the configured resources
in the pool.

When the pool is active, gst_buffer_pool_acquire_buffer() can be used to
retrieve a buffer from the pool.

Buffer allocated from a bufferpool will automatically be returned to the pool
with gst_buffer_pool_release_buffer() when their refcount drops to 0.

The bufferpool can be deactivated again with gst_buffer_pool_set_active().
All further gst_buffer_pool_acquire_buffer() calls will return an error. When
all buffers are returned to the pool they will be freed.

Use gst_object_unref() to release the reference to a bufferpool. If the
refcount of the pool reaches 0, the pool will be freed.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <constructor name="new" c:identifier="gst_buffer_pool_new">
        <doc xml:whitespace="preserve">Creates a new #GstBufferPool instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBufferPool instance</doc>
          <type name="BufferPool" c:type="GstBufferPool*"/>
        </return-value>
      </constructor>
      <function name="config_add_option"
                c:identifier="gst_buffer_pool_config_add_option">
        <doc xml:whitespace="preserve">Enabled the option in @config. This will instruct the @bufferpool to enable
the specified option on the buffers that it allocates.

The supported options by @pool can be retrieved with gst_buffer_pool_get_options().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="option" transfer-ownership="none">
            <doc xml:whitespace="preserve">an option to add</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="config_get_allocator"
                c:identifier="gst_buffer_pool_config_get_allocator">
        <doc xml:whitespace="preserve">Get the allocator and params from @config.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAllocator</doc>
            <type name="Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstAllocationParams</doc>
            <type name="AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </function>
      <function name="config_get_option"
                c:identifier="gst_buffer_pool_config_get_option">
        <doc xml:whitespace="preserve">Parse an available @config and get the option
at @index of the options API array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gchar of the option at @index.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the option array to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="config_get_params"
                c:identifier="gst_buffer_pool_config_get_params">
        <doc xml:whitespace="preserve">Get the configuration values from @config.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if all parameters could be fetched.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="caps"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the caps of buffers</doc>
            <type name="Caps" c:type="GstCaps**"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the size of each buffer, not including prefix and padding</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="min_buffers"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the minimum amount of buffers to allocate.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="max_buffers"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the maximum amount of buffers to allocate or 0 for unlimited.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="config_has_option"
                c:identifier="gst_buffer_pool_config_has_option">
        <doc xml:whitespace="preserve">Check if @config contains @option</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the options array contains @option.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="option" transfer-ownership="none">
            <doc xml:whitespace="preserve">an option</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="config_n_options"
                c:identifier="gst_buffer_pool_config_n_options">
        <doc xml:whitespace="preserve">Retrieve the number of values currently stored in the
options array of the @config structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the options array size as a #guint.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </function>
      <function name="config_set_allocator"
                c:identifier="gst_buffer_pool_config_set_allocator">
        <doc xml:whitespace="preserve">Set the @allocator and @params on @config.

One of @allocator and @params can be NULL, but not both. When @allocator
is NULL, the default allocator of the pool will use the values in @param
to perform its allocation. When @param is NULL, the pool will use the
provided allocator with its default #GstAllocationParams.

A call to gst_buffer_pool_set_config() can update the allocator and params
with the values that it is able to do. Some pools are, for example, not able
to operate with different allocators or cannot allocate with the values
specified in @params. Use gst_buffer_pool_get_config() to get the currently
used values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstAllocator</doc>
            <type name="Allocator" c:type="GstAllocator*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstAllocationParams</doc>
            <type name="AllocationParams" c:type="const GstAllocationParams*"/>
          </parameter>
        </parameters>
      </function>
      <function name="config_set_params"
                c:identifier="gst_buffer_pool_config_set_params">
        <doc xml:whitespace="preserve">Configure @config with the given parameters.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstBufferPool configuration</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">caps for the buffers</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of each buffer, not including prefix and padding</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_buffers" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minimum amount of buffers to allocate.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_buffers" transfer-ownership="none">
            <doc xml:whitespace="preserve">the maximum amount of buffers to allocate or 0 for unlimited.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="acquire_buffer" invoker="acquire_buffer">
        <doc xml:whitespace="preserve">Acquire a buffer from @pool. @buffer should point to a memory location that
can hold a pointer to the new buffer.

@params can be NULL or contain optional parameters to influence the allocation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn such as GST_FLOW_FLUSHING when the pool is inactive.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a location for a #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters.</doc>
            <type name="BufferPoolAcquireParams"
                  c:type="GstBufferPoolAcquireParams*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="alloc_buffer">
        <return-value transfer-ownership="none">
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="BufferPoolAcquireParams"
                  c:type="GstBufferPoolAcquireParams*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="free_buffer">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_options" invoker="get_options">
        <doc xml:whitespace="preserve">Get a NULL terminated array of string with supported bufferpool options for
@pool. An option would typically be enabled with
gst_buffer_pool_config_add_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a NULL terminated array of strings.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="release_buffer" invoker="release_buffer">
        <doc xml:whitespace="preserve">Release @buffer to @pool. @buffer should have previously been allocated from
@pool with gst_buffer_pool_acquire_buffer().

This function is usually called automatically when the last ref on @buffer
disappears.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset_buffer">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_config" invoker="set_config">
        <doc xml:whitespace="preserve">Set the configuration of the pool. The pool must be inactive and all buffers
allocated form this pool must be returned or else this function will do
nothing and return FALSE.

@config is a #GstStructure that contains the configuration parameters for
the pool. A default and mandatory set of parameters can be configured with
gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
and gst_buffer_pool_config_add_option().

If the parameters in @config can not be set exactly, this function returns
FALSE and will try to update as much state as possible. The new state can
then be retrieved and refined with gst_buffer_pool_get_config().

This function takes ownership of @config.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE when the configuration could be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstStructure</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <method name="acquire_buffer"
              c:identifier="gst_buffer_pool_acquire_buffer">
        <doc xml:whitespace="preserve">Acquire a buffer from @pool. @buffer should point to a memory location that
can hold a pointer to the new buffer.

@params can be NULL or contain optional parameters to influence the allocation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn such as GST_FLOW_FLUSHING when the pool is inactive.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a location for a #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters.</doc>
            <type name="BufferPoolAcquireParams"
                  c:type="GstBufferPoolAcquireParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_config" c:identifier="gst_buffer_pool_get_config">
        <doc xml:whitespace="preserve">Get a copy of the current configuration of the pool. This configuration
can either be modified and used for the gst_buffer_pool_set_config() call
or it must be freed after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of the current configuration of @pool. use gst_structure_free() after usage or gst_buffer_pool_set_config().</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <method name="get_options" c:identifier="gst_buffer_pool_get_options">
        <doc xml:whitespace="preserve">Get a NULL terminated array of string with supported bufferpool options for
@pool. An option would typically be enabled with
gst_buffer_pool_config_add_option().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a NULL terminated array of strings.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="has_option" c:identifier="gst_buffer_pool_has_option">
        <doc xml:whitespace="preserve">Check if the bufferpool supports @option.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a NULL terminated array of strings.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="option" transfer-ownership="none">
            <doc xml:whitespace="preserve">an option</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="gst_buffer_pool_is_active">
        <doc xml:whitespace="preserve">Check if @pool is active. A pool can be activated with the
gst_buffer_pool_set_active() call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE when the pool is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="release_buffer"
              c:identifier="gst_buffer_pool_release_buffer">
        <doc xml:whitespace="preserve">Release @buffer to @pool. @buffer should have previously been allocated from
@pool with gst_buffer_pool_acquire_buffer().

This function is usually called automatically when the last ref on @buffer
disappears.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstBuffer</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_active" c:identifier="gst_buffer_pool_set_active">
        <doc xml:whitespace="preserve">Control the active state of @pool. When the pool is active, new calls to
gst_buffer_pool_acquire_buffer() will return with GST_FLOW_FLUSHING.

Activating the bufferpool will preallocate all resources in the pool based on
the configuration of the pool.

Deactivating will free the resources again when there are no outstanding
buffers. When there are outstanding buffers, they will be freed as soon as
they are all returned to the pool.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE when the pool was not configured or when preallocation of the buffers failed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new active state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_config" c:identifier="gst_buffer_pool_set_config">
        <doc xml:whitespace="preserve">Set the configuration of the pool. The pool must be inactive and all buffers
allocated form this pool must be returned or else this function will do
nothing and return FALSE.

@config is a #GstStructure that contains the configuration parameters for
the pool. A default and mandatory set of parameters can be configured with
gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
and gst_buffer_pool_config_add_option().

If the parameters in @config can not be set exactly, this function returns
FALSE and will try to update as much state as possible. The new state can
then be retrieved and refined with gst_buffer_pool_get_config().

This function takes ownership of @config.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE when the configuration could be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="config" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstStructure</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="flushing">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BufferPoolPrivate" c:type="GstBufferPoolPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <bitfield name="BufferPoolAcquireFlags" c:type="GstBufferPoolAcquireFlags">
      <doc xml:whitespace="preserve">Additional flags to control the allocation of a buffer</doc>
      <member name="none"
              value="0"
              c:identifier="GST_BUFFER_POOL_ACQUIRE_FLAG_NONE">
        <doc xml:whitespace="preserve">no flags</doc>
      </member>
      <member name="key_unit"
              value="1"
              c:identifier="GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT">
        <doc xml:whitespace="preserve">buffer is keyframe</doc>
      </member>
      <member name="dontwait"
              value="2"
              c:identifier="GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT">
        <doc xml:whitespace="preserve">when the bufferpool is empty, acquire_buffer will by default block until a buffer is released into the pool again. Setting this flag makes acquire_buffer return #GST_FLOW_EOS instead of blocking.</doc>
      </member>
      <member name="discont"
              value="4"
              c:identifier="GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT">
        <doc xml:whitespace="preserve">buffer is discont</doc>
      </member>
      <member name="last"
              value="65536"
              c:identifier="GST_BUFFER_POOL_ACQUIRE_FLAG_LAST">
        <doc xml:whitespace="preserve">last flag, subclasses can use private flags starting from this value.</doc>
      </member>
    </bitfield>
    <record name="BufferPoolAcquireParams" c:type="GstBufferPoolAcquireParams">
      <doc xml:whitespace="preserve">Parameters passed to the gst_buffer_pool_acquire_buffer() function to control the
allocation of the buffer.

The default implementation ignores the @start and @stop members but other
implementations can use this extra information to decide what buffer to
return.</doc>
      <field name="format" writable="1">
        <type name="Format" c:type="GstFormat"/>
      </field>
      <field name="start" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="stop" writable="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="flags" writable="1">
        <type name="BufferPoolAcquireFlags"
              c:type="GstBufferPoolAcquireFlags"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BufferPoolClass"
            c:type="GstBufferPoolClass"
            glib:is-gtype-struct-for="BufferPool">
      <doc xml:whitespace="preserve">The GstBufferPool class.</doc>
      <field name="object_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="get_options">
        <callback name="get_options">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a NULL terminated array of strings.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_config">
        <callback name="set_config">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE when the configuration could be set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
            <parameter name="config" transfer-ownership="full">
              <doc xml:whitespace="preserve">a #GstStructure</doc>
              <type name="Structure" c:type="GstStructure*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire_buffer">
        <callback name="acquire_buffer">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstFlowReturn such as GST_FLOW_FLUSHING when the pool is inactive.</doc>
            <type name="FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
            <parameter name="buffer"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:whitespace="preserve">a location for a #GstBuffer</doc>
              <type name="Buffer" c:type="GstBuffer**"/>
            </parameter>
            <parameter name="params" transfer-ownership="none" allow-none="1">
              <doc xml:whitespace="preserve">parameters.</doc>
              <type name="BufferPoolAcquireParams"
                    c:type="GstBufferPoolAcquireParams*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="alloc_buffer">
        <callback name="alloc_buffer">
          <return-value transfer-ownership="none">
            <type name="FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Buffer" c:type="GstBuffer**"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="BufferPoolAcquireParams"
                    c:type="GstBufferPoolAcquireParams*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset_buffer">
        <callback name="reset_buffer">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release_buffer">
        <callback name="release_buffer">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="full">
              <doc xml:whitespace="preserve">a #GstBuffer</doc>
              <type name="Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="free_buffer">
        <callback name="free_buffer">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="BufferPool" c:type="GstBufferPool*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BufferPoolPrivate"
            c:type="GstBufferPoolPrivate"
            disguised="1">
    </record>
    <enumeration name="BufferingMode" c:type="GstBufferingMode">
      <doc xml:whitespace="preserve">The different types of buffering methods.</doc>
      <member name="stream" value="0" c:identifier="GST_BUFFERING_STREAM">
        <doc xml:whitespace="preserve">a small amount of data is buffered</doc>
      </member>
      <member name="download" value="1" c:identifier="GST_BUFFERING_DOWNLOAD">
        <doc xml:whitespace="preserve">the stream is being downloaded</doc>
      </member>
      <member name="timeshift"
              value="2"
              c:identifier="GST_BUFFERING_TIMESHIFT">
        <doc xml:whitespace="preserve">the stream is being downloaded in a ringbuffer</doc>
      </member>
      <member name="live" value="3" c:identifier="GST_BUFFERING_LIVE">
        <doc xml:whitespace="preserve">the stream is a live stream</doc>
      </member>
    </enumeration>
    <class name="Bus"
           c:symbol-prefix="bus"
           c:type="GstBus"
           parent="Object"
           glib:type-name="GstBus"
           glib:get-type="gst_bus_get_type"
           glib:type-struct="BusClass">
      <doc xml:whitespace="preserve">The #GstBus is an object responsible for delivering #GstMessage packets in
a first-in first-out way from the streaming threads (see #GstTask) to the
application.

Since the application typically only wants to deal with delivery of these
messages from one thread, the GstBus will marshall the messages between
different threads. This is important since the actual streaming of media
is done in another thread than the application.

The GstBus provides support for #GSource based notifications. This makes it
possible to handle the delivery in the glib mainloop.

The #GSource callback function gst_bus_async_signal_func() can be used to
convert all bus messages into signal emissions.

A message is posted on the bus with the gst_bus_post() method. With the
gst_bus_peek() and gst_bus_pop() methods one can look at or retrieve a
previously posted message.

The bus can be polled with the gst_bus_poll() method. This methods blocks
up to the specified timeout value until one of the specified messages types
is posted on the bus. The application can then gst_bus_pop() the messages
from the bus to handle them.
Alternatively the application can register an asynchronous bus function
using gst_bus_add_watch_full() or gst_bus_add_watch(). This function will
install a #GSource in the default glib main loop and will deliver messages
a short while after they have been posted. Note that the main loop should
be running for the asynchronous callbacks.

It is also possible to get messages from the bus without any thread
marshalling with the gst_bus_set_sync_handler() method. This makes it
possible to react to a message in the same thread that posted the
message on the bus. This should only be used if the application is able
to deal with messages from different threads.

Every #GstPipeline has one bus.

Note that a #GstPipeline will set its bus into flushing state when changing
from READY to NULL state.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <constructor name="new" c:identifier="gst_bus_new">
        <doc xml:whitespace="preserve">Creates a new #GstBus instance.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstBus instance</doc>
          <type name="Bus" c:type="GstBus*"/>
        </return-value>
      </constructor>
      <virtual-method name="message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sync_message">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_signal_watch" c:identifier="gst_bus_add_signal_watch">
        <doc xml:whitespace="preserve">Adds a bus signal watch to the default main context with the default priority
(%G_PRIORITY_DEFAULT). It is also possible to use a non-default
main context set up using g_main_context_push_thread_default() (before
one had to create a bus watch source and attach it to the desired main
context 'manually').

After calling this statement, the bus will emit the "message" signal for each
message posted on the bus.

This function may be called multiple times. To clean up, the caller is
responsible for calling gst_bus_remove_signal_watch() as many times as this
function is called.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_signal_watch_full"
              c:identifier="gst_bus_add_signal_watch_full">
        <doc xml:whitespace="preserve">Adds a bus signal watch to the default main context with the given @priority
(e.g. %G_PRIORITY_DEFAULT). It is also possible to use a non-default main
context set up using g_main_context_push_thread_default()
(before one had to create a bus watch source and attach it to the desired
main context 'manually').

After calling this statement, the bus will emit the "message" signal for each
message posted on the bus when the main loop is running.

This function may be called multiple times. To clean up, the caller is
responsible for calling gst_bus_remove_signal_watch() as many times as this
function is called.

There can only be a single bus watch per bus, you must remove any signal
watch before you can set another type of watch.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">The priority of the watch.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_watch"
              c:identifier="gst_bus_add_watch"
              shadowed-by="add_watch_full"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a bus watch to the default main context with the default priority
(%G_PRIORITY_DEFAULT). It is also possible to use a non-default main
context set up using g_main_context_push_thread_default() (before
one had to create a bus watch source and attach it to the desired main
context 'manually').

This function is used to receive asynchronous messages in the main loop.
There can only be a single bus watch per bus, you must remove it before you
can set a new one.

The watch can be removed using g_source_remove() or by returning FALSE
from @func.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The event source id.  MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">A function to call when a message is received.</doc>
            <type name="BusFunc" c:type="GstBusFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_watch_full"
              c:identifier="gst_bus_add_watch_full"
              shadows="add_watch">
        <doc xml:whitespace="preserve">Adds a bus watch to the default main context with the given @priority (e.g.
%G_PRIORITY_DEFAULT). It is also possible to use a non-default  main
context set up using g_main_context_push_thread_default() (before
one had to create a bus watch source and attach it to the desired main
context 'manually').

This function is used to receive asynchronous messages in the main loop.
There can only be a single bus watch per bus, you must remove it before you
can set a new one.

When @func is called, the message belongs to the caller; if you want to
keep a copy of it, call gst_message_ref() before leaving @func.

The watch can be removed using g_source_remove() or by returning FALSE
from @func.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The event source id.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:whitespace="preserve">The priority of the watch.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">A function to call when a message is received.</doc>
            <type name="BusFunc" c:type="GstBusFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @func.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">the function to call when the source is removed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="async_signal_func"
              c:identifier="gst_bus_async_signal_func">
        <doc xml:whitespace="preserve">A helper #GstBusFunc that can be used to convert all asynchronous messages
into signals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessage received</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_watch" c:identifier="gst_bus_create_watch">
        <doc xml:whitespace="preserve">Create watch for this bus. The GSource will be dispatched whenever
a message is on the bus. After the GSource is dispatched, the
message is popped off the bus and unreffed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GSource that can be added to a mainloop.</doc>
          <type name="GLib.Source" c:type="GSource*"/>
        </return-value>
      </method>
      <method name="disable_sync_message_emission"
              c:identifier="gst_bus_disable_sync_message_emission">
        <doc xml:whitespace="preserve">Instructs GStreamer to stop emitting the "sync-message" signal for this bus.
See gst_bus_enable_sync_message_emission() for more information.

In the event that multiple pieces of code have called
gst_bus_enable_sync_message_emission(), the sync-message emissions will only
be stopped after all calls to gst_bus_enable_sync_message_emission() were
"cancelled" by calling this function. In this way the semantics are exactly
the same as gst_object_ref() that which calls enable should also call
disable.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="enable_sync_message_emission"
              c:identifier="gst_bus_enable_sync_message_emission">
        <doc xml:whitespace="preserve">Instructs GStreamer to emit the "sync-message" signal after running the bus's
sync handler. This function is here so that code can ensure that they can
synchronously receive messages without having to affect what the bin's sync
handler is.

This function may be called multiple times. To clean up, the caller is
responsible for calling gst_bus_disable_sync_message_emission() as many times
as this function is called.

While this function looks similar to gst_bus_add_signal_watch(), it is not
exactly the same -- this function enables &lt;emphasis&gt;synchronous&lt;/emphasis&gt; emission of
signals when messages arrive; gst_bus_add_signal_watch() adds an idle callback
to pop messages off the bus &lt;emphasis&gt;asynchronously&lt;/emphasis&gt;. The sync-message signal
comes from the thread of whatever object posted the message; the "message"
signal is marshalled to the main thread via the main loop.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="have_pending" c:identifier="gst_bus_have_pending">
        <doc xml:whitespace="preserve">Check if there are pending messages on the bus that
should be handled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if there are messages on the bus to be handled, FALSE otherwise.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="gst_bus_peek">
        <doc xml:whitespace="preserve">Peek the message on the top of the bus' queue. The message will remain
on the bus' message queue. A reference is returned, and needs to be unreffed
by the caller.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstMessage that is on the bus, or NULL if the bus is empty.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
      </method>
      <method name="poll" c:identifier="gst_bus_poll">
        <doc xml:whitespace="preserve">Poll the bus for messages. Will block while waiting for messages to come.
You can specify a maximum time to poll with the @timeout parameter. If
@timeout is negative, this function will block indefinitely.

All messages not in @events will be popped off the bus and will be ignored.

Because poll is implemented using the "message" signal enabled by
gst_bus_add_signal_watch(), calling gst_bus_poll() will cause the "message"
signal to be emitted for every message that poll sees. Thus a "message"
signal handler will see the same messages that this function sees -- neither
will steal messages from the other.

This function will run a main loop from the default main context when
polling.

You should never use this function, since it is pure evil. This is
especially true for GUI applications based on Gtk+ or Qt, but also for any
other non-trivial application that uses the GLib main loop. As this function
runs a GLib main loop, any callback attached to the default GLib main
context may be invoked. This could be timeouts, GUI events, I/O events etc.;
even if gst_bus_poll() is called with a 0 timeout. Any of these callbacks
may do things you do not expect, e.g. destroy the main application window or
some other resource; change other application state; display a dialog and
run another main loop until the user clicks it away. In short, using this
function may add a lot of complexity to your code through unexpected
re-entrancy and unexpected changes to your application's state.

For 0 timeouts use gst_bus_pop_filtered() instead of this function; for
other short timeouts use gst_bus_timed_pop_filtered(); everything else is
better handled by setting up an asynchronous bus watch and doing things
from there.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the message that was received, or NULL if the poll timed out. The message is taken from the bus and needs to be unreffed with gst_message_unref() after usage.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="events" transfer-ownership="none">
            <doc xml:whitespace="preserve">a mask of #GstMessageType, representing the set of message types to poll for.</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">the poll timeout, as a #GstClockTime, or #GST_CLOCK_TIME_NONE to poll indefinitely.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="gst_bus_pop">
        <doc xml:whitespace="preserve">Get a message from the bus.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstMessage that is on the bus, or NULL if the bus is empty. The message is taken from the bus and needs to be unreffed with gst_message_unref() after usage.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
      </method>
      <method name="pop_filtered" c:identifier="gst_bus_pop_filtered">
        <doc xml:whitespace="preserve">Get a message matching @type from the bus.  Will discard all messages on
the bus that do not match @type and that have been posted before the first
message that does match @type.  If there is no message matching @type on
the bus, all messages will be discarded.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the next #GstMessage matching @type that is on the bus, or NULL if the bus is empty or there is no message matching @type. The message is taken from the bus and needs to be unreffed with gst_message_unref() after usage.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="types" transfer-ownership="none">
            <doc xml:whitespace="preserve">message types to take into account</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </method>
      <method name="post" c:identifier="gst_bus_post">
        <doc xml:whitespace="preserve">Post a message on the given bus. Ownership of the message
is taken by the bus.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the message could be posted, FALSE if the bus is flushing.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstMessage to post</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_signal_watch"
              c:identifier="gst_bus_remove_signal_watch">
        <doc xml:whitespace="preserve">Removes a signal watch previously added with gst_bus_add_signal_watch().

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_flushing" c:identifier="gst_bus_set_flushing">
        <doc xml:whitespace="preserve">If @flushing, flush out and unref any messages queued in the bus. Releases
references to the message origin objects. Will flush future messages until
gst_bus_set_flushing() sets @flushing to #FALSE.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not to flush the bus</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sync_handler" c:identifier="gst_bus_set_sync_handler">
        <doc xml:whitespace="preserve">Sets the synchronous handler on the bus. The function will be called
every time a new message is posted on the bus. Note that the function
will be called in the same thread context as the posting object. This
function is usually only called by the creator of the bus. Applications
should handle messages asynchronously using the gst_bus watch and poll
functions.

You cannot replace an existing sync_handler. You can pass NULL to this
function, which will clear the existing handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     allow-none="1"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">The handler function to install</doc>
            <type name="BusSyncHandler" c:type="GstBusSyncHandler"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data that will be sent to the handler function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called when @user_data becomes unused</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync_signal_handler"
              c:identifier="gst_bus_sync_signal_handler">
        <doc xml:whitespace="preserve">A helper GstBusSyncHandler that can be used to convert all synchronous
messages into signals.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">GST_BUS_PASS</doc>
          <type name="BusSyncReply" c:type="GstBusSyncReply"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessage received</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="timed_pop" c:identifier="gst_bus_timed_pop">
        <doc xml:whitespace="preserve">Get a message from the bus, waiting up to the specified timeout.

If @timeout is 0, this function behaves like gst_bus_pop(). If @timeout is
#GST_CLOCK_TIME_NONE, this function will block forever until a message was
posted on the bus.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstMessage that is on the bus after the specified timeout or NULL if the bus is empty after the timeout expired. The message is taken from the bus and needs to be unreffed with gst_message_unref() after usage.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a timeout</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="timed_pop_filtered"
              c:identifier="gst_bus_timed_pop_filtered">
        <doc xml:whitespace="preserve">Get a message from the bus whose type matches the message type mask @types,
waiting up to the specified timeout (and discarding any messages that do not
match the mask provided).

If @timeout is 0, this function behaves like gst_bus_pop_filtered(). If
@timeout is #GST_CLOCK_TIME_NONE, this function will block forever until a
matching message was posted on the bus.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstMessage matching the filter in @types, or NULL if no matching message was found on the bus until the timeout expired. The message is taken from the bus and needs to be unreffed with gst_message_unref() after usage.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a timeout in nanoseconds, or GST_CLOCK_TIME_NONE to wait forever</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="types" transfer-ownership="none">
            <doc xml:whitespace="preserve">message types to take into account, GST_MESSAGE_ANY for any type</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </method>
      <property name="enable-async"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BusPrivate" c:type="GstBusPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="message" when="last" detailed="1">
        <doc xml:whitespace="preserve">A message has been posted on the bus. This signal is emitted from a
GSource added to the mainloop. this signal will only be emitted when
there is a mainloop running.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message that has been posted asynchronously</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="sync-message" when="last" detailed="1">
        <doc xml:whitespace="preserve">A message has been posted on the bus. This signal is emitted from the
thread that posted the message so one has to be careful with locking.

This signal will not be emitted by default, you have to set up
gst_bus_sync_signal_handler() as a sync handler if you want this
signal to be emitted when a message is posted on the bus, like this:
&lt;programlisting&gt;
gst_bus_set_sync_handler (bus, gst_bus_sync_signal_handler, yourdata);
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message that has been posted synchronously</doc>
            <type name="Message"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BusClass"
            c:type="GstBusClass"
            glib:is-gtype-struct-for="Bus">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="message">
        <callback name="message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bus" transfer-ownership="none">
              <type name="Bus" c:type="GstBus*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="GstMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sync_message">
        <callback name="sync_message">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="bus" transfer-ownership="none">
              <type name="Bus" c:type="GstBus*"/>
            </parameter>
            <parameter name="message" transfer-ownership="none">
              <type name="Message" c:type="GstMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BusFlags" c:type="GstBusFlags">
      <doc xml:whitespace="preserve">The standard flags that a bus may have.</doc>
      <member name="flushing" value="16" c:identifier="GST_BUS_FLUSHING">
        <doc xml:whitespace="preserve">The bus is currently dropping all messages</doc>
      </member>
      <member name="flag_last" value="32" c:identifier="GST_BUS_FLAG_LAST">
        <doc xml:whitespace="preserve">offset to define more flags</doc>
      </member>
    </bitfield>
    <callback name="BusFunc" c:type="GstBusFunc">
      <doc xml:whitespace="preserve">Specifies the type of function passed to gst_bus_add_watch() or
gst_bus_add_watch_full(), which is called from the mainloop when a message
is available on the bus.

The message passed to the function will be unreffed after execution of this
function so it should not be freed in the function.

Note that this function is used as a GSourceFunc which means that returning
FALSE will remove the GSource from the mainloop.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE if the event source should be removed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="bus" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBus that sent the message</doc>
          <type name="Bus" c:type="GstBus*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstMessage</doc>
          <type name="Message" c:type="GstMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data that has been given, when registering the handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="BusPrivate" c:type="GstBusPrivate" disguised="1">
    </record>
    <callback name="BusSyncHandler" c:type="GstBusSyncHandler">
      <doc xml:whitespace="preserve">Handler will be invoked synchronously, when a new message has been injected
into the bus. This function is mostly used internally. Only one sync handler
can be attached to a given bus.

If the handler returns GST_BUS_DROP, it should unref the message, else the
message should not be unreffed by the sync handler.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GstBusSyncReply stating what to do with the message</doc>
        <type name="BusSyncReply" c:type="GstBusSyncReply"/>
      </return-value>
      <parameters>
        <parameter name="bus" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBus that sent the message</doc>
          <type name="Bus" c:type="GstBus*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstMessage</doc>
          <type name="Message" c:type="GstMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data that has been given, when registering the handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="BusSyncReply" c:type="GstBusSyncReply">
      <doc xml:whitespace="preserve">The result values for a GstBusSyncHandler.</doc>
      <member name="drop" value="0" c:identifier="GST_BUS_DROP">
        <doc xml:whitespace="preserve">drop the message</doc>
      </member>
      <member name="pass" value="1" c:identifier="GST_BUS_PASS">
        <doc xml:whitespace="preserve">pass the message to the async queue</doc>
      </member>
      <member name="async" value="2" c:identifier="GST_BUS_ASYNC">
        <doc xml:whitespace="preserve">pass message to async queue, continue if message is handled</doc>
      </member>
    </enumeration>
    <constant name="CAN_INLINE" value="1" c:type="GST_CAN_INLINE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CLOCK_TIME_NONE"
              value="18446744073709551615"
              c:type="GST_CLOCK_TIME_NONE">
      <type name="ClockTime" c:type="GstClockTime"/>
    </constant>
    <record name="Caps"
            c:type="GstCaps"
            glib:type-name="GstCaps"
            glib:get-type="gst_caps_get_type"
            c:symbol-prefix="caps">
      <doc xml:whitespace="preserve">Caps (capabilities) are lightweight refcounted objects describing media types.
They are composed of an array of #GstStructure.

Caps are exposed on #GstPadTemplate to describe all possible types a
given pad can handle. They are also stored in the #GstRegistry along with
a description of the #GstElement.

Caps are exposed on the element pads using the gst_pad_query_caps() pad
function. This function describes the possible types that the pad can
handle or produce at runtime.

A #GstCaps can be constructed with the following code fragment:

&lt;example&gt;
 &lt;title&gt;Creating caps&lt;/title&gt;
 &lt;programlisting&gt;
 GstCaps *caps;
 caps = gst_caps_new_simple ("video/x-raw",
      "format", G_TYPE_STRING, "I420",
      "framerate", GST_TYPE_FRACTION, 25, 1,
      "pixel-aspect-ratio", GST_TYPE_FRACTION, 1, 1,
      "width", G_TYPE_INT, 320,
      "height", G_TYPE_INT, 240,
      NULL);
 &lt;/programlisting&gt;
&lt;/example&gt;

A #GstCaps is fixed when it has no properties with ranges or lists. Use
gst_caps_is_fixed() to test for fixed caps. Fixed caps can be used in a
caps event to notify downstream elements of the current media type.

Various methods exist to work with the media types such as subtracting
or intersecting.

Last reviewed on 2011-03-28 (0.11.3)</doc>
      <field name="mini_object" writable="1">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <constructor name="new_any" c:identifier="gst_caps_new_any">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that indicates that it is compatible with
any media format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </constructor>
      <constructor name="new_empty" c:identifier="gst_caps_new_empty">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that is empty.  That is, the returned
#GstCaps contains no media formats.
The #GstCaps is guaranteed to be writable.
Caller is responsible for unreffing the returned caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </constructor>
      <constructor name="new_empty_simple"
                   c:identifier="gst_caps_new_empty_simple">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains one #GstStructure with name
@media_type.
Caller is responsible for unreffing the returned caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the media type of the structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="gst_caps_new_full"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstCaps and adds all the structures listed as
arguments.  The list must be NULL-terminated.  The structures
are not copied; the returned #GstCaps owns the structures.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="struct1" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first structure to add</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full_valist"
                   c:identifier="gst_caps_new_full_valist"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstCaps and adds all the structures listed as
arguments.  The list must be NULL-terminated.  The structures
are not copied; the returned #GstCaps owns the structures.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first structure to add</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">additional structures to add</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_simple"
                   c:identifier="gst_caps_new_simple"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains one #GstStructure.  The
structure is defined by the arguments, which have the same format
as gst_structure_new().
Caller is responsible for unreffing the returned caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the media type of the structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <method name="append" c:identifier="gst_caps_append">
        <doc xml:whitespace="preserve">Appends the structures contained in @caps2 to @caps1. The structures in
@caps2 are not copied -- they are transferred to @caps1, and then @caps2 is
freed. If either caps is ANY, the resulting caps will be ANY.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstCaps to append</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="append_structure" c:identifier="gst_caps_append_structure">
        <doc xml:whitespace="preserve">Appends @structure to @caps.  The structure is not copied; @caps
becomes the owner of @structure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstStructure to append</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_intersect" c:identifier="gst_caps_can_intersect">
        <doc xml:whitespace="preserve">Tries intersecting @caps1 and @caps2 and reports whether the result would not
be empty</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if intersection would be not empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to intersect</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_nth" c:identifier="gst_caps_copy_nth">
        <doc xml:whitespace="preserve">Creates a new #GstCaps and appends a copy of the nth structure
contained in @caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="nth" transfer-ownership="none">
            <doc xml:whitespace="preserve">the nth structure to copy</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate" c:identifier="gst_caps_fixate">
        <doc xml:whitespace="preserve">Modifies the given @caps into a representation with only fixed
values. First the caps will be truncated and then the first structure will be
fixated with gst_structure_fixate().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the fixated caps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_size" c:identifier="gst_caps_get_size">
        <doc xml:whitespace="preserve">Gets the number of structures contained in @caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of structures that @caps contains</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_caps_get_structure">
        <doc xml:whitespace="preserve">Finds the structure in @caps that has the index @index, and
returns it.

WARNING: This function takes a const GstCaps *, but returns a
non-const GstStructure *.  This is for programming convenience --
the caller should be aware that structures inside a constant
#GstCaps should not be modified. However, if you know the caps
are writable, either because you have just copied them or made
them writable with gst_caps_make_writable(), you may modify the
structure returned in the usual way, e.g. with functions like
gst_structure_set().

You do not need to free or unref the structure returned, it
belongs to the #GstCaps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the #GstStructure corresponding to @index</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect" c:identifier="gst_caps_intersect">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains all the formats that are common
to both @caps1 and @caps2. Defaults to %GST_CAPS_INTERSECT_ZIG_ZAG mode.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to intersect</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect_full" c:identifier="gst_caps_intersect_full">
        <doc xml:whitespace="preserve">Creates a new #GstCaps that contains all the formats that are common
to both @caps1 and @caps2, the order is defined by the #GstCapsIntersectMode
used.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to intersect</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">The intersection algorithm/mode to use</doc>
            <type name="CapsIntersectMode" c:type="GstCapsIntersectMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_always_compatible"
              c:identifier="gst_caps_is_always_compatible">
        <doc xml:whitespace="preserve">A given #GstCaps structure is always compatible with another if
every media format that is in the first is also contained in the
second.  That is, @caps1 is a subset of @caps2.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps1 is a subset of @caps2.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstCaps to test</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_any" c:identifier="gst_caps_is_any">
        <doc xml:whitespace="preserve">Determines if @caps represents any media format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps represents any format.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_empty" c:identifier="gst_caps_is_empty">
        <doc xml:whitespace="preserve">Determines if @caps represents no media formats.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps represents no formats.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_equal" c:identifier="gst_caps_is_equal">
        <doc xml:whitespace="preserve">Checks if the given caps represent the same set of caps.
&lt;note&gt;This function does not work reliably if optional properties for caps
are included on one caps and omitted on the other.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if both caps are equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">another #GstCaps</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_equal_fixed" c:identifier="gst_caps_is_equal_fixed">
        <doc xml:whitespace="preserve">Tests if two #GstCaps are equal.  This function only works on fixed
#GstCaps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the arguments represent the same format</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstCaps to test</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_fixed" c:identifier="gst_caps_is_fixed">
        <doc xml:whitespace="preserve">Fixed #GstCaps describe exactly one format, that is, they have exactly
one structure, and each field in the structure describes a fixed type.
Examples of non-fixed types are GST_TYPE_INT_RANGE and GST_TYPE_LIST.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @caps is fixed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_strictly_equal"
              c:identifier="gst_caps_is_strictly_equal">
        <doc xml:whitespace="preserve">Checks if the given caps are exactly the same set of caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if both caps are strictly equal.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="none">
            <doc xml:whitespace="preserve">another #GstCaps</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_subset" c:identifier="gst_caps_is_subset">
        <doc xml:whitespace="preserve">Checks if all caps represented by @subset are also represented by @superset.
&lt;note&gt;This function does not work reliably if optional properties for caps
are included on one caps and omitted on the other.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @subset is a subset of @superset</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="superset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a potentially greater #GstCaps</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_subset_structure"
              c:identifier="gst_caps_is_subset_structure">
        <doc xml:whitespace="preserve">Checks if @structure is a subset of @caps. See gst_caps_is_subset()
for more information.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @structure is a subset of @caps</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="none">
            <doc xml:whitespace="preserve">a potential #GstStructure subset of @caps</doc>
            <type name="Structure" c:type="const GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="merge" c:identifier="gst_caps_merge">
        <doc xml:whitespace="preserve">Appends the structures contained in @caps2 to @caps1 if they are not yet
expressed by @caps1. The structures in @caps2 are not copied -- they are
transferred to a writable copy of @caps1, and then @caps2 is freed.
If either caps is ANY, the resulting caps will be ANY.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the merged caps.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="caps2" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstCaps to merge in</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="merge_structure" c:identifier="gst_caps_merge_structure">
        <doc xml:whitespace="preserve">Appends @structure to @caps if its not already expressed by @caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the merged caps.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstStructure to merge</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize" c:identifier="gst_caps_normalize">
        <doc xml:whitespace="preserve">Returns a #GstCaps that represents the same set of formats as
@caps, but contains no lists.  Each list is expanded into separate
@GstStructures.

This function takes ownership of @caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the normalized #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="remove_structure" c:identifier="gst_caps_remove_structure">
        <doc xml:whitespace="preserve">removes the stucture with the given index from the list of structures
contained in @caps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">Index of the structure to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_simple"
              c:identifier="gst_caps_set_simple"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets fields in a #GstCaps.  The arguments must be passed in the same
manner as gst_structure_set(), and be NULL-terminated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_simple_valist"
              c:identifier="gst_caps_set_simple_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets fields in a #GstCaps.  The arguments must be passed in the same
manner as gst_structure_set(), and be NULL-terminated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">additional parameters</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="gst_caps_set_value">
        <doc xml:whitespace="preserve">Sets the given @field on all structures of @caps to the given @value.
This is a convenience function for calling gst_structure_set_value() on
all structures of @caps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the field to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">value to set the field to</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="simplify" c:identifier="gst_caps_simplify">
        <doc xml:whitespace="preserve">Converts the given @caps into a representation that represents the
same set of formats, but in a simpler form.  Component structures that are
identical are merged.  Component structures that have values that can be
merged are also merged.

This method does not preserve the original order of @caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The simplified caps.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="steal_structure" c:identifier="gst_caps_steal_structure">
        <doc xml:whitespace="preserve">Retrieves the structure with the given index from the list of structures
contained in @caps. The caller becomes the owner of the returned structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the #GstStructure corresponding to @index.</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">Index of the structure to retrieve</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="gst_caps_subtract">
        <doc xml:whitespace="preserve">Subtracts the @subtrahend from the @minuend.
&lt;note&gt;This function does not work reliably if optional properties for caps
are included on one caps and omitted on the other.&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the resulting caps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="subtrahend" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstCaps to subtract</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gst_caps_to_string">
        <doc xml:whitespace="preserve">Converts @caps to a string representation.  This string representation
can be converted back to a #GstCaps by gst_caps_from_string().

For debugging purposes its easier to do something like this:
|[
GST_LOG ("caps are %" GST_PTR_FORMAT, caps);
]|
This prints the caps in human readable form.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string representing @caps.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="truncate" c:identifier="gst_caps_truncate">
        <doc xml:whitespace="preserve">Discard all but the first structure from @caps. Useful when
fixating.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">truncated caps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <function name="from_string" c:identifier="gst_caps_from_string">
        <doc xml:whitespace="preserve">Converts @caps from a string representation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated #GstCaps</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string to convert to #GstCaps</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="CapsFlags" c:type="GstCapsFlags">
      <doc xml:whitespace="preserve">Extra flags for a caps.</doc>
      <member name="caps_flag_any" value="16" c:identifier="GST_CAPS_FLAG_ANY">
        <doc xml:whitespace="preserve">Caps has no specific content, but can contain anything.</doc>
      </member>
    </bitfield>
    <enumeration name="CapsIntersectMode" c:type="GstCapsIntersectMode">
      <doc xml:whitespace="preserve">Modes of caps intersection

@GST_CAPS_INTERSECT_ZIG_ZAG tries to preserve overall order of both caps
by iterating on the caps' structures as the following matrix shows:
|[
         caps1
      +-------------
      | 1  2  4  7
caps2 | 3  5  8 10
      | 6  9 11 12
]|
Used when there is no explicit precedence of one caps over the other. e.g.
tee's sink pad getcaps function, it will probe its src pad peers' for their
caps and intersect them with this mode.

@GST_CAPS_INTERSECT_FIRST is useful when an element wants to preserve
another element's caps priority order when intersecting with its own caps.
Example: If caps1 is [A, B, C] and caps2 is [E, B, D, A], the result
would be [A, B], maintaining the first caps priority on the intersection.</doc>
      <member name="zig_zag"
              value="0"
              c:identifier="GST_CAPS_INTERSECT_ZIG_ZAG">
        <doc xml:whitespace="preserve">Zig-zags over both caps.</doc>
      </member>
      <member name="first" value="1" c:identifier="GST_CAPS_INTERSECT_FIRST">
        <doc xml:whitespace="preserve">Keeps the first caps order.</doc>
      </member>
    </enumeration>
    <interface name="ChildProxy"
               c:symbol-prefix="child_proxy"
               c:type="GstChildProxy"
               glib:type-name="GstChildProxy"
               glib:get-type="gst_child_proxy_get_type"
               glib:type-struct="ChildProxyInterface">
      <doc xml:whitespace="preserve">This interface abstracts handling of property sets for elements with
children. Imagine elements such as mixers or polyphonic generators. They all
have multiple #GstPad or some kind of voice objects. Another use case are
container elements like #GstBin.
The element implementing the interface acts as a parent for those child
objects.

By implementing this interface the child properties can be accessed from the
parent element by using gst_child_proxy_get() and gst_child_proxy_set().

Property names are written as "child-name::property-name". The whole naming
scheme is recursive. Thus "child1::child2::property" is valid too, if
"child1" and "child2" implement the #GstChildProxy interface.</doc>
      <virtual-method name="child_added" invoker="child_added">
        <doc xml:whitespace="preserve">Emits the "child-added" signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:whitespace="preserve">the newly added child</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the new child</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="child_removed" invoker="child_removed">
        <doc xml:whitespace="preserve">Emits the "child-removed" signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:whitespace="preserve">the removed child</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the old child</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_child_by_index" invoker="get_child_by_index">
        <doc xml:whitespace="preserve">Fetches a child by its number.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the child object or %NULL if not found (index too high). Unref after usage.  MT safe.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the childs position in the child list</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_child_by_name" invoker="get_child_by_name">
        <doc xml:whitespace="preserve">Looks up a child element by the given name.

This virtual method has a default implementation that uses #GstObject
together with gst_object_get_name(). If the interface is to be used with
#GObjects, this methods needs to be overridden.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the child object or %NULL if not found. Unref after usage.  MT safe.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the childs name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_children_count" invoker="get_children_count">
        <doc xml:whitespace="preserve">Gets the number of child objects this parent contains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of child objects  MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </virtual-method>
      <method name="child_added" c:identifier="gst_child_proxy_child_added">
        <doc xml:whitespace="preserve">Emits the "child-added" signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:whitespace="preserve">the newly added child</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the new child</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="child_removed"
              c:identifier="gst_child_proxy_child_removed">
        <doc xml:whitespace="preserve">Emits the "child-removed" signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="child" transfer-ownership="none">
            <doc xml:whitespace="preserve">the removed child</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the old child</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="gst_child_proxy_get" introspectable="0">
        <doc xml:whitespace="preserve">Gets properties of the parent object and its children.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="get_child_by_index"
              c:identifier="gst_child_proxy_get_child_by_index">
        <doc xml:whitespace="preserve">Fetches a child by its number.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the child object or %NULL if not found (index too high). Unref after usage.  MT safe.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the childs position in the child list</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_child_by_name"
              c:identifier="gst_child_proxy_get_child_by_name">
        <doc xml:whitespace="preserve">Looks up a child element by the given name.

This virtual method has a default implementation that uses #GstObject
together with gst_object_get_name(). If the interface is to be used with
#GObjects, this methods needs to be overridden.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the child object or %NULL if not found. Unref after usage.  MT safe.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the childs name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_children_count"
              c:identifier="gst_child_proxy_get_children_count">
        <doc xml:whitespace="preserve">Gets the number of child objects this parent contains.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of child objects  MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_property" c:identifier="gst_child_proxy_get_property">
        <doc xml:whitespace="preserve">Gets a single property using the GstChildProxy mechanism.
You are responsible for freeing it by calling g_value_unset()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue that should take the result.</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist"
              c:identifier="gst_child_proxy_get_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Gets properties of the parent object and its children.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">return location for the first property, followed optionally by more name/return location pairs, followed by NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup" c:identifier="gst_child_proxy_lookup">
        <doc xml:whitespace="preserve">Looks up which object and #GParamSpec would be effected by the given @name.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @target and @pspec could be found. FALSE otherwise. In that case the values for @pspec and @target are not modified. Unref @target after usage. For plain GObjects @target is the same as @object.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the property to look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer to a #GObject that takes the real object to set property on</doc>
            <type name="GObject.Object" c:type="GObject**"/>
          </parameter>
          <parameter name="pspec"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer to take the #GParamSpec describing the property</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gst_child_proxy_set" introspectable="0">
        <doc xml:whitespace="preserve">Sets properties of the parent object and its children.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_property" c:identifier="gst_child_proxy_set_property">
        <doc xml:whitespace="preserve">Sets a single property using the GstChildProxy mechanism.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">new #GValue for the property</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="gst_child_proxy_set_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets properties of the parent object and its children.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">value for the first property, followed optionally by more name/value pairs, followed by NULL</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="child-added" when="first">
        <doc xml:whitespace="preserve">Will be emitted after the @object was added to the @child_proxy.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GObject that was added</doc>
            <type name="GObject.Object"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the new child</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="child-removed" when="first">
        <doc xml:whitespace="preserve">Will be emitted after the @object was removed from the @child_proxy.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GObject that was removed</doc>
            <type name="GObject.Object"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the old child</doc>
            <type name="utf8"/>
          </parameter>
        </parameters>
      </glib:signal>
    </interface>
    <record name="ChildProxyInterface"
            c:type="GstChildProxyInterface"
            glib:is-gtype-struct-for="ChildProxy">
      <doc xml:whitespace="preserve">#GstChildProxy interface.</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_child_by_name">
        <callback name="get_child_by_name">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the child object or %NULL if not found. Unref after usage.  MT safe.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the childs name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_child_by_index">
        <callback name="get_child_by_index">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the child object or %NULL if not found (index too high). Unref after usage.  MT safe.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <doc xml:whitespace="preserve">the childs position in the child list</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_children_count">
        <callback name="get_children_count">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of child objects  MT safe.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="child_added">
        <callback name="child_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <doc xml:whitespace="preserve">the newly added child</doc>
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the new child</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="child_removed">
        <callback name="child_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="parent" transfer-ownership="none">
              <type name="ChildProxy" c:type="GstChildProxy*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <doc xml:whitespace="preserve">the removed child</doc>
              <type name="GObject.Object" c:type="GObject*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">the name of the old child</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="Clock"
           c:symbol-prefix="clock"
           c:type="GstClock"
           parent="Object"
           abstract="1"
           glib:type-name="GstClock"
           glib:get-type="gst_clock_get_type"
           glib:type-struct="ClockClass">
      <doc xml:whitespace="preserve">GStreamer uses a global clock to synchronize the plugins in a pipeline.
Different clock implementations are possible by implementing this abstract
base class or, more conveniently, by subclassing #GstSystemClock.

The #GstClock returns a monotonically increasing time with the method
gst_clock_get_time(). Its accuracy and base time depend on the specific
clock implementation but time is always expressed in nanoseconds. Since the
baseline of the clock is undefined, the clock time returned is not
meaningful in itself, what matters are the deltas between two clock times.
The time returned by a clock is called the absolute time.

The pipeline uses the clock to calculate the running time. Usually all
renderers synchronize to the global clock using the buffer timestamps, the
newsegment events and the element's base time, see #GstPipeline.

A clock implementation can support periodic and single shot clock
notifications both synchronous and asynchronous.

One first needs to create a #GstClockID for the periodic or single shot
notification using gst_clock_new_single_shot_id() or
gst_clock_new_periodic_id().

To perform a blocking wait for the specific time of the #GstClockID use the
gst_clock_id_wait(). To receive a callback when the specific time is reached
in the clock use gst_clock_id_wait_async(). Both these calls can be
interrupted with the gst_clock_id_unschedule() call. If the blocking wait is
unscheduled a return value of #GST_CLOCK_UNSCHEDULED is returned.

Periodic callbacks scheduled async will be repeatedly called automatically
until it is unscheduled. To schedule a sync periodic callback,
gst_clock_id_wait() should be called repeatedly.

The async callbacks can happen from any thread, either provided by the core
or from a streaming thread. The application should be prepared for this.

A #GstClockID that has been unscheduled cannot be used again for any wait
operation, a new #GstClockID should be created and the old unscheduled one
should be destroyed with gst_clock_id_unref().

It is possible to perform a blocking wait on the same #GstClockID from
multiple threads. However, registering the same #GstClockID for multiple
async notifications is not possible, the callback will only be called for
the thread registering the entry last.

None of the wait operations unref the #GstClockID, the owner is responsible
for unreffing the ids itself. This holds for both periodic and single shot
notifications. The reason being that the owner of the #GstClockID has to
keep a handle to the #GstClockID to unblock the wait on FLUSHING events or
state changes and if the entry would be unreffed automatically, the handle 
might become invalid without any notification.

These clock operations do not operate on the running time, so the callbacks
will also occur when not in PLAYING state as if the clock just keeps on
running. Some clocks however do not progress when the element that provided
the clock is not PLAYING.

When a clock has the #GST_CLOCK_FLAG_CAN_SET_MASTER flag set, it can be
slaved to another #GstClock with the gst_clock_set_master(). The clock will
then automatically be synchronized to this master clock by repeatedly
sampling the master clock and the slave clock and recalibrating the slave
clock with gst_clock_set_calibration(). This feature is mostly useful for
plugins that have an internal clock but must operate with another clock
selected by the #GstPipeline.  They can track the offset and rate difference
of their internal clock relative to the master clock by using the
gst_clock_get_calibration() function. 

The master/slave synchronisation can be tuned with the #GstClock:timeout,
#GstClock:window-size and #GstClock:window-threshold properties.
The #GstClock:timeout property defines the interval to sample the master
clock and run the calibration functions. #GstClock:window-size defines the
number of samples to use when calibrating and #GstClock:window-threshold
defines the minimum number of samples before the calibration is performed.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <function name="id_compare_func"
                c:identifier="gst_clock_id_compare_func">
        <doc xml:whitespace="preserve">Compares the two #GstClockID instances. This function can be used
as a GCompareFunc when sorting ids.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">negative value if a &lt; b; zero if a = b; positive value if a &gt; b  MT safe.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="id1" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GstClockID</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="id2" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GstClockID to compare with</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_get_time" c:identifier="gst_clock_id_get_time">
        <doc xml:whitespace="preserve">Get the time of the clock ID</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the time of the given clock id.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstClockID to query</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_ref" c:identifier="gst_clock_id_ref">
        <doc xml:whitespace="preserve">Increase the refcount of given @id.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The same #GstClockID with increased refcount.  MT safe.</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstClockID to ref</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_unref" c:identifier="gst_clock_id_unref">
        <doc xml:whitespace="preserve">Unref given @id. When the refcount reaches 0 the
#GstClockID will be freed.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="full">
            <doc xml:whitespace="preserve">The #GstClockID to unref</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_unschedule" c:identifier="gst_clock_id_unschedule">
        <doc xml:whitespace="preserve">Cancel an outstanding request with @id. This can either
be an outstanding async notification or a pending sync notification.
After this call, @id cannot be used anymore to receive sync or
async notifications, you need to create a new #GstClockID.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The id to unschedule</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_wait" c:identifier="gst_clock_id_wait">
        <doc xml:whitespace="preserve">Perform a blocking wait on @id. 
@id should have been created with gst_clock_new_single_shot_id()
or gst_clock_new_periodic_id() and should not have been unscheduled
with a call to gst_clock_id_unschedule(). 

If the @jitter argument is not %NULL and this function returns #GST_CLOCK_OK
or #GST_CLOCK_EARLY, it will contain the difference
against the clock and the time of @id when this method was
called. 
Positive values indicate how late @id was relative to the clock
(in which case this function will return #GST_CLOCK_EARLY). 
Negative values indicate how much time was spent waiting on the clock 
before this function returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of the blocking wait. #GST_CLOCK_EARLY will be returned if the current clock time is past the time of @id, #GST_CLOCK_OK if @id was scheduled in time. #GST_CLOCK_UNSCHEDULED if @id was unscheduled with gst_clock_id_unschedule().  MT safe.</doc>
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstClockID to wait on</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer that will contain the jitter, can be %NULL.</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </function>
      <function name="id_wait_async" c:identifier="gst_clock_id_wait_async">
        <doc xml:whitespace="preserve">Register a callback on the given #GstClockID @id with the given
function and user_data. When passing a #GstClockID with an invalid
time to this function, the callback will be called immediately
with  a time set to GST_CLOCK_TIME_NONE. The callback will
be called when the time of @id has been reached.

The callback @func can be invoked from any thread, either provided by the
core or from a streaming thread. The application should be prepared for this.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result of the non blocking wait.  MT safe.</doc>
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockID to wait on</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">The callback function</doc>
            <type name="ClockCallback" c:type="GstClockCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data passed in the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_data"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">#GDestroyNotify for user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="change_resolution">
        <return-value transfer-ownership="none">
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="old_resolution" transfer-ownership="none">
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="new_resolution" transfer-ownership="none">
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_internal_time" invoker="get_internal_time">
        <doc xml:whitespace="preserve">Gets the current internal time of the given clock. The time is returned
unadjusted for the offset and the rate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the internal time of the clock. Or GST_CLOCK_TIME_NONE when given invalid input.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </virtual-method>
      <virtual-method name="get_resolution" invoker="get_resolution">
        <doc xml:whitespace="preserve">Get the accuracy of the clock. The accuracy of the clock is the granularity
of the values returned by gst_clock_get_time().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the resolution of the clock in units of #GstClockTime.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </virtual-method>
      <virtual-method name="unschedule">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="ClockEntry" c:type="GstClockEntry*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wait">
        <return-value transfer-ownership="none">
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="ClockEntry" c:type="GstClockEntry*"/>
          </parameter>
          <parameter name="jitter" transfer-ownership="none">
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wait_async">
        <return-value transfer-ownership="none">
          <type name="ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="none">
            <type name="ClockEntry" c:type="GstClockEntry*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_observation" c:identifier="gst_clock_add_observation">
        <doc xml:whitespace="preserve">The time @master of the master clock and the time @slave of the slave
clock are added to the list of observations. If enough observations
are available, a linear regression algorithm is run on the
observations and @clock is recalibrated.

If this functions returns %TRUE, @r_squared will contain the 
correlation coefficient of the interpolation. A value of 1.0
means a perfect regression was performed. This value can
be used to control the sampling frequency of the master and slave
clocks.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if enough observations were added to run the regression algorithm.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="slave" transfer-ownership="none">
            <doc xml:whitespace="preserve">a time on the slave</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="master" transfer-ownership="none">
            <doc xml:whitespace="preserve">a time on the master</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="r_squared"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to hold the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="adjust_unlocked" c:identifier="gst_clock_adjust_unlocked">
        <doc xml:whitespace="preserve">Converts the given @internal clock time to the external time, adjusting for the
rate and reference time set with gst_clock_set_calibration() and making sure
that the returned time is increasing. This function should be called with the
clock's OBJECT_LOCK held and is mainly used by clock subclasses.

This function is the reverse of gst_clock_unadjust_unlocked().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the converted time of the clock.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="internal" transfer-ownership="none">
            <doc xml:whitespace="preserve">a clock time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_calibration" c:identifier="gst_clock_get_calibration">
        <doc xml:whitespace="preserve">Gets the internal rate and reference time of @clock. See
gst_clock_set_calibration() for more information.

@internal, @external, @rate_num, and @rate_denom can be left %NULL if the
caller is not interested in the values.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="internal"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the internal time</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="external"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the external time</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="rate_num"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the rate numerator</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="rate_denom"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location to store the rate denominator</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_internal_time"
              c:identifier="gst_clock_get_internal_time">
        <doc xml:whitespace="preserve">Gets the current internal time of the given clock. The time is returned
unadjusted for the offset and the rate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the internal time of the clock. Or GST_CLOCK_TIME_NONE when given invalid input.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_master" c:identifier="gst_clock_get_master">
        <doc xml:whitespace="preserve">Get the master clock that @clock is slaved to or %NULL when the clock is
not slaved to any master clock.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a master #GstClock or %NULL when this clock is not slaved to a master clock. Unref after usage.  MT safe.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="get_resolution" c:identifier="gst_clock_get_resolution">
        <doc xml:whitespace="preserve">Get the accuracy of the clock. The accuracy of the clock is the granularity
of the values returned by gst_clock_get_time().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the resolution of the clock in units of #GstClockTime.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_time" c:identifier="gst_clock_get_time">
        <doc xml:whitespace="preserve">Gets the current time of the given clock. The time is always
monotonically increasing and adjusted according to the current
offset and rate.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the time of the clock. Or GST_CLOCK_TIME_NONE when given invalid input.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_timeout" c:identifier="gst_clock_get_timeout">
        <doc xml:whitespace="preserve">Get the amount of time that master and slave clocks are sampled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the interval between samples.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="new_periodic_id" c:identifier="gst_clock_new_periodic_id">
        <doc xml:whitespace="preserve">Get an ID from @clock to trigger a periodic notification.
The periodic notifications will start at time @start_time and
will then be fired with the given @interval. @id should be unreffed
after usage.

Free-function: gst_clock_id_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstClockID that can be used to request the time notification.  MT safe.</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </return-value>
        <parameters>
          <parameter name="start_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested start time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested interval</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_single_shot_id"
              c:identifier="gst_clock_new_single_shot_id">
        <doc xml:whitespace="preserve">Get a #GstClockID from @clock to trigger a single shot
notification at the requested time. The single shot id should be
unreffed after usage.

Free-function: gst_clock_id_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstClockID that can be used to request the time notification.  MT safe.</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="periodic_id_reinit"
              c:identifier="gst_clock_periodic_id_reinit">
        <doc xml:whitespace="preserve">Reinitializes the provided periodic @id to the provided start time and
interval. Does not modify the reference count.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the GstClockID could be reinitialized to the provided @time, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockID</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="start_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested start time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested interval</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_calibration" c:identifier="gst_clock_set_calibration">
        <doc xml:whitespace="preserve">Adjusts the rate and time of @clock. A rate of 1/1 is the normal speed of
the clock. Values bigger than 1/1 make the clock go faster.

@internal and @external are calibration parameters that arrange that
gst_clock_get_time() should have been @external at internal time @internal.
This internal time should not be in the future; that is, it should be less
than the value of gst_clock_get_internal_time() when this function is called.

Subsequent calls to gst_clock_get_time() will return clock times computed as
follows:

&lt;programlisting&gt;
  time = (internal_time - internal) * rate_num / rate_denom + external
&lt;/programlisting&gt;

This formula is implemented in gst_clock_adjust_unlocked(). Of course, it
tries to do the integer arithmetic as precisely as possible.

Note that gst_clock_get_time() always returns increasing values so when you
move the clock backwards, gst_clock_get_time() will report the previous value
until the clock catches up.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="internal" transfer-ownership="none">
            <doc xml:whitespace="preserve">a reference internal time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="external" transfer-ownership="none">
            <doc xml:whitespace="preserve">a reference external time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="rate_num" transfer-ownership="none">
            <doc xml:whitespace="preserve">the numerator of the rate of the clock relative to its internal time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="rate_denom" transfer-ownership="none">
            <doc xml:whitespace="preserve">the denominator of the rate of the clock</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_master" c:identifier="gst_clock_set_master">
        <doc xml:whitespace="preserve">Set @master as the master clock for @clock. @clock will be automatically
calibrated so that gst_clock_get_time() reports the same time as the
master clock.  

A clock provider that slaves its clock to a master can get the current
calibration values with gst_clock_get_calibration().

@master can be %NULL in which case @clock will not be slaved anymore. It will
however keep reporting its time adjusted with the last configured rate 
and time offsets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the clock is capable of being slaved to a master clock. Trying to set a master on a clock without the #GST_CLOCK_FLAG_CAN_SET_MASTER flag will make this function return %FALSE.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="master" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a master #GstClock</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolution" c:identifier="gst_clock_set_resolution">
        <doc xml:whitespace="preserve">Set the accuracy of the clock. Some clocks have the possibility to operate
with different accuracy at the expense of more resource usage. There is
normally no need to change the default resolution of a clock. The resolution
of a clock can only be changed if the clock has the
#GST_CLOCK_FLAG_CAN_SET_RESOLUTION flag set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the new resolution of the clock.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="resolution" transfer-ownership="none">
            <doc xml:whitespace="preserve">The resolution to set</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timeout" c:identifier="gst_clock_set_timeout">
        <doc xml:whitespace="preserve">Set the amount of time, in nanoseconds, to sample master and slave
clocks</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a timeout</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="single_shot_id_reinit"
              c:identifier="gst_clock_single_shot_id_reinit">
        <doc xml:whitespace="preserve">Reinitializes the provided single shot @id to the provided time. Does not
modify the reference count.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the GstClockID could be reinitialized to the provided @time, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockID</doc>
            <type name="ClockID" c:type="GstClockID"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">The requested time.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="unadjust_unlocked"
              c:identifier="gst_clock_unadjust_unlocked">
        <doc xml:whitespace="preserve">Converts the given @external clock time to the internal time of @clock,
using the rate and reference time set with gst_clock_set_calibration().
This function should be called with the clock's OBJECT_LOCK held and
is mainly used by clock subclasses.

This function is the reverse of gst_clock_adjust_unlocked().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the internal time of the clock corresponding to @external.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <parameter name="external" transfer-ownership="none">
            <doc xml:whitespace="preserve">an external clock time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="timeout" writable="1" transfer-ownership="none">
        <type name="guint64"/>
      </property>
      <property name="window-size" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <property name="window-threshold" writable="1" transfer-ownership="none">
        <type name="gint"/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ClockPrivate" c:type="GstClockPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <callback name="ClockCallback" c:type="GstClockCallback">
      <doc xml:whitespace="preserve">The function prototype of the callback.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE or %FALSE (currently unused)</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="clock" transfer-ownership="none">
          <doc xml:whitespace="preserve">The clock that triggered the callback</doc>
          <type name="Clock" c:type="GstClock*"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:whitespace="preserve">The time it was triggered</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstClockID that expired</doc>
          <type name="ClockID" c:type="GstClockID"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="3">
          <doc xml:whitespace="preserve">user data passed in the gst_clock_id_wait_async() function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ClockClass"
            c:type="GstClockClass"
            glib:is-gtype-struct-for="Clock">
      <doc xml:whitespace="preserve">GStreamer clock class. Override the vmethods to implement the clock
functionality.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="change_resolution">
        <callback name="change_resolution">
          <return-value transfer-ownership="none">
            <type name="ClockTime" c:type="GstClockTime"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="old_resolution" transfer-ownership="none">
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
            <parameter name="new_resolution" transfer-ownership="none">
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_resolution">
        <callback name="get_resolution">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the resolution of the clock in units of #GstClockTime.  MT safe.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_internal_time">
        <callback name="get_internal_time">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the internal time of the clock. Or GST_CLOCK_TIME_NONE when given invalid input.  MT safe.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait">
        <callback name="wait">
          <return-value transfer-ownership="none">
            <type name="ClockReturn" c:type="GstClockReturn"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="ClockEntry" c:type="GstClockEntry*"/>
            </parameter>
            <parameter name="jitter" transfer-ownership="none">
              <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait_async">
        <callback name="wait_async">
          <return-value transfer-ownership="none">
            <type name="ClockReturn" c:type="GstClockReturn"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="ClockEntry" c:type="GstClockEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unschedule">
        <callback name="unschedule">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="clock" transfer-ownership="none">
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
            <parameter name="entry" transfer-ownership="none">
              <type name="ClockEntry" c:type="GstClockEntry*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ClockEntry" c:type="GstClockEntry">
      <doc xml:whitespace="preserve">All pending timeouts or periodic notifies are converted into
an entry.
Note that GstClockEntry should be treated as an opaque structure. It must
not be extended or allocated using a custom allocator.</doc>
      <field name="refcount" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="clock" writable="1">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="type" writable="1">
        <type name="ClockEntryType" c:type="GstClockEntryType"/>
      </field>
      <field name="time" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="interval" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="status" writable="1">
        <type name="ClockReturn" c:type="GstClockReturn"/>
      </field>
      <field name="func" writable="1">
        <type name="ClockCallback" c:type="GstClockCallback"/>
      </field>
      <field name="user_data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="destroy_data" writable="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="unscheduled" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="woken_up" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="ClockEntryType" c:type="GstClockEntryType">
      <doc xml:whitespace="preserve">The type of the clock entry</doc>
      <member name="single" value="0" c:identifier="GST_CLOCK_ENTRY_SINGLE">
        <doc xml:whitespace="preserve">a single shot timeout</doc>
      </member>
      <member name="periodic"
              value="1"
              c:identifier="GST_CLOCK_ENTRY_PERIODIC">
        <doc xml:whitespace="preserve">a periodic timeout request</doc>
      </member>
    </enumeration>
    <bitfield name="ClockFlags" c:type="GstClockFlags">
      <doc xml:whitespace="preserve">The capabilities of this clock</doc>
      <member name="can_do_single_sync"
              value="16"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC">
        <doc xml:whitespace="preserve">clock can do a single sync timeout request</doc>
      </member>
      <member name="can_do_single_async"
              value="32"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC">
        <doc xml:whitespace="preserve">clock can do a single async timeout request</doc>
      </member>
      <member name="can_do_periodic_sync"
              value="64"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC">
        <doc xml:whitespace="preserve">clock can do sync periodic timeout requests</doc>
      </member>
      <member name="can_do_periodic_async"
              value="128"
              c:identifier="GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC">
        <doc xml:whitespace="preserve">clock can do async periodic timeout callbacks</doc>
      </member>
      <member name="can_set_resolution"
              value="256"
              c:identifier="GST_CLOCK_FLAG_CAN_SET_RESOLUTION">
        <doc xml:whitespace="preserve">clock's resolution can be changed</doc>
      </member>
      <member name="can_set_master"
              value="512"
              c:identifier="GST_CLOCK_FLAG_CAN_SET_MASTER">
        <doc xml:whitespace="preserve">clock can be slaved to a master clock</doc>
      </member>
      <member name="last" value="4096" c:identifier="GST_CLOCK_FLAG_LAST">
        <doc xml:whitespace="preserve">subclasses can add additional flags starting from this flag</doc>
      </member>
    </bitfield>
    <record name="ClockPrivate" c:type="GstClockPrivate" disguised="1">
    </record>
    <enumeration name="ClockReturn" c:type="GstClockReturn">
      <doc xml:whitespace="preserve">The return value of a clock operation.</doc>
      <member name="ok" value="0" c:identifier="GST_CLOCK_OK">
        <doc xml:whitespace="preserve">The operation succeeded.</doc>
      </member>
      <member name="early" value="1" c:identifier="GST_CLOCK_EARLY">
        <doc xml:whitespace="preserve">The operation was scheduled too late.</doc>
      </member>
      <member name="unscheduled"
              value="2"
              c:identifier="GST_CLOCK_UNSCHEDULED">
        <doc xml:whitespace="preserve">The clockID was unscheduled</doc>
      </member>
      <member name="busy" value="3" c:identifier="GST_CLOCK_BUSY">
        <doc xml:whitespace="preserve">The ClockID is busy</doc>
      </member>
      <member name="badtime" value="4" c:identifier="GST_CLOCK_BADTIME">
        <doc xml:whitespace="preserve">A bad time was provided to a function.</doc>
      </member>
      <member name="error" value="5" c:identifier="GST_CLOCK_ERROR">
        <doc xml:whitespace="preserve">An error occurred</doc>
      </member>
      <member name="unsupported"
              value="6"
              c:identifier="GST_CLOCK_UNSUPPORTED">
        <doc xml:whitespace="preserve">Operation is not supported</doc>
      </member>
      <member name="done" value="7" c:identifier="GST_CLOCK_DONE">
        <doc xml:whitespace="preserve">The ClockID is done waiting</doc>
      </member>
    </enumeration>
    <enumeration name="ClockType" c:type="GstClockType">
      <doc xml:whitespace="preserve">The different kind of clocks.</doc>
      <member name="realtime" value="0" c:identifier="GST_CLOCK_TYPE_REALTIME">
        <doc xml:whitespace="preserve">time since Epoch</doc>
      </member>
      <member name="monotonic"
              value="1"
              c:identifier="GST_CLOCK_TYPE_MONOTONIC">
        <doc xml:whitespace="preserve">monotonic time since some unspecified starting point</doc>
      </member>
      <member name="other" value="2" c:identifier="GST_CLOCK_TYPE_OTHER">
        <doc xml:whitespace="preserve">some other time source is used (Since: 1.0.5)</doc>
      </member>
    </enumeration>
    <class name="ControlBinding"
           c:symbol-prefix="control_binding"
           c:type="GstControlBinding"
           parent="Object"
           abstract="1"
           glib:type-name="GstControlBinding"
           glib:get-type="gst_control_binding_get_type"
           glib:type-struct="ControlBindingClass">
      <doc xml:whitespace="preserve">A value mapping object that attaches control sources to gobject properties.</doc>
      <virtual-method name="get_g_value_array" invoker="get_g_value_array">
        <doc xml:whitespace="preserve">Gets a number of #GValues for the given controlled property starting at the
requested time. The array @values need to hold enough space for @n_values of
#GValue.

This function is useful if one wants to e.g. draw a graph of the control
curve or apply a control curve sample by sample.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">array to put control-values in</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_value" invoker="get_value">
        <doc xml:whitespace="preserve">Gets the value for the given controlled property at the requested time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the GValue of the property at the given time, or %NULL if the property isn't controlled.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time the control-change should be read from</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_value_array" invoker="get_value_array">
        <doc xml:whitespace="preserve">Gets a number of values for the given controlled property starting at the
requested time. The array @values need to hold enough space for @n_values of
the same type as the objects property's type.

This function is useful if one wants to e.g. draw a graph of the control
curve or apply a control curve sample by sample.

The values are unboxed and ready to be used. The similar function 
gst_control_binding_get_g_value_array() returns the array as #GValues and is
better suites for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">array to put control-values in</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sync_values" invoker="sync_values">
        <doc xml:whitespace="preserve">Sets the property of the @object, according to the #GstControlSources that
handle them and for the given timestamp.

If this function fails, it is most likely the application developers fault.
Most probably the control sources are not setup correctly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the controller value could be applied to the object property, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object that has controlled properties</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="last_sync" transfer-ownership="none">
            <doc xml:whitespace="preserve">the last time this was called</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_g_value_array"
              c:identifier="gst_control_binding_get_g_value_array">
        <doc xml:whitespace="preserve">Gets a number of #GValues for the given controlled property starting at the
requested time. The array @values need to hold enough space for @n_values of
#GValue.

This function is useful if one wants to e.g. draw a graph of the control
curve or apply a control curve sample by sample.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">array to put control-values in</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="gst_control_binding_get_value">
        <doc xml:whitespace="preserve">Gets the value for the given controlled property at the requested time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the GValue of the property at the given time, or %NULL if the property isn't controlled.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time the control-change should be read from</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_array"
              c:identifier="gst_control_binding_get_value_array">
        <doc xml:whitespace="preserve">Gets a number of values for the given controlled property starting at the
requested time. The array @values need to hold enough space for @n_values of
the same type as the objects property's type.

This function is useful if one wants to e.g. draw a graph of the control
curve or apply a control curve sample by sample.

The values are unboxed and ready to be used. The similar function 
gst_control_binding_get_g_value_array() returns the array as #GValues and is
better suites for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">array to put control-values in</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_disabled"
              c:identifier="gst_control_binding_is_disabled">
        <doc xml:whitespace="preserve">Check if the control binding is disabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the binding is inactive</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_disabled"
              c:identifier="gst_control_binding_set_disabled">
        <doc xml:whitespace="preserve">This function is used to disable a control binding for some time, i.e.
gst_object_sync_values() will do nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="disabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean that specifies whether to disable the controller or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync_values"
              c:identifier="gst_control_binding_sync_values">
        <doc xml:whitespace="preserve">Sets the property of the @object, according to the #GstControlSources that
handle them and for the given timestamp.

If this function fails, it is most likely the application developers fault.
Most probably the control sources are not setup correctly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the controller value could be applied to the object property, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object that has controlled properties</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="last_sync" transfer-ownership="none">
            <doc xml:whitespace="preserve">the last time this was called</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="object"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Object"/>
      </property>
      <field name="parent">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="pspec">
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </field>
      <field name="object" readable="0" private="1">
        <type name="Object" c:type="GstObject*"/>
      </field>
      <field name="disabled" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="ControlBindingClass"
            c:type="GstControlBindingClass"
            glib:is-gtype-struct-for="ControlBinding">
      <doc xml:whitespace="preserve">The class structure of #GstControlBinding.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="sync_values">
        <callback name="sync_values">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the controller value could be applied to the object property, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="binding" transfer-ownership="none">
              <type name="ControlBinding" c:type="GstControlBinding*"/>
            </parameter>
            <parameter name="object" transfer-ownership="none">
              <doc xml:whitespace="preserve">the object that has controlled properties</doc>
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="timestamp" transfer-ownership="none">
              <doc xml:whitespace="preserve">the time that should be processed</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
            <parameter name="last_sync" transfer-ownership="none">
              <doc xml:whitespace="preserve">the last time this was called</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_value">
        <callback name="get_value">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the GValue of the property at the given time, or %NULL if the property isn't controlled.</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </return-value>
          <parameters>
            <parameter name="binding" transfer-ownership="none">
              <type name="ControlBinding" c:type="GstControlBinding*"/>
            </parameter>
            <parameter name="timestamp" transfer-ownership="none">
              <doc xml:whitespace="preserve">the time the control-change should be read from</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_value_array">
        <callback name="get_value_array">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="binding" transfer-ownership="none">
              <type name="ControlBinding" c:type="GstControlBinding*"/>
            </parameter>
            <parameter name="timestamp" transfer-ownership="none">
              <doc xml:whitespace="preserve">the time that should be processed</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
            <parameter name="interval" transfer-ownership="none">
              <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
            <parameter name="n_values" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of values</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="values" transfer-ownership="none">
              <doc xml:whitespace="preserve">array to put control-values in</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_g_value_array">
        <callback name="get_g_value_array">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="binding" transfer-ownership="none">
              <type name="ControlBinding" c:type="GstControlBinding*"/>
            </parameter>
            <parameter name="timestamp" transfer-ownership="none">
              <doc xml:whitespace="preserve">the time that should be processed</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
            <parameter name="interval" transfer-ownership="none">
              <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
            <parameter name="n_values" transfer-ownership="none">
              <doc xml:whitespace="preserve">the number of values</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="values" transfer-ownership="none">
              <doc xml:whitespace="preserve">array to put control-values in</doc>
              <type name="GObject.Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="ControlBindingConvert" c:type="GstControlBindingConvert">
      <doc xml:whitespace="preserve">Function to map a control-value to the target GValue.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="binding" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstControlBinding instance</doc>
          <type name="ControlBinding" c:type="GstControlBinding*"/>
        </parameter>
        <parameter name="src_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value returned by the cotnrol source</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="dest_value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the target GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ControlSource"
           c:symbol-prefix="control_source"
           c:type="GstControlSource"
           parent="Object"
           abstract="1"
           glib:type-name="GstControlSource"
           glib:get-type="gst_control_source_get_type"
           glib:type-struct="ControlSourceClass">
      <doc xml:whitespace="preserve">The #GstControlSource is a base class for control value sources that could
be used by #GstController to get timestamp-value pairs.

A #GstControlSource is used by first getting an instance, binding it to a
#GParamSpec (for example by using gst_controller_set_control_source()) and
then by having it used by the #GstController or calling
gst_control_source_get_value() or gst_control_source_get_value_array().

For implementing a new #GstControlSource one has to implement a
#GstControlSourceBind method, which will depending on the #GParamSpec set up
the control source for use and sets the #GstControlSourceGetValue and
#GstControlSourceGetValueArray functions. These are then used by
gst_control_source_get_value() or gst_control_source_get_value_array()
to get values for specific timestamps.</doc>
      <method name="get_value" c:identifier="gst_control_source_get_value">
        <doc xml:whitespace="preserve">Gets the value for this #GstControlSource at a given timestamp.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if the value couldn't be returned, TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time for which the value should be returned</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_array"
              c:identifier="gst_control_source_get_value_array">
        <doc xml:whitespace="preserve">Gets an array of values for for this #GstControlSource. Values that are
undefined contain NANs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the first timestamp</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time steps</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of values to fetch</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">array to put control-values in</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="get_value">
        <type name="ControlSourceGetValue" c:type="GstControlSourceGetValue"/>
      </field>
      <field name="get_value_array">
        <type name="ControlSourceGetValueArray"
              c:type="GstControlSourceGetValueArray"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="ControlSourceClass"
            c:type="GstControlSourceClass"
            glib:is-gtype-struct-for="ControlSource">
      <doc xml:whitespace="preserve">The class structure of #GstControlSource.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="ControlSourceGetValue" c:type="GstControlSourceGetValue">
      <doc xml:whitespace="preserve">Function for returning a value for a given timestamp.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the value was successfully calculated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstControlSource instance</doc>
          <type name="ControlSource" c:type="GstControlSource*"/>
        </parameter>
        <parameter name="timestamp" transfer-ownership="none">
          <doc xml:whitespace="preserve">timestamp for which a value should be calculated</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue which will be set to the result. It must be initialized to the correct type.</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ControlSourceGetValueArray"
              c:type="GstControlSourceGetValueArray">
      <doc xml:whitespace="preserve">Function for returning an array of values for starting at a given timestamp.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the values were successfully calculated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstControlSource instance</doc>
          <type name="ControlSource" c:type="GstControlSource*"/>
        </parameter>
        <parameter name="timestamp" transfer-ownership="none">
          <doc xml:whitespace="preserve">timestamp for which a value should be calculated</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="interval" transfer-ownership="none">
          <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="n_values" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of values</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="values" transfer-ownership="none">
          <doc xml:whitespace="preserve">array to put control-values in</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="CoreError"
                 c:type="GstCoreError"
                 glib:error-domain="gst-core-error-quark">
      <doc xml:whitespace="preserve">Core errors are errors inside the core GStreamer library.</doc>
      <member name="failed" value="1" c:identifier="GST_CORE_ERROR_FAILED">
        <doc xml:whitespace="preserve">a general error which doesn't fit in any other category.  Make sure you add a custom message to the error call.</doc>
      </member>
      <member name="too_lazy" value="2" c:identifier="GST_CORE_ERROR_TOO_LAZY">
        <doc xml:whitespace="preserve">do not use this except as a placeholder for deciding where to go while developing code.</doc>
      </member>
      <member name="not_implemented"
              value="3"
              c:identifier="GST_CORE_ERROR_NOT_IMPLEMENTED">
        <doc xml:whitespace="preserve">use this when you do not want to implement this functionality yet.</doc>
      </member>
      <member name="state_change"
              value="4"
              c:identifier="GST_CORE_ERROR_STATE_CHANGE">
        <doc xml:whitespace="preserve">used for state change errors.</doc>
      </member>
      <member name="pad" value="5" c:identifier="GST_CORE_ERROR_PAD">
        <doc xml:whitespace="preserve">used for pad-related errors.</doc>
      </member>
      <member name="thread" value="6" c:identifier="GST_CORE_ERROR_THREAD">
        <doc xml:whitespace="preserve">used for thread-related errors.</doc>
      </member>
      <member name="negotiation"
              value="7"
              c:identifier="GST_CORE_ERROR_NEGOTIATION">
        <doc xml:whitespace="preserve">used for negotiation-related errors.</doc>
      </member>
      <member name="event" value="8" c:identifier="GST_CORE_ERROR_EVENT">
        <doc xml:whitespace="preserve">used for event-related errors.</doc>
      </member>
      <member name="seek" value="9" c:identifier="GST_CORE_ERROR_SEEK">
        <doc xml:whitespace="preserve">used for seek-related errors.</doc>
      </member>
      <member name="caps" value="10" c:identifier="GST_CORE_ERROR_CAPS">
        <doc xml:whitespace="preserve">used for caps-related errors.</doc>
      </member>
      <member name="tag" value="11" c:identifier="GST_CORE_ERROR_TAG">
        <doc xml:whitespace="preserve">used for negotiation-related errors.</doc>
      </member>
      <member name="missing_plugin"
              value="12"
              c:identifier="GST_CORE_ERROR_MISSING_PLUGIN">
        <doc xml:whitespace="preserve">used if a plugin is missing.</doc>
      </member>
      <member name="clock" value="13" c:identifier="GST_CORE_ERROR_CLOCK">
        <doc xml:whitespace="preserve">used for clock related errors.</doc>
      </member>
      <member name="disabled"
              value="14"
              c:identifier="GST_CORE_ERROR_DISABLED">
        <doc xml:whitespace="preserve">used if functionality has been disabled at compile time.</doc>
      </member>
      <member name="num_errors"
              value="15"
              c:identifier="GST_CORE_ERROR_NUM_ERRORS">
        <doc xml:whitespace="preserve">the number of core error types.</doc>
      </member>
    </enumeration>
    <constant name="DEBUG_BG_MASK" value="240" c:type="GST_DEBUG_BG_MASK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DEBUG_FG_MASK" value="15" c:type="GST_DEBUG_FG_MASK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="DEBUG_FORMAT_MASK"
              value="65280"
              c:type="GST_DEBUG_FORMAT_MASK">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="DateTime"
            c:type="GstDateTime"
            glib:type-name="GstDateTime"
            glib:get-type="gst_date_time_get_type"
            c:symbol-prefix="date_time">
      <doc xml:whitespace="preserve">Struct to store date, time and timezone information altogether.
#GstDateTime is refcounted and immutable.

Date information is handled using the proleptic Gregorian calendar.

Provides basic creation functions and accessor functions to its fields.</doc>
      <constructor name="new" c:identifier="gst_date_time_new">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the date and times in the gregorian calendar
in the supplied timezone.

@year should be from 1 to 9999, @month should be from 1 to 12, @day from
1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.

Note that @tzoffset is a float and was chosen so for being able to handle
some fractional timezones, while it still keeps the readability of
represeting it in hours for most timezones.

If value is -1 then all over value will be ignored. For example
if @month == -1, then #GstDateTime will created only for @year. If
@day == -1, then #GstDateTime will created for @year and @month and
so on.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="tzoffset" transfer-ownership="none">
            <doc xml:whitespace="preserve">Offset from UTC in hours.</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="year" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian year</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:whitespace="preserve">the day of the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hour of the day</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minute of the hour</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second of the minute</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_g_date_time"
                   c:identifier="gst_date_time_new_from_g_date_time">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime from a #GDateTime object.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #GstDateTime, or NULL on error</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="dt" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GDateTime. The new #GstDateTime takes ownership.</doc>
            <type name="GLib.DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_iso8601_string"
                   c:identifier="gst_date_time_new_from_iso8601_string">
        <doc xml:whitespace="preserve">Tries to parse common variants of ISO-8601 datetime strings into a
#GstDateTime.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #GstDateTime, or NULL on error</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:whitespace="preserve">ISO 8601-formatted datetime string.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_epoch_local_time"
                   c:identifier="gst_date_time_new_from_unix_epoch_local_time">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the time since Jan 1, 1970 specified by
@secs. The #GstDateTime is in the local timezone.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="secs" transfer-ownership="none">
            <doc xml:whitespace="preserve">seconds from the Unix epoch</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_unix_epoch_utc"
                   c:identifier="gst_date_time_new_from_unix_epoch_utc">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the time since Jan 1, 1970 specified by
@secs. The #GstDateTime is in the UTC timezone.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="secs" transfer-ownership="none">
            <doc xml:whitespace="preserve">seconds from the Unix epoch</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_local_time"
                   c:identifier="gst_date_time_new_local_time">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the date and times in the gregorian calendar
in the local timezone.

@year should be from 1 to 9999, @month should be from 1 to 12, @day from
1 to 31, @hour from 0 to 23, @minutes and @seconds from 0 to 59.

If @month is -1, then the #GstDateTime created will only contain @year,
and all other fields will be considered not set.

If @day is -1, then the #GstDateTime created will only contain @year and
@month and all other fields will be considered not set.

If @hour is -1, then the #GstDateTime created will only contain @year and
@month and @day, and the time fields will be considered not set. In this
case @minute and @seconds should also be -1.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian year</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian month, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:whitespace="preserve">the day of the gregorian month, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="hour" transfer-ownership="none">
            <doc xml:whitespace="preserve">the hour of the day, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minute" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minute of the hour, or -1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="seconds" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second of the minute, or -1</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_now_local_time"
                   c:identifier="gst_date_time_new_now_local_time">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime representing the current date and time.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime which should be freed with gst_date_time_unref().</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
      </constructor>
      <constructor name="new_now_utc" c:identifier="gst_date_time_new_now_utc">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime that represents the current instant at Universal
coordinated time.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime which should be freed with gst_date_time_unref().</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
      </constructor>
      <constructor name="new_y" c:identifier="gst_date_time_new_y">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the date and times in the gregorian calendar
in the local timezone.

@year should be from 1 to 9999.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian year</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_ym" c:identifier="gst_date_time_new_ym">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the date and times in the gregorian calendar
in the local timezone.

@year should be from 1 to 9999, @month should be from 1 to 12.

If value is -1 then all over value will be ignored. For example
if @month == -1, then #GstDateTime will created only for @year.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian year</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_ymd" c:identifier="gst_date_time_new_ymd">
        <doc xml:whitespace="preserve">Creates a new #GstDateTime using the date and times in the gregorian calendar
in the local timezone.

@year should be from 1 to 9999, @month should be from 1 to 12, @day from
1 to 31.

If value is -1 then all over value will be ignored. For example
if @month == -1, then #GstDateTime will created only for @year. If
@day == -1, then #GstDateTime will created for @year and @month and
so on.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the newly created #GstDateTime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
        <parameters>
          <parameter name="year" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian year</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="month" transfer-ownership="none">
            <doc xml:whitespace="preserve">the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="day" transfer-ownership="none">
            <doc xml:whitespace="preserve">the day of the gregorian month</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_day" c:identifier="gst_date_time_get_day">
        <doc xml:whitespace="preserve">Returns the day of the month of this #GstDateTime.
Call gst_date_time_has_day before, to avoid warnings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The day of this #GstDateTime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_hour" c:identifier="gst_date_time_get_hour">
        <doc xml:whitespace="preserve">Retrieves the hour of the day represented by @datetime in the gregorian
calendar. The return is in the range of 0 to 23.
Call gst_date_time_has_haur before, to avoid warnings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the hour of the day</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_microsecond"
              c:identifier="gst_date_time_get_microsecond">
        <doc xml:whitespace="preserve">Retrieves the fractional part of the seconds in microseconds represented by
@datetime in the gregorian calendar.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the microsecond of the second</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_minute" c:identifier="gst_date_time_get_minute">
        <doc xml:whitespace="preserve">Retrieves the minute of the hour represented by @datetime in the gregorian
calendar.
Call gst_date_time_has_minute before, to avoid warnings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the minute of the hour</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_month" c:identifier="gst_date_time_get_month">
        <doc xml:whitespace="preserve">Returns the month of this #GstDateTime. January is 1, February is 2, etc..
Call gst_date_time_has_month before, to avoid warnings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The month of this #GstDateTime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_second" c:identifier="gst_date_time_get_second">
        <doc xml:whitespace="preserve">Retrieves the second of the minute represented by @datetime in the gregorian
calendar.
Call gst_date_time_has_second before, to avoid warnings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the second represented by @datetime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="get_time_zone_offset"
              c:identifier="gst_date_time_get_time_zone_offset">
        <doc xml:whitespace="preserve">Retrieves the offset from UTC in hours that the timezone specified
by @datetime represents. Timezones ahead (to the east) of UTC have positive
values, timezones before (to the west) of UTC have negative values.
If @datetime represents UTC time, then the offset is zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset from UTC in hours</doc>
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
      </method>
      <method name="get_year" c:identifier="gst_date_time_get_year">
        <doc xml:whitespace="preserve">Returns the year of this #GstDateTime
Call gst_date_time_has_year before, to avoid warnings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The year of this #GstDateTime</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="has_day" c:identifier="gst_date_time_has_day">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @datetime&lt;!-- --&gt;'s day field is set, otherwise FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_month" c:identifier="gst_date_time_has_month">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @datetime&lt;!-- --&gt;'s month field is set, otherwise FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_second" c:identifier="gst_date_time_has_second">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @datetime&lt;!-- --&gt;'s second field is set, otherwise FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_time" c:identifier="gst_date_time_has_time">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @datetime&lt;!-- --&gt;'s hour and minute fields are set, otherwise FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_year" c:identifier="gst_date_time_has_year">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @datetime&lt;!-- --&gt;'s year field is set (which should always be the case), otherwise FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="gst_date_time_ref">
        <doc xml:whitespace="preserve">Atomically increments the reference count of @datetime by one.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the reference @datetime</doc>
          <type name="DateTime" c:type="GstDateTime*"/>
        </return-value>
      </method>
      <method name="to_g_date_time"
              c:identifier="gst_date_time_to_g_date_time">
        <doc xml:whitespace="preserve">Creates a new #GDateTime from a fully defined #GstDateTime object.

Free-function: g_date_time_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly created #GDateTime, or NULL on error</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
      </method>
      <method name="to_iso8601_string"
              c:identifier="gst_date_time_to_iso8601_string">
        <doc xml:whitespace="preserve">Create a minimal string compatible with ISO-8601. Possible output formats
are (for example): 2012, 2012-06, 2012-06-23, 2012-06-23T23:30Z,
2012-06-23T23:30+0100, 2012-06-23T23:30:59Z, 2012-06-23T23:30:59+0100</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated string formatted according to ISO 8601 and only including the datetime fields that are valid, or NULL in case there was an error. The string should be freed with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="gst_date_time_unref">
        <doc xml:whitespace="preserve">Atomically decrements the reference count of @datetime by one.  When the
reference count reaches zero, the structure is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <record name="DebugCategory" c:type="GstDebugCategory">
      <doc xml:whitespace="preserve">This is the struct that describes the categories. Once initialized with
#GST_DEBUG_CATEGORY_INIT, its values can't be changed anymore.</doc>
      <field name="threshold" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="color" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="description" readable="0" private="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <method name="free" c:identifier="gst_debug_category_free">
        <doc xml:whitespace="preserve">Removes and frees the category and all associated resources.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_color" c:identifier="gst_debug_category_get_color">
        <doc xml:whitespace="preserve">Returns the color of a debug category used when printing output in this
category.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the color of the category.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_description"
              c:identifier="gst_debug_category_get_description">
        <doc xml:whitespace="preserve">Returns the description of a debug category.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the description of the category.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="gst_debug_category_get_name">
        <doc xml:whitespace="preserve">Returns the name of a debug category.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the category.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_threshold"
              c:identifier="gst_debug_category_get_threshold">
        <doc xml:whitespace="preserve">Returns the threshold of a #GstDebugCategory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstDebugLevel that is used as threshold.</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </return-value>
      </method>
      <method name="reset_threshold"
              c:identifier="gst_debug_category_reset_threshold">
        <doc xml:whitespace="preserve">Resets the threshold of the category to the default level. Debug information
will only be output if the threshold is lower or equal to the level of the
debugging message.
Use this function to set the threshold back to where it was after using
gst_debug_category_set_threshold().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_threshold"
              c:identifier="gst_debug_category_set_threshold">
        <doc xml:whitespace="preserve">Sets the threshold of the category to the given level. Debug information will
only be output if the threshold is lower or equal to the level of the
debugging message.
&lt;note&gt;&lt;para&gt;
Do not use this function in production code, because other functions may
change the threshold of categories as side effect. It is however a nice
function to use when debugging (even from gdb).
&lt;/para&gt;&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="level" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstDebugLevel threshold to set.</doc>
            <type name="DebugLevel" c:type="GstDebugLevel"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DebugColorFlags" c:type="GstDebugColorFlags">
      <doc xml:whitespace="preserve">These are some terminal style flags you can use when creating your
debugging categories to make them stand out in debugging output.</doc>
      <member name="fg_black" value="0" c:identifier="GST_DEBUG_FG_BLACK">
        <doc xml:whitespace="preserve">Use black as foreground color.</doc>
      </member>
      <member name="fg_red" value="1" c:identifier="GST_DEBUG_FG_RED">
        <doc xml:whitespace="preserve">Use red as foreground color.</doc>
      </member>
      <member name="fg_green" value="2" c:identifier="GST_DEBUG_FG_GREEN">
        <doc xml:whitespace="preserve">Use green as foreground color.</doc>
      </member>
      <member name="fg_yellow" value="3" c:identifier="GST_DEBUG_FG_YELLOW">
        <doc xml:whitespace="preserve">Use yellow as foreground color.</doc>
      </member>
      <member name="fg_blue" value="4" c:identifier="GST_DEBUG_FG_BLUE">
        <doc xml:whitespace="preserve">Use blue as foreground color.</doc>
      </member>
      <member name="fg_magenta" value="5" c:identifier="GST_DEBUG_FG_MAGENTA">
        <doc xml:whitespace="preserve">Use magenta as foreground color.</doc>
      </member>
      <member name="fg_cyan" value="6" c:identifier="GST_DEBUG_FG_CYAN">
        <doc xml:whitespace="preserve">Use cyan as foreground color.</doc>
      </member>
      <member name="fg_white" value="7" c:identifier="GST_DEBUG_FG_WHITE">
        <doc xml:whitespace="preserve">Use white as foreground color.</doc>
      </member>
      <member name="bg_black" value="0" c:identifier="GST_DEBUG_BG_BLACK">
        <doc xml:whitespace="preserve">Use black as background color.</doc>
      </member>
      <member name="bg_red" value="16" c:identifier="GST_DEBUG_BG_RED">
        <doc xml:whitespace="preserve">Use red as background color.</doc>
      </member>
      <member name="bg_green" value="32" c:identifier="GST_DEBUG_BG_GREEN">
        <doc xml:whitespace="preserve">Use green as background color.</doc>
      </member>
      <member name="bg_yellow" value="48" c:identifier="GST_DEBUG_BG_YELLOW">
        <doc xml:whitespace="preserve">Use yellow as background color.</doc>
      </member>
      <member name="bg_blue" value="64" c:identifier="GST_DEBUG_BG_BLUE">
        <doc xml:whitespace="preserve">Use blue as background color.</doc>
      </member>
      <member name="bg_magenta" value="80" c:identifier="GST_DEBUG_BG_MAGENTA">
        <doc xml:whitespace="preserve">Use magenta as background color.</doc>
      </member>
      <member name="bg_cyan" value="96" c:identifier="GST_DEBUG_BG_CYAN">
        <doc xml:whitespace="preserve">Use cyan as background color.</doc>
      </member>
      <member name="bg_white" value="112" c:identifier="GST_DEBUG_BG_WHITE">
        <doc xml:whitespace="preserve">Use white as background color.</doc>
      </member>
      <member name="bold" value="256" c:identifier="GST_DEBUG_BOLD">
        <doc xml:whitespace="preserve">Make the output bold.</doc>
      </member>
      <member name="underline" value="512" c:identifier="GST_DEBUG_UNDERLINE">
        <doc xml:whitespace="preserve">Underline the output.</doc>
      </member>
    </enumeration>
    <callback name="DebugFuncPtr" c:type="GstDebugFuncPtr">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <bitfield name="DebugGraphDetails" c:type="GstDebugGraphDetails">
      <doc xml:whitespace="preserve">Available details for pipeline graphs produced by GST_DEBUG_BIN_TO_DOT_FILE()
and GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS().</doc>
      <member name="media_type"
              value="1"
              c:identifier="GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE">
        <doc xml:whitespace="preserve">show caps-name on edges</doc>
      </member>
      <member name="caps_details"
              value="2"
              c:identifier="GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS">
        <doc xml:whitespace="preserve">show caps-details on edges</doc>
      </member>
      <member name="non_default_params"
              value="4"
              c:identifier="GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS">
        <doc xml:whitespace="preserve">show modified parameters on elements</doc>
      </member>
      <member name="states"
              value="8"
              c:identifier="GST_DEBUG_GRAPH_SHOW_STATES">
        <doc xml:whitespace="preserve">show element states</doc>
      </member>
      <member name="all" value="15" c:identifier="GST_DEBUG_GRAPH_SHOW_ALL">
        <doc xml:whitespace="preserve">show all details</doc>
      </member>
    </bitfield>
    <enumeration name="DebugLevel" c:type="GstDebugLevel">
      <doc xml:whitespace="preserve">The level defines the importance of a debugging message. The more important a
message is, the greater the probability that the debugging system outputs it.</doc>
      <member name="none" value="0" c:identifier="GST_LEVEL_NONE">
        <doc xml:whitespace="preserve">No debugging level specified or desired. Used to deactivate debugging output.</doc>
      </member>
      <member name="error" value="1" c:identifier="GST_LEVEL_ERROR">
        <doc xml:whitespace="preserve">Error messages are to be used only when an error occured that stops the application from keeping working correctly. An examples is gst_element_error, which outputs a message with this priority. It does not mean that the application is terminating as with g_errror.</doc>
      </member>
      <member name="warning" value="2" c:identifier="GST_LEVEL_WARNING">
        <doc xml:whitespace="preserve">Warning messages are to inform about abnormal behaviour that could lead to problems or weird behaviour later on. An example of this would be clocking issues ("your computer is pretty slow") or broken input data ("Can't synchronize to stream.")</doc>
      </member>
      <member name="fixme" value="3" c:identifier="GST_LEVEL_FIXME">
        <doc xml:whitespace="preserve">Fixme messages are messages that indicate that something in the executed code path is not fully implemented or handled yet. Note that this does not replace proper error handling in any way, the purpose of this message is to make it easier to spot incomplete/unfinished pieces of code when reading the debug log.</doc>
      </member>
      <member name="info" value="4" c:identifier="GST_LEVEL_INFO">
        <doc xml:whitespace="preserve">Informational messages should be used to keep the developer updated about what is happening. Examples where this should be used are when a typefind function has successfully determined the type of the stream or when an mp3 plugin detects the format to be used. ("This file has mono sound.")</doc>
      </member>
      <member name="debug" value="5" c:identifier="GST_LEVEL_DEBUG">
        <doc xml:whitespace="preserve">Debugging messages should be used when something common happens that is not the expected default behavior, or something that's useful to know but doesn't happen all the time (ie. per loop iteration or buffer processed or event handled). An example would be notifications about state changes or receiving/sending of events.</doc>
      </member>
      <member name="log" value="6" c:identifier="GST_LEVEL_LOG">
        <doc xml:whitespace="preserve">Log messages are messages that are very common but might be useful to know. As a rule of thumb a pipeline that is iterating as expected should never output anything else but LOG messages. Use this log level to log recurring information in chain functions and loop functions, for example.</doc>
      </member>
      <member name="trace" value="7" c:identifier="GST_LEVEL_TRACE">
        <doc xml:whitespace="preserve">Tracing-related messages. Examples for this are referencing/dereferencing of objects.</doc>
      </member>
      <member name="memdump" value="9" c:identifier="GST_LEVEL_MEMDUMP">
        <doc xml:whitespace="preserve">memory dump messages are used to log (small) chunks of data as memory dumps in the log. They will be displayed as hexdump with ASCII characters.</doc>
      </member>
      <member name="count" value="10" c:identifier="GST_LEVEL_COUNT">
        <doc xml:whitespace="preserve">The number of defined debugging levels.</doc>
      </member>
    </enumeration>
    <record name="DebugMessage" c:type="GstDebugMessage" disguised="1">
      <method name="get" c:identifier="gst_debug_message_get">
        <doc xml:whitespace="preserve">Gets the string representation of a #GstDebugMessage. This function is used
in debug handlers to extract the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the string representation of a #GstDebugMessage.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
    </record>
    <class name="DoubleRange"
           c:symbol-prefix="double_range"
           glib:type-name="GstDoubleRange"
           glib:get-type="gst_double_range_get_type"
           glib:fundamental="1">
    </class>
    <constant name="ELEMENT_FACTORY_KLASS_DECODER"
              value="Decoder"
              c:type="GST_ELEMENT_FACTORY_KLASS_DECODER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_DEMUXER"
              value="Demuxer"
              c:type="GST_ELEMENT_FACTORY_KLASS_DEMUXER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_DEPAYLOADER"
              value="Depayloader"
              c:type="GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_ENCODER"
              value="Encoder"
              c:type="GST_ELEMENT_FACTORY_KLASS_ENCODER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_FORMATTER"
              value="Formatter"
              c:type="GST_ELEMENT_FACTORY_KLASS_FORMATTER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_AUDIO"
              value="Audio"
              c:type="GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_IMAGE"
              value="Image"
              c:type="GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_METADATA"
              value="Metadata"
              c:type="GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE"
              value="Subtitle"
              c:type="GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MEDIA_VIDEO"
              value="Video"
              c:type="GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_MUXER"
              value="Muxer"
              c:type="GST_ELEMENT_FACTORY_KLASS_MUXER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_PARSER"
              value="Parser"
              c:type="GST_ELEMENT_FACTORY_KLASS_PARSER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_PAYLOADER"
              value="Payloader"
              c:type="GST_ELEMENT_FACTORY_KLASS_PAYLOADER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_SINK"
              value="Sink"
              c:type="GST_ELEMENT_FACTORY_KLASS_SINK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_KLASS_SRC"
              value="Source"
              c:type="GST_ELEMENT_FACTORY_KLASS_SRC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_ANY"
              value="562949953421311"
              c:type="GST_ELEMENT_FACTORY_TYPE_ANY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS"
              value="3940649673949188"
              c:type="GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_AUDIO_ENCODER"
              value="1125899906842626"
              c:type="GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DECODABLE"
              value="353"
              c:type="GST_ELEMENT_FACTORY_TYPE_DECODABLE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DECODER"
              value="1"
              c:type="GST_ELEMENT_FACTORY_TYPE_DECODER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DEMUXER"
              value="32"
              c:type="GST_ELEMENT_FACTORY_TYPE_DEMUXER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_DEPAYLOADER"
              value="256"
              c:type="GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_ENCODER"
              value="2"
              c:type="GST_ELEMENT_FACTORY_TYPE_ENCODER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_FORMATTER"
              value="512"
              c:type="GST_ELEMENT_FACTORY_TYPE_FORMATTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MAX_ELEMENTS"
              value="281474976710656"
              c:type="GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_ANY"
              value="18446462598732840960"
              c:type="GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_AUDIO"
              value="1125899906842624"
              c:type="GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_IMAGE"
              value="2251799813685248"
              c:type="GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_METADATA"
              value="9007199254740992"
              c:type="GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE"
              value="4503599627370496"
              c:type="GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MEDIA_VIDEO"
              value="562949953421312"
              c:type="GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_MUXER"
              value="16"
              c:type="GST_ELEMENT_FACTORY_TYPE_MUXER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_PARSER"
              value="64"
              c:type="GST_ELEMENT_FACTORY_TYPE_PARSER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_PAYLOADER"
              value="128"
              c:type="GST_ELEMENT_FACTORY_TYPE_PAYLOADER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_SINK"
              value="4"
              c:type="GST_ELEMENT_FACTORY_TYPE_SINK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_SRC"
              value="8"
              c:type="GST_ELEMENT_FACTORY_TYPE_SRC">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_FACTORY_TYPE_VIDEO_ENCODER"
              value="2814749767106562"
              c:type="GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="ELEMENT_METADATA_AUTHOR"
              value="author"
              c:type="GST_ELEMENT_METADATA_AUTHOR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_METADATA_DESCRIPTION"
              value="description"
              c:type="GST_ELEMENT_METADATA_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_METADATA_DOC_URI"
              value="doc-uri"
              c:type="GST_ELEMENT_METADATA_DOC_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_METADATA_ICON_NAME"
              value="icon-name"
              c:type="GST_ELEMENT_METADATA_ICON_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_METADATA_KLASS"
              value="klass"
              c:type="GST_ELEMENT_METADATA_KLASS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ELEMENT_METADATA_LONGNAME"
              value="long-name"
              c:type="GST_ELEMENT_METADATA_LONGNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="ERROR_SYSTEM"
              value="system error: %s"
              c:type="GST_ERROR_SYSTEM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="EVENT_NUM_SHIFT" value="8" c:type="GST_EVENT_NUM_SHIFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="EVENT_TYPE_BOTH" value="0" c:type="GST_EVENT_TYPE_BOTH">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Element"
           c:symbol-prefix="element"
           c:type="GstElement"
           parent="Object"
           abstract="1"
           glib:type-name="GstElement"
           glib:get-type="gst_element_get_type"
           glib:type-struct="ElementClass">
      <doc xml:whitespace="preserve">GstElement is the abstract base class needed to construct an element that
can be used in a GStreamer pipeline. Please refer to the plugin writers
guide for more information on creating #GstElement subclasses.

The name of a #GstElement can be get with gst_element_get_name() and set with
gst_element_set_name().  For speed, GST_ELEMENT_NAME() can be used in the
core when using the appropriate locking. Do not use this in plug-ins or
applications in order to retain ABI compatibility.

Elements can have pads (of the type #GstPad).  These pads link to pads on
other elements.  #GstBuffer flow between these linked pads.
A #GstElement has a #GList of #GstPad structures for all their input (or sink)
and output (or source) pads.
Core and plug-in writers can add and remove pads with gst_element_add_pad()
and gst_element_remove_pad().

An existing pad of an element can be retrieved by name with
gst_element_get_static_pad(). A new dynamic pad can be created using
gst_element_request_pad() with a #GstPadTemplate or 
gst_element_get_request_pad() with the template name such as "src_\%u".
An iterator of all pads can be retrieved with gst_element_iterate_pads().

Elements can be linked through their pads.
If the link is straightforward, use the gst_element_link()
convenience function to link two elements, or gst_element_link_many()
for more elements in a row.
Use gst_element_link_filtered() to link two elements constrained by
a specified set of #GstCaps.
For finer control, use gst_element_link_pads() and
gst_element_link_pads_filtered() to specify the pads to link on
each element by name.

Each element has a state (see #GstState).  You can get and set the state
of an element with gst_element_get_state() and gst_element_set_state().
Setting a state triggers a #GstStateChange. To get a string representation
of a #GstState, use gst_element_state_get_name().

You can get and set a #GstClock on an element using gst_element_get_clock()
and gst_element_set_clock().
Some elements can provide a clock for the pipeline if
the #GST_ELEMENT_FLAG_PROVIDE_CLOCK flag is set. With the
gst_element_provide_clock() method one can retrieve the clock provided by
such an element.
Not all elements require a clock to operate correctly. If the
#GST_ELEMENT_FLAG_REQUIRE_CLOCK() flag is set, a clock should be set on the
element with gst_element_set_clock().

Note that clock slection and distribution is normally handled by the
toplevel #GstPipeline so the clock functions are only to be used in very
specific situations.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <function name="make_from_uri"
                c:identifier="gst_element_make_from_uri"
                throws="1">
        <doc xml:whitespace="preserve">Creates an element for handling the given URI.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new element or NULL if none could be created</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether to create a source or a sink</doc>
            <type name="URIType" c:type="const GstURIType"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">URI to create an element for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="elementname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">Name of created element, can be NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register" c:identifier="gst_element_register">
        <doc xml:whitespace="preserve">Create a new elementfactory capable of instantiating objects of the
@type and add the factory to @plugin.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if the registering succeeded, FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">#GstPlugin to register the element with, or NULL for a static element.</doc>
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of elements of this type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="rank" transfer-ownership="none">
            <doc xml:whitespace="preserve">rank of element (higher rank means more importance when autoplugging)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">GType of element to register</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </function>
      <function name="state_change_return_get_name"
                c:identifier="gst_element_state_change_return_get_name">
        <doc xml:whitespace="preserve">Gets a string representing the given state change result.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string with the name of the state result.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="state_ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstStateChangeReturn to get the name of.</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </parameter>
        </parameters>
      </function>
      <function name="state_get_name"
                c:identifier="gst_element_state_get_name">
        <doc xml:whitespace="preserve">Gets a string representing the given state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a string with the name of the state.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstState to get the name of.</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="change_state" invoker="change_state">
        <doc xml:whitespace="preserve">Perform @transition on @element.

This function must be called with STATE_LOCK held and is mainly used
internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstStateChangeReturn of the state transition.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="transition" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested transition</doc>
            <type name="StateChange" c:type="GstStateChange"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_state" invoker="get_state">
        <doc xml:whitespace="preserve">Gets the state of the element.

For elements that performed an ASYNC state change, as reported by
gst_element_set_state(), this function will block up to the
specified timeout value for the state change to complete.
If the element completes the state change or goes into
an error, this function returns immediately with a return value of
%GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.

For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
returns the current and pending state immediately.

This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
successfully changed its state but is not able to provide data yet.
This mostly happens for live sources that only produce data in
%GST_STATE_PLAYING. While the state change return is equivalent to
%GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
some sink elements might not be able to complete their state change because
an element is not producing data to complete the preroll. When setting the
element to playing, the preroll will complete and playback will start.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%GST_STATE_CHANGE_SUCCESS if the element has no more pending state and the last state change succeeded, %GST_STATE_CHANGE_ASYNC if the element is still performing a state change or %GST_STATE_CHANGE_FAILURE if the last state change failed.  MT safe.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="pending"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the pending state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime to specify the timeout for an async state change or %GST_CLOCK_TIME_NONE for infinite timeout.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="no_more_pads" invoker="no_more_pads">
        <doc xml:whitespace="preserve">Use this function to signal that the element does not expect any more pads
to show up in the current pipeline. This function should be called whenever
pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
pad templates use this in combination with autopluggers to figure out that
the element is done initializing its pads.

This function emits the #GstElement::no-more-pads signal.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="pad_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pad_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="post_message" invoker="post_message">
        <doc xml:whitespace="preserve">Post a message on the element's #GstBus. This function takes ownership of the
message; if you want to access the message after this call, you should add an
additional reference before calling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message was successfully posted. The function returns %FALSE if the element did not have a bus.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMessage to post</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="provide_clock" invoker="provide_clock">
        <doc xml:whitespace="preserve">Get the clock provided by the given element.
&lt;note&gt;An element is only required to provide a clock in the PAUSED
state. Some elements can provide a clock in other states.&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the GstClock provided by the element or %NULL if no clock could be provided.  Unref after usage.  MT safe.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="query" invoker="query">
        <doc xml:whitespace="preserve">Performs a query on the given element.

For elements that don't implement a query handler, this function
forwards the query to a random srcpad or to the peer of a
random linked sinkpad of this element.

Please note that some queries might need a running pipeline to work.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release_pad">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="request_new_pad" introspectable="0">
        <return-value>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="send_event" invoker="send_event">
        <doc xml:whitespace="preserve">Sends an event to an element. If the element doesn't implement an
event handler, the event will be pushed on a random linked sink pad for
upstream events or a random linked source pad for downstream events.

This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the event was handled. Events that trigger a preroll (such as flushing seeks and steps) will emit %GST_MESSAGE_ASYNC_DONE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the element.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_bus" invoker="set_bus">
        <doc xml:whitespace="preserve">Sets the bus of the element. Increases the refcount on the bus.
For internal use only, unless you're testing elements.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstBus to set.</doc>
            <type name="Bus" c:type="GstBus*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_clock" invoker="set_clock">
        <doc xml:whitespace="preserve">Sets the clock for the element. This function increases the
refcount on the clock. Any previously set clock on the object
is unreffed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the element accepted the clock. An element can refuse a clock when it, for example, is not able to slave its internal clock to the @clock or when it requires a specific clock to operate.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstClock to set for the element.</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_state" invoker="set_state">
        <doc xml:whitespace="preserve">Sets the state of the element. This function will try to set the
requested state by going through all the intermediary states and calling
the class's state change function for each.

This function can return #GST_STATE_CHANGE_ASYNC, in which case the
element will perform the remainder of the state change asynchronously in
another thread.
An application can use gst_element_get_state() to wait for the completion
of the state change or it can wait for a state change message on the bus.

State changes to %GST_STATE_READY or %GST_STATE_NULL never return
#GST_STATE_CHANGE_ASYNC.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Result of the state change using #GstStateChangeReturn.  MT safe.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element's new #GstState.</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="state_changed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="oldstate" transfer-ownership="none">
            <type name="State" c:type="GstState"/>
          </parameter>
          <parameter name="newstate" transfer-ownership="none">
            <type name="State" c:type="GstState"/>
          </parameter>
          <parameter name="pending" transfer-ownership="none">
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="abort_state" c:identifier="gst_element_abort_state">
        <doc xml:whitespace="preserve">Abort the state change of the element. This function is used
by elements that do asynchronous state changes and find out
something is wrong.

This function should be called with the STATE_LOCK held.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="add_pad" c:identifier="gst_element_add_pad">
        <doc xml:whitespace="preserve">Adds a pad (link point) to @element. @pad's parent will be set to @element;
see gst_object_set_parent() for refcounting information.

Pads are not automatically activated so elements should perform the needed
steps to activate the pad in case this pad is added in the PAUSED or PLAYING
state. See gst_pad_set_active() for more information about activating pads.

The pad and the element should be unlocked when calling this function.

This function will emit the #GstElement::pad-added signal on the element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad could be added. This function can fail when a pad with the same name already existed or the pad already had another parent.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstPad to add to the element.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="change_state" c:identifier="gst_element_change_state">
        <doc xml:whitespace="preserve">Perform @transition on @element.

This function must be called with STATE_LOCK held and is mainly used
internally.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstStateChangeReturn of the state transition.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="transition" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested transition</doc>
            <type name="StateChange" c:type="GstStateChange"/>
          </parameter>
        </parameters>
      </method>
      <method name="continue_state" c:identifier="gst_element_continue_state">
        <doc xml:whitespace="preserve">Commit the state change of the element and proceed to the next
pending state if any. This function is used
by elements that do asynchronous state changes.
The core will normally call this method automatically when an
element returned %GST_STATE_CHANGE_SUCCESS from the state change function.

If after calling this method the element still has not reached
the pending state, the next state change is performed.

This method is used internally and should normally not be called by plugins
or applications.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The result of the commit state change.  MT safe.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">The previous state return value</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_all_pads"
              c:identifier="gst_element_create_all_pads">
        <doc xml:whitespace="preserve">Creates a pad for each pad template that is always available.
This function is only useful during object initialization of
subclasses of #GstElement.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_base_time" c:identifier="gst_element_get_base_time">
        <doc xml:whitespace="preserve">Returns the base time of the element. The base time is the
absolute time of the clock when this element was last put to
PLAYING. Subtracting the base time from the clock time gives
the running time of the element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the base time of the element.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_bus" c:identifier="gst_element_get_bus">
        <doc xml:whitespace="preserve">Returns the bus of the element. Note that only a #GstPipeline will provide a
bus for the application.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the element's #GstBus. unref after usage.  MT safe.</doc>
          <type name="Bus" c:type="GstBus*"/>
        </return-value>
      </method>
      <method name="get_clock" c:identifier="gst_element_get_clock">
        <doc xml:whitespace="preserve">Gets the currently configured clock of the element. This is the clock as was
last set with gst_element_set_clock().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstClock of the element. unref after usage.  MT safe.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="get_compatible_pad"
              c:identifier="gst_element_get_compatible_pad">
        <doc xml:whitespace="preserve">Looks for an unlinked pad to which the given pad can link. It is not
guaranteed that linking the pads will work, though it should work in most
cases.

This function will first attempt to find a compatible unlinked ALWAYS pad,
and if none can be found, it will request a compatible REQUEST pad by looking
at the templates of @element.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstPad to which a link can be made, or %NULL if one cannot be found. gst_object_unref() after usage.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to find a compatible one for.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the #GstCaps to use as a filter.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_compatible_pad_template"
              c:identifier="gst_element_get_compatible_pad_template">
        <doc xml:whitespace="preserve">Retrieves a pad template from @element that is compatible with @compattempl.
Pads from compatible templates can be linked together.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a compatible #GstPadTemplate, or NULL if none was found. No unreferencing is necessary.</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
        <parameters>
          <parameter name="compattempl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadTemplate to find a compatible template for</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_factory" c:identifier="gst_element_get_factory">
        <doc xml:whitespace="preserve">Retrieves the factory that was used to create this element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstElementFactory used for creating this element. no refcounting is needed.</doc>
          <type name="ElementFactory" c:type="GstElementFactory*"/>
        </return-value>
      </method>
      <method name="get_request_pad"
              c:identifier="gst_element_get_request_pad">
        <doc xml:whitespace="preserve">Retrieves a pad from the element by name (e.g. "src_\%d"). This version only
retrieves request pads. The pad should be released with
gst_element_release_request_pad().

This method is slow and will be deprecated in the future. New code should
use gst_element_request_pad() with the requested template.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">requested #GstPad if found, otherwise %NULL. Release after usage.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the request #GstPad to retrieve.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_start_time" c:identifier="gst_element_get_start_time">
        <doc xml:whitespace="preserve">Returns the start time of the element. The start time is the
running time of the clock when this element was last put to PAUSED.

Usually the start_time is managed by a toplevel element such as
#GstPipeline.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the start time of the element.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_state" c:identifier="gst_element_get_state">
        <doc xml:whitespace="preserve">Gets the state of the element.

For elements that performed an ASYNC state change, as reported by
gst_element_set_state(), this function will block up to the
specified timeout value for the state change to complete.
If the element completes the state change or goes into
an error, this function returns immediately with a return value of
%GST_STATE_CHANGE_SUCCESS or %GST_STATE_CHANGE_FAILURE respectively.

For elements that did not return %GST_STATE_CHANGE_ASYNC, this function
returns the current and pending state immediately.

This function returns %GST_STATE_CHANGE_NO_PREROLL if the element
successfully changed its state but is not able to provide data yet.
This mostly happens for live sources that only produce data in
%GST_STATE_PLAYING. While the state change return is equivalent to
%GST_STATE_CHANGE_SUCCESS, it is returned to the application to signal that
some sink elements might not be able to complete their state change because
an element is not producing data to complete the preroll. When setting the
element to playing, the preroll will complete and playback will start.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%GST_STATE_CHANGE_SUCCESS if the element has no more pending state and the last state change succeeded, %GST_STATE_CHANGE_ASYNC if the element is still performing a state change or %GST_STATE_CHANGE_FAILURE if the last state change failed.  MT safe.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="pending"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to #GstState to hold the pending state. Can be %NULL.</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstClockTime to specify the timeout for an async state change or %GST_CLOCK_TIME_NONE for infinite timeout.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_static_pad" c:identifier="gst_element_get_static_pad">
        <doc xml:whitespace="preserve">Retrieves a pad from @element by name. This version only retrieves
already-existing (i.e. 'static') pads.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the requested #GstPad if found, otherwise %NULL. unref after usage.  MT safe.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the static #GstPad to retrieve.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_locked_state"
              c:identifier="gst_element_is_locked_state">
        <doc xml:whitespace="preserve">Checks if the state of an element is locked.
If the state of an element is locked, state changes of the parent don't
affect the element.
This way you can leave currently unused elements inside bins. Just lock their
state before changing the state from #GST_STATE_NULL.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if the element's state is locked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="iterate_pads" c:identifier="gst_element_iterate_pads">
        <doc xml:whitespace="preserve">Retrieves an iterator of @element's pads. The iterator should
be freed after usage. Also more specialized iterators exists such as
gst_element_iterate_src_pads() or gst_element_iterate_sink_pads().

The order of pads returned by the iterator will be the order in which
the pads were added to the element.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstIterator of #GstPad. Unref each pad after use.  MT safe.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_sink_pads"
              c:identifier="gst_element_iterate_sink_pads">
        <doc xml:whitespace="preserve">Retrieves an iterator of @element's sink pads.

The order of pads returned by the iterator will be the order in which
the pads were added to the element.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstIterator of #GstPad. Unref each pad after use.  MT safe.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_src_pads"
              c:identifier="gst_element_iterate_src_pads">
        <doc xml:whitespace="preserve">Retrieves an iterator of @element's source pads.

The order of pads returned by the iterator will be the order in which
the pads were added to the element.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstIterator of #GstPad. Unref each pad after use.  MT safe.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="link" c:identifier="gst_element_link">
        <doc xml:whitespace="preserve">Links @src to @dest. The link must be from source to
destination; the other direction will not be tried. The function looks for
existing pads that aren't linked yet. It will request new pads if necessary.
Such pads need to be released manually when unlinking.
If multiple links are possible, only one is established.

Make sure you have added your elements to a bin or pipeline with
gst_bin_add() before trying to link them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the elements could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_filtered" c:identifier="gst_element_link_filtered">
        <doc xml:whitespace="preserve">Links @src to @dest using the given caps as filtercaps.
The link must be from source to
destination; the other direction will not be tried. The function looks for
existing pads that aren't linked yet. It will request new pads if necessary.
If multiple links are possible, only one is established.

Make sure you have added your elements to a bin or pipeline with
gst_bin_add() before trying to link them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the #GstCaps to filter the link, or #NULL for no filter.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_many"
              c:identifier="gst_element_link_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Chain together a series of elements. Uses gst_element_link().
Make sure you have added your elements to a bin or pipeline with
gst_bin_add() before trying to link them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="element_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GstElement in the link chain.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="link_pads" c:identifier="gst_element_link_pads">
        <doc xml:whitespace="preserve">Links the two named pads of the source and destination elements.
Side effect is that if one of the pads has no parent, it becomes a
child of the parent of the other element.  If they have different
parents, the link fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element or NULL for any pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element, or NULL for any pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_pads_filtered"
              c:identifier="gst_element_link_pads_filtered">
        <doc xml:whitespace="preserve">Links the two named pads of the source and destination elements. Side effect
is that if one of the pads has no parent, it becomes a child of the parent of
the other element. If they have different parents, the link fails. If @caps
is not #NULL, makes sure that the caps of the link is a subset of @caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element or NULL for any pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element or NULL for any pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the #GstCaps to filter the link, or #NULL for no filter.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_pads_full" c:identifier="gst_element_link_pads_full">
        <doc xml:whitespace="preserve">Links the two named pads of the source and destination elements.
Side effect is that if one of the pads has no parent, it becomes a
child of the parent of the other element.  If they have different
parents, the link fails.

Calling gst_element_link_pads_full() with @flags == %GST_PAD_LINK_CHECK_DEFAULT
is the same as calling gst_element_link_pads() and the recommended way of
linking pads with safety checks applied.

This is a convenience function for gst_pad_link_full().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads could be linked, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element or NULL for any pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element, or NULL for any pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadLinkCheck to be performed when linking pads.</doc>
            <type name="PadLinkCheck" c:type="GstPadLinkCheck"/>
          </parameter>
        </parameters>
      </method>
      <method name="lost_state" c:identifier="gst_element_lost_state">
        <doc xml:whitespace="preserve">Brings the element to the lost state. The current state of the
element is copied to the pending state so that any call to
gst_element_get_state() will return %GST_STATE_CHANGE_ASYNC.

An ASYNC_START message is posted. If the element was PLAYING, it will
go to PAUSED. The element will be restored to its PLAYING state by
the parent pipeline when it prerolls again.

This is mostly used for elements that lost their preroll buffer
in the %GST_STATE_PAUSED or %GST_STATE_PLAYING state after a flush,
they will go to their pending state again when a new preroll buffer is
queued. This function can only be called when the element is currently
not in error or an async state change.

This function is used internally and should normally not be called from
plugins or applications.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="message_full" c:identifier="gst_element_message_full">
        <doc xml:whitespace="preserve">Post an error, warning or info message on the bus from inside an element.

@type must be of #GST_MESSAGE_ERROR, #GST_MESSAGE_WARNING or
#GST_MESSAGE_INFO.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessageType</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GStreamer GError domain this message belongs to</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GError code belonging to the domain</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="text" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">an allocated text string to be used as a replacement for the default message connected to code, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">an allocated debug message to be used as a replacement for the default debugging information, or %NULL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source code file where the error was generated</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source code function where the error was generated</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="line" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source code line where the error was generated</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="no_more_pads" c:identifier="gst_element_no_more_pads">
        <doc xml:whitespace="preserve">Use this function to signal that the element does not expect any more pads
to show up in the current pipeline. This function should be called whenever
pads have been added by the element itself. Elements with #GST_PAD_SOMETIMES
pad templates use this in combination with autopluggers to figure out that
the element is done initializing its pads.

This function emits the #GstElement::no-more-pads signal.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="post_message" c:identifier="gst_element_post_message">
        <doc xml:whitespace="preserve">Post a message on the element's #GstBus. This function takes ownership of the
message; if you want to access the message after this call, you should add an
additional reference before calling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the message was successfully posted. The function returns %FALSE if the element did not have a bus.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="message" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstMessage to post</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="provide_clock" c:identifier="gst_element_provide_clock">
        <doc xml:whitespace="preserve">Get the clock provided by the given element.
&lt;note&gt;An element is only required to provide a clock in the PAUSED
state. Some elements can provide a clock in other states.&lt;/note&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the GstClock provided by the element or %NULL if no clock could be provided.  Unref after usage.  MT safe.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="query" c:identifier="gst_element_query">
        <doc xml:whitespace="preserve">Performs a query on the given element.

For elements that don't implement a query handler, this function
forwards the query to a random srcpad or to the peer of a
random linked sinkpad of this element.

Please note that some queries might need a running pipeline to work.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_convert" c:identifier="gst_element_query_convert">
        <doc xml:whitespace="preserve">Queries an element to convert @src_val in @src_format to @dest_format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstFormat to convert from.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value to convert.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat to convert to.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the result.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_duration" c:identifier="gst_element_query_duration">
        <doc xml:whitespace="preserve">Queries an element for the total stream duration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat requested</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A location in which to store the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_position" c:identifier="gst_element_query_position">
        <doc xml:whitespace="preserve">Queries an element for the stream position. If one repeatedly calls this
function one can also create and reuse it in gst_element_query().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat requested</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the current position, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release_request_pad"
              c:identifier="gst_element_release_request_pad">
        <doc xml:whitespace="preserve">Makes the element free the previously requested pad as obtained
with gst_element_get_request_pad().

This does not unref the pad. If the pad was created by using
gst_element_get_request_pad(), gst_element_release_request_pad() needs to be
followed by gst_object_unref() to free the @pad.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to release.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pad" c:identifier="gst_element_remove_pad">
        <doc xml:whitespace="preserve">Removes @pad from @element. @pad will be destroyed if it has not been
referenced elsewhere using gst_object_unparent().

This function is used by plugin developers and should not be used
by applications. Pads that were dynamically requested from elements
with gst_element_get_request_pad() should be released with the
gst_element_release_request_pad() function instead.

Pads are not automatically deactivated so elements should perform the needed
steps to deactivate the pad in case this pad is removed in the PAUSED or
PLAYING state. See gst_pad_set_active() for more information about
deactivating pads.

The pad and the element should be unlocked when calling this function.

This function will emit the #GstElement::pad-removed signal on the element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the pad could be removed. Can return %FALSE if the pad does not belong to the provided element.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstPad to remove from the element.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_pad" c:identifier="gst_element_request_pad">
        <doc xml:whitespace="preserve">Retrieves a request pad from the element according to the provided template.
Pad templates can be looked up using
gst_element_factory_get_static_pad_templates().

The pad should be released with gst_element_release_request_pad().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">requested #GstPad if found, otherwise %NULL. Release after usage.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPadTemplate of which we want a pad of.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the request #GstPad to retrieve. Can be %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the caps of the pad we want to request. Can be %NULL.</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="seek" c:identifier="gst_element_seek">
        <doc xml:whitespace="preserve">Sends a seek event to an element. See gst_event_new_seek() for the details of
the parameters. The seek event is sent to the element using
gst_element_send_event().

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the event was handled. Flushing seeks will trigger a preroll, which will emit %GST_MESSAGE_ASYNC_DONE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new playback rate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the seek values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">The optional seek flags.</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="start_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new start position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new start position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new stop position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new stop position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="seek_simple" c:identifier="gst_element_seek_simple">
        <doc xml:whitespace="preserve">Simple API to perform a seek on the given element, meaning it just seeks
to the given position relative to the start of the stream. For more complex
operations like segment seeks (e.g. for looping) or changing the playback
rate or seeking relative to the last configured playback segment you should
use gst_element_seek().

In a completely prerolled PAUSED or PLAYING pipeline, seeking is always
guaranteed to return %TRUE on a seekable media type or %FALSE when the media
type is certainly not seekable (such as a live stream).

Some elements allow for seeking in the READY state, in this
case they will store the seek event and execute it when they are put to
PAUSED. If the element supports seek in READY, it will always return %TRUE when
it receives the event in the READY state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the seek operation succeeded. Flushing seeks will trigger a preroll, which will emit %GST_MESSAGE_ASYNC_DONE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstFormat to execute the seek in, such as #GST_FORMAT_TIME</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="seek_flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">seek options; playback applications will usually want to use GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT here</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="seek_pos" transfer-ownership="none">
            <doc xml:whitespace="preserve">position to seek to (relative to the start); if you are doing a seek in #GST_FORMAT_TIME this value is in nanoseconds - multiply with #GST_SECOND to convert seconds to nanoseconds or with #GST_MSECOND to convert milliseconds to nanoseconds.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_event" c:identifier="gst_element_send_event">
        <doc xml:whitespace="preserve">Sends an event to an element. If the element doesn't implement an
event handler, the event will be pushed on a random linked sink pad for
upstream events or a random linked source pad for downstream events.

This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the event was handled. Events that trigger a preroll (such as flushing seeks and steps) will emit %GST_MESSAGE_ASYNC_DONE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the element.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_base_time" c:identifier="gst_element_set_base_time">
        <doc xml:whitespace="preserve">Set the base time of an element. See gst_element_get_base_time().

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the base time to set.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_bus" c:identifier="gst_element_set_bus">
        <doc xml:whitespace="preserve">Sets the bus of the element. Increases the refcount on the bus.
For internal use only, unless you're testing elements.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bus" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstBus to set.</doc>
            <type name="Bus" c:type="GstBus*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clock" c:identifier="gst_element_set_clock">
        <doc xml:whitespace="preserve">Sets the clock for the element. This function increases the
refcount on the clock. Any previously set clock on the object
is unreffed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the element accepted the clock. An element can refuse a clock when it, for example, is not able to slave its internal clock to the @clock or when it requires a specific clock to operate.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstClock to set for the element.</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_locked_state"
              c:identifier="gst_element_set_locked_state">
        <doc xml:whitespace="preserve">Locks the state of an element, so state changes of the parent don't affect
this element anymore.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the state was changed, FALSE if bad parameters were given or the elements state-locking needed no change.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="locked_state" transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE to lock the element's state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_start_time" c:identifier="gst_element_set_start_time">
        <doc xml:whitespace="preserve">Set the start time of an element. The start time of the element is the
running time of the element when it last went to the PAUSED state. In READY
or after a flushing seek, it is set to 0.

Toplevel elements like #GstPipeline will manage the start_time and
base_time on its children. Setting the start_time to #GST_CLOCK_TIME_NONE
on such a toplevel element will disable the distribution of the base_time to
the children and can be useful if the application manages the base_time
itself, for example if you want to synchronize capture from multiple
pipelines, and you can also ensure that the pipelines have the same clock.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the base time to set.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state" c:identifier="gst_element_set_state">
        <doc xml:whitespace="preserve">Sets the state of the element. This function will try to set the
requested state by going through all the intermediary states and calling
the class's state change function for each.

This function can return #GST_STATE_CHANGE_ASYNC, in which case the
element will perform the remainder of the state change asynchronously in
another thread.
An application can use gst_element_get_state() to wait for the completion
of the state change or it can wait for a state change message on the bus.

State changes to %GST_STATE_READY or %GST_STATE_NULL never return
#GST_STATE_CHANGE_ASYNC.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Result of the state change using #GstStateChangeReturn.  MT safe.</doc>
          <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the element's new #GstState.</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync_state_with_parent"
              c:identifier="gst_element_sync_state_with_parent">
        <doc xml:whitespace="preserve">Tries to change the state of the element to the same as its parent.
If this function returns FALSE, the state of element is undefined.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if the element's state could be synced to the parent's state.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="unlink" c:identifier="gst_element_unlink">
        <doc xml:whitespace="preserve">Unlinks all source pads of the source element with all sink pads
of the sink element to which they are linked.

If the link has been made using gst_element_link(), it could have created an
requestpad, which has to be released using gst_element_release_request_pad().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstElement to unlink.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlink_many"
              c:identifier="gst_element_unlink_many"
              introspectable="0">
        <doc xml:whitespace="preserve">Unlinks a series of elements. Uses gst_element_unlink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="element_2" transfer-ownership="none">
            <doc xml:whitespace="preserve">the second #GstElement in the link chain.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="unlink_pads" c:identifier="gst_element_unlink_pads">
        <doc xml:whitespace="preserve">Unlinks the two named pads of the source and destination elements.

This is a convenience function for gst_pad_unlink().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="srcpadname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the #GstPad in source element.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstElement containing the destination pad.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="destpadname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the #GstPad in destination element.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="state_lock">
        <type name="GLib.RecMutex" c:type="GRecMutex"/>
      </field>
      <field name="state_cond">
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <field name="state_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="target_state">
        <type name="State" c:type="GstState"/>
      </field>
      <field name="current_state">
        <type name="State" c:type="GstState"/>
      </field>
      <field name="next_state">
        <type name="State" c:type="GstState"/>
      </field>
      <field name="pending_state">
        <type name="State" c:type="GstState"/>
      </field>
      <field name="last_return">
        <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
      </field>
      <field name="bus">
        <type name="Bus" c:type="GstBus*"/>
      </field>
      <field name="clock">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="base_time">
        <type name="ClockTimeDiff" c:type="GstClockTimeDiff"/>
      </field>
      <field name="start_time">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="numpads">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="pads">
        <type name="GLib.List" c:type="GList*">
          <type name="Pad"/>
        </type>
      </field>
      <field name="numsrcpads">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="srcpads">
        <type name="GLib.List" c:type="GList*">
          <type name="Pad"/>
        </type>
      </field>
      <field name="numsinkpads">
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="sinkpads">
        <type name="GLib.List" c:type="GList*">
          <type name="Pad"/>
        </type>
      </field>
      <field name="pads_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="no-more-pads" when="last">
        <doc xml:whitespace="preserve">This signals that the element will not generate more dynamic pads.
Note that this signal will usually be emitted from the context of
the streaming thread.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
      </glib:signal>
      <glib:signal name="pad-added" when="last">
        <doc xml:whitespace="preserve">a new #GstPad has been added to the element. Note that this signal will
usually be emitted from the context of the streaming thread. Also keep in
mind that if you add new elements to the pipeline in the signal handler
you will need to set them to the desired target state with
gst_element_set_state() or gst_element_sync_state_with_parent().</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="new_pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad that has been added</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="pad-removed" when="last">
        <doc xml:whitespace="preserve">a #GstPad has been removed from the element</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="old_pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad that has been removed</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ElementClass"
            c:type="GstElementClass"
            glib:is-gtype-struct-for="Element">
      <doc xml:whitespace="preserve">GStreamer element class. Override the vmethods to implement the element
functionality.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="metadata">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="elementfactory">
        <type name="ElementFactory" c:type="GstElementFactory*"/>
      </field>
      <field name="padtemplates">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="numpadtemplates">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="pad_templ_cookie">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="pad_added">
        <callback name="pad_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pad_removed">
        <callback name="pad_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="no_more_pads">
        <callback name="no_more_pads">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="request_new_pad" introspectable="0">
        <callback name="request_new_pad" introspectable="0">
          <return-value>
            <type name="Pad" c:type="GstPad*"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="templ" transfer-ownership="none">
              <type name="PadTemplate" c:type="GstPadTemplate*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Caps" c:type="const GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release_pad">
        <callback name="release_pad">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_state">
        <callback name="get_state">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%GST_STATE_CHANGE_SUCCESS if the element has no more pending state and the last state change succeeded, %GST_STATE_CHANGE_ASYNC if the element is still performing a state change or %GST_STATE_CHANGE_FAILURE if the last state change failed.  MT safe.</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="state"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       allow-none="1">
              <doc xml:whitespace="preserve">a pointer to #GstState to hold the state. Can be %NULL.</doc>
              <type name="State" c:type="GstState*"/>
            </parameter>
            <parameter name="pending"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       allow-none="1">
              <doc xml:whitespace="preserve">a pointer to #GstState to hold the pending state. Can be %NULL.</doc>
              <type name="State" c:type="GstState*"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <doc xml:whitespace="preserve">a #GstClockTime to specify the timeout for an async state change or %GST_CLOCK_TIME_NONE for infinite timeout.</doc>
              <type name="ClockTime" c:type="GstClockTime"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_state">
        <callback name="set_state">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">Result of the state change using #GstStateChangeReturn.  MT safe.</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="state" transfer-ownership="none">
              <doc xml:whitespace="preserve">the element's new #GstState.</doc>
              <type name="State" c:type="GstState"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="change_state">
        <callback name="change_state">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstStateChangeReturn of the state transition.</doc>
            <type name="StateChangeReturn" c:type="GstStateChangeReturn"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="transition" transfer-ownership="none">
              <doc xml:whitespace="preserve">the requested transition</doc>
              <type name="StateChange" c:type="GstStateChange"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="state_changed">
        <callback name="state_changed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="oldstate" transfer-ownership="none">
              <type name="State" c:type="GstState"/>
            </parameter>
            <parameter name="newstate" transfer-ownership="none">
              <type name="State" c:type="GstState"/>
            </parameter>
            <parameter name="pending" transfer-ownership="none">
              <type name="State" c:type="GstState"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_bus">
        <callback name="set_bus">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="bus" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstBus to set.</doc>
              <type name="Bus" c:type="GstBus*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="provide_clock">
        <callback name="provide_clock">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the GstClock provided by the element or %NULL if no clock could be provided.  Unref after usage.  MT safe.</doc>
            <type name="Clock" c:type="GstClock*"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_clock">
        <callback name="set_clock">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the element accepted the clock. An element can refuse a clock when it, for example, is not able to slave its internal clock to the @clock or when it requires a specific clock to operate.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="clock" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstClock to set for the element.</doc>
              <type name="Clock" c:type="GstClock*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="send_event">
        <callback name="send_event">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the event was handled. Events that trigger a preroll (such as flushing seeks and steps) will emit %GST_MESSAGE_ASYNC_DONE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="event" transfer-ownership="full">
              <doc xml:whitespace="preserve">the #GstEvent to send to the element.</doc>
              <type name="Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query">
        <callback name="query">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the query could be performed.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstQuery.</doc>
              <type name="Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="post_message">
        <callback name="post_message">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE if the message was successfully posted. The function returns %FALSE if the element did not have a bus.  MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="element" transfer-ownership="none">
              <type name="Element" c:type="GstElement*"/>
            </parameter>
            <parameter name="message" transfer-ownership="full">
              <doc xml:whitespace="preserve">a #GstMessage to post</doc>
              <type name="Message" c:type="GstMessage*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="19">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="add_metadata"
              c:identifier="gst_element_class_add_metadata">
        <doc xml:whitespace="preserve">Set @key with @value as metadata in @klass.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_pad_template"
              c:identifier="gst_element_class_add_pad_template">
        <doc xml:whitespace="preserve">Adds a padtemplate to an element class. This is mainly used in the _class_init
functions of classes. If a pad template with the same name as an already
existing one is added the old one is replaced by the new one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="full">
            <doc xml:whitespace="preserve">a #GstPadTemplate to add to the element class.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_static_metadata"
              c:identifier="gst_element_class_add_static_metadata">
        <doc xml:whitespace="preserve">Set @key with @value as metadata in @klass.

Same as gst_element_class_add_metadata(), but @value must be a static string
or an inlined string, as it will not be copied. (GStreamer plugins will
be made resident once loaded, so this function can be used even from
dynamically loaded plugins.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_metadata"
              c:identifier="gst_element_class_get_metadata">
        <doc xml:whitespace="preserve">Get metadata with @key in @klass.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the metadata for @key.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the key to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pad_template"
              c:identifier="gst_element_class_get_pad_template">
        <doc xml:whitespace="preserve">Retrieves a padtemplate from @element_class with the given name.
&lt;note&gt;If you use this function in the #GInstanceInitFunc of an object class
that has subclasses, make sure to pass the g_class parameter of the
#GInstanceInitFunc here.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPadTemplate with the given name, or %NULL if none was found. No unreferencing is necessary.</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the #GstPadTemplate to get.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pad_template_list"
              c:identifier="gst_element_class_get_pad_template_list">
        <doc xml:whitespace="preserve">Retrieves a list of the pad templates associated with @element_class. The
list must not be modified by the calling code.
&lt;note&gt;If you use this function in the #GInstanceInitFunc of an object class
that has subclasses, make sure to pass the g_class parameter of the
#GInstanceInitFunc here.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GList of pad templates.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PadTemplate"/>
          </type>
        </return-value>
      </method>
      <method name="set_metadata"
              c:identifier="gst_element_class_set_metadata">
        <doc xml:whitespace="preserve">Sets the detailed information for a #GstElementClass.
&lt;note&gt;This function is for use in _class_init functions only.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="longname" transfer-ownership="none">
            <doc xml:whitespace="preserve">The long English name of the element. E.g. "File Sink"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="classification" transfer-ownership="none">
            <doc xml:whitespace="preserve">String describing the type of element, as an unordered list separated with slashes ('/'). See draft-klass.txt of the design docs for more details and common types. E.g: "Sink/File"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">Sentence describing the purpose of the element. E.g: "Write stream to a file"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="author" transfer-ownership="none">
            <doc xml:whitespace="preserve">Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &amp;lt;joe.blogs at foo.com&amp;gt;"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static_metadata"
              c:identifier="gst_element_class_set_static_metadata">
        <doc xml:whitespace="preserve">Sets the detailed information for a #GstElementClass.
&lt;note&gt;This function is for use in _class_init functions only.&lt;/note&gt;

Same as gst_element_class_set_metadata(), but @longname, @classification,
@description, and @author must be static strings or inlined strings, as
they will not be copied. (GStreamer plugins will be made resident once
loaded, so this function can be used even from dynamically loaded plugins.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="longname" transfer-ownership="none">
            <doc xml:whitespace="preserve">The long English name of the element. E.g. "File Sink"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="classification" transfer-ownership="none">
            <doc xml:whitespace="preserve">String describing the type of element, as an unordered list separated with slashes ('/'). See draft-klass.txt of the design docs for more details and common types. E.g: "Sink/File"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">Sentence describing the purpose of the element. E.g: "Write stream to a file"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="author" transfer-ownership="none">
            <doc xml:whitespace="preserve">Name and contact details of the author(s). Use \n to separate multiple author metadata. E.g: "Joe Bloggs &amp;lt;joe.blogs at foo.com&amp;gt;"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="ElementFactory"
           c:symbol-prefix="element_factory"
           c:type="GstElementFactory"
           parent="PluginFeature"
           glib:type-name="GstElementFactory"
           glib:get-type="gst_element_factory_get_type"
           glib:type-struct="ElementFactoryClass">
      <doc xml:whitespace="preserve">#GstElementFactory is used to create instances of elements. A
GstElementfactory can be added to a #GstPlugin as it is also a
#GstPluginFeature.

Use the gst_element_factory_find() and gst_element_factory_create()
functions to create element instances or use gst_element_factory_make() as a
convenient shortcut.

The following code example shows you how to create a GstFileSrc element.

&lt;example&gt;
&lt;title&gt;Using an element factory&lt;/title&gt;
&lt;programlisting language="c"&gt;
  #include &amp;lt;gst/gst.h&amp;gt;

  GstElement *src;
  GstElementFactory *srcfactory;

  gst_init (&amp;amp;argc, &amp;amp;argv);

  srcfactory = gst_element_factory_find ("filesrc");
  g_return_if_fail (srcfactory != NULL);
  src = gst_element_factory_create (srcfactory, "src");
  g_return_if_fail (src != NULL);
  ...
&lt;/programlisting&gt;
&lt;/example&gt;

Last reviewed on 2005-11-23 (0.9.5)</doc>
      <function name="find" c:identifier="gst_element_factory_find">
        <doc xml:whitespace="preserve">Search for an element factory of the given name. Refs the returned
element factory; caller is responsible for unreffing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">#GstElementFactory if found, NULL otherwise</doc>
          <type name="ElementFactory" c:type="GstElementFactory*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of factory to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_filter"
                c:identifier="gst_element_factory_list_filter">
        <doc xml:whitespace="preserve">Filter out all the elementfactories in @list that can handle @caps in
the given direction.

If @subsetonly is %TRUE, then only the elements whose pads templates
are a complete superset of @caps will be returned. Else any element
whose pad templates caps can intersect with @caps will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstElementFactory elements that match the given requisits. Use #gst_plugin_feature_list_free after usage.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ElementFactory"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of #GstElementFactory to filter</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="ElementFactory"/>
            </type>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPadDirection to filter on</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="subsetonly" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether to filter on caps subsets or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_get_elements"
                c:identifier="gst_element_factory_list_get_elements">
        <doc xml:whitespace="preserve">Get a list of factories that match the given @type. Only elements
with a rank greater or equal to @minrank will be returned.
The list of factories is returned by decreasing rank.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstElementFactory elements. Use gst_plugin_feature_list_free() after usage.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="ElementFactory"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstElementFactoryListType</doc>
            <type name="ElementFactoryListType"
                  c:type="GstElementFactoryListType"/>
          </parameter>
          <parameter name="minrank" transfer-ownership="none">
            <doc xml:whitespace="preserve">Minimum rank</doc>
            <type name="Rank" c:type="GstRank"/>
          </parameter>
        </parameters>
      </function>
      <function name="make" c:identifier="gst_element_factory_make">
        <doc xml:whitespace="preserve">Create a new element of the type defined by the given element factory.
If name is NULL, then the element will receive a guaranteed unique name,
consisting of the element factory name and a number.
If name is given, it will be given the name supplied.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">new #GstElement or NULL if unable to create element</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="factoryname" transfer-ownership="none">
            <doc xml:whitespace="preserve">a named factory to instantiate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">name of new element, or NULL to automatically create a unique name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="can_sink_all_caps"
              c:identifier="gst_element_factory_can_sink_all_caps">
        <doc xml:whitespace="preserve">Checks if the factory can sink all possible capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps are fully compatible.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_sink_any_caps"
              c:identifier="gst_element_factory_can_sink_any_caps">
        <doc xml:whitespace="preserve">Checks if the factory can sink any possible capability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps have a common subset.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_src_all_caps"
              c:identifier="gst_element_factory_can_src_all_caps">
        <doc xml:whitespace="preserve">Checks if the factory can src all possible capabilities.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps are fully compatible.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_src_any_caps"
              c:identifier="gst_element_factory_can_src_any_caps">
        <doc xml:whitespace="preserve">Checks if the factory can src any possible capability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the caps have a common subset.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the caps to check</doc>
            <type name="Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create" c:identifier="gst_element_factory_create">
        <doc xml:whitespace="preserve">Create a new element of the type defined by the given elementfactory.
It will be given the name supplied, since all elements require a name as
their first argument.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">new #GstElement or NULL if the element couldn't be created</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">name of new element, or NULL to automatically create a unique name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_element_type"
              c:identifier="gst_element_factory_get_element_type">
        <doc xml:whitespace="preserve">Get the #GType for elements managed by this factory. The type can
only be retrieved if the element factory is loaded, which can be
assured with gst_plugin_feature_load().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GType for elements managed by this factory or 0 if the factory is not loaded.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
      </method>
      <method name="get_metadata"
              c:identifier="gst_element_factory_get_metadata">
        <doc xml:whitespace="preserve">Get the metadata on @factory with @key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the metadata with @key on @factory or %NULL when there was no metadata with the given @key.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="key" transfer-ownership="none">
            <doc xml:whitespace="preserve">a key</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_metadata_keys"
              c:identifier="gst_element_factory_get_metadata_keys">
        <doc xml:whitespace="preserve">Get the available keys for the metadata on @factory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a %NULL-terminated array of key strings, or %NULL when there is no metadata. Free with g_strfreev() when no longer needed.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_num_pad_templates"
              c:identifier="gst_element_factory_get_num_pad_templates">
        <doc xml:whitespace="preserve">Gets the number of pad_templates in this factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of pad_templates</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_static_pad_templates"
              c:identifier="gst_element_factory_get_static_pad_templates">
        <doc xml:whitespace="preserve">Gets the #GList of #GstStaticPadTemplate for this factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the static pad templates</doc>
          <type name="GLib.List" c:type="const GList*">
            <type name="StaticPadTemplate"/>
          </type>
        </return-value>
      </method>
      <method name="get_uri_protocols"
              c:identifier="gst_element_factory_get_uri_protocols">
        <doc xml:whitespace="preserve">Gets a NULL-terminated array of protocols this element supports or NULL if
no protocols are supported. You may not change the contents of the returned
array, as it is still owned by the element factory. Use g_strdupv() to
make a copy of the protocol string array if you need to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the supported protocols or NULL</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_uri_type"
              c:identifier="gst_element_factory_get_uri_type">
        <doc xml:whitespace="preserve">Gets the type of URIs the element supports or #GST_URI_UNKNOWN if none.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">type of URIs this element supports</doc>
          <type name="URIType" c:type="GstURIType"/>
        </return-value>
      </method>
      <method name="has_interface"
              c:identifier="gst_element_factory_has_interface">
        <doc xml:whitespace="preserve">Check if @factory implements the interface with name @interfacename.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE when @factory implement the interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="interfacename" transfer-ownership="none">
            <doc xml:whitespace="preserve">an interface name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_is_type"
              c:identifier="gst_element_factory_list_is_type">
        <doc xml:whitespace="preserve">Check if @factory is of the given types.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @factory is of @type.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstElementFactoryListType</doc>
            <type name="ElementFactoryListType"
                  c:type="GstElementFactoryListType"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="ElementFactoryClass"
            c:type="GstElementFactoryClass"
            disguised="1"
            glib:is-gtype-struct-for="ElementFactory">
    </record>
    <bitfield name="ElementFlags" c:type="GstElementFlags">
      <doc xml:whitespace="preserve">The standard flags that an element may have.</doc>
      <member name="locked_state"
              value="16"
              c:identifier="GST_ELEMENT_FLAG_LOCKED_STATE">
        <doc xml:whitespace="preserve">ignore state changes from parent</doc>
      </member>
      <member name="sink" value="32" c:identifier="GST_ELEMENT_FLAG_SINK">
        <doc xml:whitespace="preserve">the element is a sink</doc>
      </member>
      <member name="source" value="64" c:identifier="GST_ELEMENT_FLAG_SOURCE">
        <doc xml:whitespace="preserve">the element is a source.</doc>
      </member>
      <member name="provide_clock"
              value="128"
              c:identifier="GST_ELEMENT_FLAG_PROVIDE_CLOCK">
        <doc xml:whitespace="preserve">the element can provide a clock</doc>
      </member>
      <member name="require_clock"
              value="256"
              c:identifier="GST_ELEMENT_FLAG_REQUIRE_CLOCK">
        <doc xml:whitespace="preserve">the element requires a clock</doc>
      </member>
      <member name="indexable"
              value="512"
              c:identifier="GST_ELEMENT_FLAG_INDEXABLE">
        <doc xml:whitespace="preserve">the element can use an index</doc>
      </member>
      <member name="last" value="16384" c:identifier="GST_ELEMENT_FLAG_LAST">
        <doc xml:whitespace="preserve">offset to define more flags</doc>
      </member>
    </bitfield>
    <record name="Event"
            c:type="GstEvent"
            glib:type-name="GstEvent"
            glib:get-type="gst_event_get_type"
            c:symbol-prefix="event">
      <doc xml:whitespace="preserve">The event class provides factory methods to construct events for sending
and functions to query (parse) received events.

Events are usually created with gst_event_new_*() which takes event-type
specific parameters as arguments.
To send an event application will usually use gst_element_send_event() and
elements will use gst_pad_send_event() or gst_pad_push_event().
The event should be unreffed with gst_event_unref() if it has not been sent.

Events that have been received can be parsed with their respective
gst_event_parse_*() functions. It is valid to pass %NULL for unwanted details.

Events are passed between elements in parallel to the data stream. Some events
are serialized with buffers, others are not. Some events only travel downstream,
others only upstream. Some events can travel both upstream and downstream.

The events are used to signal special conditions in the datastream such as
EOS (end of stream) or the start of a new stream-segment.
Events are also used to flush the pipeline of any pending data.

Most of the event API is used inside plugins. Applications usually only
construct and use seek events.
To do that gst_event_new_seek() is used to create a seek event. It takes
the needed parameters to specify seeking time and mode.
&lt;example&gt;
&lt;title&gt;performing a seek on a pipeline&lt;/title&gt;
  &lt;programlisting&gt;
  GstEvent *event;
  gboolean result;
  ...
  // construct a seek event to play the media from second 2 to 5, flush
  // the pipeline to decrease latency.
  event = gst_event_new_seek (1.0, 
     GST_FORMAT_TIME, 
     GST_SEEK_FLAG_FLUSH,
     GST_SEEK_TYPE_SET, 2 * GST_SECOND,
     GST_SEEK_TYPE_SET, 5 * GST_SECOND);
  ...
  result = gst_element_send_event (pipeline, event);
  if (!result)
    g_warning ("seek failed");
  ...
  &lt;/programlisting&gt;
&lt;/example&gt;

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <field name="mini_object" writable="1">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="type" writable="1">
        <type name="EventType" c:type="GstEventType"/>
      </field>
      <field name="timestamp" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="seqnum" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <constructor name="new_buffer_size"
                   c:identifier="gst_event_new_buffer_size">
        <doc xml:whitespace="preserve">Create a new buffersize event. The event is sent downstream and notifies
elements that they should provide a buffer of the specified dimensions.

When the @async flag is set, a thread boundary is preferred.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">buffer format</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="minsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum buffer size</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="maxsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">maximum buffer size</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="async" transfer-ownership="none">
            <doc xml:whitespace="preserve">thread behavior</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_caps" c:identifier="gst_event_new_caps">
        <doc xml:whitespace="preserve">Create a new CAPS event for @caps. The caps event can only travel downstream
synchronized with the buffer flow and contains the format of the buffers
that will follow after the event.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new CAPS event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_custom" c:identifier="gst_event_new_custom">
        <doc xml:whitespace="preserve">Create a new custom-typed event. This can be used for anything not
handled by other event-specific functions to pass an event to another
element.

Make sure to allocate an event type with the #GST_EVENT_MAKE_TYPE macro,
assigning a free number and filling in the correct direction and
serialization flags.

New custom events can also be created by subclassing the event type if
needed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new custom event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of the new event</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the structure for the event. The event will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_eos" c:identifier="gst_event_new_eos">
        <doc xml:whitespace="preserve">Create a new EOS event. The eos event can only travel downstream
synchronized with the buffer flow. Elements that receive the EOS
event on a pad can return #GST_FLOW_EOS as a #GstFlowReturn
when data after the EOS event arrives.

The EOS event will travel down to the sink elements in the pipeline
which will then post the #GST_MESSAGE_EOS on the bus after they have
finished playing any buffered data.

When all sinks have posted an EOS message, an EOS message is
forwarded to the application.

The EOS event itself will not cause any state transitions of the pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new EOS event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
      </constructor>
      <constructor name="new_flush_start"
                   c:identifier="gst_event_new_flush_start">
        <doc xml:whitespace="preserve">Allocate a new flush start event. The flush start event can be sent
upstream and downstream and travels out-of-bounds with the dataflow.

It marks pads as being flushing and will make them return
#GST_FLOW_FLUSHING when used for data flow with gst_pad_push(),
gst_pad_chain(), gst_pad_get_range() and gst_pad_pull_range().
Any event (except a #GST_EVENT_FLUSH_STOP) received
on a flushing pad will return %FALSE immediately.

Elements should unlock any blocking functions and exit their streaming
functions as fast as possible when this event is received.

This event is typically generated after a seek to flush out all queued data
in the pipeline so that the new media is played as soon as possible.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new flush start event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
      </constructor>
      <constructor name="new_flush_stop"
                   c:identifier="gst_event_new_flush_stop">
        <doc xml:whitespace="preserve">Allocate a new flush stop event. The flush stop event can be sent
upstream and downstream and travels serialized with the dataflow.
It is typically sent after sending a FLUSH_START event to make the
pads accept data again.

Elements can process this event synchronized with the dataflow since
the preceeding FLUSH_START event stopped the dataflow.

This event is typically generated to complete a seek and to resume
dataflow.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new flush stop event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="reset_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">if time should be reset</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_gap" c:identifier="gst_event_new_gap">
        <doc xml:whitespace="preserve">Create a new GAP event. A gap event can be thought of as conceptually
equivalent to a buffer to signal that there is no data for a certain
amount of time. This is useful to signal a gap to downstream elements
which may wait for data, such as muxers or mixers or overlays, especially
for sparse streams such as subtitle streams.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new GAP event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start time (pts) of the gap</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the gap</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_latency" c:identifier="gst_event_new_latency">
        <doc xml:whitespace="preserve">Create a new latency event. The event is sent upstream from the sinks and
notifies elements that they should add an additional @latency to the
running time before synchronising against the clock.

The latency is mostly used in live sinks and is always expressed in
the time format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="latency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new latency value</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_navigation"
                   c:identifier="gst_event_new_navigation">
        <doc xml:whitespace="preserve">Create a new navigation event from the given description.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">description of the event. The event will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_qos" c:identifier="gst_event_new_qos">
        <doc xml:whitespace="preserve">Allocate a new qos event with the given values.
The QOS event is generated in an element that wants an upstream
element to either reduce or increase its rate because of
high/low CPU load or other resource usage such as network performance or
throttling. Typically sinks generate these events for each buffer
they receive.

@type indicates the reason for the QoS event. #GST_QOS_TYPE_OVERFLOW is
used when a buffer arrived in time or when the sink cannot keep up with
the upstream datarate. #GST_QOS_TYPE_UNDERFLOW is when the sink is not
receiving buffers fast enough and thus has to drop late buffers. 
#GST_QOS_TYPE_THROTTLE is used when the datarate is artificially limited
by the application, for example to reduce power consumption.

@proportion indicates the real-time performance of the streaming in the
element that generated the QoS event (usually the sink). The value is
generally computed based on more long term statistics about the streams
timestamps compared to the clock.
A value &lt; 1.0 indicates that the upstream element is producing data faster
than real-time. A value &gt; 1.0 indicates that the upstream element is not
producing data fast enough. 1.0 is the ideal @proportion value. The
proportion value can safely be used to lower or increase the quality of
the element.

@diff is the difference against the clock in running time of the last
buffer that caused the element to generate the QOS event. A negative value
means that the buffer with @timestamp arrived in time. A positive value
indicates how late the buffer with @timestamp was. When throttling is
enabled, @diff will be set to the requested throttling interval.

@timestamp is the timestamp of the last buffer that cause the element
to generate the QOS event. It is expressed in running time and thus an ever
increasing value.

The upstream element can use the @diff and @timestamp values to decide
whether to process more buffers. For possitive @diff, all buffers with
timestamp &lt;= @timestamp + @diff will certainly arrive late in the sink
as well. A (negative) @diff value so that @timestamp + @diff would yield a
result smaller than 0 is not allowed.

The application can use general event probes to intercept the QoS
event and implement custom application specific QoS handling.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new QOS event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the QoS type</doc>
            <type name="QOSType" c:type="GstQOSType"/>
          </parameter>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:whitespace="preserve">the proportion of the qos message</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="diff" transfer-ownership="none">
            <doc xml:whitespace="preserve">The time difference of the last Clock sync</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">The timestamp of the buffer</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_reconfigure"
                   c:identifier="gst_event_new_reconfigure">
        <doc xml:whitespace="preserve">Create a new reconfigure event. The purpose of the reconfingure event is
to travel upstream and make elements renegotiate their caps or reconfigure
their buffer pools. This is useful when changing properties on elements
or changing the topology of the pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
      </constructor>
      <constructor name="new_seek" c:identifier="gst_event_new_seek">
        <doc xml:whitespace="preserve">Allocate a new seek event with the given parameters.

The seek event configures playback of the pipeline between @start to @stop
at the speed given in @rate, also called a playback segment.
The @start and @stop values are expressed in @format.

A @rate of 1.0 means normal playback rate, 2.0 means double speed.
Negatives values means backwards playback. A value of 0.0 for the
rate is not allowed and should be accomplished instead by PAUSING the
pipeline.

A pipeline has a default playback segment configured with a start
position of 0, a stop position of -1 and a rate of 1.0. The currently
configured playback segment can be queried with #GST_QUERY_SEGMENT. 

@start_type and @stop_type specify how to adjust the currently configured 
start and stop fields in playback segment. Adjustments can be made relative
or absolute to the last configured values. A type of #GST_SEEK_TYPE_NONE
means that the position should not be updated.

When the rate is positive and @start has been updated, playback will start
from the newly configured start position. 

For negative rates, playback will start from the newly configured stop
position (if any). If the stop position is updated, it must be different from
-1 (#GST_CLOCK_TIME_NONE) for negative rates.

It is not possible to seek relative to the current playback position, to do
this, PAUSE the pipeline, query the current playback position with
#GST_QUERY_POSITION and update the playback segment current position with a
#GST_SEEK_TYPE_SET to the desired position.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new seek event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new playback rate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the seek values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">The optional seek flags</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="start_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new start position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new start position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type and flags for the new stop position</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the new stop position</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment" c:identifier="gst_event_new_segment">
        <doc xml:whitespace="preserve">Create a new SEGMENT event for @segment. The segment event can only travel
downstream synchronized with the buffer flow and contains timing information
and playback properties for the buffers that will follow.

The newsegment event marks the range of buffers to be processed. All
data not within the segment range is not to be processed. This can be
used intelligently by plugins to apply more efficient methods of skipping
unneeded data. The valid range is expressed with the @start and @stop
values.

The time value of the segment is used in conjunction with the start
value to convert the buffer timestamps into the stream time. This is
usually done in sinks to report the current stream_time.
@time represents the stream_time of a buffer carrying a timestamp of
@start. @time cannot be -1.

@start cannot be -1, @stop can be -1. If there
is a valid @stop given, it must be greater or equal the @start, including
when the indicated playback @rate is &lt; 0.

The @applied_rate value provides information about any rate adjustment that
has already been made to the timestamps and content on the buffers of the
stream. (@rate * @applied_rate) should always equal the rate that has been
requested for playback. For example, if an element has an input segment
with intended playback @rate of 2.0 and applied_rate of 1.0, it can adjust
incoming timestamps and buffer content by half and output a newsegment event
with @rate of 1.0 and @applied_rate of 2.0

After a newsegment event, the buffer stream time is calculated with:

  time + (TIMESTAMP(buf) - start) * ABS (rate * applied_rate)</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new SEGMENT event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstSegment</doc>
            <type name="Segment" c:type="const GstSegment*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment_done"
                   c:identifier="gst_event_new_segment_done">
        <doc xml:whitespace="preserve">Create a new segment-done event. This event is sent by elements that
finish playback of a segment as a result of a segment seek.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the position being done</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">The position of the segment being done</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_sink_message"
                   c:identifier="gst_event_new_sink_message">
        <doc xml:whitespace="preserve">Create a new sink-message event. The purpose of the sink-message event is
to instruct a sink to post the message contained in the event synchronized
with the stream.

@name is used to store multiple sticky events on one pad.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a name for the event</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="msg" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstMessage to be posted</doc>
            <type name="Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_step" c:identifier="gst_event_new_step">
        <doc xml:whitespace="preserve">Create a new step event. The purpose of the step event is to instruct a sink
to skip @amount (expressed in @format) of media. It can be used to implement
stepping through the video frame by frame or for doing fast trick modes.

A rate of &lt;= 0.0 is not allowed. Pause the pipeline, for the effect of rate
= 0.0 or first reverse the direction of playback using a seek event to get
the same effect as rate &lt; 0.0.

The @flush flag will clear any pending data in the pipeline before starting
the step operation.

The @intermediate flag instructs the pipeline that this step operation is
part of a larger step operation.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of @amount</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="amount" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount of data to step</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the step rate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">flushing steps</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="intermediate" transfer-ownership="none">
            <doc xml:whitespace="preserve">intermediate steps</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_stream_start"
                   c:identifier="gst_event_new_stream_start">
        <doc xml:whitespace="preserve">Create a new STREAM_START event. The stream start event can only
travel downstream synchronized with the buffer flow. It is expected
to be the first event that is sent for a new stream.

Source elements, demuxers and other elements that create new streams
are supposed to send this event as the first event of a new stream. It
should not be send after a flushing seek or in similar situations
and is used to mark the beginning of a new logical stream. Elements
combining multiple streams must ensure that this event is only forwarded
downstream once and not for every single input stream.

The @stream_id should be a unique string that consists of the upstream
stream-id, / as separator and a unique stream-id for this specific
stream. A new stream-id should only be created for a stream if the upstream
stream is split into (potentially) multiple new streams, e.g. in a demuxer,
but not for every single element in the pipeline.
gst_pad_create_stream_id() or gst_pad_create_stream_id_printf() can be
used to create a stream-id.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new STREAM_START event.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="stream_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">Identifier for this stream</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_tag" c:identifier="gst_event_new_tag">
        <doc xml:whitespace="preserve">Generates a metadata tag event from the given @taglist.

The scope of the taglist specifies if the taglist applies to the
complete medium or only to this specific stream. As the tag event
is a sticky event, elements should merge tags received from
upstream with a given scope with their own tags with the same
scope and create a new tag event from it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="taglist" transfer-ownership="full">
            <doc xml:whitespace="preserve">metadata list. The event will take ownership of the taglist.</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_toc" c:identifier="gst_event_new_toc">
        <doc xml:whitespace="preserve">Generate a TOC event from the given @toc. The purpose of the TOC event is to
inform elements that some kind of the TOC was found.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="toc" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstToc structure.</doc>
            <type name="Toc" c:type="GstToc*"/>
          </parameter>
          <parameter name="updated" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether @toc was updated or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_toc_select"
                   c:identifier="gst_event_new_toc_select">
        <doc xml:whitespace="preserve">Generate a TOC select event with the given @uid. The purpose of the
TOC select event is to start playback based on the TOC's entry with the
given @uid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstEvent.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:whitespace="preserve">UID in the TOC to start playback from.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy_segment" c:identifier="gst_event_copy_segment">
        <doc xml:whitespace="preserve">Parses a segment @event and copies the #GstSegment into the location
given by @segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a #GstSegment</doc>
            <type name="Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_seqnum" c:identifier="gst_event_get_seqnum">
        <doc xml:whitespace="preserve">Retrieve the sequence number of a event.

Events have ever-incrementing sequence numbers, which may also be set
explicitly via gst_event_set_seqnum(). Sequence numbers are typically used to
indicate that a event corresponds to some other set of events or messages,
for example an EOS event corresponding to a SEEK event. It is considered good
practice to make this correspondence when possible, though it is not
required.

Note that events and messages share the same sequence number incrementor;
two events or messages will never have the same sequence number unless
that correspondence was made explicitly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The event's sequence number.  MT safe.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_event_get_structure">
        <doc xml:whitespace="preserve">Access the structure of the event.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The structure of the event. The structure is still owned by the event, which means that you should not free it and that the pointer becomes invalid when you free the event.  MT safe.</doc>
          <type name="Structure" c:type="const GstStructure*"/>
        </return-value>
      </method>
      <method name="has_name" c:identifier="gst_event_has_name">
        <doc xml:whitespace="preserve">Checks if @event has the given @name. This function is usually used to
check the name of a custom event.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name matches the name of the event structure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name to check</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffer_size"
              c:identifier="gst_event_parse_buffer_size">
        <doc xml:whitespace="preserve">Get the format, minsize, maxsize and async-flag in the buffersize event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the format in</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="minsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the minsize in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="maxsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the maxsize in</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="async"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the async-flag in</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_caps" c:identifier="gst_event_parse_caps">
        <doc xml:whitespace="preserve">Get the caps from @event. The caps remains valid as long as @event remains
valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the caps</doc>
            <type name="Caps" c:type="GstCaps**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_flush_stop"
              c:identifier="gst_event_parse_flush_stop">
        <doc xml:whitespace="preserve">Parse the FLUSH_STOP event and retrieve the @reset_time member.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="reset_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">if time should be reset</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_gap" c:identifier="gst_event_parse_gap">
        <doc xml:whitespace="preserve">Extract timestamp and duration from a new GAP event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location where to store the start time (pts) of the gap, or %NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location where to store the duration of the gap, or %NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_latency" c:identifier="gst_event_parse_latency">
        <doc xml:whitespace="preserve">Get the latency in the latency event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the latency in.</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos" c:identifier="gst_event_parse_qos">
        <doc xml:whitespace="preserve">Get the type, proportion, diff and timestamp in the qos event. See
gst_event_new_qos() for more information about the different QoS values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the QoS type in</doc>
            <type name="QOSType" c:type="GstQOSType*"/>
          </parameter>
          <parameter name="proportion"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the proportion in</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="diff"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the diff in</doc>
            <type name="ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
          <parameter name="timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to store the timestamp in</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_seek" c:identifier="gst_event_parse_seek">
        <doc xml:whitespace="preserve">Parses a seek @event and stores the results in the given result locations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the rate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the stream format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the #GstSeekFlags</doc>
            <type name="SeekFlags" c:type="GstSeekFlags*"/>
          </parameter>
          <parameter name="start_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the #GstSeekType of the start position</doc>
            <type name="SeekType" c:type="GstSeekType*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the start postion expressed in @format</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the #GstSeekType of the stop position</doc>
            <type name="SeekType" c:type="GstSeekType*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">result location for the stop postion expressed in @format</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment" c:identifier="gst_event_parse_segment">
        <doc xml:whitespace="preserve">Parses a segment @event and stores the result in the given @segment location.
@segment remains valid only until the @event is freed. Don't modify the segment
and make a copy if you want to modify it or store it for later use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="segment"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a #GstSegment</doc>
            <type name="Segment" c:type="const GstSegment**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment_done"
              c:identifier="gst_event_parse_segment_done">
        <doc xml:whitespace="preserve">Extracts the position and format from the segment done message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the format, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the position, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_sink_message"
              c:identifier="gst_event_parse_sink_message">
        <doc xml:whitespace="preserve">Parse the sink-message event. Unref @msg after usage.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="msg"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to store the #GstMessage in.</doc>
            <type name="Message" c:type="GstMessage**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_step" c:identifier="gst_event_parse_step">
        <doc xml:whitespace="preserve">Parse the step event.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the format in</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="amount"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the amount in</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the rate in</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="flush"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the flush boolean in</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="intermediate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the intermediate boolean in</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_stream_start"
              c:identifier="gst_event_parse_stream_start">
        <doc xml:whitespace="preserve">Parse a stream-id @event and store the result in the given @stream_id
location. The string stored in @stream_id must not be modified and will
remain valid only until @event gets freed. Make a copy if you want to
modify it or store it for later use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="stream_id"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to store the stream-id</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_tag" c:identifier="gst_event_parse_tag">
        <doc xml:whitespace="preserve">Parses a tag @event and stores the results in the given @taglist location.
No reference to the taglist will be returned, it remains valid only until
the @event is freed. Don't modify or free the taglist, make a copy if you
want to modify it or store it for later use.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="taglist"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to metadata list</doc>
            <type name="TagList" c:type="GstTagList**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_toc" c:identifier="gst_event_parse_toc">
        <doc xml:whitespace="preserve">Parse a TOC @event and store the results in the given @toc and @updated locations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="toc"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to #GstToc structure.</doc>
            <type name="Toc" c:type="GstToc**"/>
          </parameter>
          <parameter name="updated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to store TOC updated flag.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_toc_select"
              c:identifier="gst_event_parse_toc_select">
        <doc xml:whitespace="preserve">Parse a TOC select @event and store the results in the given @uid location.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uid"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">storage for the selection UID.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seqnum" c:identifier="gst_event_set_seqnum">
        <doc xml:whitespace="preserve">Set the sequence number of a event.

This function might be called by the creator of a event to indicate that the
event relates to other events or messages. See gst_event_get_seqnum() for
more information.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="seqnum" transfer-ownership="none">
            <doc xml:whitespace="preserve">A sequence number.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="writable_structure"
              c:identifier="gst_event_writable_structure">
        <doc xml:whitespace="preserve">Get a writable version of the structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The structure of the event. The structure is still owned by the event, which means that you should not free it and that the pointer becomes invalid when you free the event. This function checks if @event is writable and will never return NULL.  MT safe.</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <function name="type_get_flags" c:identifier="gst_event_type_get_flags">
        <doc xml:whitespace="preserve">Gets the #GstEventTypeFlags associated with @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstEventTypeFlags.</doc>
          <type name="EventTypeFlags" c:type="GstEventTypeFlags"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstEventType</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_get_name" c:identifier="gst_event_type_get_name">
        <doc xml:whitespace="preserve">Get a printable name for the given event type. Do not modify or free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a reference to the static name of the event.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the event type</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_to_quark" c:identifier="gst_event_type_to_quark">
        <doc xml:whitespace="preserve">Get the unique quark for the given event type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark associated with the event type</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the event type</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="EventType" c:type="GstEventType">
      <doc xml:whitespace="preserve">#GstEventType lists the standard event types that can be sent in a pipeline.

The custom event types can be used for private messages between elements
that can't be expressed using normal
GStreamer buffer passing semantics. Custom events carry an arbitrary
#GstStructure.
Specific custom events are distinguished by the name of the structure.</doc>
      <member name="unknown" value="0" c:identifier="GST_EVENT_UNKNOWN">
        <doc xml:whitespace="preserve">unknown event.</doc>
      </member>
      <member name="flush_start"
              value="2563"
              c:identifier="GST_EVENT_FLUSH_START">
        <doc xml:whitespace="preserve">Start a flush operation. This event clears all data from the pipeline and unblock all streaming threads.</doc>
      </member>
      <member name="flush_stop"
              value="5127"
              c:identifier="GST_EVENT_FLUSH_STOP">
        <doc xml:whitespace="preserve">Stop a flush operation. This event resets the running-time of the pipeline.</doc>
      </member>
      <member name="stream_start"
              value="10254"
              c:identifier="GST_EVENT_STREAM_START">
        <doc xml:whitespace="preserve">Event to mark the start of a new stream. Sent before any other serialized event and only sent at the start of a new stream, not after flushing seeks.</doc>
      </member>
      <member name="caps" value="12814" c:identifier="GST_EVENT_CAPS">
        <doc xml:whitespace="preserve">#GstCaps event. Notify the pad of a new media type.</doc>
      </member>
      <member name="segment" value="17934" c:identifier="GST_EVENT_SEGMENT">
        <doc xml:whitespace="preserve">A new media segment follows in the dataflow. The segment events contains information for clipping buffers and converting buffer timestamps to running-time and stream-time.</doc>
      </member>
      <member name="tag" value="20510" c:identifier="GST_EVENT_TAG">
        <doc xml:whitespace="preserve">A new set of metadata tags has been found in the stream.</doc>
      </member>
      <member name="buffersize"
              value="23054"
              c:identifier="GST_EVENT_BUFFERSIZE">
        <doc xml:whitespace="preserve">Notification of buffering requirements. Currently not used yet.</doc>
      </member>
      <member name="sink_message"
              value="25630"
              c:identifier="GST_EVENT_SINK_MESSAGE">
        <doc xml:whitespace="preserve">An event that sinks turn into a message. Used to send messages that should be emitted in sync with rendering.</doc>
      </member>
      <member name="eos" value="28174" c:identifier="GST_EVENT_EOS">
        <doc xml:whitespace="preserve">End-Of-Stream. No more data is to be expected to follow without a SEGMENT event.</doc>
      </member>
      <member name="toc" value="30750" c:identifier="GST_EVENT_TOC">
        <doc xml:whitespace="preserve">An event which indicates that a new table of contents (TOC) was found or updated.</doc>
      </member>
      <member name="segment_done"
              value="38406"
              c:identifier="GST_EVENT_SEGMENT_DONE">
        <doc xml:whitespace="preserve">Marks the end of a segment playback.</doc>
      </member>
      <member name="gap" value="40966" c:identifier="GST_EVENT_GAP">
        <doc xml:whitespace="preserve">Marks a gap in the datastream.</doc>
      </member>
      <member name="qos" value="48641" c:identifier="GST_EVENT_QOS">
        <doc xml:whitespace="preserve">A quality message. Used to indicate to upstream elements that the downstream elements should adjust their processing rate.</doc>
      </member>
      <member name="seek" value="51201" c:identifier="GST_EVENT_SEEK">
        <doc xml:whitespace="preserve">A request for a new playback position and rate.</doc>
      </member>
      <member name="navigation"
              value="53761"
              c:identifier="GST_EVENT_NAVIGATION">
        <doc xml:whitespace="preserve">Navigation events are usually used for communicating user requests, such as mouse or keyboard movements, to upstream elements.</doc>
      </member>
      <member name="latency" value="56321" c:identifier="GST_EVENT_LATENCY">
        <doc xml:whitespace="preserve">Notification of new latency adjustment. Sinks will use the latency information to adjust their synchronisation.</doc>
      </member>
      <member name="step" value="58881" c:identifier="GST_EVENT_STEP">
        <doc xml:whitespace="preserve">A request for stepping through the media. Sinks will usually execute the step operation.</doc>
      </member>
      <member name="reconfigure"
              value="61441"
              c:identifier="GST_EVENT_RECONFIGURE">
        <doc xml:whitespace="preserve">A request for upstream renegotiating caps and reconfiguring.</doc>
      </member>
      <member name="toc_select"
              value="64001"
              c:identifier="GST_EVENT_TOC_SELECT">
        <doc xml:whitespace="preserve">A request for a new playback position based on TOC entry's UID.</doc>
      </member>
      <member name="custom_upstream"
              value="69121"
              c:identifier="GST_EVENT_CUSTOM_UPSTREAM">
        <doc xml:whitespace="preserve">Upstream custom event</doc>
      </member>
      <member name="custom_downstream"
              value="71686"
              c:identifier="GST_EVENT_CUSTOM_DOWNSTREAM">
        <doc xml:whitespace="preserve">Downstream custom event that travels in the data flow.</doc>
      </member>
      <member name="custom_downstream_oob"
              value="74242"
              c:identifier="GST_EVENT_CUSTOM_DOWNSTREAM_OOB">
        <doc xml:whitespace="preserve">Custom out-of-band downstream event.</doc>
      </member>
      <member name="custom_downstream_sticky"
              value="76830"
              c:identifier="GST_EVENT_CUSTOM_DOWNSTREAM_STICKY">
        <doc xml:whitespace="preserve">Custom sticky downstream event.</doc>
      </member>
      <member name="custom_both"
              value="79367"
              c:identifier="GST_EVENT_CUSTOM_BOTH">
        <doc xml:whitespace="preserve">Custom upstream or downstream event. In-band when travelling downstream.</doc>
      </member>
      <member name="custom_both_oob"
              value="81923"
              c:identifier="GST_EVENT_CUSTOM_BOTH_OOB">
        <doc xml:whitespace="preserve">Custom upstream or downstream out-of-band event.</doc>
      </member>
    </bitfield>
    <bitfield name="EventTypeFlags" c:type="GstEventTypeFlags">
      <doc xml:whitespace="preserve">#GstEventTypeFlags indicate the aspects of the different #GstEventType
values. You can get the type flags of a #GstEventType with the
gst_event_type_get_flags() function.</doc>
      <member name="upstream" value="1" c:identifier="GST_EVENT_TYPE_UPSTREAM">
        <doc xml:whitespace="preserve">Set if the event can travel upstream.</doc>
      </member>
      <member name="downstream"
              value="2"
              c:identifier="GST_EVENT_TYPE_DOWNSTREAM">
        <doc xml:whitespace="preserve">Set if the event can travel downstream.</doc>
      </member>
      <member name="serialized"
              value="4"
              c:identifier="GST_EVENT_TYPE_SERIALIZED">
        <doc xml:whitespace="preserve">Set if the event should be serialized with data flow.</doc>
      </member>
      <member name="sticky" value="8" c:identifier="GST_EVENT_TYPE_STICKY">
        <doc xml:whitespace="preserve">Set if the event is sticky on the pads.</doc>
      </member>
      <member name="sticky_multi"
              value="16"
              c:identifier="GST_EVENT_TYPE_STICKY_MULTI">
        <doc xml:whitespace="preserve">Multiple sticky events can be on a pad, each identified by the event name.</doc>
      </member>
    </bitfield>
    <constant name="FORMAT_PERCENT_MAX"
              value="1000000"
              c:type="GST_FORMAT_PERCENT_MAX">
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="FORMAT_PERCENT_SCALE"
              value="10000"
              c:type="GST_FORMAT_PERCENT_SCALE">
      <type name="gint64" c:type="gint64"/>
    </constant>
    <constant name="FOURCC_FORMAT" value="c%c%c%c" c:type="GST_FOURCC_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="FlowReturn" c:type="GstFlowReturn">
      <doc xml:whitespace="preserve">The result of passing data to a pad.

Note that the custom return values should not be exposed outside of the
element scope.</doc>
      <member name="custom_success_2"
              value="102"
              c:identifier="GST_FLOW_CUSTOM_SUCCESS_2">
        <doc xml:whitespace="preserve">Pre-defined custom success code.</doc>
      </member>
      <member name="custom_success_1"
              value="101"
              c:identifier="GST_FLOW_CUSTOM_SUCCESS_1">
        <doc xml:whitespace="preserve">Pre-defined custom success code (define your custom success code to this to avoid compiler warnings).</doc>
      </member>
      <member name="custom_success"
              value="100"
              c:identifier="GST_FLOW_CUSTOM_SUCCESS">
        <doc xml:whitespace="preserve">Elements can use values starting from this (and higher) to define custom success codes.</doc>
      </member>
      <member name="ok" value="0" c:identifier="GST_FLOW_OK">
        <doc xml:whitespace="preserve">Data passing was ok.</doc>
      </member>
      <member name="not_linked" value="-1" c:identifier="GST_FLOW_NOT_LINKED">
        <doc xml:whitespace="preserve">Pad is not linked.</doc>
      </member>
      <member name="flushing" value="-2" c:identifier="GST_FLOW_FLUSHING">
        <doc xml:whitespace="preserve">Pad is flushing.</doc>
      </member>
      <member name="eos" value="-3" c:identifier="GST_FLOW_EOS">
        <doc xml:whitespace="preserve">Pad is EOS.</doc>
      </member>
      <member name="not_negotiated"
              value="-4"
              c:identifier="GST_FLOW_NOT_NEGOTIATED">
        <doc xml:whitespace="preserve">Pad is not negotiated.</doc>
      </member>
      <member name="error" value="-5" c:identifier="GST_FLOW_ERROR">
        <doc xml:whitespace="preserve">Some (fatal) error occured. Element generating this error should post an error message with more details.</doc>
      </member>
      <member name="not_supported"
              value="-6"
              c:identifier="GST_FLOW_NOT_SUPPORTED">
        <doc xml:whitespace="preserve">This operation is not supported.</doc>
      </member>
      <member name="custom_error"
              value="-100"
              c:identifier="GST_FLOW_CUSTOM_ERROR">
        <doc xml:whitespace="preserve">Elements can use values starting from this (and lower) to define custom error codes.</doc>
      </member>
      <member name="custom_error_1"
              value="-101"
              c:identifier="GST_FLOW_CUSTOM_ERROR_1">
        <doc xml:whitespace="preserve">Pre-defined custom error code (define your custom error code to this to avoid compiler warnings).</doc>
      </member>
      <member name="custom_error_2"
              value="-102"
              c:identifier="GST_FLOW_CUSTOM_ERROR_2">
        <doc xml:whitespace="preserve">Pre-defined custom error code.</doc>
      </member>
    </enumeration>
    <enumeration name="Format" c:type="GstFormat">
      <doc xml:whitespace="preserve">Standard predefined formats</doc>
      <member name="undefined" value="0" c:identifier="GST_FORMAT_UNDEFINED">
        <doc xml:whitespace="preserve">undefined format</doc>
      </member>
      <member name="default" value="1" c:identifier="GST_FORMAT_DEFAULT">
        <doc xml:whitespace="preserve">the default format of the pad/element. This can be samples for raw audio, frames/fields for raw video (some, but not all, elements support this; use @GST_FORMAT_TIME if you don't have a good reason to query for samples/frames)</doc>
      </member>
      <member name="bytes" value="2" c:identifier="GST_FORMAT_BYTES">
        <doc xml:whitespace="preserve">bytes</doc>
      </member>
      <member name="time" value="3" c:identifier="GST_FORMAT_TIME">
        <doc xml:whitespace="preserve">time in nanoseconds</doc>
      </member>
      <member name="buffers" value="4" c:identifier="GST_FORMAT_BUFFERS">
        <doc xml:whitespace="preserve">buffers (few, if any, elements implement this as of May 2009)</doc>
      </member>
      <member name="percent" value="5" c:identifier="GST_FORMAT_PERCENT">
        <doc xml:whitespace="preserve">percentage of stream (few, if any, elements implement this as of May 2009)</doc>
      </member>
    </enumeration>
    <record name="FormatDefinition" c:type="GstFormatDefinition">
      <doc xml:whitespace="preserve">A format definition</doc>
      <field name="value" writable="1">
        <type name="Format" c:type="GstFormat"/>
      </field>
      <field name="nick" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="quark" writable="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
    </record>
    <class name="Fraction"
           c:symbol-prefix="fraction"
           glib:type-name="GstFraction"
           glib:get-type="gst_fraction_get_type"
           glib:fundamental="1">
    </class>
    <class name="FractionRange"
           c:symbol-prefix="fraction_range"
           glib:type-name="GstFractionRange"
           glib:get-type="gst_fraction_range_get_type"
           glib:fundamental="1">
    </class>
    <class name="GhostPad"
           c:symbol-prefix="ghost_pad"
           c:type="GstGhostPad"
           parent="ProxyPad"
           glib:type-name="GstGhostPad"
           glib:get-type="gst_ghost_pad_get_type"
           glib:type-struct="GhostPadClass">
      <doc xml:whitespace="preserve">GhostPads are useful when organizing pipelines with #GstBin like elements.
The idea here is to create hierarchical element graphs. The bin element
contains a sub-graph. Now one would like to treat the bin-element like any
other #GstElement. This is where GhostPads come into play. A GhostPad acts as
a proxy for another pad. Thus the bin can have sink and source ghost-pads
that are associated with sink and source pads of the child elements.

If the target pad is known at creation time, gst_ghost_pad_new() is the
function to use to get a ghost-pad. Otherwise one can use gst_ghost_pad_new_no_target()
to create the ghost-pad and use gst_ghost_pad_set_target() to establish the
association later on.

Note that GhostPads add overhead to the data processing of a pipeline.

Last reviewed on 2005-11-18 (0.9.5)</doc>
      <constructor name="new" c:identifier="gst_ghost_pad_new">
        <doc xml:whitespace="preserve">Create a new ghostpad with @target as the target. The direction will be taken
from the target pad. @target must be unlinked.

Will ref the target.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to ghost.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_template"
                   c:identifier="gst_ghost_pad_new_from_template">
        <doc xml:whitespace="preserve">Create a new ghostpad with @target as the target. The direction will be taken
from the target pad. The template used on the ghostpad will be @template.

Will ref the target.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad to ghost.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadTemplate to use on the ghostpad.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_no_target"
                   c:identifier="gst_ghost_pad_new_no_target">
        <doc xml:whitespace="preserve">Create a new ghostpad without a target with the given direction.
A target can be set on the ghostpad later with the
gst_ghost_pad_set_target() function.

The created ghostpad will not have a padtemplate.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dir" transfer-ownership="none">
            <doc xml:whitespace="preserve">the direction of the ghostpad</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_no_target_from_template"
                   c:identifier="gst_ghost_pad_new_no_target_from_template">
        <doc xml:whitespace="preserve">Create a new ghostpad based on @templ, without setting a target. The
direction will be taken from the @templ.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the name of the new pad, or NULL to assign a default name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadTemplate to create the ghostpad from.</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="activate_mode_default"
                c:identifier="gst_ghost_pad_activate_mode_default">
        <doc xml:whitespace="preserve">Invoke the default activate mode function of a ghost pad.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to activate or deactivate.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested activation mode</doc>
            <type name="PadMode" c:type="GstPadMode"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the pad should be active or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="internal_activate_mode_default"
                c:identifier="gst_ghost_pad_internal_activate_mode_default">
        <doc xml:whitespace="preserve">Invoke the default activate mode function of a proxy pad that is
owned by a ghost pad.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the operation was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to activate or deactivate.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested activation mode</doc>
            <type name="PadMode" c:type="GstPadMode"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the pad should be active or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <method name="construct" c:identifier="gst_ghost_pad_construct">
        <doc xml:whitespace="preserve">Finish initialization of a newly allocated ghost pad.

This function is most useful in language bindings and when subclassing
#GstGhostPad; plugin and application developers normally will not call this
function. Call this function directly after a call to g_object_new
(GST_TYPE_GHOST_PAD, "direction", @dir, ..., NULL).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the construction succeeds, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_target" c:identifier="gst_ghost_pad_get_target">
        <doc xml:whitespace="preserve">Get the target pad of @gpad. Unref target pad after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the target #GstPad, can be NULL if the ghostpad has no target set. Unref target pad after usage.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
      </method>
      <method name="set_target" c:identifier="gst_ghost_pad_set_target">
        <doc xml:whitespace="preserve">Set the new target of the ghostpad @gpad. Any existing target
is unlinked and links to the new target are established. if @newtarget is
NULL the target will be cleared.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">TRUE if the new target could be set. This function can return FALSE when the internal pads could not be linked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="newtarget" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the new pad target</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <field name="pad">
        <type name="ProxyPad" c:type="GstProxyPad"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="GhostPadPrivate" c:type="GstGhostPadPrivate*"/>
      </field>
    </class>
    <record name="GhostPadClass"
            c:type="GstGhostPadClass"
            glib:is-gtype-struct-for="GhostPad">
      <field name="parent_class">
        <type name="ProxyPadClass" c:type="GstProxyPadClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="GhostPadPrivate" c:type="GstGhostPadPrivate" disguised="1">
    </record>
    <class name="Int64Range"
           c:symbol-prefix="int64_range"
           glib:type-name="GstInt64Range"
           glib:get-type="gst_int64_range_get_type"
           glib:fundamental="1">
    </class>
    <class name="IntRange"
           c:symbol-prefix="int_range"
           glib:type-name="GstIntRange"
           glib:get-type="gst_int_range_get_type"
           glib:fundamental="1">
    </class>
    <record name="Iterator"
            c:type="GstIterator"
            glib:type-name="GstIterator"
            glib:get-type="gst_iterator_get_type"
            c:symbol-prefix="iterator">
      <doc xml:whitespace="preserve">A GstIterator is used to retrieve multiple objects from another object in
a threadsafe way.

Various GStreamer objects provide access to their internal structures using
an iterator.

In general, whenever calling a GstIterator function results in your code
receiving a refcounted object, the refcount for that object will have been
increased.  Your code is responsible for unrefing that object after use.

The basic use pattern of an iterator is as follows:

&lt;example&gt;
&lt;title&gt;Using an iterator&lt;/title&gt;
  &lt;programlisting&gt;
   it = _get_iterator(object);
   done = FALSE;
   while (!done) {
     switch (gst_iterator_next (it, &amp;amp;item)) {
       case GST_ITERATOR_OK:
         ... use/change item here...
         g_value_reset (&amp;amp;item);
         break;
       case GST_ITERATOR_RESYNC:
         ...rollback changes to items...
         gst_iterator_resync (it);
         break;
       case GST_ITERATOR_ERROR:
         ...wrong parameters were given...
         done = TRUE;
         break;
       case GST_ITERATOR_DONE:
         done = TRUE;
         break;
     }
   }
   g_value_unset (&amp;amp;item);
   gst_iterator_free (it);
  &lt;/programlisting&gt;
&lt;/example&gt;

Last reviewed on 2009-06-16 (0.10.24)</doc>
      <field name="copy" writable="1">
        <type name="IteratorCopyFunction" c:type="GstIteratorCopyFunction"/>
      </field>
      <field name="next" writable="1">
        <type name="IteratorNextFunction" c:type="GstIteratorNextFunction"/>
      </field>
      <field name="item" writable="1">
        <type name="IteratorItemFunction" c:type="GstIteratorItemFunction"/>
      </field>
      <field name="resync" writable="1">
        <type name="IteratorResyncFunction"
              c:type="GstIteratorResyncFunction"/>
      </field>
      <field name="free" writable="1">
        <type name="IteratorFreeFunction" c:type="GstIteratorFreeFunction"/>
      </field>
      <field name="pushed" writable="1">
        <type name="Iterator" c:type="GstIterator*"/>
      </field>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="lock" writable="1">
        <type name="GLib.Mutex" c:type="GMutex*"/>
      </field>
      <field name="cookie" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="master_cookie" writable="1">
        <type name="guint32" c:type="guint32*"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new"
                   c:identifier="gst_iterator_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Create a new iterator. This function is mainly used for objects
implementing the next/resync/free function to iterate a data structure.

For each item retrieved, the @item function is called with the lock
held. The @free function is called when the iterator is freed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstIterator.  MT safe.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the iterator structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GType of children</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="lock" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to a #GMutex.</doc>
            <type name="GLib.Mutex" c:type="GMutex*"/>
          </parameter>
          <parameter name="master_cookie" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to a guint32 that is changed when the items in the iterator changed.</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="copy" transfer-ownership="none">
            <doc xml:whitespace="preserve">copy function</doc>
            <type name="IteratorCopyFunction"
                  c:type="GstIteratorCopyFunction"/>
          </parameter>
          <parameter name="next" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to get next item</doc>
            <type name="IteratorNextFunction"
                  c:type="GstIteratorNextFunction"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to call on each item retrieved</doc>
            <type name="IteratorItemFunction"
                  c:type="GstIteratorItemFunction"/>
          </parameter>
          <parameter name="resync" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to resync the iterator</doc>
            <type name="IteratorResyncFunction"
                  c:type="GstIteratorResyncFunction"/>
          </parameter>
          <parameter name="free" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to free the iterator</doc>
            <type name="IteratorFreeFunction"
                  c:type="GstIteratorFreeFunction"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_list"
                   c:identifier="gst_iterator_new_list"
                   introspectable="0">
        <doc xml:whitespace="preserve">Create a new iterator designed for iterating @list.

The list you iterate is usually part of a data structure @owner and is
protected with @lock. 

The iterator will use @lock to retrieve the next item of the list and it
will then call the @item function before releasing @lock again.

When a concurrent update to the list is performed, usually by @owner while
holding @lock, @master_cookie will be updated. The iterator implementation
will notice the update of the cookie and will return %GST_ITERATOR_RESYNC to
the user of the iterator in the next call to gst_iterator_next().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstIterator for @list.  MT safe.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GType of elements</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="lock" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to a #GMutex protecting the list.</doc>
            <type name="GLib.Mutex" c:type="GMutex*"/>
          </parameter>
          <parameter name="master_cookie" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to a guint32 that is incremented when the list is changed.</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to the list</doc>
            <type name="GLib.List" c:type="GList**">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="owner" transfer-ownership="none">
            <doc xml:whitespace="preserve">object owning the list</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:whitespace="preserve">function to call on each item retrieved</doc>
            <type name="IteratorItemFunction"
                  c:type="GstIteratorItemFunction"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_single" c:identifier="gst_iterator_new_single">
        <doc xml:whitespace="preserve">This #GstIterator is a convenient iterator for the common
case where a #GstIterator needs to be returned but only
a single object has to be considered. This happens often
for the #GstPadIterIntLinkFunction.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstIterator for @object.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GType of the passed object</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">object that this iterator should return</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="gst_iterator_copy">
        <doc xml:whitespace="preserve">Copy the iterator and its state.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new copy of @it.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="filter" c:identifier="gst_iterator_filter">
        <doc xml:whitespace="preserve">Create a new iterator from an existing iterator. The new iterator
will only return those elements that match the given compare function @func.
The first parameter that is passed to @func is the #GValue of the current
iterator element and the second parameter is @user_data. @func should
return 0 for elements that should be included in the filtered iterator.

When this iterator is freed, @it will also be freed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstIterator.  MT safe.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">the compare function to select elements</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the compare function</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_custom" c:identifier="gst_iterator_find_custom">
        <doc xml:whitespace="preserve">Find the first element in @it that matches the compare function @func.
@func should return 0 when the element is found. The first parameter
to @func will be the current element of the iterator and the
second parameter will be @user_data.
The result will be stored in @elem if a result is found.

The iterator will not be freed.

This function will return FALSE if an error happened to the iterator
or if the element wasn't found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Returns TRUE if the element was found, else FALSE.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:whitespace="preserve">the compare function to use</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="elem"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to a #GValue where to store the result</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the compare function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="fold" c:identifier="gst_iterator_fold">
        <doc xml:whitespace="preserve">Folds @func over the elements of @iter. That is to say, @func will be called
as @func (object, @ret, @user_data) for each object in @it. The normal use
of this procedure is to accumulate the results of operating on the objects in
@ret.

This procedure can be used (and is used internally) to implement the
gst_iterator_foreach() and gst_iterator_find_custom() operations.

The fold will proceed as long as @func returns TRUE. When the iterator has no
more arguments, %GST_ITERATOR_DONE will be returned. If @func returns FALSE,
the fold will stop, and %GST_ITERATOR_OK will be returned. Errors or resyncs
will cause fold to return %GST_ITERATOR_ERROR or %GST_ITERATOR_RESYNC as
appropriate.

The iterator will not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstIteratorResult, as described above.  MT safe.</doc>
          <type name="IteratorResult" c:type="GstIteratorResult"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:whitespace="preserve">the fold function</doc>
            <type name="IteratorFoldFunction"
                  c:type="GstIteratorFoldFunction"/>
          </parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seed value passed to the fold function</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the fold function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="gst_iterator_foreach">
        <doc xml:whitespace="preserve">Iterate over all element of @it and call the given function @func for
each element.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the result call to gst_iterator_fold(). The iterator will not be freed.  MT safe.</doc>
          <type name="IteratorResult" c:type="GstIteratorResult"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">the function to call for each element.</doc>
            <type name="IteratorForeachFunction"
                  c:type="GstIteratorForeachFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_iterator_free">
        <doc xml:whitespace="preserve">Free the iterator.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="next" c:identifier="gst_iterator_next">
        <doc xml:whitespace="preserve">Get the next item from the iterator in @elem. 

Only when this function returns %GST_ITERATOR_OK, @elem will contain a valid
value. @elem must have been initialized to the type of the iterator or
initialized to zeroes with g_value_unset(). The caller is responsible for
unsetting or resetting @elem with g_value_unset() or g_value_reset()
after usage.

When this function returns %GST_ITERATOR_DONE, no more elements can be
retrieved from @it.

A return value of %GST_ITERATOR_RESYNC indicates that the element list was
concurrently updated. The user of @it should call gst_iterator_resync() to
get the newly updated list. 

A return value of %GST_ITERATOR_ERROR indicates an unrecoverable fatal error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The result of the iteration. Unset @elem after usage.  MT safe.</doc>
          <type name="IteratorResult" c:type="GstIteratorResult"/>
        </return-value>
        <parameters>
          <parameter name="elem"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to hold next element</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_iterator_push">
        <doc xml:whitespace="preserve">Pushes @other iterator onto @it. All calls performed on @it are
forwarded to @other. If @other returns %GST_ITERATOR_DONE, it is
popped again and calls are handled by @it again.

This function is mainly used by objects implementing the iterator
next function to recurse into substructures.

When gst_iterator_resync() is called on @it, @other will automatically be
popped.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="other" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstIterator to push</doc>
            <type name="Iterator" c:type="GstIterator*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resync" c:identifier="gst_iterator_resync">
        <doc xml:whitespace="preserve">Resync the iterator. this function is mostly called
after gst_iterator_next() returned %GST_ITERATOR_RESYNC.

When an iterator was pushed on @it, it will automatically be popped again
with this function.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <callback name="IteratorCopyFunction" c:type="GstIteratorCopyFunction">
      <doc xml:whitespace="preserve">This function will be called when creating a copy of @it and should
create a copy of all custom iterator fields or increase their
reference counts.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">The original iterator</doc>
          <type name="Iterator" c:type="const GstIterator*"/>
        </parameter>
        <parameter name="copy" transfer-ownership="none">
          <doc xml:whitespace="preserve">The copied iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="IteratorFoldFunction" c:type="GstIteratorFoldFunction">
      <doc xml:whitespace="preserve">A function to be passed to gst_iterator_fold().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the fold should continue, FALSE if it should stop.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="item" transfer-ownership="none">
          <doc xml:whitespace="preserve">the item to fold</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue collecting the result</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">data passed to gst_iterator_fold()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="IteratorForeachFunction"
              c:type="GstIteratorForeachFunction">
      <doc xml:whitespace="preserve">A function that is called by gst_iterator_foreach() for every element.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="item" transfer-ownership="none">
          <doc xml:whitespace="preserve">The item</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">User data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="IteratorFreeFunction" c:type="GstIteratorFreeFunction">
      <doc xml:whitespace="preserve">This function will be called when the iterator is freed.

Implementors of a #GstIterator should implement this
function and pass it to the constructor of the custom iterator.
The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="IteratorItem" c:type="GstIteratorItem">
      <doc xml:whitespace="preserve">The result of a #GstIteratorItemFunction.</doc>
      <member name="skip" value="0" c:identifier="GST_ITERATOR_ITEM_SKIP">
        <doc xml:whitespace="preserve">Skip this item</doc>
      </member>
      <member name="pass" value="1" c:identifier="GST_ITERATOR_ITEM_PASS">
        <doc xml:whitespace="preserve">Return item</doc>
      </member>
      <member name="end" value="2" c:identifier="GST_ITERATOR_ITEM_END">
        <doc xml:whitespace="preserve">Stop after this item.</doc>
      </member>
    </enumeration>
    <callback name="IteratorItemFunction" c:type="GstIteratorItemFunction">
      <doc xml:whitespace="preserve">The function that will be called after the next item of the iterator
has been retrieved. This function can be used to skip items or stop
the iterator.

The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the result of the operation.</doc>
        <type name="IteratorItem" c:type="GstIteratorItem"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
        <parameter name="item" transfer-ownership="none">
          <doc xml:whitespace="preserve">the item being retrieved.</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="IteratorNextFunction" c:type="GstIteratorNextFunction">
      <doc xml:whitespace="preserve">The function that will be called when the next element of the iterator
should be retrieved.

Implementors of a #GstIterator should implement this
function and pass it to the constructor of the custom iterator.
The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the result of the operation.</doc>
        <type name="IteratorResult" c:type="GstIteratorResult"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
        <parameter name="result" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to hold the next item</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="IteratorResult" c:type="GstIteratorResult">
      <doc xml:whitespace="preserve">The result of gst_iterator_next().</doc>
      <member name="done" value="0" c:identifier="GST_ITERATOR_DONE">
        <doc xml:whitespace="preserve">No more items in the iterator</doc>
      </member>
      <member name="ok" value="1" c:identifier="GST_ITERATOR_OK">
        <doc xml:whitespace="preserve">An item was retrieved</doc>
      </member>
      <member name="resync" value="2" c:identifier="GST_ITERATOR_RESYNC">
        <doc xml:whitespace="preserve">Datastructure changed while iterating</doc>
      </member>
      <member name="error" value="3" c:identifier="GST_ITERATOR_ERROR">
        <doc xml:whitespace="preserve">An error happened</doc>
      </member>
    </enumeration>
    <callback name="IteratorResyncFunction" c:type="GstIteratorResyncFunction">
      <doc xml:whitespace="preserve">This function will be called whenever a concurrent update happened
to the iterated datastructure. The implementor of the iterator should
restart the iterator from the beginning and clean up any state it might
have.

Implementors of a #GstIterator should implement this
function and pass it to the constructor of the custom iterator.
The function will be called with the iterator lock held.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="it" transfer-ownership="none">
          <doc xml:whitespace="preserve">the iterator</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="LICENSE_UNKNOWN"
              value="unknown"
              c:type="GST_LICENSE_UNKNOWN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="LOCK_FLAG_READWRITE"
              value="0"
              c:type="GST_LOCK_FLAG_READWRITE">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="LibraryError"
                 c:type="GstLibraryError"
                 glib:error-domain="gst-library-error-quark">
      <doc xml:whitespace="preserve">Library errors are for errors from the library being used by elements
(initializing, finalizing, settings, ...)</doc>
      <member name="failed" value="1" c:identifier="GST_LIBRARY_ERROR_FAILED">
        <doc xml:whitespace="preserve">a general error which doesn't fit in any other category.  Make sure you add a custom message to the error call.</doc>
      </member>
      <member name="too_lazy"
              value="2"
              c:identifier="GST_LIBRARY_ERROR_TOO_LAZY">
        <doc xml:whitespace="preserve">do not use this except as a placeholder for deciding where to go while developing code.</doc>
      </member>
      <member name="init" value="3" c:identifier="GST_LIBRARY_ERROR_INIT">
        <doc xml:whitespace="preserve">used when the library could not be opened.</doc>
      </member>
      <member name="shutdown"
              value="4"
              c:identifier="GST_LIBRARY_ERROR_SHUTDOWN">
        <doc xml:whitespace="preserve">used when the library could not be closed.</doc>
      </member>
      <member name="settings"
              value="5"
              c:identifier="GST_LIBRARY_ERROR_SETTINGS">
        <doc xml:whitespace="preserve">used when the library doesn't accept settings.</doc>
      </member>
      <member name="encode" value="6" c:identifier="GST_LIBRARY_ERROR_ENCODE">
        <doc xml:whitespace="preserve">used when the library generated an encoding error.</doc>
      </member>
      <member name="num_errors"
              value="7"
              c:identifier="GST_LIBRARY_ERROR_NUM_ERRORS">
        <doc xml:whitespace="preserve">the number of library error types.</doc>
      </member>
    </enumeration>
    <bitfield name="LockFlags" c:type="GstLockFlags">
      <doc xml:whitespace="preserve">Flags used when locking miniobjects</doc>
      <member name="read" value="1" c:identifier="GST_LOCK_FLAG_READ">
        <doc xml:whitespace="preserve">lock for read access</doc>
      </member>
      <member name="write" value="2" c:identifier="GST_LOCK_FLAG_WRITE">
        <doc xml:whitespace="preserve">lock for write access</doc>
      </member>
      <member name="exclusive"
              value="4"
              c:identifier="GST_LOCK_FLAG_EXCLUSIVE">
        <doc xml:whitespace="preserve">lock for exclusive access</doc>
      </member>
      <member name="last" value="256" c:identifier="GST_LOCK_FLAG_LAST">
        <doc xml:whitespace="preserve">first flag that can be used for custom purposes</doc>
      </member>
    </bitfield>
    <callback name="LogFunction" c:type="GstLogFunction">
      <doc xml:whitespace="preserve">Function prototype for a logging function that can be registered with
gst_debug_add_log_function().
Use G_GNUC_NO_INSTRUMENT on that function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstDebugCategory</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstDebugLevel</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">file name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">function name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">line number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GObject</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message</doc>
          <type name="DebugMessage" c:type="GstDebugMessage*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="7">
          <doc xml:whitespace="preserve">user data for the log function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="MAP_READWRITE" value="0" c:type="GST_MAP_READWRITE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MSECOND" value="1000000" c:type="GST_MSECOND">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="MapFlags" c:type="GstMapFlags">
      <doc xml:whitespace="preserve">Flags used when mapping memory</doc>
      <member name="read" value="1" c:identifier="GST_MAP_READ">
        <doc xml:whitespace="preserve">map for read access</doc>
      </member>
      <member name="write" value="2" c:identifier="GST_MAP_WRITE">
        <doc xml:whitespace="preserve">map for write access</doc>
      </member>
      <member name="flag_last" value="65536" c:identifier="GST_MAP_FLAG_LAST">
        <doc xml:whitespace="preserve">first flag that can be used for custom purposes</doc>
      </member>
    </bitfield>
    <record name="MapInfo" c:type="GstMapInfo">
      <doc xml:whitespace="preserve">A structure containing the result of a map operation such as
gst_memory_map(). It contains the data and size.</doc>
      <field name="memory" writable="1">
        <type name="Memory" c:type="GstMemory*"/>
      </field>
      <field name="flags" writable="1">
        <type name="MapFlags" c:type="GstMapFlags"/>
      </field>
      <field name="data" writable="1">
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="maxsize" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="user_data" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="Memory"
            c:type="GstMemory"
            glib:type-name="GstMemory"
            glib:get-type="gst_memory_get_type"
            c:symbol-prefix="memory">
      <doc xml:whitespace="preserve">GstMemory is a lightweight refcounted object that wraps a region of memory.
They are typically used to manage the data of a #GstBuffer.

A GstMemory object has an allocated region of memory of maxsize. The maximum
size does not change during the lifetime of the memory object. The memory
also has an offset and size property that specifies the valid range of memory
in the allocated region.

Memory is usually created by allocators with a gst_allocator_alloc()
method call. When NULL is used as the allocator, the default allocator will
be used.

New allocators can be registered with gst_allocator_register().
Allocators are identified by name and can be retrieved with
gst_allocator_find(). gst_allocator_set_default() can be used to change the
default allocator.

New memory can be created with gst_memory_new_wrapped() that wraps the memory
allocated elsewhere.

Refcounting of the memory block is performed with gst_memory_ref() and
gst_memory_unref().

The size of the memory can be retrieved and changed with
gst_memory_get_sizes() and gst_memory_resize() respectively.

Getting access to the data of the memory is performed with gst_memory_map().
The call will return a pointer to offset bytes into the region of memory.
After the memory access is completed, gst_memory_unmap() should be called.

Memory can be copied with gst_memory_copy(), which will return a writable
copy. gst_memory_share() will create a new memory block that shares the
memory with an existing memory block at a custom offset and with a custom
size.

Memory can be efficiently merged when gst_memory_is_span() returns TRUE.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <field name="mini_object" writable="1">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="allocator" writable="1">
        <type name="Allocator" c:type="GstAllocator*"/>
      </field>
      <field name="parent" writable="1">
        <type name="Memory" c:type="GstMemory*"/>
      </field>
      <field name="maxsize" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="align" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="offset" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="size" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <constructor name="new_wrapped" c:identifier="gst_memory_new_wrapped">
        <doc xml:whitespace="preserve">Allocate a new memory block that wraps the given @data.

The prefix/padding must be filled with 0 if @flags contains
#GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED respectively.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstMemory.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstMemoryFlags</doc>
            <type name="MemoryFlags" c:type="GstMemoryFlags"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to wrap</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="maxsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">allocated size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">offset in @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">size of valid data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called with @user_data when the memory is freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="gst_memory_copy">
        <doc xml:whitespace="preserve">Return a copy of @size bytes from @mem starting from @offset. This copy is
guaranteed to be writable. @size can be set to -1 to return a copy all bytes
from @offset.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstMemory.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">an offset to copy</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">size to copy or -1 to copy all bytes from offset</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sizes" c:identifier="gst_memory_get_sizes">
        <doc xml:whitespace="preserve">Get the current @size, @offset and @maxsize of @mem.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the current sizes of @mem</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to offset</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
          <parameter name="maxsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to maxsize</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_memory_init" introspectable="0">
        <doc xml:whitespace="preserve">Initializes a newly allocated @mem with the given parameters. This function
will call gst_mini_object_init() with the default memory parameters.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstMemoryFlags</doc>
            <type name="MemoryFlags" c:type="GstMemoryFlags"/>
          </parameter>
          <parameter name="allocator" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstAllocator</doc>
            <type name="Allocator" c:type="GstAllocator*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @mem</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
          <parameter name="maxsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">the total size of the memory</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="align" transfer-ownership="none">
            <doc xml:whitespace="preserve">the alignment of the memory</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The offset in the memory</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of valid data in the memory</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_span" c:identifier="gst_memory_is_span">
        <doc xml:whitespace="preserve">Check if @mem1 and mem2 share the memory with a common parent memory object
and that the memory is contiguous.

If this is the case, the memory of @mem1 and @mem2 can be merged
efficiently by performing gst_memory_share() on the parent object from
the returned @offset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the memory is contiguous and of a common parent.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="mem2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstMemory</doc>
            <type name="Memory" c:type="GstMemory*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to a result offset</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_mapped" c:identifier="gst_memory_make_mapped">
        <doc xml:whitespace="preserve">Create a #GstMemory object that is mapped with @flags. If @mem is mappable
with @flags, this function returns the mapped @mem directly. Otherwise a
mapped copy of @mem is returned.

This function takes ownership of old @mem and returns a reference to a new
#GstMemory.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstMemory object mapped with @flags or NULL when a mapping is not possible.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="info"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer for info</doc>
            <type name="MapInfo" c:type="GstMapInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">mapping flags</doc>
            <type name="MapFlags" c:type="GstMapFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="gst_memory_map">
        <doc xml:whitespace="preserve">Fill @info with the pointer and sizes of the memory in @mem that can be
accessed according to @flags.

This function can return %FALSE for various reasons:
- the memory backed by @mem is not accessible with the given @flags.
- the memory was already mapped with a different mapping.

@info and its contents remain valid for as long as @mem is valid and
until gst_memory_unmap() is called.

For each gst_memory_map() call, a corresponding gst_memory_unmap() call
should be done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the map operation was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="info"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer for info</doc>
            <type name="MapInfo" c:type="GstMapInfo*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">mapping flags</doc>
            <type name="MapFlags" c:type="GstMapFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="resize" c:identifier="gst_memory_resize">
        <doc xml:whitespace="preserve">Resize the memory region. @mem should be writable and offset + size should be
less than the maxsize of @mem.

#GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED will be
cleared when offset or padding is increased respectively.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new offset</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new size</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="share" c:identifier="gst_memory_share">
        <doc xml:whitespace="preserve">Return a shared copy of @size bytes from @mem starting from @offset. No
memory copy is performed and the memory region is simply shared. The result
is guaranteed to be not-writable. @size can be set to -1 to return a share
all bytes from @offset.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstMemory.</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">an offset to share</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">size to share or -1 to share bytes from offset</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmap" c:identifier="gst_memory_unmap">
        <doc xml:whitespace="preserve">Release the memory obtained with gst_memory_map()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstMapInfo</doc>
            <type name="MapInfo" c:type="GstMapInfo*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <callback name="MemoryCopyFunction" c:type="GstMemoryCopyFunction">
      <doc xml:whitespace="preserve">Copy @size bytes from @mem starting at @offset and return them wrapped in a
new GstMemory object.
If @size is set to -1, all bytes starting at @offset are copied.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstMemory object wrapping a copy of the requested region in @mem.</doc>
        <type name="Memory" c:type="GstMemory*"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMemory</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">an offset</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">a size or -1</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="MemoryFlags" c:type="GstMemoryFlags">
      <doc xml:whitespace="preserve">Flags for wrapped memory.</doc>
      <member name="readonly"
              value="2"
              c:identifier="GST_MEMORY_FLAG_READONLY">
        <doc xml:whitespace="preserve">memory is readonly. It is not allowed to map the memory with #GST_MAP_WRITE.</doc>
      </member>
      <member name="no_share"
              value="16"
              c:identifier="GST_MEMORY_FLAG_NO_SHARE">
        <doc xml:whitespace="preserve">memory must not be shared. Copies will have to be made when this memory needs to be shared between buffers.</doc>
      </member>
      <member name="zero_prefixed"
              value="32"
              c:identifier="GST_MEMORY_FLAG_ZERO_PREFIXED">
        <doc xml:whitespace="preserve">the memory prefix is filled with 0 bytes</doc>
      </member>
      <member name="zero_padded"
              value="64"
              c:identifier="GST_MEMORY_FLAG_ZERO_PADDED">
        <doc xml:whitespace="preserve">the memory padding is filled with 0 bytes</doc>
      </member>
      <member name="last" value="1048576" c:identifier="GST_MEMORY_FLAG_LAST">
        <doc xml:whitespace="preserve">first flag that can be used for custom purposes</doc>
      </member>
    </bitfield>
    <callback name="MemoryIsSpanFunction" c:type="GstMemoryIsSpanFunction">
      <doc xml:whitespace="preserve">Check if @mem1 and @mem2 occupy contiguous memory and return the offset of
@mem1 in the parent buffer in @offset.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @mem1 and @mem2 are in contiguous memory.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="mem1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMemory</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </parameter>
        <parameter name="mem2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMemory</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">a result offset</doc>
          <type name="gsize" c:type="gsize*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="MemoryMapFunction"
              c:type="GstMemoryMapFunction"
              introspectable="0">
      <doc xml:whitespace="preserve">Get the memory of @mem that can be accessed according to the mode specified
in @flags. The function should return a pointer that contains at least
@maxsize bytes.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a pointer to memory of which at least @maxsize bytes can be accessed according to the access pattern in @flags.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMemory</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </parameter>
        <parameter name="maxsize" transfer-ownership="none">
          <doc xml:whitespace="preserve">size to map</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">access mode for the memory</doc>
          <type name="MapFlags" c:type="GstMapFlags"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="MemoryShareFunction" c:type="GstMemoryShareFunction">
      <doc xml:whitespace="preserve">Share @size bytes from @mem starting at @offset and return them wrapped in a
new GstMemory object. If @size is set to -1, all bytes starting at @offset are
shared. This function does not make a copy of the bytes in @mem.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstMemory object sharing the requested region in @mem.</doc>
        <type name="Memory" c:type="GstMemory*"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMemory</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">an offset</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">a size or -1</doc>
          <type name="gssize" c:type="gssize"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="MemoryUnmapFunction" c:type="GstMemoryUnmapFunction">
      <doc xml:whitespace="preserve">Return the pointer previously retrieved with gst_memory_map().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE on success.</doc>
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMemory</doc>
          <type name="Memory" c:type="GstMemory*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Message"
            c:type="GstMessage"
            glib:type-name="GstMessage"
            glib:get-type="gst_message_get_type"
            c:symbol-prefix="message">
      <doc xml:whitespace="preserve">Messages are implemented as a subclass of #GstMiniObject with a generic
#GstStructure as the content. This allows for writing custom messages without
requiring an API change while allowing a wide range of different types
of messages.

Messages are posted by objects in the pipeline and are passed to the
application using the #GstBus.

The basic use pattern of posting a message on a #GstBus is as follows:

&lt;example&gt;
&lt;title&gt;Posting a #GstMessage&lt;/title&gt;
  &lt;programlisting&gt;
   gst_bus_post (bus, gst_message_new_eos());
  &lt;/programlisting&gt;
&lt;/example&gt;

A #GstElement usually posts messages on the bus provided by the parent
container using gst_element_post_message().

Last reviewed on 2005-11-09 (0.9.4)</doc>
      <field name="mini_object" writable="1">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="type" writable="1">
        <type name="MessageType" c:type="GstMessageType"/>
      </field>
      <field name="timestamp" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="src" writable="1">
        <type name="Object" c:type="GstObject*"/>
      </field>
      <field name="seqnum" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="lock" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="cond" readable="0" private="1">
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <constructor name="new_application"
                   c:identifier="gst_message_new_application">
        <doc xml:whitespace="preserve">Create a new application-typed message. GStreamer will never create these
messages; they are a gift from us to you. Enjoy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new application message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the structure for the message. The message will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_async_done"
                   c:identifier="gst_message_new_async_done">
        <doc xml:whitespace="preserve">The message is posted when elements completed an ASYNC state change.
@running_time contains the time of the desired running_time when this
elements goes to PLAYING. A value of #GST_CLOCK_TIME_NONE for @running_time
means that the element has no clock interaction and thus doesn't care about
the running_time of the pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new async_done message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the desired running_time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_async_start"
                   c:identifier="gst_message_new_async_start">
        <doc xml:whitespace="preserve">This message is posted by elements when they start an ASYNC state change.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new async_start message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_buffering"
                   c:identifier="gst_message_new_buffering">
        <doc xml:whitespace="preserve">Create a new buffering message. This message can be posted by an element that
needs to buffer data before it can continue processing. @percent should be a
value between 0 and 100. A value of 100 means that the buffering completed.

When @percent is &lt; 100 the application should PAUSE a PLAYING pipeline. When
@percent is 100, the application can set the pipeline (back) to PLAYING.
The application must be prepared to receive BUFFERING messages in the
PREROLLING state and may only set the pipeline to PLAYING after receiving a
message with @percent set to 100, which can happen after the pipeline
completed prerolling.

MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new buffering message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="percent" transfer-ownership="none">
            <doc xml:whitespace="preserve">The buffering percent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_clock_lost"
                   c:identifier="gst_message_new_clock_lost">
        <doc xml:whitespace="preserve">Create a clock lost message. This message is posted whenever the
clock is not valid anymore.

If this message is posted by the pipeline, the pipeline will
select a new clock again when it goes to PLAYING. It might therefore
be needed to set the pipeline to PAUSED and PLAYING again.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new clock lost message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock that was lost</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_clock_provide"
                   c:identifier="gst_message_new_clock_provide">
        <doc xml:whitespace="preserve">Create a clock provide message. This message is posted whenever an
element is ready to provide a clock or lost its ability to provide
a clock (maybe because it paused or became EOS).

This message is mainly used internally to manage the clock
selection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new provide clock message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock it provides</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
          <parameter name="ready" transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the sender can provide a clock</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_custom" c:identifier="gst_message_new_custom">
        <doc xml:whitespace="preserve">Create a new custom-typed message. This can be used for anything not
handled by other message-specific functions to pass a message to the
app. The structure field can be NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GstMessageType to distinguish messages</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">the structure for the message. The message will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_duration_changed"
                   c:identifier="gst_message_new_duration_changed">
        <doc xml:whitespace="preserve">Create a new duration changed message. This message is posted by elements
that know the duration of a stream when the duration changes. This message
is received by bins and is used to calculate the total duration of a
pipeline. Elements may post a duration message with a duration of
GST_CLOCK_TIME_NONE to indicate that the duration has changed and the 
cached duration should be discarded. The new duration can then be 
retrieved via a query.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new duration-changed message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_element" c:identifier="gst_message_new_element">
        <doc xml:whitespace="preserve">Create a new element-specific message. This is meant as a generic way of
allowing one-way communication from an element to an application, for example
"the firewire cable was unplugged". The format of the message should be
documented in the element's documentation. The structure field can be NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new element message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="structure" transfer-ownership="full">
            <doc xml:whitespace="preserve">The structure for the message. The message will take ownership of the structure.</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_eos" c:identifier="gst_message_new_eos">
        <doc xml:whitespace="preserve">Create a new eos message. This message is generated and posted in
the sink elements of a GstBin. The bin will only forward the EOS
message to the application if all sinks have posted an EOS message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new eos message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_error" c:identifier="gst_message_new_error">
        <doc xml:whitespace="preserve">Create a new error message. The message will copy @error and
@debug. This message is posted by element when a fatal event
occured. The pipeline will probably (partially) stop. The application
receiving this message should stop the pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new error message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GError for this message.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">A debugging string.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_info" c:identifier="gst_message_new_info">
        <doc xml:whitespace="preserve">Create a new info message. The message will make copies of @error and
@debug.

MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new info message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GError for this message.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">A debugging string.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_latency" c:identifier="gst_message_new_latency">
        <doc xml:whitespace="preserve">This message can be posted by elements when their latency requirements have
changed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new latency message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_new_clock"
                   c:identifier="gst_message_new_new_clock">
        <doc xml:whitespace="preserve">Create a new clock message. This message is posted whenever the
pipeline selectes a new clock for the pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new new clock message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new selected clock</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_progress" c:identifier="gst_message_new_progress">
        <doc xml:whitespace="preserve">Progress messages are posted by elements when they use an asynchronous task
to perform actions triggered by a state change.

@code contains a well defined string describing the action.
@test should contain a user visible string detailing the current action.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new qos message.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstProgressType</doc>
            <type name="ProgressType" c:type="GstProgressType"/>
          </parameter>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">a progress code</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="text" transfer-ownership="none">
            <doc xml:whitespace="preserve">free, user visible text describing the progress</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_qos" c:identifier="gst_message_new_qos">
        <doc xml:whitespace="preserve">A QOS message is posted on the bus whenever an element decides to drop a
buffer because of QoS reasons or whenever it changes its processing strategy
because of QoS reasons (quality adjustments such as processing at lower
accuracy).

This message can be posted by an element that performs synchronisation against the
clock (live) or it could be dropped by an element that performs QoS because of QOS
events received from a downstream element (!live).

@running_time, @stream_time, @timestamp, @duration should be set to the
respective running-time, stream-time, timestamp and duration of the (dropped)
buffer that generated the QoS event. Values can be left to
GST_CLOCK_TIME_NONE when unknown.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new qos message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="live" transfer-ownership="none">
            <doc xml:whitespace="preserve">if the message was generated by a live element</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="stream_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stream time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the timestamps of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_request_state"
                   c:identifier="gst_message_new_request_state">
        <doc xml:whitespace="preserve">This message can be posted by elements when they want to have their state
changed. A typical use case would be an audio server that wants to pause the
pipeline because a higher priority stream is being played.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new requst state message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new requested state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_reset_time"
                   c:identifier="gst_message_new_reset_time">
        <doc xml:whitespace="preserve">This message is posted when the pipeline running-time should be reset to
@running_time, like after a flushing seek.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new reset_time message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested running-time</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment_done"
                   c:identifier="gst_message_new_segment_done">
        <doc xml:whitespace="preserve">Create a new segment done message. This message is posted by elements that
finish playback of a segment as a result of a segment seek. This message
is received by the application after all elements that posted a segment_start
have posted the segment_done.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new segment done message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the position being done</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">The position of the segment being done</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment_start"
                   c:identifier="gst_message_new_segment_start">
        <doc xml:whitespace="preserve">Create a new segment message. This message is posted by elements that
start playback of a segment as a result of a segment seek. This message
is not received by the application but is used for maintenance reasons in
container elements.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new segment start message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">The format of the position being played</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">The position of the segment being played</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_state_changed"
                   c:identifier="gst_message_new_state_changed">
        <doc xml:whitespace="preserve">Create a state change message. This message is posted whenever an element
changed its state.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new state change message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="oldstate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the previous state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
          <parameter name="newstate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new (current) state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
          <parameter name="pending" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pending (target) state</doc>
            <type name="State" c:type="GstState"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_state_dirty"
                   c:identifier="gst_message_new_state_dirty">
        <doc xml:whitespace="preserve">Create a state dirty message. This message is posted whenever an element
changed its state asynchronously and is used internally to update the
states of container objects.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new state dirty message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_step_done"
                   c:identifier="gst_message_new_step_done">
        <doc xml:whitespace="preserve">This message is posted by elements when they complete a part, when @intermediate set
to TRUE, or a complete step operation.

@duration will contain the amount of time (in GST_FORMAT_TIME) of the stepped
@amount of media in format @format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new step_done message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of @amount</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="amount" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount of stepped data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the stepped amount</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an flushing step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="intermediate" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an intermediate step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="eos" transfer-ownership="none">
            <doc xml:whitespace="preserve">the step caused EOS</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_step_start"
                   c:identifier="gst_message_new_step_start">
        <doc xml:whitespace="preserve">This message is posted by elements when they accept or activate a new step
event for @amount in @format. 

@active is set to FALSE when the element accepted the new step event and has
queued it for execution in the streaming threads.

@active is set to TRUE when the element has activated the step operation and
is now ready to start executing the step in the streaming thread. After this
message is emited, the application can queue a new step operation in the
element.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new step_start message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">if the step is active or queued</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of @amount</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="amount" transfer-ownership="none">
            <doc xml:whitespace="preserve">the amount of stepped data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the stepped amount</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an flushing step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="intermediate" transfer-ownership="none">
            <doc xml:whitespace="preserve">is this an intermediate step</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_stream_start"
                   c:identifier="gst_message_new_stream_start">
        <doc xml:whitespace="preserve">Create a new stream_start message. This message is generated and posted in
the sink elements of a GstBin. The bin will only forward the STREAM_START
message to the application if all sinks have posted an STREAM_START message.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new stream_start message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_stream_status"
                   c:identifier="gst_message_new_stream_status">
        <doc xml:whitespace="preserve">Create a new stream status message. This message is posted when a streaming
thread is created/destroyed or when the state changed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new stream status message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The stream status type.</doc>
            <type name="StreamStatusType" c:type="GstStreamStatusType"/>
          </parameter>
          <parameter name="owner" transfer-ownership="none">
            <doc xml:whitespace="preserve">the owner element of @src.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_structure_change"
                   c:identifier="gst_message_new_structure_change">
        <doc xml:whitespace="preserve">Create a new structure change message. This message is posted when the
structure of a pipeline is in the process of being changed, for example
when pads are linked or unlinked.

@src should be the sinkpad that unlinked or linked.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new structure change message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The change type.</doc>
            <type name="StructureChangeType" c:type="GstStructureChangeType"/>
          </parameter>
          <parameter name="owner" transfer-ownership="none">
            <doc xml:whitespace="preserve">The owner element of @src.</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="busy" transfer-ownership="none">
            <doc xml:whitespace="preserve">Whether the structure change is busy.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_tag" c:identifier="gst_message_new_tag">
        <doc xml:whitespace="preserve">Create a new tag message. The message will take ownership of the tag list.
The message is posted by elements that discovered a new taglist.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new tag message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="tag_list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the tag list for the message.</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_toc" c:identifier="gst_message_new_toc">
        <doc xml:whitespace="preserve">Create a new TOC message. The message is posted by elements
that discovered or updated a TOC.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new TOC message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="toc" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstToc structure for the message.</doc>
            <type name="Toc" c:type="GstToc*"/>
          </parameter>
          <parameter name="updated" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether TOC was updated or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_warning" c:identifier="gst_message_new_warning">
        <doc xml:whitespace="preserve">Create a new warning message. The message will make copies of @error and
@debug.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The new warning message.  MT safe.</doc>
          <type name="Message" c:type="GstMessage*"/>
        </return-value>
        <parameters>
          <parameter name="src" transfer-ownership="none">
            <doc xml:whitespace="preserve">The object originating the message.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">The GError for this message.</doc>
            <type name="GLib.Error" c:type="GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none">
            <doc xml:whitespace="preserve">A debugging string.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_seqnum" c:identifier="gst_message_get_seqnum">
        <doc xml:whitespace="preserve">Retrieve the sequence number of a message.

Messages have ever-incrementing sequence numbers, which may also be set
explicitly via gst_message_set_seqnum(). Sequence numbers are typically used
to indicate that a message corresponds to some other set of messages or
events, for example a SEGMENT_DONE message corresponding to a SEEK event. It
is considered good practice to make this correspondence when possible, though
it is not required.

Note that events and messages share the same sequence number incrementor;
two events or messages will never have the same sequence number unless
that correspondence was made explicitly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The message's sequence number.  MT safe.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_stream_status_object"
              c:identifier="gst_message_get_stream_status_object">
        <doc xml:whitespace="preserve">Extracts the object managing the streaming thread from @message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue containing the object that manages the streaming thread. This object is usually of type GstTask but other types can be added in the future. The object remains valid as long as @message is valid.</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_message_get_structure">
        <doc xml:whitespace="preserve">Access the structure of the message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The structure of the message. The structure is still owned by the message, which means that you should not free it and that the pointer becomes invalid when you free the message.  MT safe.</doc>
          <type name="Structure" c:type="const GstStructure*"/>
        </return-value>
      </method>
      <method name="has_name" c:identifier="gst_message_has_name">
        <doc xml:whitespace="preserve">Checks if @message has the given @name. This function is usually used to
check the name of a custom message.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @name matches the name of the message structure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name to check</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_async_done"
              c:identifier="gst_message_parse_async_done">
        <doc xml:whitespace="preserve">Extract the running_time from the async_done message.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="running_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the running_time or NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering"
              c:identifier="gst_message_parse_buffering">
        <doc xml:whitespace="preserve">Extracts the buffering percent from the GstMessage. see also
gst_message_new_buffering().

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="percent"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Return location for the percent.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering_stats"
              c:identifier="gst_message_parse_buffering_stats">
        <doc xml:whitespace="preserve">Extracts the buffering stats values from @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a buffering mode, or NULL</doc>
            <type name="BufferingMode" c:type="GstBufferingMode*"/>
          </parameter>
          <parameter name="avg_in"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average input rate, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="avg_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average output rate, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="buffering_left"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">amount of buffering time left in milliseconds, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_clock_lost"
              c:identifier="gst_message_parse_clock_lost">
        <doc xml:whitespace="preserve">Extracts the lost clock from the GstMessage.
The clock object returned remains valid until the message is freed.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold the lost clock</doc>
            <type name="Clock" c:type="GstClock**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_clock_provide"
              c:identifier="gst_message_parse_clock_provide">
        <doc xml:whitespace="preserve">Extracts the clock and ready flag from the GstMessage.
The clock object returned remains valid until the message is freed.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to  hold a clock object, or NULL</doc>
            <type name="Clock" c:type="GstClock**"/>
          </parameter>
          <parameter name="ready"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold the ready flag, or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_error" c:identifier="gst_message_parse_error">
        <doc xml:whitespace="preserve">Extracts the GError and debug string from the GstMessage. The values returned
in the output arguments are copies; the caller must free them when done.

Typical usage of this function might be:
|[
  ...
  switch (GST_MESSAGE_TYPE (msg)) {
    case GST_MESSAGE_ERROR: {
      GError *err = NULL;
      gchar *dbg_info = NULL;
      
      gst_message_parse_error (msg, &amp;amp;err, &amp;amp;dbg_info);
      g_printerr ("ERROR from element %s: %s\n",
          GST_OBJECT_NAME (msg-&gt;src), err-&gt;message);
      g_printerr ("Debugging info: %s\n", (dbg_info) ? dbg_info : "none");
      g_error_free (err);
      g_free (dbg_info);
      break;
    }
    ...
  }
  ...
]|

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gerror"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="debug"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the debug message, or NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_info" c:identifier="gst_message_parse_info">
        <doc xml:whitespace="preserve">Extracts the GError and debug string from the GstMessage. The values returned
in the output arguments are copies; the caller must free them when done.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gerror"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="debug"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the debug message, or NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_new_clock"
              c:identifier="gst_message_parse_new_clock">
        <doc xml:whitespace="preserve">Extracts the new clock from the GstMessage.
The clock object returned remains valid until the message is freed.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold the selected new clock</doc>
            <type name="Clock" c:type="GstClock**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_progress" c:identifier="gst_message_parse_progress">
        <doc xml:whitespace="preserve">Parses the progress @type, @code and @text.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the type</doc>
            <type name="ProgressType" c:type="GstProgressType*"/>
          </parameter>
          <parameter name="code"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the code</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="text"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the text</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos" c:identifier="gst_message_parse_qos">
        <doc xml:whitespace="preserve">Extract the timestamps and live status from the QoS message.

The returned values give the running_time, stream_time, timestamp and
duration of the dropped buffer. Values of GST_CLOCK_TIME_NONE mean unknown
values.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if the message was generated by a live element</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="running_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the running time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="stream_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the stream time of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the timestamps of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the duration of the buffer that generated the message</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos_stats"
              c:identifier="gst_message_parse_qos_stats">
        <doc xml:whitespace="preserve">Extract the QoS stats representing the history of the current continuous
pipeline playback period.

When @format is @GST_FORMAT_UNDEFINED both @dropped and @processed are
invalid. Values of -1 for either @processed or @dropped mean unknown values.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Units of the 'processed' and 'dropped' fields. Video sinks and video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks and audio filters will likely use GST_FORMAT_DEFAULT (samples).</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="processed"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Total number of units correctly processed since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="dropped"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Total number of units dropped since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_qos_values"
              c:identifier="gst_message_parse_qos_values">
        <doc xml:whitespace="preserve">Extract the QoS values that have been calculated/analysed from the QoS data

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">The difference of the running-time against the deadline.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="proportion"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Long term prediction of the ideal rate relative to normal rate to get optimal quality.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="quality"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">An element dependent integer value that specifies the current quality level of the element. The default maximum quality is 1000000.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_request_state"
              c:identifier="gst_message_parse_request_state">
        <doc xml:whitespace="preserve">Extract the requested state from the request_state message.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the requested state or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_reset_time"
              c:identifier="gst_message_parse_reset_time">
        <doc xml:whitespace="preserve">Extract the running-time from the RESET_TIME message.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="running_time"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the running_time or NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment_done"
              c:identifier="gst_message_parse_segment_done">
        <doc xml:whitespace="preserve">Extracts the position and format from the segment start message.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the format, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the position, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment_start"
              c:identifier="gst_message_parse_segment_start">
        <doc xml:whitespace="preserve">Extracts the position and format from the segment start message.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the format, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Result location for the position, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_state_changed"
              c:identifier="gst_message_parse_state_changed">
        <doc xml:whitespace="preserve">Extracts the old and new states from the GstMessage.

Typical usage of this function might be:
|[
  ...
  switch (GST_MESSAGE_TYPE (msg)) {
    case GST_MESSAGE_STATE_CHANGED: {
      GstState old_state, new_state;
      
      gst_message_parse_state_changed (msg, &amp;amp;old_state, &amp;amp;new_state, NULL);
      g_print ("Element %s changed state from %s to %s.\n",
          GST_OBJECT_NAME (msg-&gt;src),
          gst_element_state_get_name (old_state),
          gst_element_state_get_name (new_state));
      break;
    }
    ...
  }
  ...
]|

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="oldstate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the previous state, or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="newstate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the new (current) state, or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
          <parameter name="pending"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the pending (target) state, or NULL</doc>
            <type name="State" c:type="GstState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_step_done"
              c:identifier="gst_message_parse_step_done">
        <doc xml:whitespace="preserve">Extract the values the step_done message.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="amount"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the amount</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the rate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="flush"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the flush flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="intermediate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the intermediate flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the duration</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="eos"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the EOS flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_step_start"
              c:identifier="gst_message_parse_step_start">
        <doc xml:whitespace="preserve">Extract the values from step_start message.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="active"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the active flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="amount"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the amount</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the rate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="flush"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the flush flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="intermediate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">result location for the intermediate flag</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_stream_status"
              c:identifier="gst_message_parse_stream_status">
        <doc xml:whitespace="preserve">Extracts the stream status type and owner the GstMessage. The returned
owner remains valid for as long as the reference to @message is valid and
should thus not be unreffed.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to hold the status type</doc>
            <type name="StreamStatusType" c:type="GstStreamStatusType*"/>
          </parameter>
          <parameter name="owner"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">The owner element of the message source</doc>
            <type name="Element" c:type="GstElement**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_structure_change"
              c:identifier="gst_message_parse_structure_change">
        <doc xml:whitespace="preserve">Extracts the change type and completion status from the GstMessage.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to hold the change type</doc>
            <type name="StructureChangeType" c:type="GstStructureChangeType*"/>
          </parameter>
          <parameter name="owner"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">The owner element of the message source</doc>
            <type name="Element" c:type="GstElement**"/>
          </parameter>
          <parameter name="busy"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to hold whether the change is in progress or has been completed</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_tag" c:identifier="gst_message_parse_tag">
        <doc xml:whitespace="preserve">Extracts the tag list from the GstMessage. The tag list returned in the
output argument is a copy; the caller must free it when done.

Typical usage of this function might be:
|[
  ...
  switch (GST_MESSAGE_TYPE (msg)) {
    case GST_MESSAGE_TAG: {
      GstTagList *tags = NULL;
      
      gst_message_parse_tag (msg, &amp;amp;tags);
      g_print ("Got tags from element %s\n", GST_OBJECT_NAME (msg-&gt;src));
      handle_tags (tags);
      gst_tag_list_unref (tags);
      break;
    }
    ...
  }
  ...
]|

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tag_list"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the tag-list.</doc>
            <type name="TagList" c:type="GstTagList**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_toc" c:identifier="gst_message_parse_toc">
        <doc xml:whitespace="preserve">Extract thef TOC from the #GstMessage. The TOC returned in the
output argument is a copy; the caller must free it with
gst_toc_unref() when done.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="toc"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the TOC.</doc>
            <type name="Toc" c:type="GstToc**"/>
          </parameter>
          <parameter name="updated"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">return location for the updated flag.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_warning" c:identifier="gst_message_parse_warning">
        <doc xml:whitespace="preserve">Extracts the GError and debug string from the GstMessage. The values returned
in the output arguments are copies; the caller must free them when done.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="gerror"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the GError</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="debug"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">location for the debug message, or NULL</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_stats"
              c:identifier="gst_message_set_buffering_stats">
        <doc xml:whitespace="preserve">Configures the buffering stats values in @message.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffering mode</doc>
            <type name="BufferingMode" c:type="GstBufferingMode"/>
          </parameter>
          <parameter name="avg_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="avg_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffering_left" transfer-ownership="none">
            <doc xml:whitespace="preserve">amount of buffering time left in milliseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_stats" c:identifier="gst_message_set_qos_stats">
        <doc xml:whitespace="preserve">Set the QoS stats representing the history of the current continuous pipeline
playback period.

When @format is @GST_FORMAT_UNDEFINED both @dropped and @processed are
invalid. Values of -1 for either @processed or @dropped mean unknown values.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">Units of the 'processed' and 'dropped' fields. Video sinks and video filters will use GST_FORMAT_BUFFERS (frames). Audio sinks and audio filters will likely use GST_FORMAT_DEFAULT (samples).</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="processed" transfer-ownership="none">
            <doc xml:whitespace="preserve">Total number of units correctly processed since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="dropped" transfer-ownership="none">
            <doc xml:whitespace="preserve">Total number of units dropped since the last state change to READY or a flushing operation.</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_values" c:identifier="gst_message_set_qos_values">
        <doc xml:whitespace="preserve">Set the QoS values that have been calculated/analysed from the QoS data

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="jitter" transfer-ownership="none">
            <doc xml:whitespace="preserve">The difference of the running-time against the deadline.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:whitespace="preserve">Long term prediction of the ideal rate relative to normal rate to get optimal quality.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="quality" transfer-ownership="none">
            <doc xml:whitespace="preserve">An element dependent integer value that specifies the current quality level of the element. The default maximum quality is 1000000.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seqnum" c:identifier="gst_message_set_seqnum">
        <doc xml:whitespace="preserve">Set the sequence number of a message.

This function might be called by the creator of a message to indicate that
the message relates to other messages or events. See gst_message_get_seqnum()
for more information.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="seqnum" transfer-ownership="none">
            <doc xml:whitespace="preserve">A sequence number.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stream_status_object"
              c:identifier="gst_message_set_stream_status_object">
        <doc xml:whitespace="preserve">Configures the object handling the streaming thread. This is usually a
GstTask object but other objects might be added in the future.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object controlling the streaming</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <function name="type_get_name" c:identifier="gst_message_type_get_name">
        <doc xml:whitespace="preserve">Get a printable name for the given message type. Do not modify or free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a reference to the static name of the message.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message type</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_to_quark" c:identifier="gst_message_type_to_quark">
        <doc xml:whitespace="preserve">Get the unique quark for the given message type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark associated with the message type</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the message type</doc>
            <type name="MessageType" c:type="GstMessageType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="MessageType" c:type="GstMessageType">
      <doc xml:whitespace="preserve">The different message types that are available.</doc>
      <member name="unknown" value="0" c:identifier="GST_MESSAGE_UNKNOWN">
        <doc xml:whitespace="preserve">an undefined message</doc>
      </member>
      <member name="eos" value="1" c:identifier="GST_MESSAGE_EOS">
        <doc xml:whitespace="preserve">end-of-stream reached in a pipeline. The application will only receive this message in the PLAYING state and every time it sets a pipeline to PLAYING that is in the EOS state. The application can perform a flushing seek in the pipeline, which will undo the EOS state again.</doc>
      </member>
      <member name="error" value="2" c:identifier="GST_MESSAGE_ERROR">
        <doc xml:whitespace="preserve">an error occured. When the application receives an error message it should stop playback of the pipeline and not assume that more data will be played.</doc>
      </member>
      <member name="warning" value="4" c:identifier="GST_MESSAGE_WARNING">
        <doc xml:whitespace="preserve">a warning occured.</doc>
      </member>
      <member name="info" value="8" c:identifier="GST_MESSAGE_INFO">
        <doc xml:whitespace="preserve">an info message occured</doc>
      </member>
      <member name="tag" value="16" c:identifier="GST_MESSAGE_TAG">
        <doc xml:whitespace="preserve">a tag was found.</doc>
      </member>
      <member name="buffering" value="32" c:identifier="GST_MESSAGE_BUFFERING">
        <doc xml:whitespace="preserve">the pipeline is buffering. When the application receives a buffering message in the PLAYING state for a non-live pipeline it must PAUSE the pipeline until the buffering completes, when the percentage field in the message is 100%. For live pipelines, no action must be performed and the buffering percentage can be used to inform the user about the progress.</doc>
      </member>
      <member name="state_changed"
              value="64"
              c:identifier="GST_MESSAGE_STATE_CHANGED">
        <doc xml:whitespace="preserve">a state change happened</doc>
      </member>
      <member name="state_dirty"
              value="128"
              c:identifier="GST_MESSAGE_STATE_DIRTY">
        <doc xml:whitespace="preserve">an element changed state in a streaming thread. This message is deprecated.</doc>
      </member>
      <member name="step_done"
              value="256"
              c:identifier="GST_MESSAGE_STEP_DONE">
        <doc xml:whitespace="preserve">a stepping operation finished.</doc>
      </member>
      <member name="clock_provide"
              value="512"
              c:identifier="GST_MESSAGE_CLOCK_PROVIDE">
        <doc xml:whitespace="preserve">an element notifies its capability of providing a clock. This message is used internally and never forwarded to the application.</doc>
      </member>
      <member name="clock_lost"
              value="1024"
              c:identifier="GST_MESSAGE_CLOCK_LOST">
        <doc xml:whitespace="preserve">The current clock as selected by the pipeline became unusable. The pipeline will select a new clock on the next PLAYING state change. The application should set the pipeline to PAUSED and back to PLAYING when this message is received.</doc>
      </member>
      <member name="new_clock"
              value="2048"
              c:identifier="GST_MESSAGE_NEW_CLOCK">
        <doc xml:whitespace="preserve">a new clock was selected in the pipeline.</doc>
      </member>
      <member name="structure_change"
              value="4096"
              c:identifier="GST_MESSAGE_STRUCTURE_CHANGE">
        <doc xml:whitespace="preserve">the structure of the pipeline changed. This message is used internally and never forwarded to the application.</doc>
      </member>
      <member name="stream_status"
              value="8192"
              c:identifier="GST_MESSAGE_STREAM_STATUS">
        <doc xml:whitespace="preserve">status about a stream, emitted when it starts, stops, errors, etc..</doc>
      </member>
      <member name="application"
              value="16384"
              c:identifier="GST_MESSAGE_APPLICATION">
        <doc xml:whitespace="preserve">message posted by the application, possibly via an application-specific element.</doc>
      </member>
      <member name="element" value="32768" c:identifier="GST_MESSAGE_ELEMENT">
        <doc xml:whitespace="preserve">element-specific message, see the specific element's documentation</doc>
      </member>
      <member name="segment_start"
              value="65536"
              c:identifier="GST_MESSAGE_SEGMENT_START">
        <doc xml:whitespace="preserve">pipeline started playback of a segment. This message is used internally and never forwarded to the application.</doc>
      </member>
      <member name="segment_done"
              value="131072"
              c:identifier="GST_MESSAGE_SEGMENT_DONE">
        <doc xml:whitespace="preserve">pipeline completed playback of a segment. This message is forwarded to the application after all elements that posted @GST_MESSAGE_SEGMENT_START posted a GST_MESSAGE_SEGMENT_DONE message.</doc>
      </member>
      <member name="duration_changed"
              value="262144"
              c:identifier="GST_MESSAGE_DURATION_CHANGED">
        <doc xml:whitespace="preserve">The duration of a pipeline changed. The application can get the new duration with a duration query.</doc>
      </member>
      <member name="latency" value="524288" c:identifier="GST_MESSAGE_LATENCY">
        <doc xml:whitespace="preserve">Posted by elements when their latency changes. The application should recalculate and distribute a new latency.</doc>
      </member>
      <member name="async_start"
              value="1048576"
              c:identifier="GST_MESSAGE_ASYNC_START">
        <doc xml:whitespace="preserve">Posted by elements when they start an ASYNC #GstStateChange. This message is not forwarded to the application but is used internally.</doc>
      </member>
      <member name="async_done"
              value="2097152"
              c:identifier="GST_MESSAGE_ASYNC_DONE">
        <doc xml:whitespace="preserve">Posted by elements when they complete an ASYNC #GstStateChange. The application will only receive this message from the toplevel pipeline.</doc>
      </member>
      <member name="request_state"
              value="4194304"
              c:identifier="GST_MESSAGE_REQUEST_STATE">
        <doc xml:whitespace="preserve">Posted by elements when they want the pipeline to change state. This message is a suggestion to the application which can decide to perform the state change on (part of) the pipeline.</doc>
      </member>
      <member name="step_start"
              value="8388608"
              c:identifier="GST_MESSAGE_STEP_START">
        <doc xml:whitespace="preserve">A stepping operation was started.</doc>
      </member>
      <member name="qos" value="16777216" c:identifier="GST_MESSAGE_QOS">
        <doc xml:whitespace="preserve">A buffer was dropped or an element changed its processing strategy for Quality of Service reasons.</doc>
      </member>
      <member name="progress"
              value="33554432"
              c:identifier="GST_MESSAGE_PROGRESS">
        <doc xml:whitespace="preserve">A progress message.</doc>
      </member>
      <member name="toc" value="67108864" c:identifier="GST_MESSAGE_TOC">
        <doc xml:whitespace="preserve">A new table of contents (TOC) was found or previously found TOC was updated.</doc>
      </member>
      <member name="reset_time"
              value="134217728"
              c:identifier="GST_MESSAGE_RESET_TIME">
        <doc xml:whitespace="preserve">Message to request resetting the pipeline's running time from the pipeline. This is an internal message which applications will likely never receive.</doc>
      </member>
      <member name="stream_start"
              value="268435456"
              c:identifier="GST_MESSAGE_STREAM_START">
        <doc xml:whitespace="preserve">Message indicating start of a new stream. Useful e.g. when using playbin in gapless playback mode, to get notified when the next title actually starts playing (which will be some time after the URI for the next title has been set).</doc>
      </member>
      <member name="any" value="-1" c:identifier="GST_MESSAGE_ANY">
        <doc xml:whitespace="preserve">mask for all of the above messages.</doc>
      </member>
    </bitfield>
    <record name="Meta" c:type="GstMeta">
      <doc xml:whitespace="preserve">The #GstMeta structure should be included as the first member of a #GstBuffer
metadata structure. The structure defines the API of the metadata and should
be accessible to all elements using the metadata.

A metadata API is registered with gst_meta_api_type_register() which takes a
name for the metadata API and some tags associated with the metadata.
With gst_meta_api_type_has_tag() one can check if a certain metadata API
contains a given tag.

Multiple implementations of a metadata API can be registered.
To implement a metadata API, gst_meta_register() should be used. This
function takes all parameters needed to create, free and transform metadata
along with the size of the metadata. The function returns a #GstMetaInfo
structure that contains the information for the implementation of the API.

A specific implementation can be retrieved by name with gst_meta_get_info().

See #GstBuffer for how the metadata can be added, retrieved and removed from
buffers.

Last reviewed on 2012-03-28 (0.11.3)</doc>
      <field name="flags" writable="1">
        <type name="MetaFlags" c:type="GstMetaFlags"/>
      </field>
      <field name="info" writable="1">
        <type name="MetaInfo" c:type="const GstMetaInfo*"/>
      </field>
      <function name="api_type_has_tag"
                c:identifier="gst_meta_api_type_has_tag">
        <doc xml:whitespace="preserve">Check if @api was registered with @tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @api was registered with @tag.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="api" transfer-ownership="none">
            <doc xml:whitespace="preserve">an API</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the tag to check</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </function>
      <function name="api_type_register"
                c:identifier="gst_meta_api_type_register">
        <doc xml:whitespace="preserve">Register and return a GType for the @api and associate it with
@tags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a unique GType for @api.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="api" transfer-ownership="none">
            <doc xml:whitespace="preserve">an API to register</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="tags" transfer-ownership="none">
            <doc xml:whitespace="preserve">tags for @api</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_info" c:identifier="gst_meta_get_info">
        <doc xml:whitespace="preserve">Lookup a previously registered meta info structure by its implementation name
@impl.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMetaInfo with @impl, or #NULL when no such metainfo exists.</doc>
          <type name="MetaInfo" c:type="const GstMetaInfo*"/>
        </return-value>
        <parameters>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register" c:identifier="gst_meta_register">
        <doc xml:whitespace="preserve">Register a new #GstMeta implementation.

The same @info can be retrieved later with gst_meta_get_info() by using
@impl as the key.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMetaInfo that can be used to access metadata.</doc>
          <type name="MetaInfo" c:type="const GstMetaInfo*"/>
        </return-value>
        <parameters>
          <parameter name="api" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of the #GstMeta API</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="impl" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the #GstMeta implementation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size of the #GstMeta structure</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="init_func" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">a #GstMetaInitFunction</doc>
            <type name="MetaInitFunction" c:type="GstMetaInitFunction"/>
          </parameter>
          <parameter name="free_func" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">a #GstMetaFreeFunction</doc>
            <type name="MetaFreeFunction" c:type="GstMetaFreeFunction"/>
          </parameter>
          <parameter name="transform_func"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">a #GstMetaTransformFunction</doc>
            <type name="MetaTransformFunction"
                  c:type="GstMetaTransformFunction"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="MetaFlags" c:type="GstMetaFlags">
      <doc xml:whitespace="preserve">Extra metadata flags.</doc>
      <member name="none" value="0" c:identifier="GST_META_FLAG_NONE">
        <doc xml:whitespace="preserve">no flags</doc>
      </member>
      <member name="readonly" value="1" c:identifier="GST_META_FLAG_READONLY">
        <doc xml:whitespace="preserve">metadata should not be modified</doc>
      </member>
      <member name="pooled" value="2" c:identifier="GST_META_FLAG_POOLED">
        <doc xml:whitespace="preserve">metadata is managed by a bufferpool</doc>
      </member>
      <member name="locked" value="4" c:identifier="GST_META_FLAG_LOCKED">
        <doc xml:whitespace="preserve">metadata should not be removed</doc>
      </member>
      <member name="last" value="65536" c:identifier="GST_META_FLAG_LAST">
        <doc xml:whitespace="preserve">additional flags can be added starting from this flag.</doc>
      </member>
    </bitfield>
    <callback name="MetaFreeFunction" c:type="GstMetaFreeFunction">
      <doc xml:whitespace="preserve">Function called when @meta is freed in @buffer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="meta" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMeta</doc>
          <type name="Meta" c:type="GstMeta*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="MetaInfo" c:type="GstMetaInfo">
      <doc xml:whitespace="preserve">The #GstMetaInfo provides information about a specific metadata
structure.</doc>
      <field name="api" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="size" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="init_func" writable="1">
        <type name="MetaInitFunction" c:type="GstMetaInitFunction"/>
      </field>
      <field name="free_func" writable="1">
        <type name="MetaFreeFunction" c:type="GstMetaFreeFunction"/>
      </field>
      <field name="transform_func" writable="1">
        <type name="MetaTransformFunction" c:type="GstMetaTransformFunction"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="MetaInitFunction" c:type="GstMetaInitFunction">
      <doc xml:whitespace="preserve">Function called when @meta is initialized in @buffer.</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="meta" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMeta</doc>
          <type name="Meta" c:type="GstMeta*"/>
        </parameter>
        <parameter name="params" transfer-ownership="none">
          <doc xml:whitespace="preserve">parameters passed to the init function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="MetaTransformCopy" c:type="GstMetaTransformCopy">
      <doc xml:whitespace="preserve">Extra data passed to a "gst-copy" transform #GstMetaTransformFunction.</doc>
      <field name="region" writable="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="offset" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="size" writable="1">
        <type name="gsize" c:type="gsize"/>
      </field>
    </record>
    <callback name="MetaTransformFunction" c:type="GstMetaTransformFunction">
      <doc xml:whitespace="preserve">Function called for each @meta in @buffer as a result of performing a
transformation on @transbuf. Additional @type specific transform data
is passed to the function as @data.

Implementations should check the @type of the transform and parse
additional type specific fields in @data that should be used to update
the metadata on @transbuf.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the transform could be performed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="transbuf" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="meta" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstMeta</doc>
          <type name="Meta" c:type="GstMeta*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstBuffer</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the transform type</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">transform specific data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="MiniObject" c:type="GstMiniObject">
      <doc xml:whitespace="preserve">#GstMiniObject is a simple structure that can be used to implement refcounted
types.

Subclasses will include #GstMiniObject as the first member in their structure
and then call gst_mini_object_init() to initialize the #GstMiniObject fields.

gst_mini_object_ref() and gst_mini_object_unref() increment and decrement the
refcount respectively. When the refcount of a mini-object reaches 0, the
dispose function is called first and when this returns %TRUE, the free
function of the miniobject is called.

A copy can be made with gst_mini_object_copy().

gst_mini_object_is_writable() will return %TRUE when the refcount of the
object is exactly 1, meaning the current caller has the only reference to the
object. gst_mini_object_make_writable() will return a writable version of the
object, which might be a new copy when the refcount was not 1.

Opaque data can be associated with a #GstMiniObject with
gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
meant to be specific to the particular object and is not automatically copied
with gst_mini_object_copy() or similar methods.

A weak reference can be added and remove with gst_mini_object_weak_ref()
and gst_mini_object_weak_unref() respectively.

Last reviewed on 2012-06-15 (0.11.93)</doc>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="refcount" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="lockstate" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="flags" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="copy" introspectable="0" writable="1">
        <type name="MiniObjectCopyFunction"
              c:type="GstMiniObjectCopyFunction"/>
      </field>
      <field name="dispose" writable="1">
        <type name="MiniObjectDisposeFunction"
              c:type="GstMiniObjectDisposeFunction"/>
      </field>
      <field name="free" writable="1">
        <type name="MiniObjectFreeFunction"
              c:type="GstMiniObjectFreeFunction"/>
      </field>
      <field name="n_qdata" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="qdata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <method name="copy"
              c:identifier="gst_mini_object_copy"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a copy of the mini-object.

MT safe</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new mini-object.</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
      </method>
      <method name="get_qdata" c:identifier="gst_mini_object_get_qdata">
        <doc xml:whitespace="preserve">This function gets back user data pointers stored via
gst_mini_object_set_qdata().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="init"
              c:identifier="gst_mini_object_init"
              introspectable="0">
        <doc xml:whitespace="preserve">Initializes a mini-object with the desired type and copy/dispose/free
functions.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">initial #GstMiniObjectFlags</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GType of the mini-object to create</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="copy_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the copy function, or NULL</doc>
            <type name="MiniObjectCopyFunction"
                  c:type="GstMiniObjectCopyFunction"/>
          </parameter>
          <parameter name="dispose_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the dispose function, or NULL</doc>
            <type name="MiniObjectDisposeFunction"
                  c:type="GstMiniObjectDisposeFunction"/>
          </parameter>
          <parameter name="free_func" transfer-ownership="none">
            <doc xml:whitespace="preserve">the free function or NULL</doc>
            <type name="MiniObjectFreeFunction"
                  c:type="GstMiniObjectFreeFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_writable" c:identifier="gst_mini_object_is_writable">
        <doc xml:whitespace="preserve">If @mini_object has the LOCKABLE flag set, check if the current EXCLUSIVE
lock on @object is the only one, this means that changes to the object will
not be visible to any other object.

If the LOCKABLE flag is not set, check if the refcount of @mini_object is
exactly 1, meaning that no other reference exists to the object and that the
object is therefore writable.

Modification of a mini-object should only be done after verifying that it
is writable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the object is writable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="lock" c:identifier="gst_mini_object_lock">
        <doc xml:whitespace="preserve">Lock the mini-object with the specified access mode in @flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @object could be locked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstLockFlags</doc>
            <type name="LockFlags" c:type="GstLockFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="make_writable"
              c:identifier="gst_mini_object_make_writable"
              introspectable="0">
        <doc xml:whitespace="preserve">Checks if a mini-object is writable.  If not, a writable copy is made and
returned.  This gives away the reference to the original mini object,
and returns a reference to the new object.

MT safe</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a mini-object (possibly the same pointer) that is writable.</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="gst_mini_object_ref" introspectable="0">
        <doc xml:whitespace="preserve">Increase the reference count of the mini-object.

Note that the refcount affects the writeability
of @mini-object, see gst_mini_object_is_writable(). It is
important to note that keeping additional references to
GstMiniObject instances can potentially increase the number
of memcpy operations in a pipeline, especially if the miniobject
is a #GstBuffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the mini-object.</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
      </method>
      <method name="set_qdata" c:identifier="gst_mini_object_set_qdata">
        <doc xml:whitespace="preserve">This sets an opaque, named pointer on a miniobject.
The name is specified through a #GQuark (retrived e.g. via
g_quark_from_static_string()), and the pointer
can be gotten back from the @object with gst_mini_object_get_qdata()
until the @object is disposed.
Setting a previously set user data pointer, overrides (frees)
the old pointer set, using #NULL as pointer essentially
removes the data stored.

@destroy may be specified which is called with @data as argument
when the @object is disposed, or the data is being overwritten by
a call to gst_mini_object_set_qdata() with the same @quark.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">An opaque user data pointer</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">Function to invoke with @data as argument, when @data needs to be freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="steal_qdata" c:identifier="gst_mini_object_steal_qdata">
        <doc xml:whitespace="preserve">This function gets back user data pointers stored via gst_mini_object_set_qdata()
and removes the data from @object without invoking its destroy() function (if
any was set).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">The user data pointer set, or %NULL</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GQuark, naming the user data pointer</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlock" c:identifier="gst_mini_object_unlock">
        <doc xml:whitespace="preserve">Unlock the mini-object with the specified access mode in @flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstLockFlags</doc>
            <type name="LockFlags" c:type="GstLockFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="gst_mini_object_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of the mini-object, possibly freeing
the mini-object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="weak_ref"
              c:identifier="gst_mini_object_weak_ref"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds a weak reference callback to a mini object. Weak references are
used for notification when a mini object is finalized. They are called
"weak references" because they allow you to safely hold a pointer
to the mini object without calling gst_mini_object_ref()
(gst_mini_object_ref() adds a strong reference, that is, forces the object
to stay alive).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">callback to invoke before the mini object is freed</doc>
            <type name="MiniObjectNotify" c:type="GstMiniObjectNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">extra data to pass to notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="weak_unref"
              c:identifier="gst_mini_object_weak_unref"
              introspectable="0">
        <doc xml:whitespace="preserve">Removes a weak reference callback from a mini object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="notify" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">callback to search for</doc>
            <type name="MiniObjectNotify" c:type="GstMiniObjectNotify"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to search for</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <function name="replace" c:identifier="gst_mini_object_replace">
        <doc xml:whitespace="preserve">Atomically modifies a pointer to point to a new mini-object.
The reference count of @olddata is decreased and the reference count of
@newdata is increased.

Either @newdata and the value pointed to by @olddata may be NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @newdata was different from @olddata</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="olddata"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to a pointer to a mini-object to be replaced</doc>
            <type name="MiniObject" c:type="GstMiniObject**"/>
          </parameter>
          <parameter name="newdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to new mini-object</doc>
            <type name="MiniObject" c:type="GstMiniObject*"/>
          </parameter>
        </parameters>
      </function>
      <function name="steal"
                c:identifier="gst_mini_object_steal"
                introspectable="0">
        <doc xml:whitespace="preserve">Replace the current #GstMiniObject pointer to by @olddata with NULL and
return the old value.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the #GstMiniObject at @oldata</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </return-value>
        <parameters>
          <parameter name="olddata"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to a pointer to a mini-object to be stolen</doc>
            <type name="MiniObject" c:type="GstMiniObject**"/>
          </parameter>
        </parameters>
      </function>
      <function name="take" c:identifier="gst_mini_object_take">
        <doc xml:whitespace="preserve">Modifies a pointer to point to a new mini-object. The modification
is done atomically. This version is similar to gst_mini_object_replace()
except that it does not increase the refcount of @newdata and thus
takes ownership of @newdata.

Either @newdata and the value pointed to by @olddata may be NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @newdata was different from @olddata</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="olddata"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to a pointer to a mini-object to be replaced</doc>
            <type name="MiniObject" c:type="GstMiniObject**"/>
          </parameter>
          <parameter name="newdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to new mini-object</doc>
            <type name="MiniObject" c:type="GstMiniObject*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="MiniObjectCopyFunction"
              c:type="GstMiniObjectCopyFunction"
              introspectable="0">
      <doc xml:whitespace="preserve">Function prototype for methods to create copies of instances.</doc>
      <return-value>
        <doc xml:whitespace="preserve">reference to cloned instance.</doc>
        <type name="MiniObject" c:type="GstMiniObject*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">MiniObject to copy</doc>
          <type name="MiniObject" c:type="const GstMiniObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="MiniObjectDisposeFunction"
              c:type="GstMiniObjectDisposeFunction">
      <doc xml:whitespace="preserve">Function prototype for when a miniobject has lost its last refcount.
Implementation of the mini object are allowed to revive the
passed object by doing a gst_mini_object_ref(). If the object is not
revived after the dispose function, the function should return %TRUE
and the memory associated with the object is freed.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the object should be cleaned up.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">MiniObject to dispose</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="MiniObjectFlags" c:type="GstMiniObjectFlags">
      <doc xml:whitespace="preserve">Flags for the mini object</doc>
      <member name="lockable"
              value="1"
              c:identifier="GST_MINI_OBJECT_FLAG_LOCKABLE">
        <doc xml:whitespace="preserve">the object can be locked and unlocked with gst_mini_object_lock() and gst_mini_object_unlock().</doc>
      </member>
      <member name="lock_readonly"
              value="2"
              c:identifier="GST_MINI_OBJECT_FLAG_LOCK_READONLY">
        <doc xml:whitespace="preserve">the object is permanently locked in READONLY mode. Only read locks can be performed on the object.</doc>
      </member>
      <member name="last" value="16" c:identifier="GST_MINI_OBJECT_FLAG_LAST">
        <doc xml:whitespace="preserve">first flag that can be used by subclasses.</doc>
      </member>
    </bitfield>
    <callback name="MiniObjectFreeFunction" c:type="GstMiniObjectFreeFunction">
      <doc xml:whitespace="preserve">Virtual function prototype for methods to free ressources used by
mini-objects.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">MiniObject to free</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="MiniObjectNotify" c:type="GstMiniObjectNotify">
      <doc xml:whitespace="preserve">A #GstMiniObjectNotify function can be added to a mini object as a
callback that gets triggered when gst_mini_object_unref() drops the
last ref and @obj is about to be freed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" closure="0">
          <doc xml:whitespace="preserve">data that was provided when the notify was added</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:whitespace="preserve">the mini object</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="NSECOND" value="1" c:type="GST_NSECOND">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="GstObject"
           parent="GObject.InitiallyUnowned"
           abstract="1"
           glib:type-name="GstObject"
           glib:get-type="gst_object_get_type"
           glib:type-struct="ObjectClass">
      <doc xml:whitespace="preserve">#GstObject provides a root for the object hierarchy tree filed in by the
GStreamer library.  It is currently a thin wrapper on top of
#GInitiallyUnowned. It is an abstract class that is not very usable on its own.

#GstObject gives us basic refcounting, parenting functionality and locking.
Most of the function are just extended for special GStreamer needs and can be
found under the same name in the base class of #GstObject which is #GObject
(e.g. g_object_ref() becomes gst_object_ref()).

Since #GstObject dereives from #GInitiallyUnowned, it also inherits the
floating reference. Be aware that functions such as gst_bin_add() and
gst_element_add_pad() take ownership of the floating reference.

In contrast to #GObject instances, #GstObject adds a name property. The functions
gst_object_set_name() and gst_object_get_name() are used to set/get the name
of the object.

&lt;refsect2&gt;
&lt;title&gt;controlled properties&lt;/title&gt;
&lt;para&gt;
Controlled properties offers a lightweight way to adjust gobject
properties over stream-time. It works by using time-stamped value pairs that
are queued for element-properties. At run-time the elements continously pull
values changes for the current stream-time.

What needs to be changed in a #GstElement?
Very little - it is just two steps to make a plugin controllable!
&lt;orderedlist&gt;
  &lt;listitem&gt;&lt;para&gt;
    mark gobject-properties paramspecs that make sense to be controlled,
    by GST_PARAM_CONTROLLABLE.
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    when processing data (get, chain, loop function) at the beginning call
    gst_object_sync_values(element,timestamp).
    This will made the controller to update all gobject properties that are under
    control with the current values based on timestamp.
  &lt;/para&gt;&lt;/listitem&gt;
&lt;/orderedlist&gt;

What needs to be done in applications?
Again it's not a lot to change.
&lt;orderedlist&gt;
  &lt;listitem&gt;&lt;para&gt;
    create a #GstControlSource.
    csource = gst_interpolation_control_source_new ();
    g_object_set (csource, "mode", GST_INTERPOLATION_MODE_LINEAR, NULL);
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    Attach the #GstControlSource on the controller to a property.
    gst_object_add_control_binding (object, gst_direct_control_binding_new (object, "prop1", csource));
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    Set the control values
    gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,0 * GST_SECOND, value1);
    gst_timed_value_control_source_set ((GstTimedValueControlSource *)csource,1 * GST_SECOND, value2);
  &lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;
    start your pipeline
  &lt;/para&gt;&lt;/listitem&gt;
&lt;/orderedlist&gt;
&lt;/para&gt;
&lt;/refsect2&gt;

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <function name="check_uniqueness"
                c:identifier="gst_object_check_uniqueness">
        <doc xml:whitespace="preserve">Checks to see if there is any object named @name in @list. This function
does not do any locking of any kind. You might want to protect the
provided list with the lock of the owner of the list. This function
will lock each #GstObject in the list to compare the name, so be
carefull when passing a list with a locked object.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if a #GstObject named @name does not appear in @list, FALSE if it does.  MT safe. Grabs and releases the LOCK of each object in the list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a list of #GstObject to check through</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Object"/>
            </type>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name to search for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="default_deep_notify"
                c:identifier="gst_object_default_deep_notify">
        <doc xml:whitespace="preserve">A default deep_notify signal callback for an object. The user data
should contain a pointer to an array of strings that should be excluded
from the notify. The default handler will print the new value of the property
using g_print.

MT safe. This function grabs and releases @object's LOCK for getting its
         path string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GObject that signalled the notify.</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="orig" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject that initiated the notify.</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GParamSpec of the property.</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="excluded_props"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">a set of user-specified properties to exclude or NULL to show all changes.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </function>
      <function name="ref_sink"
                c:identifier="gst_object_ref_sink"
                introspectable="0">
        <doc xml:whitespace="preserve">Increase the reference count of @object, and possibly remove the floating
reference, if @object has a floating reference.

In other words, if the object is floating, then this call "assumes ownership"
of the floating reference, converting it to a normal reference by clearing
the floating flag while leaving the reference count unchanged. If the object
is not floating, then this call adds a new normal reference increasing the
reference count by one.</doc>
        <return-value>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject to sink</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="replace" c:identifier="gst_object_replace">
        <doc xml:whitespace="preserve">Atomically modifies a pointer to point to a new object.
The reference count of @oldobj is decreased and the reference count of
@newobj is increased.

Either @newobj and the value pointed to by @oldobj may be NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @newobj was different from @oldobj</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="oldobj"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">pointer to a place of a #GstObject to replace</doc>
            <type name="Object" c:type="GstObject**"/>
          </parameter>
          <parameter name="newobj" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new #GstObject</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="deep_notify">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="orig" transfer-ownership="none">
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_control_binding"
              c:identifier="gst_object_add_control_binding">
        <doc xml:whitespace="preserve">Sets the #GstControlBinding. If there already was a #GstControlBinding
for this property it will be replaced.
The @object will take ownership of the @binding.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if the given @binding has not been setup for this object  or %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="binding" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstControlBinding that should be used</doc>
            <type name="ControlBinding" c:type="GstControlBinding*"/>
          </parameter>
        </parameters>
      </method>
      <method name="default_error" c:identifier="gst_object_default_error">
        <doc xml:whitespace="preserve">A default error function that uses g_printerr() to display the error message
and the optional debug sting..

The default handler will simply print the error string using g_print.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="error" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GError.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
          <parameter name="debug" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">an additional debug information string, or NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_control_binding"
              c:identifier="gst_object_get_control_binding">
        <doc xml:whitespace="preserve">Gets the corresponding #GstControlBinding for the property. This should be
unreferenced again after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstControlBinding for @property_name or %NULL if the property is not controlled.</doc>
          <type name="ControlBinding" c:type="GstControlBinding*"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the property</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_control_rate"
              c:identifier="gst_object_get_control_rate">
        <doc xml:whitespace="preserve">Obtain the control-rate for this @object. Audio processing #GstElement
objects will use this rate to sub-divide their processing loop and call
gst_object_sync_values() inbetween. The length of the processing segment
should be up to @control-rate nanoseconds.

If the @object is not under property control, this will return
%GST_CLOCK_TIME_NONE. This allows the element to avoid the sub-dividing.

The control-rate is not expected to change if the element is in
%GST_STATE_PAUSED or %GST_STATE_PLAYING.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the control rate in nanoseconds</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="get_g_value_array"
              c:identifier="gst_object_get_g_value_array">
        <doc xml:whitespace="preserve">Gets a number of #GValues for the given controlled property starting at the
requested time. The array @values need to hold enough space for @n_values of
#GValue.

This function is useful if one wants to e.g. draw a graph of the control
curve or apply a control curve sample by sample.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">array to put control-values in</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="gst_object_get_name">
        <doc xml:whitespace="preserve">Returns a copy of the name of @object.
Caller should g_free() the return value after usage.
For a nameless object, this returns NULL, which you can safely g_free()
as well.

Free-function: g_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the name of @object. g_free() after usage.  MT safe. This function grabs and releases @object's LOCK.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_parent" c:identifier="gst_object_get_parent">
        <doc xml:whitespace="preserve">Returns the parent of @object. This function increases the refcount
of the parent object so you should gst_object_unref() it after usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">parent of @object, this can be NULL if @object has no parent. unref after usage.  MT safe. Grabs and releases @object's LOCK.</doc>
          <type name="Object" c:type="GstObject*"/>
        </return-value>
      </method>
      <method name="get_path_string" c:identifier="gst_object_get_path_string">
        <doc xml:whitespace="preserve">Generates a string describing the path of @object in
the object hierarchy. Only useful (or used) for debugging.

Free-function: g_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a string describing the path of @object. You must g_free() the string after usage.  MT safe. Grabs and releases the #GstObject's LOCK for all objects in the hierarchy.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_value" c:identifier="gst_object_get_value">
        <doc xml:whitespace="preserve">Gets the value for the given controlled property at the requested time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the GValue of the property at the given time, or %NULL if the property isn't controlled.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time the control-change should be read from</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_array" c:identifier="gst_object_get_value_array">
        <doc xml:whitespace="preserve">Gets a number of values for the given controlled property starting at the
requested time. The array @values need to hold enough space for @n_values of
the same type as the objects property's type.

This function is useful if one wants to e.g. draw a graph of the control
curve or apply a control curve sample by sample.

The values are unboxed and ready to be used. The similar function 
gst_object_get_g_value_array() returns the array as #GValues and is
better suites for bindings.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the given array could be filled, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time spacing between subsequent values</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of values</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:whitespace="preserve">array to put control-values in</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_active_control_bindings"
              c:identifier="gst_object_has_active_control_bindings">
        <doc xml:whitespace="preserve">Check if the @object has an active controlled properties.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the object has active controlled properties</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="has_ancestor" c:identifier="gst_object_has_ancestor">
        <doc xml:whitespace="preserve">Check if @object has an ancestor @ancestor somewhere up in
the hierarchy. One can e.g. check if a #GstElement is inside a #GstPipeline.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @ancestor is an ancestor of @object.  MT safe. Grabs and releases @object's locks.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="ancestor" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstObject to check as ancestor</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gst_object_ref">
        <doc xml:whitespace="preserve">Increments the reference count on @object. This function
does not take the lock on @object because it relies on
atomic refcounting.

This object returns the input parameter to ease writing
constructs like :
 result = gst_object_ref (object-&gt;parent);</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A pointer to @object</doc>
          <type name="Object" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="remove_control_binding"
              c:identifier="gst_object_remove_control_binding">
        <doc xml:whitespace="preserve">Removes the corresponding #GstControlBinding. If it was the
last ref of the binding, it will be disposed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the binding could be removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="binding" transfer-ownership="none">
            <doc xml:whitespace="preserve">the binding</doc>
            <type name="ControlBinding" c:type="GstControlBinding*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_control_binding_disabled"
              c:identifier="gst_object_set_control_binding_disabled">
        <doc xml:whitespace="preserve">This function is used to disable the #GstController on a property for
some time, i.e. gst_controller_sync_values() will do nothing for the
property.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">property to disable</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="disabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean that specifies whether to disable the controller or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_control_bindings_disabled"
              c:identifier="gst_object_set_control_bindings_disabled">
        <doc xml:whitespace="preserve">This function is used to disable all controlled properties of the @object for
some time, i.e. gst_object_sync_values() will do nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="disabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean that specifies whether to disable the controller or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_control_rate"
              c:identifier="gst_object_set_control_rate">
        <doc xml:whitespace="preserve">Change the control-rate for this @object. Audio processing #GstElement
objects will use this rate to sub-divide their processing loop and call
gst_object_sync_values() inbetween. The length of the processing segment
should be up to @control-rate nanoseconds.

The control-rate should not change if the element is in %GST_STATE_PAUSED or
%GST_STATE_PLAYING.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="control_rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new control-rate in nanoseconds.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="gst_object_set_name">
        <doc xml:whitespace="preserve">Sets the name of @object, or gives @object a guaranteed unique
name (if @name is NULL).
This function makes a copy of the provided name, so the caller
retains ownership of the name it sent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the name could be set. Since Objects that have a parent cannot be renamed, this function returns FALSE in those cases.  MT safe.  This function grabs and releases @object's LOCK.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">new name of object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parent" c:identifier="gst_object_set_parent">
        <doc xml:whitespace="preserve">Sets the parent of @object to @parent. The object's reference count will
be incremented, and any floating reference will be removed (see gst_object_ref_sink()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @parent could be set or FALSE when @object already had a parent or @object and @parent are the same.  MT safe. Grabs and releases @object's LOCK.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">new parent of object</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="suggest_next_sync"
              c:identifier="gst_object_suggest_next_sync">
        <doc xml:whitespace="preserve">Returns a suggestion for timestamps where buffers should be split
to get best controller results.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Returns the suggested timestamp or %GST_CLOCK_TIME_NONE if no control-rate was set.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="sync_values" c:identifier="gst_object_sync_values">
        <doc xml:whitespace="preserve">Sets the properties of the object, according to the #GstControlSources that
(maybe) handle them and for the given timestamp.

If this function fails, it is most likely the application developers fault.
Most probably the control sources are not setup correctly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the controller values could be applied to the object properties, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:whitespace="preserve">the time that should be processed</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="unparent" c:identifier="gst_object_unparent">
        <doc xml:whitespace="preserve">Clear the parent of @object, removing the associated reference.
This function decreases the refcount of @object.

MT safe. Grabs and releases @object's lock.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="gst_object_unref">
        <doc xml:whitespace="preserve">Decrements the reference count on @object.  If reference count hits
zero, destroy @object. This function does not take the lock
on @object as it relies on atomic refcounting.

The unref method should never be called with the LOCK held since
this might deadlock the dispose function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="parent" writable="1" transfer-ownership="none">
        <type name="Object"/>
      </property>
      <field name="object">
        <type name="GObject.InitiallyUnowned" c:type="GInitiallyUnowned"/>
      </field>
      <field name="lock">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="name">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="parent">
        <type name="Object" c:type="GstObject*"/>
      </field>
      <field name="flags">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="control_bindings" readable="0" private="1">
        <type name="GLib.List" c:type="GList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="control_rate" readable="0" private="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="last_sync" readable="0" private="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="deep-notify"
                   when="first"
                   no-recurse="1"
                   detailed="1"
                   no-hooks="1">
        <doc xml:whitespace="preserve">The deep notify signal is used to be notified of property changes. It is
typically attached to the toplevel bin to receive notifications from all
the elements contained in that bin.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="prop_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the object that originated the signal</doc>
            <type name="Object"/>
          </parameter>
          <parameter name="prop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the property that changed</doc>
            <type name="GObject.ParamSpec"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ObjectClass"
            c:type="GstObjectClass"
            glib:is-gtype-struct-for="Object">
      <doc xml:whitespace="preserve">GStreamer base object class.</doc>
      <field name="parent_class">
        <type name="GObject.InitiallyUnownedClass"
              c:type="GInitiallyUnownedClass"/>
      </field>
      <field name="path_string_separator">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="deep_notify">
        <callback name="deep_notify">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="object" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="orig" transfer-ownership="none">
              <type name="Object" c:type="GstObject*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ObjectFlags" c:type="GstObjectFlags">
      <doc xml:whitespace="preserve">The standard flags that an gstobject may have.</doc>
      <member name="object_flag_last"
              value="16"
              c:identifier="GST_OBJECT_FLAG_LAST">
        <doc xml:whitespace="preserve">subclasses can add additional flags starting from this flag</doc>
      </member>
    </bitfield>
    <constant name="PARAM_CONTROLLABLE"
              value="2"
              c:type="GST_PARAM_CONTROLLABLE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_MUTABLE_PAUSED"
              value="8"
              c:type="GST_PARAM_MUTABLE_PAUSED">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_MUTABLE_PLAYING"
              value="16"
              c:type="GST_PARAM_MUTABLE_PLAYING">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_MUTABLE_READY"
              value="4"
              c:type="GST_PARAM_MUTABLE_READY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PARAM_USER_SHIFT"
              value="256"
              c:type="GST_PARAM_USER_SHIFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Pad"
           c:symbol-prefix="pad"
           c:type="GstPad"
           parent="Object"
           glib:type-name="GstPad"
           glib:get-type="gst_pad_get_type"
           glib:type-struct="PadClass">
      <doc xml:whitespace="preserve">A #GstElement is linked to other elements via "pads", which are extremely
light-weight generic link points.

Pads have a #GstPadDirection, source pads produce data, sink pads consume
data.

Pads are typically created from a #GstPadTemplate with
gst_pad_new_from_template() and are then added to a #GstElement. This usually
happens when the element is created but it can also happen dynamically based
on the data that the element is processing or based on the pads that the
application requests.

Pads without pad templates can be created with gst_pad_new(),
which takes a direction and a name as an argument.  If the name is NULL,
then a guaranteed unique name will be assigned to it.

A #GstElement creating a pad will typically use the various
gst_pad_set_*_function() calls to register callbacks for events, queries or
dataflow on the pads.

gst_pad_get_parent() will retrieve the #GstElement that owns the pad.

After two pads are retrieved from an element with gst_element_get_pad(),
the pads can be linked with gst_pad_link(). (For quick links,
you can also use gst_element_link(), which will make the obvious
link for you if it's straightforward.). Pads can be unlinked again with
gst_pad_unlink(). gst_pad_get_peer() can be used to check what the pad is
linked to.

Before dataflow is possible on the pads, they need to be activated with
gst_pad_set_active().

gst_pad_query() and gst_pad_peer_query() can be used to query various
properties of the pad and the stream.

To send a #GstEvent on a pad, use gst_pad_send_event() and
gst_pad_push_event(). Some events will be sticky on the pad, meaning that
after they pass on the pad they can be queried later with
gst_pad_get_sticky_event() and gst_pad_sticky_events_foreach().
gst_pad_get_current_caps() and gst_pad_has_current_caps() are convenience
functions to query the current sticky CAPS event on a pad.

GstElements will use gst_pad_push() and gst_pad_pull_range() to push out
or pull in a buffer.

The dataflow, events and queries that happen on a pad can be monitored with
probes that can be installed with gst_pad_add_probe(). gst_pad_is_blocked()
can be used to check if a block probe is installed on the pad.
gst_pad_is_blocking() checks if the blocking probe is currently blocking the
pad. gst_pad_remove_probe() is used to remove a previously installed probe
and unblock blocking probes if any.

Pad have an offset that can be retrieved with gst_pad_get_offset(). This
offset will be applied to the running_time of all data passing over the pad.
gst_pad_set_offset() can be used to change the offset.

Convenience functions exist to start, pause and stop the task on a pad with
gst_pad_start_task(), gst_pad_pause_task() and gst_pad_stop_task()
respectively.

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <constructor name="new" c:identifier="gst_pad_new">
        <doc xml:whitespace="preserve">Creates a new pad with the given name in the given direction.
If name is NULL, a guaranteed unique name (across all pads)
will be assigned.
This function makes a copy of the name so you can safely free the name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.  MT safe.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the new pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadDirection of the pad.</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_static_template"
                   c:identifier="gst_pad_new_from_static_template">
        <doc xml:whitespace="preserve">Creates a new pad with the given name from the given static template.
If name is NULL, a guaranteed unique name (across all pads)
will be assigned.
This function makes a copy of the name so you can safely free the name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstStaticPadTemplate to use</doc>
            <type name="StaticPadTemplate" c:type="GstStaticPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the element</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_template"
                   c:identifier="gst_pad_new_from_template">
        <doc xml:whitespace="preserve">Creates a new pad with the given name from the given template.
If name is NULL, a guaranteed unique name (across all pads)
will be assigned.
This function makes a copy of the name so you can safely free the name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPad, or NULL in case of an error.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
        <parameters>
          <parameter name="templ" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad template to use</doc>
            <type name="PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the element</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="mode_get_name" c:identifier="gst_pad_mode_get_name">
        <doc xml:whitespace="preserve">Return the name of a pad mode, for use in debug messages mostly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">short mnemonic for pad mode @mode</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad mode</doc>
            <type name="PadMode" c:type="GstPadMode"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="linked">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unlinked">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="activate_mode" c:identifier="gst_pad_activate_mode">
        <doc xml:whitespace="preserve">Activates or deactivates the given pad in @mode via dispatching to the
pad's activatemodefunc. For use from within pad activation functions only.

If you don't know what this is, you probably don't want to call it.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the operation was successful.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested activation mode</doc>
            <type name="PadMode" c:type="GstPadMode"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not the pad should be active.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_probe" c:identifier="gst_pad_add_probe">
        <doc xml:whitespace="preserve">Be notified of different states of pads. The provided callback is called for
every state that matches @mask.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">an id or 0 on error. The id can be used to remove the probe with gst_pad_remove_probe().  MT safe.</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:whitespace="preserve">the probe mask</doc>
            <type name="PadProbeType" c:type="GstPadProbeType"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:whitespace="preserve">#GstPadProbeCallback that will be called with notifications of the pad state</doc>
            <type name="PadProbeCallback" c:type="GstPadProbeCallback"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_data"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">#GDestroyNotify for user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="can_link" c:identifier="gst_pad_can_link">
        <doc xml:whitespace="preserve">Checks if the source pad and the sink pad are compatible so they can be
linked.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads can be linked.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="chain" c:identifier="gst_pad_chain">
        <doc xml:whitespace="preserve">Chain a buffer to @pad.

The function returns #GST_FLOW_FLUSHING if the pad was flushing.

If the buffer type is not acceptable for @pad (as negotiated with a
preceeding GST_EVENT_CAPS event), this function returns
#GST_FLOW_NOT_NEGOTIATED.

The function proceeds calling the chain function installed on @pad (see
gst_pad_set_chain_function()) and the return value of that function is
returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
chain function.

In all cases, success or failure, the caller loses its reference to @buffer
after calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.  MT safe.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBuffer to send, return GST_FLOW_ERROR if not.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="chain_list" c:identifier="gst_pad_chain_list">
        <doc xml:whitespace="preserve">Chain a bufferlist to @pad.

The function returns #GST_FLOW_FLUSHING if the pad was flushing.

If @pad was not negotiated properly with a CAPS event, this function
returns #GST_FLOW_NOT_NEGOTIATED.

The function proceeds calling the chainlist function installed on @pad (see
gst_pad_set_chain_list_function()) and the return value of that function is
returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
chainlist function.

In all cases, success or failure, the caller loses its reference to @list
after calling this function.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBufferList to send, return GST_FLOW_ERROR if not.</doc>
            <type name="BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_reconfigure"
              c:identifier="gst_pad_check_reconfigure">
        <doc xml:whitespace="preserve">Check and clear the #GST_PAD_FLAG_NEED_RECONFIGURE flag on @pad and return %TRUE
if the flag was set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag was set on @pad.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="create_stream_id" c:identifier="gst_pad_create_stream_id">
        <doc xml:whitespace="preserve">Creates a stream-id for the source #GstPad @pad by combining the
upstream information with the optional @stream_id of the stream
of @pad. @pad must have a parent #GstElement and which must have zero
or one sinkpad. @stream_id can only be %NULL if the parent element
of @pad has only a single source pad.

This function generates an unique stream-id by getting the upstream
stream-start event stream ID and appending @stream_id to it. If the
element has no sinkpad it will generate an upstream stream-id by
doing an URI query on the element and in the worst case just uses
a random number. Source elements that don't implement the URI
handler interface should ideally generate a unique, deterministic
stream-id manually instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A stream-id for @pad. g_free() after usage.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">Parent #GstElement of @pad</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="stream_id" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The stream-id</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_stream_id_printf"
              c:identifier="gst_pad_create_stream_id_printf"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a stream-id for the source #GstPad @pad by combining the
upstream information with the optional @stream_id of the stream
of @pad. @pad must have a parent #GstElement and which must have zero
or one sinkpad. @stream_id can only be %NULL if the parent element
of @pad has only a single source pad.

This function generates an unique stream-id by getting the upstream
stream-start event stream ID and appending @stream_id to it. If the
element has no sinkpad it will generate an upstream stream-id by
doing an URI query on the element and in the worst case just uses
a random number. Source elements that don't implement the URI
handler interface should ideally generate a unique, deterministic
stream-id manually instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A stream-id for @pad. g_free() after usage.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">Parent #GstElement of @pad</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="stream_id" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The stream-id</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="create_stream_id_printf_valist"
              c:identifier="gst_pad_create_stream_id_printf_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Creates a stream-id for the source #GstPad @pad by combining the
upstream information with the optional @stream_id of the stream
of @pad. @pad must have a parent #GstElement and which must have zero
or one sinkpad. @stream_id can only be %NULL if the parent element
of @pad has only a single source pad.

This function generates an unique stream-id by getting the upstream
stream-start event stream ID and appending @stream_id to it. If the
element has no sinkpad it will generate an upstream stream-id by
doing an URI query on the element and in the worst case just uses
a random number. Source elements that don't implement the URI
handler interface should ideally generate a unique, deterministic
stream-id manually instead.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A stream-id for @pad. g_free() after usage.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">Parent #GstElement of @pad</doc>
            <type name="Element" c:type="GstElement*"/>
          </parameter>
          <parameter name="stream_id" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">The stream-id</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">parameters for the @stream_id format string</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="event_default" c:identifier="gst_pad_event_default">
        <doc xml:whitespace="preserve">Invokes the default event handler for the given pad.

The EOS event will pause the task associated with @pad before it is forwarded
to all internally linked pads,

The the event is sent to all pads internally linked to @pad. This function
takes ownership of @event.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the event was sent successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to handle.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="forward" c:identifier="gst_pad_forward">
        <doc xml:whitespace="preserve">Calls @forward for all internally linked pads of @pad. This function deals with
dynamically changing internal pads and will make sure that the @forward
function is only called once for each pad.

When @forward returns TRUE, no further pads will be processed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if one of the dispatcher functions returned TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="forward"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a #GstPadForwardFunction</doc>
            <type name="PadForwardFunction" c:type="GstPadForwardFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @forward</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allowed_caps" c:identifier="gst_pad_get_allowed_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the allowed media types that can flow through
@pad and its peer.

The allowed capabilities is calculated as the intersection of the results of
calling gst_pad_query_caps() on @pad and its peer. The caller owns a reference
on the resulting caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the allowed #GstCaps of the pad link. Unref the caps when you no longer need it. This function returns NULL when @pad has no peer.  MT safe.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_current_caps" c:identifier="gst_pad_get_current_caps">
        <doc xml:whitespace="preserve">Gets the capabilities currently configured on @pad with the last
#GST_EVENT_CAPS event.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the current caps of the pad with incremented ref-count.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_direction" c:identifier="gst_pad_get_direction">
        <doc xml:whitespace="preserve">Gets the direction of the pad. The direction of the pad is
decided at construction time so this function does not take
the LOCK.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPadDirection of the pad.  MT safe.</doc>
          <type name="PadDirection" c:type="GstPadDirection"/>
        </return-value>
      </method>
      <method name="get_element_private"
              c:identifier="gst_pad_get_element_private">
        <doc xml:whitespace="preserve">Gets the private data of a pad.
No locking is performed in this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gpointer to the private data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
      </method>
      <method name="get_offset" c:identifier="gst_pad_get_offset">
        <doc xml:whitespace="preserve">Get the offset applied to the running time of @pad. @pad has to be a source
pad.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
      </method>
      <method name="get_pad_template" c:identifier="gst_pad_get_pad_template">
        <doc xml:whitespace="preserve">Gets the template for @pad.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstPadTemplate from which this pad was instantiated, or %NULL if this pad has no template. Unref after usage.</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
      </method>
      <method name="get_pad_template_caps"
              c:identifier="gst_pad_get_pad_template_caps">
        <doc xml:whitespace="preserve">Gets the capabilities for @pad's template.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstCaps of this pad template. Unref after usage.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_parent_element"
              c:identifier="gst_pad_get_parent_element">
        <doc xml:whitespace="preserve">Gets the parent of @pad, cast to a #GstElement. If a @pad has no parent or
its parent is not an element, return NULL.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the parent of the pad. The caller has a reference on the parent, so unref when you're finished with it.  MT safe.</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
      </method>
      <method name="get_peer" c:identifier="gst_pad_get_peer">
        <doc xml:whitespace="preserve">Gets the peer of @pad. This function refs the peer pad so
you need to unref it after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the peer #GstPad. Unref after usage.  MT safe.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </return-value>
      </method>
      <method name="get_range" c:identifier="gst_pad_get_range">
        <doc xml:whitespace="preserve">When @pad is flushing this function returns #GST_FLOW_FLUSHING
immediately and @buffer is %NULL.

Calls the getrange function of @pad, see #GstPadGetRangeFunction for a
description of a getrange function. If @pad has no getrange function
installed (see gst_pad_set_getrange_function()) this function returns
#GST_FLOW_NOT_SUPPORTED.

If @buffer points to a variable holding NULL, a valid new #GstBuffer will be
placed in @buffer when this function returns #GST_FLOW_OK. The new buffer
must be freed with gst_buffer_unref() after usage.

When @buffer points to a variable that points to a valid #GstBuffer, the
buffer will be filled with the result data when this function returns
#GST_FLOW_OK. If the provided buffer is larger than @size, only
@size bytes will be filled in the result buffer and its size will be updated
accordingly.

Note that less than @size bytes can be returned in @buffer when, for example,
an EOS condition is near or when @buffer is not large enough to hold @size
bytes. The caller should check the result buffer size to get the result size.

When this function returns any other result value than #GST_FLOW_OK, @buffer
will be unchanged.

This is a lowlevel function. Usualy gst_pad_pull_range() is used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.  MT safe.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The start offset of the buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">The length of the buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to hold the #GstBuffer, returns #GST_FLOW_ERROR if %NULL.</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sticky_event" c:identifier="gst_pad_get_sticky_event">
        <doc xml:whitespace="preserve">Returns a new reference of the sticky event of type @event_type
from the event.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstEvent of type @event_type or NULL when no event of @event_type was on @pad. Unref after usage.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
        <parameters>
          <parameter name="event_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstEventType that should be retrieved.</doc>
            <type name="EventType" c:type="GstEventType"/>
          </parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index of the event</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_current_caps" c:identifier="gst_pad_has_current_caps">
        <doc xml:whitespace="preserve">Check if @pad has caps set on it with a #GST_EVENT_CAPS event.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE when @pad has caps associated with it.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_active" c:identifier="gst_pad_is_active">
        <doc xml:whitespace="preserve">Query if a pad is active</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is active.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_blocked" c:identifier="gst_pad_is_blocked">
        <doc xml:whitespace="preserve">Checks if the pad is blocked or not. This function returns the
last requested state of the pad. It is not certain that the pad
is actually blocking at this point (see gst_pad_is_blocking()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is blocked.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_blocking" c:identifier="gst_pad_is_blocking">
        <doc xml:whitespace="preserve">Checks if the pad is blocking or not. This is a guaranteed state
of whether the pad is actually blocking on a #GstBuffer or a #GstEvent.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is blocking.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_linked" c:identifier="gst_pad_is_linked">
        <doc xml:whitespace="preserve">Checks if a @pad is linked to another pad or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad is linked, FALSE otherwise.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="iterate_internal_links"
              c:identifier="gst_pad_iterate_internal_links">
        <doc xml:whitespace="preserve">Gets an iterator for the pads to which the given pad is linked to inside
of the parent element.

Each #GstPad element yielded by the iterator will have its refcount increased,
so unref after use.

Free-function: gst_iterator_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstIterator of #GstPad or %NULL when the pad does not have an iterator function configured. Use gst_iterator_free() after usage.</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
      </method>
      <method name="iterate_internal_links_default"
              c:identifier="gst_pad_iterate_internal_links_default">
        <doc xml:whitespace="preserve">Iterate the list of pads to which the given pad is linked to inside of
the parent element.
This is the default handler, and thus returns an iterator of all of the
pads inside the parent element with opposite direction.

The caller must free this iterator after use with gst_iterator_free().</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstPad, or NULL if @pad has no parent. Unref each returned pad with gst_object_unref().</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link" c:identifier="gst_pad_link">
        <doc xml:whitespace="preserve">Links the source pad and the sink pad.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A result code indicating if the connection worked or what went wrong.  MT Safe.</doc>
          <type name="PadLinkReturn" c:type="GstPadLinkReturn"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad to link.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_full" c:identifier="gst_pad_link_full">
        <doc xml:whitespace="preserve">Links the source pad and the sink pad.

This variant of #gst_pad_link provides a more granular control on the
checks being done when linking. While providing some considerable speedups
the caller of this method must be aware that wrong usage of those flags
can cause severe issues. Refer to the documentation of #GstPadLinkCheck
for more information.

MT Safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A result code indicating if the connection worked or what went wrong.</doc>
          <type name="PadLinkReturn" c:type="GstPadLinkReturn"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad to link.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the checks to validate when linking</doc>
            <type name="PadLinkCheck" c:type="GstPadLinkCheck"/>
          </parameter>
        </parameters>
      </method>
      <method name="mark_reconfigure" c:identifier="gst_pad_mark_reconfigure">
        <doc xml:whitespace="preserve">Mark a pad for needing reconfiguration. The next call to
gst_pad_check_reconfigure() will return %TRUE after this call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="needs_reconfigure"
              c:identifier="gst_pad_needs_reconfigure">
        <doc xml:whitespace="preserve">Check the #GST_PAD_FLAG_NEED_RECONFIGURE flag on @pad and return %TRUE
if the flag was set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag is set on @pad.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="pause_task" c:identifier="gst_pad_pause_task">
        <doc xml:whitespace="preserve">Pause the task of @pad. This function will also wait until the
function executed by the task is finished if this function is not
called from the task function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a TRUE if the task could be paused or FALSE when the pad has no task.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="peer_query" c:identifier="gst_pad_peer_query">
        <doc xml:whitespace="preserve">Performs gst_pad_query() on the peer of @pad.

The caller is responsible for both the allocation and deallocation of
the query structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed. This function returns %FALSE if @pad has no peer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery to perform.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peer_query_accept_caps"
              c:identifier="gst_pad_peer_query_accept_caps">
        <doc xml:whitespace="preserve">Check if the peer of @pad accepts @caps. If @pad has no peer, this function
returns TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the peer of @pad can accept the caps or @pad has no peer.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to check on the pad</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peer_query_caps" c:identifier="gst_pad_peer_query_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the peer connected to this pad. Similar to
gst_pad_query_caps().

When called on srcpads @filter contains the caps that
upstream could produce in the order preferred by upstream. When
called on sinkpads @filter contains the caps accepted by
downstream in the preffered order. @filter might be %NULL but
if it is not %NULL the returned caps will be a subset of @filter.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the caps of the peer pad with incremented ref-count. When there is no peer pad, this function returns @filter or, when @filter is %NULL, ANY caps.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #GstCaps filter, or NULL.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peer_query_convert"
              c:identifier="gst_pad_peer_query_convert">
        <doc xml:whitespace="preserve">Queries the peer pad of a given sink pad to convert @src_val in @src_format
to @dest_format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstFormat to convert from.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value to convert.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat to convert to.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the result.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peer_query_duration"
              c:identifier="gst_pad_peer_query_duration">
        <doc xml:whitespace="preserve">Queries the peer pad of a given sink pad for the total stream duration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat requested</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peer_query_position"
              c:identifier="gst_pad_peer_query_position">
        <doc xml:whitespace="preserve">Queries the peer of a given sink pad for the stream position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat requested</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the current position, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="proxy_query_accept_caps"
              c:identifier="gst_pad_proxy_query_accept_caps">
        <doc xml:whitespace="preserve">Calls gst_pad_accept_caps() for all internally linked pads of @pad and
returns the intersection of the results.

This function is useful as a default accept caps query function for an element
that can handle any stream format, but requires caps that are acceptable for
all oposite pads.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @query could be executed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">an ACCEPT_CAPS #GstQuery.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="proxy_query_caps" c:identifier="gst_pad_proxy_query_caps">
        <doc xml:whitespace="preserve">Calls gst_pad_query_caps() for all internally linked pads fof @pad and returns
the intersection of the results.

This function is useful as a default caps query function for an element
that can handle any stream format, but requires all its pads to have
the same caps.  Two such elements are tee and adder.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @query could be executed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">a CAPS #GstQuery.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pull_range" c:identifier="gst_pad_pull_range">
        <doc xml:whitespace="preserve">Pulls a @buffer from the peer pad or fills up a provided buffer.

This function will first trigger the pad block signal if it was
installed.

When @pad is not linked #GST_FLOW_NOT_LINKED is returned else this
function returns the result of gst_pad_get_range() on the peer pad.
See gst_pad_get_range() for a list of return values and for the
semantics of the arguments of this function.

If @buffer points to a variable holding NULL, a valid new #GstBuffer will be
placed in @buffer when this function returns #GST_FLOW_OK. The new buffer
must be freed with gst_buffer_unref() after usage. When this function
returns any other result value, @buffer will still point to NULL.

When @buffer points to a variable that points to a valid #GstBuffer, the
buffer will be filled with the result data when this function returns
#GST_FLOW_OK. When this function returns any other result value,
@buffer will be unchanged. If the provided buffer is larger than @size, only
@size bytes will be filled in the result buffer and its size will be updated
accordingly.

Note that less than @size bytes can be returned in @buffer when, for example,
an EOS condition is near or when @buffer is not large enough to hold @size
bytes. The caller should check the result buffer size to get the result size.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the peer pad.  MT safe.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The start offset of the buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">The length of the buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to hold the #GstBuffer, returns GST_FLOW_ERROR if %NULL.</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_pad_push">
        <doc xml:whitespace="preserve">Pushes a buffer to the peer of @pad.

This function will call installed block probes before triggering any
installed data probes.

The function proceeds calling gst_pad_chain() on the peer pad and returns
the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
be returned.

In all cases, success or failure, the caller loses its reference to @buffer
after calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the peer pad.  MT safe.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBuffer to push returns GST_FLOW_ERROR if not.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_event" c:identifier="gst_pad_push_event">
        <doc xml:whitespace="preserve">Sends the event to the peer of the given pad. This function is
mainly used by elements to send events to their peer
elements.

This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the event was handled.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the pad.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_list" c:identifier="gst_pad_push_list">
        <doc xml:whitespace="preserve">Pushes a buffer list to the peer of @pad.

This function will call installed block probes before triggering any
installed data probes.

The function proceeds calling the chain function on the peer pad and returns
the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
be returned. If the peer pad does not have any installed chainlist function
every group buffer of the list will be merged into a normal #GstBuffer and
chained via gst_pad_chain().

In all cases, success or failure, the caller loses its reference to @list
after calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the peer pad.  MT safe.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBufferList to push returns GST_FLOW_ERROR if not.</doc>
            <type name="BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query" c:identifier="gst_pad_query">
        <doc xml:whitespace="preserve">Dispatches a query to a pad. The query should have been allocated by the
caller via one of the type-specific allocation functions. The element that
the pad belongs to is responsible for filling the query with an appropriate
response, which should then be parsed with a type-specific query parsing
function.

Again, the caller is responsible for both the allocation and deallocation of
the query structure.

Please also note that some queries might need a running pipeline to work.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery to perform.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_accept_caps"
              c:identifier="gst_pad_query_accept_caps">
        <doc xml:whitespace="preserve">Check if the given pad accepts the caps.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pad can accept the caps.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps to check on the pad</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_caps" c:identifier="gst_pad_query_caps">
        <doc xml:whitespace="preserve">Gets the capabilities this pad can produce or consume.
Note that this method doesn't necessarily return the caps set by
gst_pad_set_caps() - use gst_pad_get_current_caps() for that instead.
gst_pad_query_caps returns all possible caps a pad can operate with, using
the pad's CAPS query function, If the query fails, this function will return
@filter, if not #NULL, otherwise ANY.

When called on sinkpads @filter contains the caps that
upstream could produce in the order preferred by upstream. When
called on srcpads @filter contains the caps accepted by
downstream in the preffered order. @filter might be %NULL but
if it is not %NULL the returned caps will be a subset of @filter.

Note that this function does not return writable #GstCaps, use
gst_caps_make_writable() before modifying the caps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the caps of the pad with incremented ref-count.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">suggested #GstCaps, or NULL</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_convert" c:identifier="gst_pad_query_convert">
        <doc xml:whitespace="preserve">Queries a pad to convert @src_val in @src_format to @dest_format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstFormat to convert from.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:whitespace="preserve">a value to convert.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat to convert to.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to the result.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_default" c:identifier="gst_pad_query_default">
        <doc xml:whitespace="preserve">Invokes the default query handler for the given pad.
The query is sent to all pads internally linked to @pad. Note that
if there are many possible sink pads that are internally linked to
@pad, only one will be sent the query.
Multi-sinkpad elements should implement custom query handlers.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query was performed successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstQuery to handle.</doc>
            <type name="Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_duration" c:identifier="gst_pad_query_duration">
        <doc xml:whitespace="preserve">Queries a pad for the total stream duration.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat requested</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a location in which to store the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_position" c:identifier="gst_pad_query_position">
        <doc xml:whitespace="preserve">Queries a pad for the stream position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat requested</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A location in which to store the current position, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_probe" c:identifier="gst_pad_remove_probe">
        <doc xml:whitespace="preserve">Remove the probe with @id from @pad.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the probe id to remove</doc>
            <type name="gulong" c:type="gulong"/>
          </parameter>
        </parameters>
      </method>
      <method name="send_event" c:identifier="gst_pad_send_event">
        <doc xml:whitespace="preserve">Sends the event to the pad. This function can be used
by applications to send events in the pipeline.

If @pad is a source pad, @event should be an upstream event. If @pad is a
sink pad, @event should be a downstream event. For example, you would not
send a #GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
Furthermore, some downstream events have to be serialized with data flow,
like EOS, while some can travel out-of-band, like #GST_EVENT_FLUSH_START. If
the event needs to be serialized with data flow, this function will take the
pad's stream lock while calling its event function.

To find out whether an event type is upstream, downstream, or downstream and
serialized, see #GstEventTypeFlags, gst_event_type_get_flags(),
#GST_EVENT_IS_UPSTREAM, #GST_EVENT_IS_DOWNSTREAM, and
#GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
plugin doesn't need to bother itself with this information; the core handles
all necessary locks and checks.

This function takes owership of the provided event so you should
gst_event_ref() it if you want to reuse the event after this call.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the event was handled.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="event" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstEvent to send to the pad.</doc>
            <type name="Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_activate_function_full"
              c:identifier="gst_pad_set_activate_function_full">
        <doc xml:whitespace="preserve">Sets the given activate function for @pad. The activate function will
dispatch to gst_pad_activate_mode() to perform the actual activation.
Only makes sense to set on sink pads.

Call this function if your sink pad can start a pull-based task.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="activate"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadActivateFunction to set.</doc>
            <type name="PadActivateFunction" c:type="GstPadActivateFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @activate will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_activatemode_function_full"
              c:identifier="gst_pad_set_activatemode_function_full">
        <doc xml:whitespace="preserve">Sets the given activate_mode function for the pad. An activate_mode function
prepares the element for data passing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="activatemode"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadActivateModeFunction to set.</doc>
            <type name="PadActivateModeFunction"
                  c:type="GstPadActivateModeFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @activatemode will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_active" c:identifier="gst_pad_set_active">
        <doc xml:whitespace="preserve">Activates or deactivates the given pad.
Normally called from within core state change functions.

If @active, makes sure the pad is active. If it is already active, either in
push or pull mode, just return. Otherwise dispatches to the pad's activate
function to perform the actual activation.

If not @active, calls gst_pad_activate_mode() with the pad's current mode
and a FALSE argument.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if the operation was successful.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not the pad should be active.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chain_function_full"
              c:identifier="gst_pad_set_chain_function_full">
        <doc xml:whitespace="preserve">Sets the given chain function for the pad. The chain function is called to
process a #GstBuffer input buffer. see #GstPadChainFunction for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chain"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadChainFunction to set.</doc>
            <type name="PadChainFunction" c:type="GstPadChainFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @chain will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_chain_list_function_full"
              c:identifier="gst_pad_set_chain_list_function_full">
        <doc xml:whitespace="preserve">Sets the given chain list function for the pad. The chainlist function is
called to process a #GstBufferList input buffer list. See
#GstPadChainListFunction for more details.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="chainlist"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadChainListFunction to set.</doc>
            <type name="PadChainListFunction"
                  c:type="GstPadChainListFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @chainlist will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_element_private"
              c:identifier="gst_pad_set_element_private">
        <doc xml:whitespace="preserve">Set the given private data gpointer on the pad.
This function can only be used by the element that owns the pad.
No locking is performed in this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="priv" transfer-ownership="none">
            <doc xml:whitespace="preserve">The private data to attach to the pad.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_event_function_full"
              c:identifier="gst_pad_set_event_function_full">
        <doc xml:whitespace="preserve">Sets the given event handler for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="event"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadEventFunction to set.</doc>
            <type name="PadEventFunction" c:type="GstPadEventFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @event will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_getrange_function_full"
              c:identifier="gst_pad_set_getrange_function_full">
        <doc xml:whitespace="preserve">Sets the given getrange function for the pad. The getrange function is
called to produce a new #GstBuffer to start the processing pipeline. see
#GstPadGetRangeFunction for a description of the getrange function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="get"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadGetRangeFunction to set.</doc>
            <type name="PadGetRangeFunction" c:type="GstPadGetRangeFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @get will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_iterate_internal_links_function_full"
              c:identifier="gst_pad_set_iterate_internal_links_function_full">
        <doc xml:whitespace="preserve">Sets the given internal link iterator function for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="iterintlink"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadIterIntLinkFunction to set.</doc>
            <type name="PadIterIntLinkFunction"
                  c:type="GstPadIterIntLinkFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @iterintlink will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_link_function_full"
              c:identifier="gst_pad_set_link_function_full">
        <doc xml:whitespace="preserve">Sets the given link function for the pad. It will be called when
the pad is linked with another pad.

The return value #GST_PAD_LINK_OK should be used when the connection can be
made.

The return value #GST_PAD_LINK_REFUSED should be used when the connection
cannot be made for some reason.

If @link is installed on a source pad, it should call the #GstPadLinkFunction
of the peer sink pad, if present.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="link"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadLinkFunction to set.</doc>
            <type name="PadLinkFunction" c:type="GstPadLinkFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @link will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_offset" c:identifier="gst_pad_set_offset">
        <doc xml:whitespace="preserve">Set the offset that will be applied to the running time of @pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">the offset</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query_function_full"
              c:identifier="gst_pad_set_query_function_full">
        <doc xml:whitespace="preserve">Set the given query function for the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="query"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadQueryFunction to set.</doc>
            <type name="PadQueryFunction" c:type="GstPadQueryFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @query will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unlink_function_full"
              c:identifier="gst_pad_set_unlink_function_full">
        <doc xml:whitespace="preserve">Sets the given unlink function for the pad. It will be called
when the pad is unlinked.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="unlink"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the #GstPadUnlinkFunction to set.</doc>
            <type name="PadUnlinkFunction" c:type="GstPadUnlinkFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user_data passed to @notify</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">notify called when @unlink will not be used anymore.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_task" c:identifier="gst_pad_start_task">
        <doc xml:whitespace="preserve">Starts a task that repeatedly calls @func with @user_data. This function
is mostly used in pad activation functions to start the dataflow.
The #GST_PAD_STREAM_LOCK of @pad will automatically be acquired
before @func is called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a %TRUE if the task could be started.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">the task function to call</doc>
            <type name="TaskFunction" c:type="GstTaskFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the task function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called when @user_data is no longer referenced</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="sticky_events_foreach"
              c:identifier="gst_pad_sticky_events_foreach">
        <doc xml:whitespace="preserve">Iterates all sticky events on @pad and calls @foreach_func for every
event. If @foreach_func returns %FALSE the iteration is immediately stopped.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="foreach_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">the #GstPadStickyEventsForeachFunction that should be called for every event.</doc>
            <type name="PadStickyEventsForeachFunction"
                  c:type="GstPadStickyEventsForeachFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the optional user data.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_task" c:identifier="gst_pad_stop_task">
        <doc xml:whitespace="preserve">Stop the task of @pad. This function will also make sure that the
function executed by the task will effectively stop if not called
from the GstTaskFunction.

This function will deadlock if called from the GstTaskFunction of
the task. Use gst_task_pause() instead.

Regardless of whether the pad has a task, the stream lock is acquired and
released so as to ensure that streaming through this pad has finished.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a TRUE if the task could be stopped or FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="unlink" c:identifier="gst_pad_unlink">
        <doc xml:whitespace="preserve">Unlinks the source pad from the sink pad. Will emit the #GstPad::unlinked
signal on both pads.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the pads were unlinked. This function returns FALSE if the pads were not linked together.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="sinkpad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the sink #GstPad to unlink.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="use_fixed_caps" c:identifier="gst_pad_use_fixed_caps">
        <doc xml:whitespace="preserve">A helper function you can use that sets the FIXED_CAPS flag
This way the default CAPS query will always return the negotiated caps
or in case the pad is not negotiated, the padtemplate caps.

The negotiated caps are the caps of the last CAPS event that passed on the
pad. Use this function on a pad that, once it negotiated to a CAPS, cannot
be renegotiated to something else.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <property name="caps" transfer-ownership="none">
        <type name="Caps"/>
      </property>
      <property name="direction"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="template" writable="1" transfer-ownership="none">
        <type name="PadTemplate"/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="element_private">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="padtemplate">
        <type name="PadTemplate" c:type="GstPadTemplate*"/>
      </field>
      <field name="direction">
        <type name="PadDirection" c:type="GstPadDirection"/>
      </field>
      <field name="stream_rec_lock" readable="0" private="1">
        <type name="GLib.RecMutex" c:type="GRecMutex"/>
      </field>
      <field name="task" readable="0" private="1">
        <type name="Task" c:type="GstTask*"/>
      </field>
      <field name="block_cond" readable="0" private="1">
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <field name="probes" readable="0" private="1">
        <type name="GLib.HookList" c:type="GHookList"/>
      </field>
      <field name="mode" readable="0" private="1">
        <type name="PadMode" c:type="GstPadMode"/>
      </field>
      <field name="activatefunc" readable="0" private="1">
        <type name="PadActivateFunction" c:type="GstPadActivateFunction"/>
      </field>
      <field name="activatedata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="activatenotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="activatemodefunc" readable="0" private="1">
        <type name="PadActivateModeFunction"
              c:type="GstPadActivateModeFunction"/>
      </field>
      <field name="activatemodedata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="activatemodenotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="peer" readable="0" private="1">
        <type name="Pad" c:type="GstPad*"/>
      </field>
      <field name="linkfunc" readable="0" private="1">
        <type name="PadLinkFunction" c:type="GstPadLinkFunction"/>
      </field>
      <field name="linkdata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="linknotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="unlinkfunc" readable="0" private="1">
        <type name="PadUnlinkFunction" c:type="GstPadUnlinkFunction"/>
      </field>
      <field name="unlinkdata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="unlinknotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="chainfunc" readable="0" private="1">
        <type name="PadChainFunction" c:type="GstPadChainFunction"/>
      </field>
      <field name="chaindata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="chainnotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="chainlistfunc" readable="0" private="1">
        <type name="PadChainListFunction" c:type="GstPadChainListFunction"/>
      </field>
      <field name="chainlistdata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="chainlistnotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="getrangefunc" readable="0" private="1">
        <type name="PadGetRangeFunction" c:type="GstPadGetRangeFunction"/>
      </field>
      <field name="getrangedata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="getrangenotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="eventfunc" readable="0" private="1">
        <type name="PadEventFunction" c:type="GstPadEventFunction"/>
      </field>
      <field name="eventdata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="eventnotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="offset" readable="0" private="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="queryfunc" readable="0" private="1">
        <type name="PadQueryFunction" c:type="GstPadQueryFunction"/>
      </field>
      <field name="querydata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="querynotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="iterintlinkfunc" readable="0" private="1">
        <type name="PadIterIntLinkFunction"
              c:type="GstPadIterIntLinkFunction"/>
      </field>
      <field name="iterintlinkdata" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="iterintlinknotify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="num_probes" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="num_blocked" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PadPrivate" c:type="GstPadPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="linked" when="last">
        <doc xml:whitespace="preserve">Signals that a pad has been linked to the peer pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the peer pad that has been connected</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="unlinked" when="last">
        <doc xml:whitespace="preserve">Signals that a pad has been unlinked from the peer pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="peer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the peer pad that has been disconnected</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="PadActivateFunction" c:type="GstPadActivateFunction">
      <doc xml:whitespace="preserve">This function is called when the pad is activated during the element
READY to PAUSED state change. By default this function will call the
activate function that puts the pad in push mode but elements can
override this function to activate the pad in pull mode if they wish.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the pad could be activated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadActivateModeFunction"
              c:type="GstPadActivateModeFunction">
      <doc xml:whitespace="preserve">The prototype of the push and pull activate functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the pad could be activated or deactivated.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPad</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:whitespace="preserve">the requested activation mode of @pad</doc>
          <type name="PadMode" c:type="GstPadMode"/>
        </parameter>
        <parameter name="active" transfer-ownership="none">
          <doc xml:whitespace="preserve">activate or deactivate the pad.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadChainFunction" c:type="GstPadChainFunction">
      <doc xml:whitespace="preserve">A function that will be called on sinkpads when chaining buffers.
The function typically processes the data contained in the buffer and
either consumes the data or passes it on to the internally linked pad(s).

The implementer of this function receives a refcount to @buffer and should
gst_buffer_unref() when the buffer is no longer needed.

When a chain function detects an error in the data stream, it must post an
error on the bus and return an appropriate #GstFlowReturn value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success</doc>
        <type name="FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the sink #GstPad that performed the chain.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBuffer that is chained, not %NULL.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadChainListFunction" c:type="GstPadChainListFunction">
      <doc xml:whitespace="preserve">A function that will be called on sinkpads when chaining buffer lists.
The function typically processes the data contained in the buffer list and
either consumes the data or passes it on to the internally linked pad(s).

The implementer of this function receives a refcount to @list and
should gst_buffer_list_unref() when the list is no longer needed.

When a chainlist function detects an error in the data stream, it must
post an error on the bus and return an appropriate #GstFlowReturn value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success</doc>
        <type name="FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the sink #GstPad that performed the chain.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstBufferList that is chained, not %NULL.</doc>
          <type name="BufferList" c:type="GstBufferList*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PadClass"
            c:type="GstPadClass"
            glib:is-gtype-struct-for="Pad">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="linked">
        <callback name="linked">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
            <parameter name="peer" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlinked">
        <callback name="unlinked">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
            <parameter name="peer" transfer-ownership="none">
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="PadDirection" c:type="GstPadDirection">
      <doc xml:whitespace="preserve">The direction of a pad.</doc>
      <member name="unknown" value="0" c:identifier="GST_PAD_UNKNOWN">
        <doc xml:whitespace="preserve">direction is unknown.</doc>
      </member>
      <member name="src" value="1" c:identifier="GST_PAD_SRC">
        <doc xml:whitespace="preserve">the pad is a source pad.</doc>
      </member>
      <member name="sink" value="2" c:identifier="GST_PAD_SINK">
        <doc xml:whitespace="preserve">the pad is a sink pad.</doc>
      </member>
    </enumeration>
    <callback name="PadEventFunction" c:type="GstPadEventFunction">
      <doc xml:whitespace="preserve">Function signature to handle an event for the pad.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the pad could handle the event.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to handle the event.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstEvent to handle.</doc>
          <type name="Event" c:type="GstEvent*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="PadFlags" c:type="GstPadFlags">
      <doc xml:whitespace="preserve">Pad state flags</doc>
      <member name="blocked" value="16" c:identifier="GST_PAD_FLAG_BLOCKED">
        <doc xml:whitespace="preserve">is dataflow on a pad blocked</doc>
      </member>
      <member name="flushing" value="32" c:identifier="GST_PAD_FLAG_FLUSHING">
        <doc xml:whitespace="preserve">is pad flushing</doc>
      </member>
      <member name="eos" value="64" c:identifier="GST_PAD_FLAG_EOS">
        <doc xml:whitespace="preserve">is pad in EOS state</doc>
      </member>
      <member name="blocking" value="128" c:identifier="GST_PAD_FLAG_BLOCKING">
        <doc xml:whitespace="preserve">is pad currently blocking on a buffer or event</doc>
      </member>
      <member name="need_parent"
              value="256"
              c:identifier="GST_PAD_FLAG_NEED_PARENT">
        <doc xml:whitespace="preserve">ensure that there is a parent object before calling into the pad callbacks.</doc>
      </member>
      <member name="need_reconfigure"
              value="512"
              c:identifier="GST_PAD_FLAG_NEED_RECONFIGURE">
        <doc xml:whitespace="preserve">the pad should be reconfigured/renegotiated. The flag has to be unset manually after reconfiguration happened.</doc>
      </member>
      <member name="pending_events"
              value="1024"
              c:identifier="GST_PAD_FLAG_PENDING_EVENTS">
        <doc xml:whitespace="preserve">the pad has pending events</doc>
      </member>
      <member name="fixed_caps"
              value="2048"
              c:identifier="GST_PAD_FLAG_FIXED_CAPS">
        <doc xml:whitespace="preserve">the pad is using fixed caps this means that once the caps are set on the pad, the caps query function only returns those caps.</doc>
      </member>
      <member name="proxy_caps"
              value="4096"
              c:identifier="GST_PAD_FLAG_PROXY_CAPS">
        <doc xml:whitespace="preserve">the default event and query handler will forward all events and queries to the internally linked pads instead of discarding them.</doc>
      </member>
      <member name="proxy_allocation"
              value="8192"
              c:identifier="GST_PAD_FLAG_PROXY_ALLOCATION">
        <doc xml:whitespace="preserve">the default query handler will forward allocation queries to the internally linked pads instead of discarding them.</doc>
      </member>
      <member name="proxy_scheduling"
              value="16384"
              c:identifier="GST_PAD_FLAG_PROXY_SCHEDULING">
        <doc xml:whitespace="preserve">the default query handler will forward scheduling queries to the internally linked pads instead of discarding them.</doc>
      </member>
      <member name="last" value="1048576" c:identifier="GST_PAD_FLAG_LAST">
        <doc xml:whitespace="preserve">offset to define more flags</doc>
      </member>
    </bitfield>
    <callback name="PadForwardFunction" c:type="GstPadForwardFunction">
      <doc xml:whitespace="preserve">A forward function is called for all internally linked pads, see
gst_pad_forward().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the dispatching procedure has to be stopped.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is forwarded.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the gpointer to optional user data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadGetRangeFunction" c:type="GstPadGetRangeFunction">
      <doc xml:whitespace="preserve">This function will be called on source pads when a peer element
request a buffer at the specified @offset and @length. If this function
returns #GST_FLOW_OK, the result buffer will be stored in @buffer. The
contents of @buffer is invalid for any other return value.

This function is installed on a source pad with
gst_pad_set_getrange_function() and can only be called on source pads after
they are successfully activated with gst_pad_activate_mode() with the
#GST_PAD_MODE_PULL.

@offset and @length are always given in byte units. @offset must normally be a value
between 0 and the length in bytes of the data available on @pad. The
length (duration in bytes) can be retrieved with a #GST_QUERY_DURATION or with a
#GST_QUERY_SEEKING.

Any @offset larger or equal than the length will make the function return
#GST_FLOW_EOS, which corresponds to EOS. In this case @buffer does not
contain a valid buffer.

The buffer size of @buffer will only be smaller than @length when @offset is
near the end of the stream. In all other cases, the size of @buffer must be
exactly the requested size.

It is allowed to call this function with a 0 @length and valid @offset, in
which case @buffer will contain a 0-sized buffer and the function returns
#GST_FLOW_OK.

When this function is called with a -1 @offset, the sequentially next buffer
of length @length in the stream is returned.

When this function is called with a -1 @length, a buffer with a default
optimal length is returned in @buffer. The length might depend on the value
of @offset.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">#GST_FLOW_OK for success and a valid buffer in @buffer. Any other return value leaves @buffer undefined.</doc>
        <type name="FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the src #GstPad to perform the getrange on.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:whitespace="preserve">the offset of the range</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the range</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:whitespace="preserve">a memory location to hold the result buffer, cannot be NULL.</doc>
          <type name="Buffer" c:type="GstBuffer**"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadIterIntLinkFunction" c:type="GstPadIterIntLinkFunction">
      <doc xml:whitespace="preserve">The signature of the internal pad link iterator function.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstIterator that will iterate over all pads that are linked to the given pad on the inside of the parent element.  the caller must call gst_iterator_free() after usage.</doc>
        <type name="Iterator" c:type="GstIterator*"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstPad to query.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="PadLinkCheck" c:type="GstPadLinkCheck">
      <doc xml:whitespace="preserve">The amount of checking to be done when linking pads. @GST_PAD_LINK_CHECK_CAPS
and @GST_PAD_LINK_CHECK_TEMPLATE_CAPS are mutually exclusive. If both are
specified, expensive but safe @GST_PAD_LINK_CHECK_CAPS are performed.

&lt;warning&gt;&lt;para&gt;
Only disable some of the checks if you are 100% certain you know the link
will not fail because of hierarchy/caps compatibility failures. If uncertain,
use the default checks (%GST_PAD_LINK_CHECK_DEFAULT) or the regular methods
for linking the pads.
&lt;/para&gt;&lt;/warning&gt;</doc>
      <member name="nothing"
              value="0"
              c:identifier="GST_PAD_LINK_CHECK_NOTHING">
        <doc xml:whitespace="preserve">Don't check hierarchy or caps compatibility.</doc>
      </member>
      <member name="hierarchy"
              value="1"
              c:identifier="GST_PAD_LINK_CHECK_HIERARCHY">
        <doc xml:whitespace="preserve">Check the pads have same parents/grandparents. Could be omitted if it is already known that the two elements that own the pads are in the same bin.</doc>
      </member>
      <member name="template_caps"
              value="2"
              c:identifier="GST_PAD_LINK_CHECK_TEMPLATE_CAPS">
        <doc xml:whitespace="preserve">Check if the pads are compatible by using their template caps. This is much faster than @GST_PAD_LINK_CHECK_CAPS, but would be unsafe e.g. if one pad has %GST_CAPS_ANY.</doc>
      </member>
      <member name="caps" value="4" c:identifier="GST_PAD_LINK_CHECK_CAPS">
        <doc xml:whitespace="preserve">Check if the pads are compatible by comparing the caps returned by gst_pad_query_caps().</doc>
      </member>
      <member name="default"
              value="5"
              c:identifier="GST_PAD_LINK_CHECK_DEFAULT">
        <doc xml:whitespace="preserve">The default checks done when linking pads (i.e. the ones used by gst_pad_link()).</doc>
      </member>
    </bitfield>
    <callback name="PadLinkFunction" c:type="GstPadLinkFunction">
      <doc xml:whitespace="preserve">Function signature to handle a new link on the pad.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the result of the link with the specified peer.</doc>
        <type name="PadLinkReturn" c:type="GstPadLinkReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is linked.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="peer" transfer-ownership="none">
          <doc xml:whitespace="preserve">the peer #GstPad of the link</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="PadLinkReturn" c:type="GstPadLinkReturn">
      <doc xml:whitespace="preserve">Result values from gst_pad_link and friends.</doc>
      <member name="ok" value="0" c:identifier="GST_PAD_LINK_OK">
        <doc xml:whitespace="preserve">link succeeded</doc>
      </member>
      <member name="wrong_hierarchy"
              value="-1"
              c:identifier="GST_PAD_LINK_WRONG_HIERARCHY">
        <doc xml:whitespace="preserve">pads have no common grandparent</doc>
      </member>
      <member name="was_linked"
              value="-2"
              c:identifier="GST_PAD_LINK_WAS_LINKED">
        <doc xml:whitespace="preserve">pad was already linked</doc>
      </member>
      <member name="wrong_direction"
              value="-3"
              c:identifier="GST_PAD_LINK_WRONG_DIRECTION">
        <doc xml:whitespace="preserve">pads have wrong direction</doc>
      </member>
      <member name="noformat" value="-4" c:identifier="GST_PAD_LINK_NOFORMAT">
        <doc xml:whitespace="preserve">pads do not have common format</doc>
      </member>
      <member name="nosched" value="-5" c:identifier="GST_PAD_LINK_NOSCHED">
        <doc xml:whitespace="preserve">pads cannot cooperate in scheduling</doc>
      </member>
      <member name="refused" value="-6" c:identifier="GST_PAD_LINK_REFUSED">
        <doc xml:whitespace="preserve">refused for some reason</doc>
      </member>
    </enumeration>
    <enumeration name="PadMode" c:type="GstPadMode">
      <doc xml:whitespace="preserve">The status of a GstPad. After activating a pad, which usually happens when the
parent element goes from READY to PAUSED, the GstPadMode defines if the
pad operates in push or pull mode.</doc>
      <member name="none" value="0" c:identifier="GST_PAD_MODE_NONE">
        <doc xml:whitespace="preserve">Pad will not handle dataflow</doc>
      </member>
      <member name="push" value="1" c:identifier="GST_PAD_MODE_PUSH">
        <doc xml:whitespace="preserve">Pad handles dataflow in downstream push mode</doc>
      </member>
      <member name="pull" value="2" c:identifier="GST_PAD_MODE_PULL">
        <doc xml:whitespace="preserve">Pad handles dataflow in upstream pull mode</doc>
      </member>
    </enumeration>
    <enumeration name="PadPresence" c:type="GstPadPresence">
      <doc xml:whitespace="preserve">Indicates when this pad will become available.</doc>
      <member name="always" value="0" c:identifier="GST_PAD_ALWAYS">
        <doc xml:whitespace="preserve">the pad is always available</doc>
      </member>
      <member name="sometimes" value="1" c:identifier="GST_PAD_SOMETIMES">
        <doc xml:whitespace="preserve">the pad will become available depending on the media stream</doc>
      </member>
      <member name="request" value="2" c:identifier="GST_PAD_REQUEST">
        <doc xml:whitespace="preserve">the pad is only available on request with gst_element_get_request_pad().</doc>
      </member>
    </enumeration>
    <record name="PadPrivate" c:type="GstPadPrivate" disguised="1">
    </record>
    <callback name="PadProbeCallback" c:type="GstPadProbeCallback">
      <doc xml:whitespace="preserve">Callback used by gst_pad_add_probe(). Gets called to notify about the current
blocking type.

The callback is allowed to modify the data pointer in @info.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GstPadProbeReturn</doc>
        <type name="PadProbeReturn" c:type="GstPadProbeReturn"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is blocked</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstPadProbeInfo</doc>
          <type name="PadProbeInfo" c:type="GstPadProbeInfo*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the gpointer to optional user data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="PadProbeInfo" c:type="GstPadProbeInfo">
      <doc xml:whitespace="preserve">Info passed in the #GstPadProbeCallback.</doc>
      <field name="type" writable="1">
        <type name="PadProbeType" c:type="GstPadProbeType"/>
      </field>
      <field name="id" writable="1">
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="offset" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="size" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="get_buffer" c:identifier="gst_pad_probe_info_get_buffer">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstBuffer from the probe</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="get_buffer_list"
              c:identifier="gst_pad_probe_info_get_buffer_list">
        <return-value transfer-ownership="full">
          <type name="BufferList" c:type="GstBufferList*"/>
        </return-value>
      </method>
      <method name="get_event" c:identifier="gst_pad_probe_info_get_event">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstEvent from the probe</doc>
          <type name="Event" c:type="GstEvent*"/>
        </return-value>
      </method>
      <method name="get_query" c:identifier="gst_pad_probe_info_get_query">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstQuery from the probe</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </method>
    </record>
    <enumeration name="PadProbeReturn" c:type="GstPadProbeReturn">
      <doc xml:whitespace="preserve">Different return values for the #GstPadProbeCallback.</doc>
      <member name="drop" value="0" c:identifier="GST_PAD_PROBE_DROP">
        <doc xml:whitespace="preserve">drop data in data probes. For push mode this means that the data item is not sent downstream. For pull mode, it means that the data item is not passed upstream. In both cases, this result code returns #GST_FLOW_OK or %TRUE to the caller.</doc>
      </member>
      <member name="ok" value="1" c:identifier="GST_PAD_PROBE_OK">
        <doc xml:whitespace="preserve">normal probe return value</doc>
      </member>
      <member name="remove" value="2" c:identifier="GST_PAD_PROBE_REMOVE">
        <doc xml:whitespace="preserve">remove probe</doc>
      </member>
      <member name="pass" value="3" c:identifier="GST_PAD_PROBE_PASS">
        <doc xml:whitespace="preserve">pass the data item in the block probe and block on the next item</doc>
      </member>
    </enumeration>
    <bitfield name="PadProbeType" c:type="GstPadProbeType">
      <doc xml:whitespace="preserve">The different probing types that can occur. When either one of
@GST_PAD_PROBE_TYPE_IDLE or @GST_PAD_PROBE_TYPE_BLOCK is used, the probe will be a
blocking probe.</doc>
      <member name="invalid"
              value="0"
              c:identifier="GST_PAD_PROBE_TYPE_INVALID">
        <doc xml:whitespace="preserve">invalid probe type</doc>
      </member>
      <member name="idle" value="1" c:identifier="GST_PAD_PROBE_TYPE_IDLE">
        <doc xml:whitespace="preserve">probe idle pads and block</doc>
      </member>
      <member name="block" value="2" c:identifier="GST_PAD_PROBE_TYPE_BLOCK">
        <doc xml:whitespace="preserve">probe and block pads</doc>
      </member>
      <member name="buffer"
              value="16"
              c:identifier="GST_PAD_PROBE_TYPE_BUFFER">
        <doc xml:whitespace="preserve">probe buffers</doc>
      </member>
      <member name="buffer_list"
              value="32"
              c:identifier="GST_PAD_PROBE_TYPE_BUFFER_LIST">
        <doc xml:whitespace="preserve">probe buffer lists</doc>
      </member>
      <member name="event_downstream"
              value="64"
              c:identifier="GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM">
        <doc xml:whitespace="preserve">probe downstream events</doc>
      </member>
      <member name="event_upstream"
              value="128"
              c:identifier="GST_PAD_PROBE_TYPE_EVENT_UPSTREAM">
        <doc xml:whitespace="preserve">probe upstream events</doc>
      </member>
      <member name="event_flush"
              value="256"
              c:identifier="GST_PAD_PROBE_TYPE_EVENT_FLUSH">
        <doc xml:whitespace="preserve">probe flush events. This probe has to be explicitly enabled and is not included in the @@GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM or @@GST_PAD_PROBE_TYPE_EVENT_UPSTREAM probe types.</doc>
      </member>
      <member name="query_downstream"
              value="512"
              c:identifier="GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM">
        <doc xml:whitespace="preserve">probe downstream queries</doc>
      </member>
      <member name="query_upstream"
              value="1024"
              c:identifier="GST_PAD_PROBE_TYPE_QUERY_UPSTREAM">
        <doc xml:whitespace="preserve">probe upstream queries</doc>
      </member>
      <member name="push" value="4096" c:identifier="GST_PAD_PROBE_TYPE_PUSH">
        <doc xml:whitespace="preserve">probe push</doc>
      </member>
      <member name="pull" value="8192" c:identifier="GST_PAD_PROBE_TYPE_PULL">
        <doc xml:whitespace="preserve">probe pull</doc>
      </member>
      <member name="blocking"
              value="3"
              c:identifier="GST_PAD_PROBE_TYPE_BLOCKING">
        <doc xml:whitespace="preserve">probe and block at the next opportunity, at data flow or when idle</doc>
      </member>
      <member name="data_downstream"
              value="112"
              c:identifier="GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM">
        <doc xml:whitespace="preserve">probe downstream data (buffers, buffer lists, and events)</doc>
      </member>
      <member name="data_upstream"
              value="128"
              c:identifier="GST_PAD_PROBE_TYPE_DATA_UPSTREAM">
        <doc xml:whitespace="preserve">probe upstream data (events)</doc>
      </member>
      <member name="data_both"
              value="240"
              c:identifier="GST_PAD_PROBE_TYPE_DATA_BOTH">
        <doc xml:whitespace="preserve">probe upstream and downstream data (buffers, buffer lists, and events)</doc>
      </member>
      <member name="block_downstream"
              value="114"
              c:identifier="GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM">
        <doc xml:whitespace="preserve">probe and block downstream data (buffers, buffer lists, and events)</doc>
      </member>
      <member name="block_upstream"
              value="130"
              c:identifier="GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM">
        <doc xml:whitespace="preserve">probe and block upstream data (events)</doc>
      </member>
      <member name="event_both"
              value="192"
              c:identifier="GST_PAD_PROBE_TYPE_EVENT_BOTH">
        <doc xml:whitespace="preserve">probe upstream and downstream events</doc>
      </member>
      <member name="query_both"
              value="1536"
              c:identifier="GST_PAD_PROBE_TYPE_QUERY_BOTH">
        <doc xml:whitespace="preserve">probe upstream and downstream queries</doc>
      </member>
      <member name="all_both"
              value="1776"
              c:identifier="GST_PAD_PROBE_TYPE_ALL_BOTH">
        <doc xml:whitespace="preserve">probe upstream events and queries and downstream buffers, buffer lists, events and queries</doc>
      </member>
      <member name="scheduling"
              value="12288"
              c:identifier="GST_PAD_PROBE_TYPE_SCHEDULING">
        <doc xml:whitespace="preserve">probe push and pull</doc>
      </member>
    </bitfield>
    <callback name="PadQueryFunction" c:type="GstPadQueryFunction">
      <doc xml:whitespace="preserve">The signature of the query function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the query could be performed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad to query.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstQuery object to execute</doc>
          <type name="Query" c:type="GstQuery*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PadStickyEventsForeachFunction"
              c:type="GstPadStickyEventsForeachFunction">
      <doc xml:whitespace="preserve">Callback used by gst_pad_sticky_events_foreach().

When this function returns %TRUE, the next event will be
returned. When %FALSE is returned, gst_pad_sticky_events_foreach() will return.

When @event is set to NULL, the item will be removed from the list of sticky events.
When @event has been made writable, the new buffer reference can be assigned
to @event. This function is responsible for unreffing the old event when
removing or modifying.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the iteration should continue</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:whitespace="preserve">a sticky #GstEvent.</doc>
          <type name="Event" c:type="GstEvent**"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">the #gpointer to optional user data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="PadTemplate"
           c:symbol-prefix="pad_template"
           c:type="GstPadTemplate"
           parent="Object"
           glib:type-name="GstPadTemplate"
           glib:get-type="gst_pad_template_get_type"
           glib:type-struct="PadTemplateClass">
      <doc xml:whitespace="preserve">Padtemplates describe the possible media types a pad or an elementfactory can
handle. This allows for both inspection of handled types before loading the
element plugin as well as identifying pads on elements that are not yet
created (request or sometimes pads).

Pad and PadTemplates have #GstCaps attached to it to describe the media type
they are capable of dealing with. gst_pad_template_get_caps() or
GST_PAD_TEMPLATE_CAPS() are used to get the caps of a padtemplate. It's not
possible to modify the caps of a padtemplate after creation.

PadTemplates have a #GstPadPresence property which identifies the lifetime
of the pad and that can be retrieved with GST_PAD_TEMPLATE_PRESENCE(). Also
the direction of the pad can be retrieved from the #GstPadTemplate with
GST_PAD_TEMPLATE_DIRECTION().

The GST_PAD_TEMPLATE_NAME_TEMPLATE () is important for GST_PAD_REQUEST pads
because it has to be used as the name in the gst_element_get_request_pad()
call to instantiate a pad from this template.

Padtemplates can be created with gst_pad_template_new() or with
gst_static_pad_template_get (), which creates a #GstPadTemplate from a
#GstStaticPadTemplate that can be filled with the
convenient GST_STATIC_PAD_TEMPLATE() macro.

A padtemplate can be used to create a pad (see gst_pad_new_from_template()
or gst_pad_new_from_static_template ()) or to add to an element class
(see gst_element_class_add_pad_template ()).

The following code example shows the code to create a pad from a padtemplate.
&lt;example&gt;
&lt;title&gt;Create a pad from a padtemplate&lt;/title&gt;
  &lt;programlisting&gt;
  GstStaticPadTemplate my_template =
  GST_STATIC_PAD_TEMPLATE (
    "sink",          // the name of the pad
    GST_PAD_SINK,    // the direction of the pad
    GST_PAD_ALWAYS,  // when this pad will be present
    GST_STATIC_CAPS (        // the capabilities of the padtemplate
      "audio/x-raw, "
        "channels = (int) [ 1, 6 ]"
    )
  );
  void
  my_method (void)
  {
    GstPad *pad;
    pad = gst_pad_new_from_static_template (&amp;amp;my_template, "sink");
    ...
  }
  &lt;/programlisting&gt;
&lt;/example&gt;

The following example shows you how to add the padtemplate to an
element class, this is usually done in the class_init of the class:
&lt;informalexample&gt;
  &lt;programlisting&gt;
  static void
  my_element_class_init (GstMyElementClass *klass)
  {
    GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);

    gst_element_class_add_pad_template (gstelement_class,
        gst_static_pad_template_get (&amp;amp;my_template));
  }
  &lt;/programlisting&gt;
&lt;/informalexample&gt;

Last reviewed on 2006-02-14 (0.10.3)</doc>
      <constructor name="new" c:identifier="gst_pad_template_new">
        <doc xml:whitespace="preserve">Creates a new pad template with a name according to the given template
and with the given arguments.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #GstPadTemplate.</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
        <parameters>
          <parameter name="name_template" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name template.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadDirection of the template.</doc>
            <type name="PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="presence" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPadPresence of the pad.</doc>
            <type name="PadPresence" c:type="GstPadPresence"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstCaps set for the template.</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="pad_created" invoker="pad_created">
        <doc xml:whitespace="preserve">Emit the pad-created signal for this template when created by this pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad that created it</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_caps" c:identifier="gst_pad_template_get_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the pad template.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstCaps of the pad template. Unref after usage.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="pad_created" c:identifier="gst_pad_template_pad_created">
        <doc xml:whitespace="preserve">Emit the pad-created signal for this template when created by this pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad that created it</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <property name="caps"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The capabilities of the pad described by the pad template.</doc>
        <type name="Caps"/>
      </property>
      <property name="direction"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The direction of the pad described by the pad template.</doc>
        <type/>
      </property>
      <property name="name-template"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">The name template of the pad template.</doc>
        <type name="utf8"/>
      </property>
      <property name="presence"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:whitespace="preserve">When the pad described by the pad template will become available.</doc>
        <type/>
      </property>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="name_template">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="direction">
        <type name="PadDirection" c:type="GstPadDirection"/>
      </field>
      <field name="presence">
        <type name="PadPresence" c:type="GstPadPresence"/>
      </field>
      <field name="caps">
        <type name="Caps" c:type="GstCaps*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="pad-created" when="last">
        <doc xml:whitespace="preserve">This signal is fired when an element creates a pad from this template.</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pad that was created.</doc>
            <type name="Pad"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="PadTemplateClass"
            c:type="GstPadTemplateClass"
            glib:is-gtype-struct-for="PadTemplate">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="pad_created">
        <callback name="pad_created">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="templ" transfer-ownership="none">
              <type name="PadTemplate" c:type="GstPadTemplate*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <doc xml:whitespace="preserve">the #GstPad that created it</doc>
              <type name="Pad" c:type="GstPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="PadTemplateFlags" c:type="GstPadTemplateFlags">
      <doc xml:whitespace="preserve">Flags for the padtemplate</doc>
      <member name="pad_template_flag_last"
              value="256"
              c:identifier="GST_PAD_TEMPLATE_FLAG_LAST">
        <doc xml:whitespace="preserve">first flag that can be used by subclasses.</doc>
      </member>
    </bitfield>
    <callback name="PadUnlinkFunction" c:type="GstPadUnlinkFunction">
      <doc xml:whitespace="preserve">Function signature to handle a unlinking the pad prom its peer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstPad that is linked.</doc>
          <type name="Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="parent" transfer-ownership="none">
          <doc xml:whitespace="preserve">the parent of @pad. If the #GST_PAD_FLAG_NEED_PARENT flag is set, @parent is guaranteed to be not-NULL and remain valid during the execution of this function.</doc>
          <type name="Object" c:type="GstObject*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ParamFraction"
           c:symbol-prefix="param_spec_fraction"
           parent="GObject.ParamSpec"
           glib:type-name="GstParamFraction"
           glib:get-type="gst_param_spec_fraction_get_type"
           glib:fundamental="1">
    </class>
    <record name="ParamSpecFraction" c:type="GstParamSpecFraction">
      <doc xml:whitespace="preserve">A GParamSpec derived structure that contains the meta data for fractional
properties.</doc>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="min_num" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="min_den" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="max_num" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="max_den" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="def_num" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="def_den" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <record name="ParseContext"
            c:type="GstParseContext"
            glib:type-name="GstParseContext"
            glib:get-type="gst_parse_context_get_type"
            c:symbol-prefix="parse_context">
      <doc xml:whitespace="preserve">Opaque structure.</doc>
      <constructor name="new" c:identifier="gst_parse_context_new">
        <doc xml:whitespace="preserve">Allocates a parse context for use with gst_parse_launch_full() or
gst_parse_launchv_full().

Free-function: gst_parse_context_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly-allocated parse context. Free with gst_parse_context_free() when no longer needed.</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </return-value>
      </constructor>
      <method name="free" c:identifier="gst_parse_context_free">
        <doc xml:whitespace="preserve">Frees a parse context previously allocated with gst_parse_context_new().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_missing_elements"
              c:identifier="gst_parse_context_get_missing_elements">
        <doc xml:whitespace="preserve">Retrieve missing elements from a previous run of gst_parse_launch_full()
or gst_parse_launchv_full(). Will only return results if an error code
of %GST_PARSE_ERROR_NO_SUCH_ELEMENT was returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a NULL-terminated array of element factory name strings of missing elements. Free with g_strfreev() when no longer needed.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
    </record>
    <enumeration name="ParseError"
                 c:type="GstParseError"
                 glib:error-domain="gst_parse_error">
      <doc xml:whitespace="preserve">The different parsing errors that can occur.</doc>
      <member name="syntax" value="0" c:identifier="GST_PARSE_ERROR_SYNTAX">
        <doc xml:whitespace="preserve">A syntax error occured.</doc>
      </member>
      <member name="no_such_element"
              value="1"
              c:identifier="GST_PARSE_ERROR_NO_SUCH_ELEMENT">
        <doc xml:whitespace="preserve">The description contained an unknown element</doc>
      </member>
      <member name="no_such_property"
              value="2"
              c:identifier="GST_PARSE_ERROR_NO_SUCH_PROPERTY">
        <doc xml:whitespace="preserve">An element did not have a specified property</doc>
      </member>
      <member name="link" value="3" c:identifier="GST_PARSE_ERROR_LINK">
        <doc xml:whitespace="preserve">There was an error linking two pads.</doc>
      </member>
      <member name="could_not_set_property"
              value="4"
              c:identifier="GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY">
        <doc xml:whitespace="preserve">There was an error setting a property</doc>
      </member>
      <member name="empty_bin"
              value="5"
              c:identifier="GST_PARSE_ERROR_EMPTY_BIN">
        <doc xml:whitespace="preserve">An empty bin was specified.</doc>
      </member>
      <member name="empty" value="6" c:identifier="GST_PARSE_ERROR_EMPTY">
        <doc xml:whitespace="preserve">An empty description was specified</doc>
      </member>
    </enumeration>
    <bitfield name="ParseFlags" c:type="GstParseFlags">
      <doc xml:whitespace="preserve">Parsing options.</doc>
      <member name="none" value="0" c:identifier="GST_PARSE_FLAG_NONE">
        <doc xml:whitespace="preserve">Do not use any special parsing options.</doc>
      </member>
      <member name="fatal_errors"
              value="1"
              c:identifier="GST_PARSE_FLAG_FATAL_ERRORS">
        <doc xml:whitespace="preserve">Always return NULL when an error occurs (default behaviour is to return partially constructed bins or elements in some cases)</doc>
      </member>
    </bitfield>
    <class name="Pipeline"
           c:symbol-prefix="pipeline"
           c:type="GstPipeline"
           parent="Bin"
           glib:type-name="GstPipeline"
           glib:get-type="gst_pipeline_get_type"
           glib:type-struct="PipelineClass">
      <doc xml:whitespace="preserve">A #GstPipeline is a special #GstBin used as the toplevel container for
the filter graph. The #GstPipeline will manage the selection and
distribution of a global #GstClock as well as provide a #GstBus to the
application.

gst_pipeline_new() is used to create a pipeline. when you are done with
the pipeline, use gst_object_unref() to free its resources including all
added #GstElement objects (if not otherwise referenced).

Elements are added and removed from the pipeline using the #GstBin
methods like gst_bin_add() and gst_bin_remove() (see #GstBin).

Before changing the state of the #GstPipeline (see #GstElement) a #GstBus
can be retrieved with gst_pipeline_get_bus(). This bus can then be
used to receive #GstMessage from the elements in the pipeline.

By default, a #GstPipeline will automatically flush the pending #GstBus
messages when going to the NULL state to ensure that no circular
references exist when no messages are read from the #GstBus. This
behaviour can be changed with gst_pipeline_set_auto_flush_bus().

When the #GstPipeline performs the PAUSED to PLAYING state change it will
select a clock for the elements. The clock selection algorithm will by
default select a clock provided by an element that is most upstream
(closest to the source). For live pipelines (ones that return
#GST_STATE_CHANGE_NO_PREROLL from the gst_element_set_state() call) this
will select the clock provided by the live source. For normal pipelines
this will select a clock provided by the sinks (most likely the audio
sink). If no element provides a clock, a default #GstSystemClock is used.

The clock selection can be controlled with the gst_pipeline_use_clock()
method, which will enforce a given clock on the pipeline. With
gst_pipeline_auto_clock() the default clock selection algorithm can be
restored.

A #GstPipeline maintains a running time for the elements. The running
time is defined as the difference between the current clock time and
the base time. When the pipeline goes to READY or a flushing seek is
performed on it, the running time is reset to 0. When the pipeline is
set from PLAYING to PAUSED, the current clock time is sampled and used to
configure the base time for the elements when the pipeline is set
to PLAYING again. The effect is that the running time (as the difference
between the clock time and the base time) will count how much time was spent
in the PLAYING state. This default behaviour can be changed with the
gst_element_set_start_time() method.

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <implements name="ChildProxy"/>
      <constructor name="new" c:identifier="gst_pipeline_new">
        <doc xml:whitespace="preserve">Create a new pipeline with the given name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">newly created GstPipeline  MT safe.</doc>
          <type name="Element" c:type="GstElement*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new pipeline</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="auto_clock" c:identifier="gst_pipeline_auto_clock">
        <doc xml:whitespace="preserve">Let @pipeline select a clock automatically. This is the default
behaviour.

Use this function if you previous forced a fixed clock with
gst_pipeline_use_clock() and want to restore the default
pipeline clock selection algorithm.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_auto_flush_bus"
              c:identifier="gst_pipeline_get_auto_flush_bus">
        <doc xml:whitespace="preserve">Check if @pipeline will automatically flush messages when going to
the NULL state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">whether the pipeline will automatically flush its bus when going from READY to NULL state or not.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="get_bus" c:identifier="gst_pipeline_get_bus">
        <doc xml:whitespace="preserve">Gets the #GstBus of @pipeline. The bus allows applications to receive
#GstMessage packets.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstBus, unref after usage.  MT safe.</doc>
          <type name="Bus" c:type="GstBus*"/>
        </return-value>
      </method>
      <method name="get_clock" c:identifier="gst_pipeline_get_clock">
        <doc xml:whitespace="preserve">Gets the current clock used by @pipeline.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstClock, unref after usage.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </method>
      <method name="get_delay" c:identifier="gst_pipeline_get_delay">
        <doc xml:whitespace="preserve">Get the configured delay (see gst_pipeline_set_delay()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The configured delay.  MT safe.</doc>
          <type name="ClockTime" c:type="GstClockTime"/>
        </return-value>
      </method>
      <method name="set_auto_flush_bus"
              c:identifier="gst_pipeline_set_auto_flush_bus">
        <doc xml:whitespace="preserve">Usually, when a pipeline goes from READY to NULL state, it automatically
flushes all pending messages on the bus, which is done for refcounting
purposes, to break circular references.

This means that applications that update state using (async) bus messages
(e.g. do certain things when a pipeline goes from PAUSED to READY) might
not get to see messages when the pipeline is shut down, because they might
be flushed before they can be dispatched in the main thread. This behaviour
can be disabled using this function.

It is important that all messages on the bus are handled when the
automatic flushing is disabled else memory leaks will be introduced.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="auto_flush" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether or not to automatically flush the bus when the pipeline goes from READY to NULL state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clock" c:identifier="gst_pipeline_set_clock">
        <doc xml:whitespace="preserve">Set the clock for @pipeline. The clock will be distributed
to all the elements managed by the pipeline.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the clock could be set on the pipeline. FALSE if some element did not accept the clock.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock to set</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_delay" c:identifier="gst_pipeline_set_delay">
        <doc xml:whitespace="preserve">Set the expected delay needed for all elements to perform the
PAUSED to PLAYING state change. @delay will be added to the
base time of the elements so that they wait an additional @delay
amount of time before starting to process buffers and cannot be
#GST_CLOCK_TIME_NONE.

This option is used for tuning purposes and should normally not be
used.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:whitespace="preserve">the delay</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="use_clock" c:identifier="gst_pipeline_use_clock">
        <doc xml:whitespace="preserve">Force @pipeline to use the given @clock. The pipeline will
always use the given clock even if new clock providers are added
to this pipeline.

If @clock is NULL all clocking will be disabled which will make
the pipeline run as fast as possible.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="clock" transfer-ownership="none">
            <doc xml:whitespace="preserve">the clock to use</doc>
            <type name="Clock" c:type="GstClock*"/>
          </parameter>
        </parameters>
      </method>
      <property name="auto-flush-bus" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">Whether or not to automatically flush all messages on the
pipeline's bus when going from READY to NULL state. Please see
gst_pipeline_set_auto_flush_bus() for more information on this option.</doc>
        <type name="gboolean"/>
      </property>
      <property name="delay" writable="1" transfer-ownership="none">
        <doc xml:whitespace="preserve">The expected delay needed for elements to spin up to the
PLAYING state expressed in nanoseconds.
see gst_pipeline_set_delay() for more information on this option.</doc>
        <type name="guint64"/>
      </property>
      <field name="bin">
        <type name="Bin" c:type="GstBin"/>
      </field>
      <field name="fixed_clock">
        <type name="Clock" c:type="GstClock*"/>
      </field>
      <field name="stream_time">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="delay">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PipelinePrivate" c:type="GstPipelinePrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PipelineClass"
            c:type="GstPipelineClass"
            glib:is-gtype-struct-for="Pipeline">
      <field name="parent_class">
        <type name="BinClass" c:type="GstBinClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="PipelineFlags" c:type="GstPipelineFlags">
      <doc xml:whitespace="preserve">Pipeline flags</doc>
      <member name="fixed_clock"
              value="524288"
              c:identifier="GST_PIPELINE_FLAG_FIXED_CLOCK">
        <doc xml:whitespace="preserve">this pipeline works with a fixed clock</doc>
      </member>
      <member name="last"
              value="8388608"
              c:identifier="GST_PIPELINE_FLAG_LAST">
        <doc xml:whitespace="preserve">offset to define more flags</doc>
      </member>
    </bitfield>
    <record name="PipelinePrivate" c:type="GstPipelinePrivate" disguised="1">
    </record>
    <class name="Plugin"
           c:symbol-prefix="plugin"
           c:type="GstPlugin"
           parent="Object"
           glib:type-name="GstPlugin"
           glib:get-type="gst_plugin_get_type"
           glib:type-struct="PluginClass">
      <doc xml:whitespace="preserve">GStreamer is extensible, so #GstElement instances can be loaded at runtime.
A plugin system can provide one or more of the basic
&lt;application&gt;GStreamer&lt;/application&gt; #GstPluginFeature subclasses.

A plugin should export a symbol &lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt; that is a
struct of type #GstPluginDesc.
the plugin loader will check the version of the core library the plugin was
linked against and will create a new #GstPlugin. It will then call the
#GstPluginInitFunc function that was provided in the
&lt;symbol&gt;gst_plugin_desc&lt;/symbol&gt;.

Once you have a handle to a #GstPlugin (e.g. from the #GstRegistry), you
can add any object that subclasses #GstPluginFeature.

Usually plugins are always automaticlly loaded so you don't need to call
gst_plugin_load() explicitly to bring it into memory. There are options to
statically link plugins to an app or even use GStreamer without a plugin
repository in which case gst_plugin_load() can be needed to bring the plugin
into memory.</doc>
      <function name="error_quark" c:identifier="gst_plugin_error_quark">
        <doc xml:whitespace="preserve">Get the error quark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The error quark used in GError messages</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="list_free" c:identifier="gst_plugin_list_free">
        <doc xml:whitespace="preserve">Unrefs each member of @list, then frees the list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">list of #GstPlugin</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Plugin"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="load_by_name" c:identifier="gst_plugin_load_by_name">
        <doc xml:whitespace="preserve">Load the named plugin. Refs the plugin.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a loaded plugin, or NULL on error.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of plugin to load</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="load_file"
                c:identifier="gst_plugin_load_file"
                throws="1">
        <doc xml:whitespace="preserve">Loads the given plugin and refs it.  Caller needs to unref after use.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to the existing loaded GstPlugin, a reference to the newly-loaded GstPlugin, or NULL if an error occurred.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin filename to load</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_static"
                c:identifier="gst_plugin_register_static">
        <doc xml:whitespace="preserve">Registers a static plugin, ie. a plugin which is private to an application
or library and contained within the application or library (as opposed to
being shipped as a separate module file).

You must make sure that GStreamer has been initialised (with gst_init() or
via gst_init_get_option_group()) before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the plugin was registered correctly, otherwise FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="major_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the major version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MAJOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minor_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minor version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MINOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a unique name of the plugin (ideally prefixed with an application- or library-specific namespace prefix in order to avoid name conflicts in case a similar plugin with the same name ever gets added to GStreamer)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">description of the plugin</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="init_func" transfer-ownership="none" scope="call">
            <doc xml:whitespace="preserve">pointer to the init function of this plugin.</doc>
            <type name="PluginInitFunc" c:type="GstPluginInitFunc"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:whitespace="preserve">version string of the plugin</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="license" transfer-ownership="none">
            <doc xml:whitespace="preserve">effective license of plugin. Must be one of the approved licenses (see #GstPluginDesc above) or the plugin will not be registered.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">source module plugin belongs to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="package" transfer-ownership="none">
            <doc xml:whitespace="preserve">shipped package plugin belongs to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none">
            <doc xml:whitespace="preserve">URL to provider of plugin</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_static_full"
                c:identifier="gst_plugin_register_static_full">
        <doc xml:whitespace="preserve">Registers a static plugin, ie. a plugin which is private to an application
or library and contained within the application or library (as opposed to
being shipped as a separate module file) with a #GstPluginInitFullFunc
which allows user data to be passed to the callback function (useful
for bindings).

You must make sure that GStreamer has been initialised (with gst_init() or
via gst_init_get_option_group()) before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the plugin was registered correctly, otherwise FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="major_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the major version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MAJOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="minor_version" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minor version number of the GStreamer core that the plugin was compiled for, you can just use GST_VERSION_MINOR here</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a unique name of the plugin (ideally prefixed with an application- or library-specific namespace prefix in order to avoid name conflicts in case a similar plugin with the same name ever gets added to GStreamer)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:whitespace="preserve">description of the plugin</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="init_full_func"
                     transfer-ownership="none"
                     scope="call"
                     closure="10">
            <doc xml:whitespace="preserve">pointer to the init function with user data of this plugin.</doc>
            <type name="PluginInitFullFunc" c:type="GstPluginInitFullFunc"/>
          </parameter>
          <parameter name="version" transfer-ownership="none">
            <doc xml:whitespace="preserve">version string of the plugin</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="license" transfer-ownership="none">
            <doc xml:whitespace="preserve">effective license of plugin. Must be one of the approved licenses (see #GstPluginDesc above) or the plugin will not be registered.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:whitespace="preserve">source module plugin belongs to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="package" transfer-ownership="none">
            <doc xml:whitespace="preserve">shipped package plugin belongs to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="origin" transfer-ownership="none">
            <doc xml:whitespace="preserve">URL to provider of plugin</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">gpointer to user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_dependency" c:identifier="gst_plugin_add_dependency">
        <doc xml:whitespace="preserve">Make GStreamer aware of external dependencies which affect the feature
set of this plugin (ie. the elements or typefinders associated with it).

GStreamer will re-inspect plugins with external dependencies whenever any
of the external dependencies change. This is useful for plugins which wrap
other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
library and makes visualisations available as GStreamer elements, or a
codec loader which exposes elements and/or caps dependent on what external
codec libraries are currently installed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="env_vars" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated array of environment variables affecting the feature set of the plugin (e.g. an environment variable containing paths where to look for additional modules/plugins of a library), or NULL. Environment variable names may be followed by a path component which will be added to the content of the environment variable, e.g. "HOME/.mystuff/plugins".</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated array of directories/paths where dependent files may be.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated array of file names (or file name suffixes, depending on @flags) to be used in combination with the paths from @paths and/or the paths extracted from the environment variables in @env_vars, or NULL.</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE</doc>
            <type name="PluginDependencyFlags"
                  c:type="GstPluginDependencyFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_dependency_simple"
              c:identifier="gst_plugin_add_dependency_simple">
        <doc xml:whitespace="preserve">Make GStreamer aware of external dependencies which affect the feature
set of this plugin (ie. the elements or typefinders associated with it).

GStreamer will re-inspect plugins with external dependencies whenever any
of the external dependencies change. This is useful for plugins which wrap
other plugin systems, e.g. a plugin which wraps a plugin-based visualisation
library and makes visualisations available as GStreamer elements, or a
codec loader which exposes elements and/or caps dependent on what external
codec libraries are currently installed.

Convenience wrapper function for gst_plugin_add_dependency() which
takes simple strings as arguments instead of string arrays, with multiple
arguments separated by predefined delimiters (see above).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="env_vars" transfer-ownership="none">
            <doc xml:whitespace="preserve">one or more environment variables (separated by ':', ';' or ','), or NULL. Environment variable names may be followed by a path component which will be added to the content of the environment variable, e.g. "HOME/.mystuff/plugins:MYSTUFF_PLUGINS_PATH"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:whitespace="preserve">one ore more directory paths (separated by ':' or ';' or ','), or NULL. Example: "/usr/lib/mystuff/plugins"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="names" transfer-ownership="none">
            <doc xml:whitespace="preserve">one or more file names or file name suffixes (separated by commas), or NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">optional flags, or #GST_PLUGIN_DEPENDENCY_FLAG_NONE</doc>
            <type name="PluginDependencyFlags"
                  c:type="GstPluginDependencyFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cache_data" c:identifier="gst_plugin_get_cache_data">
        <doc xml:whitespace="preserve">Gets the plugin specific data cache. If it is %NULL there is no cached data
stored. This is the case when the registry is getting rebuilt.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The cached data as a #GstStructure or %NULL.</doc>
          <type name="Structure" c:type="const GstStructure*"/>
        </return-value>
      </method>
      <method name="get_description" c:identifier="gst_plugin_get_description">
        <doc xml:whitespace="preserve">Get the long descriptive name of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the long name of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_filename" c:identifier="gst_plugin_get_filename">
        <doc xml:whitespace="preserve">get the filename of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the filename of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_license" c:identifier="gst_plugin_get_license">
        <doc xml:whitespace="preserve">get the license of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the license of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="gst_plugin_get_name">
        <doc xml:whitespace="preserve">Get the short name of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_origin" c:identifier="gst_plugin_get_origin">
        <doc xml:whitespace="preserve">get the URL where the plugin comes from</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the origin of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_package" c:identifier="gst_plugin_get_package">
        <doc xml:whitespace="preserve">get the package the plugin belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the package of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_release_date_string"
              c:identifier="gst_plugin_get_release_date_string">
        <doc xml:whitespace="preserve">Get the release date (and possibly time) in form of a string, if available.

For normal GStreamer plugin releases this will usually just be a date in
the form of "YYYY-MM-DD", while pre-releases and builds from git may contain
a time component after the date as well, in which case the string will be
formatted like "YYYY-MM-DDTHH:MMZ" (e.g. "2012-04-30T09:30Z").

There may be plugins that do not have a valid release date set on them.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the date string of the plugin, or %NULL if not available.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_source" c:identifier="gst_plugin_get_source">
        <doc xml:whitespace="preserve">get the source module the plugin belongs to.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the source of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_version" c:identifier="gst_plugin_get_version">
        <doc xml:whitespace="preserve">get the version of the plugin</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the version of the plugin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="is_loaded" c:identifier="gst_plugin_is_loaded">
        <doc xml:whitespace="preserve">queries if the plugin is loaded into memory</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE is loaded, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="load" c:identifier="gst_plugin_load">
        <doc xml:whitespace="preserve">Loads @plugin. Note that the *return value* is the loaded plugin; @plugin is
untouched. The normal use pattern of this function goes like this:

&lt;programlisting&gt;
GstPlugin *loaded_plugin;
loaded_plugin = gst_plugin_load (plugin);
// presumably, we're no longer interested in the potentially-unloaded plugin
gst_object_unref (plugin);
plugin = loaded_plugin;
&lt;/programlisting&gt;</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to a loaded plugin, or NULL on error.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
      </method>
      <method name="set_cache_data" c:identifier="gst_plugin_set_cache_data">
        <doc xml:whitespace="preserve">Adds plugin specific data to cache. Passes the ownership of the structure to
the @plugin.

The cache is flushed every time the registry is rebuilt.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="cache_data" transfer-ownership="full">
            <doc xml:whitespace="preserve">a structure containing the data to cache</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="PluginClass"
            c:type="GstPluginClass"
            disguised="1"
            glib:is-gtype-struct-for="Plugin">
    </record>
    <bitfield name="PluginDependencyFlags" c:type="GstPluginDependencyFlags">
      <doc xml:whitespace="preserve">Flags used in connection with gst_plugin_add_dependency().</doc>
      <member name="none"
              value="0"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_NONE">
        <doc xml:whitespace="preserve">no special flags</doc>
      </member>
      <member name="recurse"
              value="1"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_RECURSE">
        <doc xml:whitespace="preserve">recurse into subdirectories</doc>
      </member>
      <member name="paths_are_default_only"
              value="2"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY">
        <doc xml:whitespace="preserve">use paths argument only if none of the environment variables is set</doc>
      </member>
      <member name="file_name_is_suffix"
              value="4"
              c:identifier="GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX">
        <doc xml:whitespace="preserve">interpret filename argument as filter suffix and check all matching files in the directory</doc>
      </member>
    </bitfield>
    <record name="PluginDesc" c:type="GstPluginDesc">
      <doc xml:whitespace="preserve">A plugin should export a variable of this type called plugin_desc. The plugin
loader will use the data provided there to initialize the plugin.

The @licence parameter must be one of: LGPL, GPL, QPL, GPL/QPL, MPL,
BSD, MIT/X11, Proprietary, unknown.</doc>
      <field name="major_version" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="minor_version" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="plugin_init" writable="1">
        <type name="PluginInitFunc" c:type="GstPluginInitFunc"/>
      </field>
      <field name="version" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="license" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="source" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="package" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="origin" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="release_datetime" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="PluginError" c:type="GstPluginError">
      <doc xml:whitespace="preserve">The plugin loading errors</doc>
      <member name="module" value="0" c:identifier="GST_PLUGIN_ERROR_MODULE">
        <doc xml:whitespace="preserve">The plugin could not be loaded</doc>
      </member>
      <member name="dependencies"
              value="1"
              c:identifier="GST_PLUGIN_ERROR_DEPENDENCIES">
        <doc xml:whitespace="preserve">The plugin has unresolved dependencies</doc>
      </member>
      <member name="name_mismatch"
              value="2"
              c:identifier="GST_PLUGIN_ERROR_NAME_MISMATCH">
        <doc xml:whitespace="preserve">The plugin has already be loaded from a different file</doc>
      </member>
    </enumeration>
    <class name="PluginFeature"
           c:symbol-prefix="plugin_feature"
           c:type="GstPluginFeature"
           parent="Object"
           abstract="1"
           glib:type-name="GstPluginFeature"
           glib:get-type="gst_plugin_feature_get_type"
           glib:type-struct="PluginFeatureClass">
      <doc xml:whitespace="preserve">This is a base class for anything that can be added to a #GstPlugin.</doc>
      <function name="list_copy" c:identifier="gst_plugin_feature_list_copy">
        <doc xml:whitespace="preserve">Copies the list of features. Caller should call @gst_plugin_feature_list_free
when done with the list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a copy of @list, with each feature's reference count incremented.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">list of #GstPluginFeature</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="PluginFeature"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="list_debug" c:identifier="gst_plugin_feature_list_debug">
        <doc xml:whitespace="preserve">Debug the plugin feature names in @list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GList of plugin features</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="PluginFeature"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="list_free" c:identifier="gst_plugin_feature_list_free">
        <doc xml:whitespace="preserve">Unrefs each member of @list, then frees the list.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">list of #GstPluginFeature</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="PluginFeature"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="rank_compare_func"
                c:identifier="gst_plugin_feature_rank_compare_func">
        <doc xml:whitespace="preserve">Compares the two given #GstPluginFeature instances. This function can be
used as a #GCompareFunc when sorting by rank and then by name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">negative value if the rank of p1 &gt; the rank of p2 or the ranks are equal but the name of p1 comes before the name of p2; zero if the rank and names are equal; positive value if the rank of p1 &lt; the rank of p2 or the ranks are equal but the name of p2 comes after the name of p1</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="p1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPluginFeature</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="p2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPluginFeature</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="check_version"
              c:identifier="gst_plugin_feature_check_version">
        <doc xml:whitespace="preserve">Checks whether the given plugin feature is at least
 the required version</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if the plugin feature has at least the required version, otherwise #FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="min_major" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum required major version</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_minor" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum required minor version</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_micro" transfer-ownership="none">
            <doc xml:whitespace="preserve">minimum required micro version</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_plugin" c:identifier="gst_plugin_feature_get_plugin">
        <doc xml:whitespace="preserve">Get the plugin that provides this feature.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the plugin that provides this feature, or %NULL. Unref with gst_object_unref() when no longer needed.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
      </method>
      <method name="get_rank" c:identifier="gst_plugin_feature_get_rank">
        <doc xml:whitespace="preserve">Gets the rank of a plugin feature.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The rank of the feature</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="load" c:identifier="gst_plugin_feature_load">
        <doc xml:whitespace="preserve">Loads the plugin containing @feature if it's not already loaded. @feature is
unaffected; use the return value instead.

Normally this function is used like this:
|[
GstPluginFeature *loaded_feature;

loaded_feature = gst_plugin_feature_load (feature);
// presumably, we're no longer interested in the potentially-unloaded feature
gst_object_unref (feature);
feature = loaded_feature;
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a reference to the loaded feature, or NULL on error</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </return-value>
      </method>
      <method name="set_rank" c:identifier="gst_plugin_feature_set_rank">
        <doc xml:whitespace="preserve">Specifies a rank for a plugin feature, so that autoplugging uses
the most appropriate feature.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rank" transfer-ownership="none">
            <doc xml:whitespace="preserve">rank value - higher number means more priority rank</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="PluginFeatureClass"
            c:type="GstPluginFeatureClass"
            disguised="1"
            glib:is-gtype-struct-for="PluginFeature">
    </record>
    <callback name="PluginFeatureFilter" c:type="GstPluginFeatureFilter">
      <doc xml:whitespace="preserve">A function that can be used with e.g. gst_registry_feature_filter()
to get a list of pluginfeature that match certain criteria.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE for a positive match, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:whitespace="preserve">the pluginfeature to check</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the user_data that has been passed on e.g. gst_registry_feature_filter()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PluginFilter" c:type="GstPluginFilter">
      <doc xml:whitespace="preserve">A function that can be used with e.g. gst_registry_plugin_filter()
to get a list of plugins that match certain criteria.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE for a positive match, FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">the plugin to check</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">the user_data that has been passed on e.g. gst_registry_plugin_filter()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="PluginFlags" c:type="GstPluginFlags">
      <doc xml:whitespace="preserve">The plugin loading state</doc>
      <member name="cached" value="16" c:identifier="GST_PLUGIN_FLAG_CACHED">
        <doc xml:whitespace="preserve">Temporarily loaded plugins</doc>
      </member>
      <member name="blacklisted"
              value="32"
              c:identifier="GST_PLUGIN_FLAG_BLACKLISTED">
        <doc xml:whitespace="preserve">The plugin won't be scanned (again)</doc>
      </member>
    </bitfield>
    <callback name="PluginInitFullFunc" c:type="GstPluginInitFullFunc">
      <doc xml:whitespace="preserve">A plugin should provide a pointer to a function of either #GstPluginInitFunc
or this type in the plugin_desc struct.
The function will be called by the loader at startup. One would then
register each #GstPluginFeature. This version allows
user data to be passed to init function (useful for bindings).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if plugin initialised successfully</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">The plugin object</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">extra data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="PluginInitFunc" c:type="GstPluginInitFunc">
      <doc xml:whitespace="preserve">A plugin should provide a pointer to a function of this type in the
plugin_desc struct.
This function will be called by the loader at startup. One would then
register each #GstPluginFeature.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if plugin initialised successfully</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">The plugin object</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Poll" c:type="GstPoll" disguised="1">
      <doc xml:whitespace="preserve">A #GstPoll keeps track of file descriptors much like fd_set (used with
select()) or a struct pollfd array (used with poll()). Once created with
gst_poll_new(), the set can be used to wait for file descriptors to be
readable and/or writable. It is possible to make this wait be controlled
by specifying %TRUE for the @controllable flag when creating the set (or
later calling gst_poll_set_controllable()).

New file descriptors are added to the set using gst_poll_add_fd(), and
removed using gst_poll_remove_fd(). Controlling which file descriptors
should be waited for to become readable and/or writable are done using
gst_poll_fd_ctl_read() and gst_poll_fd_ctl_write().

Use gst_poll_wait() to wait for the file descriptors to actually become
readable and/or writable, or to timeout if no file descriptor is available
in time. The wait can be controlled by calling gst_poll_restart() and
gst_poll_set_flushing().

Once the file descriptor set has been waited for, one can use
gst_poll_fd_has_closed() to see if the file descriptor has been closed,
gst_poll_fd_has_error() to see if it has generated an error,
gst_poll_fd_can_read() to see if it is possible to read from the file
descriptor, and gst_poll_fd_can_write() to see if it is possible to
write to it.</doc>
      <method name="add_fd" c:identifier="gst_poll_add_fd">
        <doc xml:whitespace="preserve">Add a file descriptor to the file descriptor set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file descriptor was successfully added to the set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_can_read" c:identifier="gst_poll_fd_can_read">
        <doc xml:whitespace="preserve">Check if @fd in @set has data to be read.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor has data to be read.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_can_write" c:identifier="gst_poll_fd_can_write">
        <doc xml:whitespace="preserve">Check if @fd in @set can be used for writing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor can be used for writing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_ctl_read" c:identifier="gst_poll_fd_ctl_read">
        <doc xml:whitespace="preserve">Control whether the descriptor @fd in @set will be monitored for
readability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor was successfully updated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new status.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_ctl_write" c:identifier="gst_poll_fd_ctl_write">
        <doc xml:whitespace="preserve">Control whether the descriptor @fd in @set will be monitored for
writability.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor was successfully updated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:whitespace="preserve">a new status.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_has_closed" c:identifier="gst_poll_fd_has_closed">
        <doc xml:whitespace="preserve">Check if @fd in @set has closed the connection.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the connection was closed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_has_error" c:identifier="gst_poll_fd_has_error">
        <doc xml:whitespace="preserve">Check if @fd in @set has an error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the descriptor has an error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fd_ignored" c:identifier="gst_poll_fd_ignored">
        <doc xml:whitespace="preserve">Mark @fd as ignored so that the next call to gst_poll_wait() will yield
the same result for @fd as last time. This function must be called if no
operation (read/write/recv/send/etc.) will be performed on @fd before
the next call to gst_poll_wait().

The reason why this is needed is because the underlying implementation
might not allow querying the fd more than once between calls to one of
the re-enabling operations.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_poll_free">
        <doc xml:whitespace="preserve">Free a file descriptor set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_read_gpollfd" c:identifier="gst_poll_get_read_gpollfd">
        <doc xml:whitespace="preserve">Get a GPollFD for the reading part of the control socket. This is useful when
integrating with a GSource and GMainLoop.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GPollFD</doc>
            <type name="GLib.PollFD" c:type="GPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_control" c:identifier="gst_poll_read_control">
        <doc xml:whitespace="preserve">Read a byte from the control socket of the controllable @set.
This function is mostly useful for timer #GstPoll objects created with
gst_poll_new_timer().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success. %FALSE when @set is not controllable or when there was no byte to read.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="remove_fd" c:identifier="gst_poll_remove_fd">
        <doc xml:whitespace="preserve">Remove a file descriptor from the file descriptor set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the file descriptor was successfully removed from the set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fd" transfer-ownership="none">
            <doc xml:whitespace="preserve">a file descriptor.</doc>
            <type name="PollFD" c:type="GstPollFD*"/>
          </parameter>
        </parameters>
      </method>
      <method name="restart" c:identifier="gst_poll_restart">
        <doc xml:whitespace="preserve">Restart any gst_poll_wait() that is in progress. This function is typically
used after adding or removing descriptors to @set.

If @set is not controllable, then this call will have no effect.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_controllable" c:identifier="gst_poll_set_controllable">
        <doc xml:whitespace="preserve">When @controllable is %TRUE, this function ensures that future calls to
gst_poll_wait() will be affected by gst_poll_restart() and
gst_poll_set_flushing().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the controllability of @set could be updated.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="controllable" transfer-ownership="none">
            <doc xml:whitespace="preserve">new controllable state.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing" c:identifier="gst_poll_set_flushing">
        <doc xml:whitespace="preserve">When @flushing is %TRUE, this function ensures that current and future calls
to gst_poll_wait() will return -1, with errno set to EBUSY.

Unsetting the flushing state will restore normal operation of @set.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:whitespace="preserve">new flushing state.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait" c:identifier="gst_poll_wait">
        <doc xml:whitespace="preserve">Wait for activity on the file descriptors in @set. This function waits up to
the specified @timeout.  A timeout of #GST_CLOCK_TIME_NONE waits forever.

For #GstPoll objects created with gst_poll_new(), this function can only be
called from a single thread at a time.  If called from multiple threads,
-1 will be returned with errno set to EPERM.

This is not true for timer #GstPoll objects created with
gst_poll_new_timer(), where it is allowed to have multiple threads waiting
simultaneously.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of #GstPollFD in @set that have activity or 0 when no activity was detected after @timeout. If an error occurs, -1 is returned and errno is set.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <parameter name="timeout" transfer-ownership="none">
            <doc xml:whitespace="preserve">a timeout in nanoseconds.</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="write_control" c:identifier="gst_poll_write_control">
        <doc xml:whitespace="preserve">Write a byte to the control socket of the controllable @set.
This function is mostly useful for timer #GstPoll objects created with
gst_poll_new_timer(). 

It will make any current and future gst_poll_wait() function return with
1, meaning the control socket is set. After an equal amount of calls to
gst_poll_read_control() have been performed, calls to gst_poll_wait() will
block again until their timeout expired.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success. %FALSE when @set is not controllable or when the byte could not be written.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <function name="new" c:identifier="gst_poll_new" introspectable="0">
        <doc xml:whitespace="preserve">Create a new file descriptor set. If @controllable, it
is possible to restart or flush a call to gst_poll_wait() with
gst_poll_restart() and gst_poll_set_flushing() respectively.

Free-function: gst_poll_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPoll, or %NULL in case of an error. Free with gst_poll_free().</doc>
          <type name="Poll" c:type="GstPoll*"/>
        </return-value>
        <parameters>
          <parameter name="controllable" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether it should be possible to control a wait.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_timer"
                c:identifier="gst_poll_new_timer"
                introspectable="0">
        <doc xml:whitespace="preserve">Create a new poll object that can be used for scheduling cancellable
timeouts.

A timeout is performed with gst_poll_wait(). Multiple timeouts can be
performed from different threads. 

Free-function: gst_poll_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPoll, or %NULL in case of an error. Free with gst_poll_free().</doc>
          <type name="Poll" c:type="GstPoll*"/>
        </return-value>
      </function>
    </record>
    <record name="PollFD" c:type="GstPollFD">
      <doc xml:whitespace="preserve">A file descriptor object.</doc>
      <field name="fd" writable="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="idx" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="init" c:identifier="gst_poll_fd_init">
        <doc xml:whitespace="preserve">Initializes @fd. Alternatively you can initialize it with
#GST_POLL_FD_INIT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <interface name="Preset"
               c:symbol-prefix="preset"
               c:type="GstPreset"
               glib:type-name="GstPreset"
               glib:get-type="gst_preset_get_type"
               glib:type-struct="PresetInterface">
      <doc xml:whitespace="preserve">This interface offers methods to query and manipulate parameter preset sets.
A preset is a bunch of property settings, together with meta data and a name.
The name of a preset serves as key for subsequent method calls to manipulate
single presets.
All instances of one type will share the list of presets. The list is created
on demand, if presets are not used, the list is not created.

The interface comes with a default implementation that serves most plugins.
Wrapper plugins will override most methods to implement support for the
native preset format of those wrapped plugins.
One method that is useful to be overridden is gst_preset_get_property_names().
With that one can control which properties are saved and in which order.

The default implementation supports presets located in a system directory, 
application specific directory and in the users home directory. When getting
a list of presets individual presets are read and overlaid in 1) system, 
2) application and 3) user order. Whenever an earlier entry is newer, the
later entries will be updated.</doc>
      <function name="get_app_dir" c:identifier="gst_preset_get_app_dir">
        <doc xml:whitespace="preserve">Gets the directory for application specific presets if set by the
application.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the directory or %NULL, don't free or modify the string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </function>
      <function name="set_app_dir" c:identifier="gst_preset_set_app_dir">
        <doc xml:whitespace="preserve">Sets an extra directory as an absolute path that should be considered when
looking for presets. Any presets in the application dir will shadow the 
system presets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if the dir already has been set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="app_dir" transfer-ownership="none">
            <doc xml:whitespace="preserve">the application specific preset dir</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="delete_preset" invoker="delete_preset">
        <doc xml:whitespace="preserve">Delete the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_meta" invoker="get_meta">
        <doc xml:whitespace="preserve">Gets the @value for an existing meta data @tag. Meta data @tag names can be
something like e.g. "comment". Returned values need to be released when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name or no value for the given @tag</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">value</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_preset_names" invoker="get_preset_names">
        <doc xml:whitespace="preserve">Get a copy of preset names as a NULL terminated string array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">list with names, ue g_strfreev() after usage.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="get_property_names" invoker="get_property_names">
        <doc xml:whitespace="preserve">Get a the names of the GObject properties that can be used for presets.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an array of property names which should be freed with g_strfreev() after use.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </virtual-method>
      <virtual-method name="load_preset" invoker="load_preset">
        <doc xml:whitespace="preserve">Load the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to load</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="rename_preset" invoker="rename_preset">
        <doc xml:whitespace="preserve">Renames a preset. If there is already a preset by the @new_name it will be
overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with @old_name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">current preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">new preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="save_preset" invoker="save_preset">
        <doc xml:whitespace="preserve">Save the current object settings as a preset under the given name. If there
is already a preset by this @name it will be overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to save</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_meta" invoker="set_meta">
        <doc xml:whitespace="preserve">Sets a new @value for an existing meta data item or adds a new item. Meta
data @tag names can be something like e.g. "comment". Supplying %NULL for the
@value will unset an existing value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">new value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="delete_preset" c:identifier="gst_preset_delete_preset">
        <doc xml:whitespace="preserve">Delete the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_meta" c:identifier="gst_preset_get_meta">
        <doc xml:whitespace="preserve">Gets the @value for an existing meta data @tag. Meta data @tag names can be
something like e.g. "comment". Returned values need to be released when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name or no value for the given @tag</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">value</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_preset_names"
              c:identifier="gst_preset_get_preset_names">
        <doc xml:whitespace="preserve">Get a copy of preset names as a NULL terminated string array.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">list with names, ue g_strfreev() after usage.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_property_names"
              c:identifier="gst_preset_get_property_names">
        <doc xml:whitespace="preserve">Get a the names of the GObject properties that can be used for presets.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">an array of property names which should be freed with g_strfreev() after use.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="load_preset" c:identifier="gst_preset_load_preset">
        <doc xml:whitespace="preserve">Load the given preset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to load</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rename_preset" c:identifier="gst_preset_rename_preset">
        <doc xml:whitespace="preserve">Renames a preset. If there is already a preset by the @new_name it will be
overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with @old_name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="old_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">current preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="new_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">new preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="save_preset" c:identifier="gst_preset_save_preset">
        <doc xml:whitespace="preserve">Save the current object settings as a preset under the given name. If there
is already a preset by this @name it will be overwritten.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name to save</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_meta" c:identifier="gst_preset_set_meta">
        <doc xml:whitespace="preserve">Sets a new @value for an existing meta data item or adds a new item. Meta
data @tag names can be something like e.g. "comment". Supplying %NULL for the
@value will unset an existing value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">preset name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">meta data item name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">new value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="PresetInterface"
            c:type="GstPresetInterface"
            glib:is-gtype-struct-for="Preset">
      <doc xml:whitespace="preserve">#GstPreset interface.</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_preset_names">
        <callback name="get_preset_names">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">list with names, ue g_strfreev() after usage.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_property_names">
        <callback name="get_property_names">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">an array of property names which should be freed with g_strfreev() after use.</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="load_preset">
        <callback name="load_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name to load</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="save_preset">
        <callback name="save_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name to save</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="rename_preset">
        <callback name="rename_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with @old_name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="old_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">current preset name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="new_name" transfer-ownership="none">
              <doc xml:whitespace="preserve">new preset name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delete_preset">
        <callback name="delete_preset">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name to remove</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_meta">
        <callback name="set_meta">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="tag" transfer-ownership="none">
              <doc xml:whitespace="preserve">meta data item name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:whitespace="preserve">new value</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_meta">
        <callback name="get_meta">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">%TRUE for success, %FALSE if e.g. there is no preset with that @name or no value for the given @tag</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="preset" transfer-ownership="none">
              <type name="Preset" c:type="GstPreset*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:whitespace="preserve">preset name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="tag" transfer-ownership="none">
              <doc xml:whitespace="preserve">meta data item name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:whitespace="preserve">value</doc>
              <type name="utf8" c:type="gchar**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="ProgressType" c:type="GstProgressType">
      <doc xml:whitespace="preserve">The type of a %GST_MESSAGE_PROGRESS. The progress messages inform the
application of the status of assynchronous tasks.</doc>
      <member name="start" value="0" c:identifier="GST_PROGRESS_TYPE_START">
        <doc xml:whitespace="preserve">A new task started.</doc>
      </member>
      <member name="continue"
              value="1"
              c:identifier="GST_PROGRESS_TYPE_CONTINUE">
        <doc xml:whitespace="preserve">A task completed and a new one continues.</doc>
      </member>
      <member name="complete"
              value="2"
              c:identifier="GST_PROGRESS_TYPE_COMPLETE">
        <doc xml:whitespace="preserve">A task completed.</doc>
      </member>
      <member name="canceled"
              value="3"
              c:identifier="GST_PROGRESS_TYPE_CANCELED">
        <doc xml:whitespace="preserve">A task was canceled.</doc>
      </member>
      <member name="error" value="4" c:identifier="GST_PROGRESS_TYPE_ERROR">
        <doc xml:whitespace="preserve">A task caused an error. An error message is also posted on the bus.</doc>
      </member>
    </enumeration>
    <class name="ProxyPad"
           c:symbol-prefix="proxy_pad"
           c:type="GstProxyPad"
           parent="Pad"
           glib:type-name="GstProxyPad"
           glib:get-type="gst_proxy_pad_get_type"
           glib:type-struct="ProxyPadClass">
      <function name="chain_default"
                c:identifier="gst_proxy_pad_chain_default">
        <doc xml:whitespace="preserve">Invoke the default chain function of the proxy pad.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">a sink #GstPad, returns GST_FLOW_ERROR if not.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBuffer to send, return GST_FLOW_ERROR if not.</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </function>
      <function name="chain_list_default"
                c:identifier="gst_proxy_pad_chain_list_default">
        <doc xml:whitespace="preserve">Invoke the default chain list function of the proxy pad.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">a sink #GstPad, returns GST_FLOW_ERROR if not.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="list" transfer-ownership="full">
            <doc xml:whitespace="preserve">the #GstBufferList to send, return GST_FLOW_ERROR if not.</doc>
            <type name="BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </function>
      <function name="getrange_default"
                c:identifier="gst_proxy_pad_getrange_default">
        <doc xml:whitespace="preserve">Invoke the default getrange function of the proxy pad.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn from the pad.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">a src #GstPad, returns #GST_FLOW_ERROR if not.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The start offset of the buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">The length of the buffer</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buffer"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to hold the #GstBuffer, returns #GST_FLOW_ERROR if %NULL.</doc>
            <type name="Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </function>
      <function name="iterate_internal_links_default"
                c:identifier="gst_proxy_pad_iterate_internal_links_default">
        <doc xml:whitespace="preserve">Invoke the default iterate internal links function of the proxy pad.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstIterator of #GstPad, or NULL if @pad has no parent. Unref each returned pad with gst_object_unref().</doc>
          <type name="Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstPad to get the internal links of.</doc>
            <type name="Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parent of @pad or NULL</doc>
            <type name="Object" c:type="GstObject*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_internal" c:identifier="gst_proxy_pad_get_internal">
        <doc xml:whitespace="preserve">Get the internal pad of @pad. Unref target pad after usage.

The internal pad of a #GstGhostPad is the internally used
pad of opposite direction, which is used to link to the target.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the target #GstProxyPad, can be NULL. Unref target pad after usage.</doc>
          <type name="ProxyPad" c:type="GstProxyPad*"/>
        </return-value>
      </method>
      <field name="pad">
        <type name="Pad" c:type="GstPad"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ProxyPadPrivate" c:type="GstProxyPadPrivate*"/>
      </field>
    </class>
    <record name="ProxyPadClass"
            c:type="GstProxyPadClass"
            glib:is-gtype-struct-for="ProxyPad">
      <field name="parent_class">
        <type name="PadClass" c:type="GstPadClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="1">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ProxyPadPrivate" c:type="GstProxyPadPrivate" disguised="1">
    </record>
    <enumeration name="QOSType" c:type="GstQOSType">
      <doc xml:whitespace="preserve">The different types of QoS events that can be given to the
gst_event_new_qos() method.</doc>
      <member name="overflow" value="0" c:identifier="GST_QOS_TYPE_OVERFLOW">
        <doc xml:whitespace="preserve">The QoS event type that is produced when downstream elements are producing data too quickly and the element can't keep up processing the data. Upstream should reduce their processing rate. This type is also used when buffers arrive early or in time.</doc>
      </member>
      <member name="underflow" value="1" c:identifier="GST_QOS_TYPE_UNDERFLOW">
        <doc xml:whitespace="preserve">The QoS event type that is produced when downstream elements are producing data too slowly and need to speed up their processing rate.</doc>
      </member>
      <member name="throttle" value="2" c:identifier="GST_QOS_TYPE_THROTTLE">
        <doc xml:whitespace="preserve">The QoS event type that is produced when the application enabled throttling to limit the datarate.</doc>
      </member>
    </enumeration>
    <constant name="QUERY_NUM_SHIFT" value="8" c:type="GST_QUERY_NUM_SHIFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="QUERY_TYPE_BOTH" value="0" c:type="GST_QUERY_TYPE_BOTH">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Query"
            c:type="GstQuery"
            glib:type-name="GstQuery"
            glib:get-type="gst_query_get_type"
            c:symbol-prefix="query">
      <doc xml:whitespace="preserve">Queries can be performed on pads (gst_pad_query()) and elements
(gst_element_query()). Please note that some queries might need a running
pipeline to work.

Queries can be created using the gst_query_new_*() functions.
Query values can be set using gst_query_set_*(), and parsed using
gst_query_parse_*() helpers.

The following example shows how to query the duration of a pipeline:

&lt;example&gt;
 &lt;title&gt;Query duration on a pipeline&lt;/title&gt;
 &lt;programlisting&gt;
 GstQuery *query;
 gboolean res;
 query = gst_query_new_duration (GST_FORMAT_TIME);
 res = gst_element_query (pipeline, query);
 if (res) {
   gint64 duration;
   gst_query_parse_duration (query, NULL, &amp;amp;duration);
   g_print ("duration = %"GST_TIME_FORMAT, GST_TIME_ARGS (duration));
 }
 else {
   g_print ("duration query failed...");
 }
 gst_query_unref (query);
 &lt;/programlisting&gt;
&lt;/example&gt;

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <field name="mini_object" writable="1">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <field name="type" writable="1">
        <type name="QueryType" c:type="GstQueryType"/>
      </field>
      <constructor name="new_accept_caps"
                   c:identifier="gst_query_new_accept_caps">
        <doc xml:whitespace="preserve">Constructs a new query object for querying if @caps are accepted.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">a fixed #GstCaps</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_allocation"
                   c:identifier="gst_query_new_allocation">
        <doc xml:whitespace="preserve">Constructs a new query object for querying the allocation properties.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">the negotiated caps</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="need_pool" transfer-ownership="none">
            <doc xml:whitespace="preserve">return a pool</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_buffering" c:identifier="gst_query_new_buffering">
        <doc xml:whitespace="preserve">Constructs a new query object for querying the buffering status of
a stream.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_caps" c:identifier="gst_query_new_caps">
        <doc xml:whitespace="preserve">Constructs a new query object for querying the caps.

The CAPS query should return the allowable caps for a pad in the context
of the element's state, its link to other elements, and the devices or files
it has opened. These caps must be a subset of the pad template caps. In the
NULL state with no links, the CAPS query should ideally return the same caps
as the pad template. In rare circumstances, an object property can affect
the caps returned by the CAPS query, but this is discouraged.

For most filters, the caps returned by CAPS query is directly affected by the
allowed caps on other pads. For demuxers and decoders, the caps returned by
the srcpad's getcaps function is directly related to the stream data. Again,
the CAPS query should return the most specific caps it reasonably can, since this
helps with autoplugging.

The @filter is used to restrict the result caps, only the caps matching
@filter should be returned from the CAPS query. Specifying a filter might
greatly reduce the amount of processing an element needs to do.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:whitespace="preserve">a filter</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_convert" c:identifier="gst_query_new_convert">
        <doc xml:whitespace="preserve">Constructs a new convert query object. Use gst_query_unref()
when done with it. A convert query is used to ask for a conversion between
one format and another.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to convert</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_custom" c:identifier="gst_query_new_custom">
        <doc xml:whitespace="preserve">Constructs a new custom query object. Use gst_query_unref()
when done with it.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the query type</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
          <parameter name="structure" transfer-ownership="none">
            <doc xml:whitespace="preserve">a structure for the query</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_drain" c:identifier="gst_query_new_drain">
        <doc xml:whitespace="preserve">Constructs a new query object for querying the drain state.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <constructor name="new_duration" c:identifier="gst_query_new_duration">
        <doc xml:whitespace="preserve">Constructs a new stream duration query object to query in the given format.
Use gst_query_unref() when done with it. A duration query will give the
total length of the stream.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat for this duration query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_formats" c:identifier="gst_query_new_formats">
        <doc xml:whitespace="preserve">Constructs a new query object for querying formats of
the stream.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <constructor name="new_latency" c:identifier="gst_query_new_latency">
        <doc xml:whitespace="preserve">Constructs a new latency query object.
Use gst_query_unref() when done with it. A latency query is usually performed
by sinks to compensate for additional latency introduced by elements in the
pipeline.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <constructor name="new_position" c:identifier="gst_query_new_position">
        <doc xml:whitespace="preserve">Constructs a new query stream position query object. Use gst_query_unref()
when done with it. A position query is used to query the current position
of playback in the streams, in some format.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_scheduling"
                   c:identifier="gst_query_new_scheduling">
        <doc xml:whitespace="preserve">Constructs a new query object for querying the scheduling properties.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <constructor name="new_seeking" c:identifier="gst_query_new_seeking">
        <doc xml:whitespace="preserve">Constructs a new query object for querying seeking properties of
the stream.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the default #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_segment" c:identifier="gst_query_new_segment">
        <doc xml:whitespace="preserve">Constructs a new segment query object. Use gst_query_unref()
when done with it. A segment query is used to discover information about the
currently configured segment for playback.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat for the new query</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_uri" c:identifier="gst_query_new_uri">
        <doc xml:whitespace="preserve">Constructs a new query URI query object. Use gst_query_unref()
when done with it. An URI query is used to query the current URI
that is used by the source or sink.

Free-function: gst_query_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstQuery</doc>
          <type name="Query" c:type="GstQuery*"/>
        </return-value>
      </constructor>
      <method name="add_allocation_meta"
              c:identifier="gst_query_add_allocation_meta">
        <doc xml:whitespace="preserve">Add @api with @params as one of the supported metadata API to @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="api" transfer-ownership="none">
            <doc xml:whitespace="preserve">the metadata API</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">API specific parameters</doc>
            <type name="Structure" c:type="const GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_allocation_param"
              c:identifier="gst_query_add_allocation_param">
        <doc xml:whitespace="preserve">Add @allocator and its @params as a supported memory allocator.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="allocator" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">the memory allocator</doc>
            <type name="Allocator" c:type="GstAllocator*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #GstAllocationParams</doc>
            <type name="AllocationParams" c:type="const GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_allocation_pool"
              c:identifier="gst_query_add_allocation_pool">
        <doc xml:whitespace="preserve">Set the pool parameters in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pool" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstBufferPool</doc>
            <type name="BufferPool" c:type="GstBufferPool*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_buffers" transfer-ownership="none">
            <doc xml:whitespace="preserve">the min buffers</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_buffers" transfer-ownership="none">
            <doc xml:whitespace="preserve">the max buffers</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_buffering_range"
              c:identifier="gst_query_add_buffering_range">
        <doc xml:whitespace="preserve">Set the buffering-ranges array field in @query. The current last
start position of the array should be inferior to @start.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gboolean indicating if the range was added or not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">start position of the range</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">stop position of the range</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_scheduling_mode"
              c:identifier="gst_query_add_scheduling_mode">
        <doc xml:whitespace="preserve">Add @mode as aone of the supported scheduling modes to @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPadMode</doc>
            <type name="PadMode" c:type="GstPadMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_allocation_meta"
              c:identifier="gst_query_find_allocation_meta">
        <doc xml:whitespace="preserve">Check if @query has metadata @api set. When this function returns TRUE,
@index will contain the index where the requested API and the flags can be
found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE when @api is in the list of metadata.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="api" transfer-ownership="none">
            <doc xml:whitespace="preserve">the metadata API</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="index"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the index</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_allocation_metas"
              c:identifier="gst_query_get_n_allocation_metas">
        <doc xml:whitespace="preserve">Retrieve the number of values currently stored in the
meta API array of the query's structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the metadata API array size as a #guint.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_n_allocation_params"
              c:identifier="gst_query_get_n_allocation_params">
        <doc xml:whitespace="preserve">Retrieve the number of values currently stored in the
allocator params array of the query's structure.

If no memory allocator is specified, the downstream element can handle
the default memory allocator.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the allocator array size as a #guint.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_n_allocation_pools"
              c:identifier="gst_query_get_n_allocation_pools">
        <doc xml:whitespace="preserve">Retrieve the number of values currently stored in the
pool array of the query's structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the pool array size as a #guint.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_n_buffering_ranges"
              c:identifier="gst_query_get_n_buffering_ranges">
        <doc xml:whitespace="preserve">Retrieve the number of values currently stored in the
buffered-ranges array of the query's structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the range array size as a #guint.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_n_scheduling_modes"
              c:identifier="gst_query_get_n_scheduling_modes">
        <doc xml:whitespace="preserve">Retrieve the number of values currently stored in the
scheduling mode array of the query's structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the scheduling mode array size as a #guint.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_structure" c:identifier="gst_query_get_structure">
        <doc xml:whitespace="preserve">Get the structure of a query.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstStructure of the query. The structure is still owned by the query and will therefore be freed when the query is unreffed.</doc>
          <type name="Structure" c:type="const GstStructure*"/>
        </return-value>
      </method>
      <method name="has_scheduling_mode"
              c:identifier="gst_query_has_scheduling_mode">
        <doc xml:whitespace="preserve">Check if @query has scheduling mode set.

&lt;note&gt;
  &lt;para&gt;
    When checking if upstream supports pull mode, it is usually not
    enough to just check for GST_PAD_MODE_PULL with this function, you
    also want to check whether the scheduling flags returned by
    gst_query_parse_scheduling() have the seeking flag set (meaning
    random access is supported, not only sequential pulls).
  &lt;/para&gt;
&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE when @mode is in the list of scheduling modes.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the scheduling mode</doc>
            <type name="PadMode" c:type="GstPadMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_scheduling_mode_with_flags"
              c:identifier="gst_query_has_scheduling_mode_with_flags">
        <doc xml:whitespace="preserve">Check if @query has scheduling mode set and @flags is set in
query scheduling flags.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE when @mode is in the list of scheduling modes and @flags are compatible with query flags.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the scheduling mode</doc>
            <type name="PadMode" c:type="GstPadMode"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstSchedulingFlags</doc>
            <type name="SchedulingFlags" c:type="GstSchedulingFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_accept_caps"
              c:identifier="gst_query_parse_accept_caps">
        <doc xml:whitespace="preserve">Get the caps from @query. The caps remains valid as long as @query remains
valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the caps</doc>
            <type name="Caps" c:type="GstCaps**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_accept_caps_result"
              c:identifier="gst_query_parse_accept_caps_result">
        <doc xml:whitespace="preserve">Parse the result from @query and store in @result.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_allocation"
              c:identifier="gst_query_parse_allocation">
        <doc xml:whitespace="preserve">Parse an allocation query, writing the requested caps in @caps and
whether a pool is needed in @need_pool, if the respective parameters
are non-NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">The #GstCaps</doc>
            <type name="Caps" c:type="GstCaps**"/>
          </parameter>
          <parameter name="need_pool"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">Whether a #GstBufferPool is needed</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering_percent"
              c:identifier="gst_query_parse_buffering_percent">
        <doc xml:whitespace="preserve">Get the percentage of buffered data. This is a value between 0 and 100.
The @busy indicator is %TRUE when the buffering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="busy"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">if buffering is busy, or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="percent"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a buffering percent, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering_range"
              c:identifier="gst_query_parse_buffering_range">
        <doc xml:whitespace="preserve">Parse an available query, writing the format into @format, and
other results into the passed parameters, if the respective parameters
are non-NULL</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the format to set for the @segment_start and @segment_end values, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the start to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the stop to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="estimated_total"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">estimated total amount of download time, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_buffering_stats"
              c:identifier="gst_query_parse_buffering_stats">
        <doc xml:whitespace="preserve">Extracts the buffering stats values from @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a buffering mode, or NULL</doc>
            <type name="BufferingMode" c:type="GstBufferingMode*"/>
          </parameter>
          <parameter name="avg_in"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average input rate, or NULL</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="avg_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the average output rat, or NULLe</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="buffering_left"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">amount of buffering time left in milliseconds, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_caps" c:identifier="gst_query_parse_caps">
        <doc xml:whitespace="preserve">Get the filter from the caps @query. The caps remains valid as long as
@query remains valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="filter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the caps filter</doc>
            <type name="Caps" c:type="GstCaps**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_caps_result"
              c:identifier="gst_query_parse_caps_result">
        <doc xml:whitespace="preserve">Get the caps result from @query. The caps remains valid as long as
@query remains valid.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">A pointer to the caps</doc>
            <type name="Caps" c:type="GstCaps**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_convert" c:identifier="gst_query_parse_convert">
        <doc xml:whitespace="preserve">Parse a convert query answer. Any of @src_format, @src_value, @dest_format,
and @dest_value may be NULL, in which case that value is omitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src_format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the source value, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="src_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the source value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="dest_format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the destination value, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="dest_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the destination value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_duration" c:identifier="gst_query_parse_duration">
        <doc xml:whitespace="preserve">Parse a duration query answer. Write the format of the duration into @format,
and the value into @duration, if the respective variables are non-NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the duration value, or NULL.</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the total duration, or NULL.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_latency" c:identifier="gst_query_parse_latency">
        <doc xml:whitespace="preserve">Parse a latency query answer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">storage for live or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the min latency or NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the max latency or NULL</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_n_formats" c:identifier="gst_query_parse_n_formats">
        <doc xml:whitespace="preserve">Parse the number of formats in the formats @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_formats"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the number of formats in this query.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_nth_allocation_meta"
              c:identifier="gst_query_parse_nth_allocation_meta">
        <doc xml:whitespace="preserve">Parse an available query and get the metadata API
at @index of the metadata API array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GType of the metadata API at @index.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the metadata API array to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">API specific flags</doc>
            <type name="Structure" c:type="const GstStructure**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_nth_allocation_param"
              c:identifier="gst_query_parse_nth_allocation_param">
        <doc xml:whitespace="preserve">Parse an available query and get the alloctor and its params
at @index of the allocator array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the allocator array to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">variable to hold the result</doc>
            <type name="Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">parameters for the allocator</doc>
            <type name="AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_nth_allocation_pool"
              c:identifier="gst_query_parse_nth_allocation_pool">
        <doc xml:whitespace="preserve">Get the pool parameters in @query.

Unref @pool with gst_object_unref() when it's not needed any more.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">index to parse</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pool"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the #GstBufferPool</doc>
            <type name="BufferPool" c:type="GstBufferPool**"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the size</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="min_buffers"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the min buffers</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="max_buffers"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the max buffers</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_nth_buffering_range"
              c:identifier="gst_query_parse_nth_buffering_range">
        <doc xml:whitespace="preserve">Parse an available query and get the start and stop values stored
at the @index of the buffered ranges array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #gboolean indicating if the parsing succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the buffered-ranges array to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the start position to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the stop position to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_nth_format"
              c:identifier="gst_query_parse_nth_format">
        <doc xml:whitespace="preserve">Parse the format query and retrieve the @nth format from it into
@format. If the list contains less elements than @nth, @format will be
set to GST_FORMAT_UNDEFINED.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="nth"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the nth format to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">a pointer to store the nth format</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_nth_scheduling_mode"
              c:identifier="gst_query_parse_nth_scheduling_mode">
        <doc xml:whitespace="preserve">Parse an available query and get the scheduling mode
at @index of the scheduling modes array.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstPadMode of the scheduling mode at @index.</doc>
          <type name="PadMode" c:type="GstPadMode"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the scheduling modes array to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_position" c:identifier="gst_query_parse_position">
        <doc xml:whitespace="preserve">Parse a position query, writing the format into @format, and the position
into @cur, if the respective parameters are non-NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the position values (may be NULL)</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="cur"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the current position (may be NULL)</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_scheduling"
              c:identifier="gst_query_parse_scheduling">
        <doc xml:whitespace="preserve">Set the scheduling properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">#GstSchedulingFlags</doc>
            <type name="SchedulingFlags" c:type="GstSchedulingFlags*"/>
          </parameter>
          <parameter name="minsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the suggested minimum size of pull requests</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="maxsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the suggested maximum size of pull requests:</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="align"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the suggested alignment of pull requests</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_seeking" c:identifier="gst_query_parse_seeking">
        <doc xml:whitespace="preserve">Parse a seeking query, writing the format into @format, and
other results into the passed parameters, if the respective parameters
are non-NULL</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the format to set for the @segment_start and @segment_end values, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="seekable"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the seekable flag to set, or NULL</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="segment_start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the segment_start to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="segment_end"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the segment_end to set, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_segment" c:identifier="gst_query_parse_segment">
        <doc xml:whitespace="preserve">Parse a segment query answer. Any of @rate, @format, @start_value, and
@stop_value may be NULL, which will cause this value to be omitted.

See gst_query_set_segment() for an explanation of the function arguments.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the rate of the segment, or NULL</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="format"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the #GstFormat of the values, or NULL</doc>
            <type name="Format" c:type="GstFormat*"/>
          </parameter>
          <parameter name="start_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the start value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the stop value, or NULL</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_uri" c:identifier="gst_query_parse_uri">
        <doc xml:whitespace="preserve">Parse an URI query, writing the URI into @uri as a newly
allocated string, if the respective parameters are non-NULL.
Free the string with g_free() after usage.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the storage for the current URI (may be NULL)</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_nth_allocation_meta"
              c:identifier="gst_query_remove_nth_allocation_meta">
        <doc xml:whitespace="preserve">Remove the metadata API at @index of the metadata API array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the metadata API array to remove</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_accept_caps_result"
              c:identifier="gst_query_set_accept_caps_result">
        <doc xml:whitespace="preserve">Set @result as the result for the @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:whitespace="preserve">the result to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_percent"
              c:identifier="gst_query_set_buffering_percent">
        <doc xml:whitespace="preserve">Set the percentage of buffered data. This is a value between 0 and 100.
The @busy indicator is %TRUE when the buffering is in progress.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="busy" transfer-ownership="none">
            <doc xml:whitespace="preserve">if buffering is busy</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="percent" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffering percent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_range"
              c:identifier="gst_query_set_buffering_range">
        <doc xml:whitespace="preserve">Set the available query result fields in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format to set for the @start and @stop values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stop to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="estimated_total" transfer-ownership="none">
            <doc xml:whitespace="preserve">estimated total amount of download time</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffering_stats"
              c:identifier="gst_query_set_buffering_stats">
        <doc xml:whitespace="preserve">Configures the buffering stats values in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">a buffering mode</doc>
            <type name="BufferingMode" c:type="GstBufferingMode"/>
          </parameter>
          <parameter name="avg_in" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="avg_out" transfer-ownership="none">
            <doc xml:whitespace="preserve">the average output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="buffering_left" transfer-ownership="none">
            <doc xml:whitespace="preserve">amount of buffering time left in milliseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps_result" c:identifier="gst_query_set_caps_result">
        <doc xml:whitespace="preserve">Set the @caps result in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">A pointer to the caps</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_convert" c:identifier="gst_query_set_convert">
        <doc xml:whitespace="preserve">Answer a convert query by setting the requested values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the source value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the destination value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_duration" c:identifier="gst_query_set_duration">
        <doc xml:whitespace="preserve">Answer a duration query by setting the requested value in the given format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat for the duration</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:whitespace="preserve">the duration of the stream</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_formats"
              c:identifier="gst_query_set_formats"
              introspectable="0">
        <doc xml:whitespace="preserve">Set the formats query result fields in @query. The number of formats passed
must be equal to @n_formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_formats" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of formats to set.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_formatsv" c:identifier="gst_query_set_formatsv">
        <doc xml:whitespace="preserve">Set the formats query result fields in @query. The number of formats passed
in the @formats array must be equal to @n_formats.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="n_formats" transfer-ownership="none">
            <doc xml:whitespace="preserve">the number of formats to set.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="formats" transfer-ownership="none">
            <doc xml:whitespace="preserve">an array containing @n_formats @GstFormat values.</doc>
            <array length="0" zero-terminated="0" c:type="GstFormat*">
              <type name="Format" c:type="GstFormat"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency" c:identifier="gst_query_set_latency">
        <doc xml:whitespace="preserve">Answer a latency query by setting the requested values in the given format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="live" transfer-ownership="none">
            <doc xml:whitespace="preserve">if there is a live element upstream</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="min_latency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minimal latency of the upstream elements</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max_latency" transfer-ownership="none">
            <doc xml:whitespace="preserve">the maximal latency of the upstream elements</doc>
            <type name="ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nth_allocation_param"
              c:identifier="gst_query_set_nth_allocation_param">
        <doc xml:whitespace="preserve">Parse an available query and get the alloctor and its params
at @index of the allocator array.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">position in the allocator array to set</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="allocator" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">new allocator to set</doc>
            <type name="Allocator" c:type="GstAllocator*"/>
          </parameter>
          <parameter name="params" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">parameters for the allocator</doc>
            <type name="AllocationParams" c:type="const GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_nth_allocation_pool"
              c:identifier="gst_query_set_nth_allocation_pool">
        <doc xml:whitespace="preserve">Set the pool parameters in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">index to modify</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="pool" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstBufferPool</doc>
            <type name="BufferPool" c:type="GstBufferPool*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:whitespace="preserve">the size</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_buffers" transfer-ownership="none">
            <doc xml:whitespace="preserve">the min buffers</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="max_buffers" transfer-ownership="none">
            <doc xml:whitespace="preserve">the max buffers</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_position" c:identifier="gst_query_set_position">
        <doc xml:whitespace="preserve">Answer a position query by setting the requested value in the given format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the requested #GstFormat</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="cur" transfer-ownership="none">
            <doc xml:whitespace="preserve">the position to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scheduling" c:identifier="gst_query_set_scheduling">
        <doc xml:whitespace="preserve">Set the scheduling properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GstSchedulingFlags</doc>
            <type name="SchedulingFlags" c:type="GstSchedulingFlags"/>
          </parameter>
          <parameter name="minsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">the suggested minimum size of pull requests</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="maxsize" transfer-ownership="none">
            <doc xml:whitespace="preserve">the suggested maximum size of pull requests</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="align" transfer-ownership="none">
            <doc xml:whitespace="preserve">the suggested alignment of pull requests</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seeking" c:identifier="gst_query_set_seeking">
        <doc xml:whitespace="preserve">Set the seeking query result fields in @query.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format to set for the @segment_start and @segment_end values</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="seekable" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seekable flag to set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="segment_start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment_start to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="segment_end" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment_end to set</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_segment" c:identifier="gst_query_set_segment">
        <doc xml:whitespace="preserve">Answer a segment query by setting the requested values. The normal
playback segment of a pipeline is 0 to duration at the default rate of
1.0. If a seek was performed on the pipeline to play a different
segment, this query will return the range specified in the last seek.

@start_value and @stop_value will respectively contain the configured
playback range start and stop values expressed in @format.
The values are always between 0 and the duration of the media and
@start_value &lt;= @stop_value. @rate will contain the playback rate. For
negative rates, playback will actually happen from @stop_value to
@start_value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the segment</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GstFormat of the segment values (@start_value and @stop_value)</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stop value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri" c:identifier="gst_query_set_uri">
        <doc xml:whitespace="preserve">Answer a URI query by setting the requested URI.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the URI to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="writable_structure"
              c:identifier="gst_query_writable_structure">
        <doc xml:whitespace="preserve">Get the structure of a query. This method should be called with a writable
@query so that the returned structure is guranteed to be writable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstStructure of the query. The structure is still owned by the query and will therefore be freed when the query is unreffed.</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <function name="type_get_flags" c:identifier="gst_query_type_get_flags">
        <doc xml:whitespace="preserve">Gets the #GstQueryTypeFlags associated with @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstQueryTypeFlags.</doc>
          <type name="QueryTypeFlags" c:type="GstQueryTypeFlags"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstQueryType</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_get_name" c:identifier="gst_query_type_get_name">
        <doc xml:whitespace="preserve">Get a printable name for the given query type. Do not modify or free.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a reference to the static name of the query.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the query type</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
        </parameters>
      </function>
      <function name="type_to_quark" c:identifier="gst_query_type_to_quark">
        <doc xml:whitespace="preserve">Get the unique quark for the given query type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark associated with the query type</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the query type</doc>
            <type name="QueryType" c:type="GstQueryType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="QueryType" c:type="GstQueryType">
      <doc xml:whitespace="preserve">Standard predefined Query types</doc>
      <member name="unknown" value="0" c:identifier="GST_QUERY_UNKNOWN">
        <doc xml:whitespace="preserve">unknown query type</doc>
      </member>
      <member name="position" value="2563" c:identifier="GST_QUERY_POSITION">
        <doc xml:whitespace="preserve">current position in stream</doc>
      </member>
      <member name="duration" value="5123" c:identifier="GST_QUERY_DURATION">
        <doc xml:whitespace="preserve">total duration of the stream</doc>
      </member>
      <member name="latency" value="7683" c:identifier="GST_QUERY_LATENCY">
        <doc xml:whitespace="preserve">latency of stream</doc>
      </member>
      <member name="jitter" value="10243" c:identifier="GST_QUERY_JITTER">
        <doc xml:whitespace="preserve">current jitter of stream</doc>
      </member>
      <member name="rate" value="12803" c:identifier="GST_QUERY_RATE">
        <doc xml:whitespace="preserve">current rate of the stream</doc>
      </member>
      <member name="seeking" value="15363" c:identifier="GST_QUERY_SEEKING">
        <doc xml:whitespace="preserve">seeking capabilities</doc>
      </member>
      <member name="segment" value="17923" c:identifier="GST_QUERY_SEGMENT">
        <doc xml:whitespace="preserve">segment start/stop positions</doc>
      </member>
      <member name="convert" value="20483" c:identifier="GST_QUERY_CONVERT">
        <doc xml:whitespace="preserve">convert values between formats</doc>
      </member>
      <member name="formats" value="23043" c:identifier="GST_QUERY_FORMATS">
        <doc xml:whitespace="preserve">query supported formats for convert</doc>
      </member>
      <member name="buffering"
              value="28163"
              c:identifier="GST_QUERY_BUFFERING">
        <doc xml:whitespace="preserve">query available media for efficient seeking.</doc>
      </member>
      <member name="custom" value="30723" c:identifier="GST_QUERY_CUSTOM">
        <doc xml:whitespace="preserve">a custom application or element defined query.</doc>
      </member>
      <member name="uri" value="33283" c:identifier="GST_QUERY_URI">
        <doc xml:whitespace="preserve">query the URI of the source or sink.</doc>
      </member>
      <member name="allocation"
              value="35846"
              c:identifier="GST_QUERY_ALLOCATION">
        <doc xml:whitespace="preserve">the buffer allocation properties</doc>
      </member>
      <member name="scheduling"
              value="38401"
              c:identifier="GST_QUERY_SCHEDULING">
        <doc xml:whitespace="preserve">the scheduling properties</doc>
      </member>
      <member name="accept_caps"
              value="40963"
              c:identifier="GST_QUERY_ACCEPT_CAPS">
        <doc xml:whitespace="preserve">the accept caps query</doc>
      </member>
      <member name="caps" value="43523" c:identifier="GST_QUERY_CAPS">
        <doc xml:whitespace="preserve">the caps query</doc>
      </member>
      <member name="drain" value="46086" c:identifier="GST_QUERY_DRAIN">
        <doc xml:whitespace="preserve">wait till all serialized data is consumed downstream</doc>
      </member>
    </bitfield>
    <bitfield name="QueryTypeFlags" c:type="GstQueryTypeFlags">
      <doc xml:whitespace="preserve">#GstQueryTypeFlags indicate the aspects of the different #GstQueryType
values. You can get the type flags of a #GstQueryType with the
gst_query_type_get_flags() function.</doc>
      <member name="upstream" value="1" c:identifier="GST_QUERY_TYPE_UPSTREAM">
        <doc xml:whitespace="preserve">Set if the query can travel upstream.</doc>
      </member>
      <member name="downstream"
              value="2"
              c:identifier="GST_QUERY_TYPE_DOWNSTREAM">
        <doc xml:whitespace="preserve">Set if the query can travel downstream.</doc>
      </member>
      <member name="serialized"
              value="4"
              c:identifier="GST_QUERY_TYPE_SERIALIZED">
        <doc xml:whitespace="preserve">Set if the query should be serialized with data flow.</doc>
      </member>
    </bitfield>
    <enumeration name="Rank" c:type="GstRank">
      <doc xml:whitespace="preserve">Element priority ranks. Defines the order in which the autoplugger (or
similar rank-picking mechanisms, such as e.g. gst_element_make_from_uri())
will choose this element over an alternative one with the same function.

These constants serve as a rough guidance for defining the rank of a
#GstPluginFeature. Any value is valid, including values bigger than
@GST_RANK_PRIMARY.</doc>
      <member name="none" value="0" c:identifier="GST_RANK_NONE">
        <doc xml:whitespace="preserve">will be chosen last or not at all</doc>
      </member>
      <member name="marginal" value="64" c:identifier="GST_RANK_MARGINAL">
        <doc xml:whitespace="preserve">unlikely to be chosen</doc>
      </member>
      <member name="secondary" value="128" c:identifier="GST_RANK_SECONDARY">
        <doc xml:whitespace="preserve">likely to be chosen</doc>
      </member>
      <member name="primary" value="256" c:identifier="GST_RANK_PRIMARY">
        <doc xml:whitespace="preserve">will be chosen first</doc>
      </member>
    </enumeration>
    <class name="Registry"
           c:symbol-prefix="registry"
           c:type="GstRegistry"
           parent="Object"
           glib:type-name="GstRegistry"
           glib:get-type="gst_registry_get_type"
           glib:type-struct="RegistryClass">
      <doc xml:whitespace="preserve">One registry holds the metadata of a set of plugins.

&lt;emphasis role="bold"&gt;Design:&lt;/emphasis&gt;

The #GstRegistry object is a list of plugins and some functions for dealing
with them. Each #GstPlugin is matched 1-1 with a file on disk, and may or may
not be loaded at a given time.

The primary source, at all times, of plugin information is each plugin file
itself. Thus, if an application wants information about a particular plugin,
or wants to search for a feature that satisfies given criteria, the primary
means of doing so is to load every plugin and look at the resulting
information that is gathered in the default registry. Clearly, this is a time
consuming process, so we cache information in the registry file. The format
and location of the cache file is internal to gstreamer.

On startup, plugins are searched for in the plugin search path. The following
locations are checked in this order:
&lt;itemizedlist&gt;
  &lt;listitem&gt;
    &lt;para&gt;location from --gst-plugin-path commandline option.&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;the GST_PLUGIN_PATH environment variable.&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;the GST_PLUGIN_SYSTEM_PATH environment variable.&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;default locations (if GST_PLUGIN_SYSTEM_PATH is not set). Those
      default locations are:
      &lt;filename&gt;~/.gstreamer-$GST_API_VERSION/plugins/&lt;/filename&gt;
      and &lt;filename&gt;$prefix/libs/gstreamer-$GST_API_VERSION/&lt;/filename&gt;.
    &lt;/para&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;
The registry cache file is loaded from
&lt;filename&gt;~/.gstreamer-$GST_API_VERSION/registry-$ARCH.bin&lt;/filename&gt; or the
file listed in the GST_REGISTRY env var. One reason to change the registry
location is for testing.

For each plugin that is found in the plugin search path, there could be 3
possibilities for cached information:
&lt;itemizedlist&gt;
  &lt;listitem&gt;
    &lt;para&gt;the cache may not contain information about a given file.&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;the cache may have stale information.&lt;/para&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;para&gt;the cache may have current information.&lt;/para&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;

In the first two cases, the plugin is loaded and the cache updated. In
addition to these cases, the cache may have entries for plugins that are not
relevant to the current process. These are marked as not available to the
current process. If the cache is updated for whatever reason, it is marked
dirty.

A dirty cache is written out at the end of initialization. Each entry is
checked to make sure the information is minimally valid. If not, the entry is
simply dropped.

&lt;emphasis role="bold"&gt;Implementation notes:&lt;/emphasis&gt;

The "cache" and "registry" are different concepts and can represent
different sets of plugins. For various reasons, at init time, the cache is
stored in the default registry, and plugins not relevant to the current
process are marked with the %GST_PLUGIN_FLAG_CACHED bit. These plugins are
removed at the end of initialization.

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <function name="fork_is_enabled"
                c:identifier="gst_registry_fork_is_enabled">
        <doc xml:whitespace="preserve">By default GStreamer will perform scanning and rebuilding of the
registry file using a helper child process.

Applications might want to disable this behaviour with the
gst_registry_fork_set_enabled() function, in which case new plugins
are scanned (and loaded) into the application process.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if GStreamer will use the child helper process when rebuilding the registry.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </function>
      <function name="fork_set_enabled"
                c:identifier="gst_registry_fork_set_enabled">
        <doc xml:whitespace="preserve">Applications might want to disable/enable spawning of a child helper process
when rebuilding the registry. See gst_registry_fork_is_enabled() for more
information.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether rebuilding the registry can use a temporary child helper process.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="get" c:identifier="gst_registry_get">
        <doc xml:whitespace="preserve">Retrieves the singleton plugin registry. The caller does not own a
reference on the registry, as it is alive as long as GStreamer is
initialized.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstRegistry.</doc>
          <type name="Registry" c:type="GstRegistry*"/>
        </return-value>
      </function>
      <method name="add_feature" c:identifier="gst_registry_add_feature">
        <doc xml:whitespace="preserve">Add the feature to the registry. The feature-added signal will be emitted.
This function sinks @feature.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="full">
            <doc xml:whitespace="preserve">the feature to add</doc>
            <type name="PluginFeature" c:type="GstPluginFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_plugin" c:identifier="gst_registry_add_plugin">
        <doc xml:whitespace="preserve">Add the plugin to the registry. The plugin-added signal will be emitted.
This function will sink @plugin.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="full">
            <doc xml:whitespace="preserve">the plugin to add</doc>
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_feature_version"
              c:identifier="gst_registry_check_feature_version">
        <doc xml:whitespace="preserve">Checks whether a plugin feature by the given name exists in
@registry and whether its version is at least the
version required.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#TRUE if the feature could be found and the version is the same as the required version or newer, and #FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="feature_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the feature (e.g. "oggdemux")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="min_major" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minimum major version number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_minor" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minimum minor version number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="min_micro" transfer-ownership="none">
            <doc xml:whitespace="preserve">the minimum micro version number</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="feature_filter" c:identifier="gst_registry_feature_filter">
        <doc xml:whitespace="preserve">Runs a filter against all features of the plugins in the registry
and returns a GList with the results.
If the first flag is set, only the first match is
returned (as a list with a single object).</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstPluginFeature. Use gst_plugin_feature_list_free() after usage.  MT safe.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="filter"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:whitespace="preserve">the filter to use</doc>
            <type name="PluginFeatureFilter" c:type="GstPluginFeatureFilter"/>
          </parameter>
          <parameter name="first" transfer-ownership="none">
            <doc xml:whitespace="preserve">only return first match</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the filter function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_feature" c:identifier="gst_registry_find_feature">
        <doc xml:whitespace="preserve">Find the pluginfeature with the given name and type in the registry.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the pluginfeature with the given name and type or NULL if the plugin was not found. gst_object_unref() after usage.  MT safe.</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pluginfeature name to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the pluginfeature type to find</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_plugin" c:identifier="gst_registry_find_plugin">
        <doc xml:whitespace="preserve">Find the plugin with the given name in the registry.
The plugin will be reffed; caller is responsible for unreffing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the plugin with the given name or NULL if the plugin was not found. gst_object_unref() after usage.  MT safe.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin name to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_list"
              c:identifier="gst_registry_get_feature_list">
        <doc xml:whitespace="preserve">Retrieves a #GList of #GstPluginFeature of @type.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstPluginFeature of @type. Use gst_plugin_feature_list_free() after use  MT safe.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_list_by_plugin"
              c:identifier="gst_registry_get_feature_list_by_plugin">
        <doc xml:whitespace="preserve">Retrieves a #GList of features of the plugin with name @name.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstPluginFeature. Use gst_plugin_feature_list_free() after usage.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="PluginFeature"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a plugin name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_feature_list_cookie"
              c:identifier="gst_registry_get_feature_list_cookie">
        <doc xml:whitespace="preserve">Returns the registrys feature list cookie. This changes
every time a feature is added or removed from the registry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the feature list cookie.</doc>
          <type name="guint32" c:type="guint32"/>
        </return-value>
      </method>
      <method name="get_plugin_list"
              c:identifier="gst_registry_get_plugin_list">
        <doc xml:whitespace="preserve">Get a copy of all plugins registered in the given registry. The refcount
of each element in the list in incremented.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstPlugin. Use gst_plugin_list_free() after usage.  MT safe.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Plugin"/>
          </type>
        </return-value>
      </method>
      <method name="lookup" c:identifier="gst_registry_lookup">
        <doc xml:whitespace="preserve">Look up a plugin in the given registry with the given filename.
If found, plugin is reffed.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstPlugin if found, or NULL if not. gst_object_unref() after usage.</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the file to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_feature" c:identifier="gst_registry_lookup_feature">
        <doc xml:whitespace="preserve">Find a #GstPluginFeature with @name in @registry.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GstPluginFeature with its refcount incremented, use gst_object_unref() after usage.  MT safe.</doc>
          <type name="PluginFeature" c:type="GstPluginFeature*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstPluginFeature name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="plugin_filter" c:identifier="gst_registry_plugin_filter">
        <doc xml:whitespace="preserve">Runs a filter against all plugins in the registry and returns a #GList with
the results. If the first flag is set, only the first match is
returned (as a list with a single object).
Every plugin is reffed; use gst_plugin_list_free() after use, which
will unref again.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a #GList of #GstPlugin. Use gst_plugin_list_free() after usage.  MT safe.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Plugin"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="filter"
                     transfer-ownership="none"
                     scope="call"
                     closure="2">
            <doc xml:whitespace="preserve">the filter to use</doc>
            <type name="PluginFilter" c:type="GstPluginFilter"/>
          </parameter>
          <parameter name="first" transfer-ownership="none">
            <doc xml:whitespace="preserve">only return first match</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to the filter function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feature" c:identifier="gst_registry_remove_feature">
        <doc xml:whitespace="preserve">Remove the feature from the registry.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the feature to remove</doc>
            <type name="PluginFeature" c:type="GstPluginFeature*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_plugin" c:identifier="gst_registry_remove_plugin">
        <doc xml:whitespace="preserve">Remove the plugin from the registry.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin to remove</doc>
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scan_path" c:identifier="gst_registry_scan_path">
        <doc xml:whitespace="preserve">Scan the given path for plugins to add to the registry. The syntax of the
path is specific to the registry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if registry changed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:whitespace="preserve">the path to scan</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="RegistryPrivate" c:type="GstRegistryPrivate*"/>
      </field>
      <glib:signal name="feature-added" when="last">
        <doc xml:whitespace="preserve">Signals that a feature has been added to the registry (possibly
replacing a previously-added one by the same name)</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:whitespace="preserve">the feature that has been added</doc>
            <type name="PluginFeature"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="plugin-added" when="last">
        <doc xml:whitespace="preserve">Signals that a plugin has been added to the registry (possibly
replacing a previously-added one by the same name)</doc>
        <return-value transfer-ownership="none">
          <type name="none"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:whitespace="preserve">the plugin that has been added</doc>
            <type name="Plugin"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="RegistryClass"
            c:type="GstRegistryClass"
            glib:is-gtype-struct-for="Registry">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
    </record>
    <record name="RegistryPrivate" c:type="GstRegistryPrivate" disguised="1">
    </record>
    <enumeration name="ResourceError"
                 c:type="GstResourceError"
                 glib:error-domain="gst-resource-error-quark">
      <doc xml:whitespace="preserve">Resource errors are for any resource used by an element:
memory, files, network connections, process space, ...
They're typically used by source and sink elements.</doc>
      <member name="failed" value="1" c:identifier="GST_RESOURCE_ERROR_FAILED">
        <doc xml:whitespace="preserve">a general error which doesn't fit in any other category.  Make sure you add a custom message to the error call.</doc>
      </member>
      <member name="too_lazy"
              value="2"
              c:identifier="GST_RESOURCE_ERROR_TOO_LAZY">
        <doc xml:whitespace="preserve">do not use this except as a placeholder for deciding where to go while developing code.</doc>
      </member>
      <member name="not_found"
              value="3"
              c:identifier="GST_RESOURCE_ERROR_NOT_FOUND">
        <doc xml:whitespace="preserve">used when the resource could not be found.</doc>
      </member>
      <member name="busy" value="4" c:identifier="GST_RESOURCE_ERROR_BUSY">
        <doc xml:whitespace="preserve">used when resource is busy.</doc>
      </member>
      <member name="open_read"
              value="5"
              c:identifier="GST_RESOURCE_ERROR_OPEN_READ">
        <doc xml:whitespace="preserve">used when resource fails to open for reading.</doc>
      </member>
      <member name="open_write"
              value="6"
              c:identifier="GST_RESOURCE_ERROR_OPEN_WRITE">
        <doc xml:whitespace="preserve">used when resource fails to open for writing.</doc>
      </member>
      <member name="open_read_write"
              value="7"
              c:identifier="GST_RESOURCE_ERROR_OPEN_READ_WRITE">
        <doc xml:whitespace="preserve">used when resource cannot be opened for both reading and writing, or either (but unspecified which).</doc>
      </member>
      <member name="close" value="8" c:identifier="GST_RESOURCE_ERROR_CLOSE">
        <doc xml:whitespace="preserve">used when the resource can't be closed.</doc>
      </member>
      <member name="read" value="9" c:identifier="GST_RESOURCE_ERROR_READ">
        <doc xml:whitespace="preserve">used when the resource can't be read from.</doc>
      </member>
      <member name="write" value="10" c:identifier="GST_RESOURCE_ERROR_WRITE">
        <doc xml:whitespace="preserve">used when the resource can't be written to.</doc>
      </member>
      <member name="seek" value="11" c:identifier="GST_RESOURCE_ERROR_SEEK">
        <doc xml:whitespace="preserve">used when a seek on the resource fails.</doc>
      </member>
      <member name="sync" value="12" c:identifier="GST_RESOURCE_ERROR_SYNC">
        <doc xml:whitespace="preserve">used when a synchronize on the resource fails.</doc>
      </member>
      <member name="settings"
              value="13"
              c:identifier="GST_RESOURCE_ERROR_SETTINGS">
        <doc xml:whitespace="preserve">used when settings can't be manipulated on.</doc>
      </member>
      <member name="no_space_left"
              value="14"
              c:identifier="GST_RESOURCE_ERROR_NO_SPACE_LEFT">
        <doc xml:whitespace="preserve">used when the resource has no space left.</doc>
      </member>
      <member name="num_errors"
              value="15"
              c:identifier="GST_RESOURCE_ERROR_NUM_ERRORS">
        <doc xml:whitespace="preserve">the number of resource error types.</doc>
      </member>
    </enumeration>
    <constant name="SECOND" value="1000000000" c:type="GST_SECOND">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Sample"
            c:type="GstSample"
            glib:type-name="GstSample"
            glib:get-type="gst_sample_get_type"
            c:symbol-prefix="sample">
      <doc xml:whitespace="preserve">A #GstSample is a small object containing data, a type, timing and
extra arbitrary information.

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <constructor name="new" c:identifier="gst_sample_new">
        <doc xml:whitespace="preserve">Create a new #GstSample with the provided details.

Free-function: gst_sample_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new #GstSample. gst_sample_unref() after usage.</doc>
          <type name="Sample" c:type="GstSample*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #GstBuffer, or NULL</doc>
            <type name="Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #GstCaps, or NULL</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="segment" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #GstSegment, or NULL</doc>
            <type name="Segment" c:type="const GstSegment*"/>
          </parameter>
          <parameter name="info" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">a #GstStructure, or NULL</doc>
            <type name="Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_buffer" c:identifier="gst_sample_get_buffer">
        <doc xml:whitespace="preserve">Get the buffer associated with @sample</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the buffer of @sample or NULL when there is no buffer. The buffer remains valid as long as @sample is valid.</doc>
          <type name="Buffer" c:type="GstBuffer*"/>
        </return-value>
      </method>
      <method name="get_caps" c:identifier="gst_sample_get_caps">
        <doc xml:whitespace="preserve">Get the caps associated with @sample</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the caps of @sample or NULL when there is no caps. The caps remain valid as long as @sample is valid.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_info" c:identifier="gst_sample_get_info">
        <doc xml:whitespace="preserve">Get extra information associated with @sample.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the extra info of @sample. The info remains valid as long as @sample is valid.</doc>
          <type name="Structure" c:type="const GstStructure*"/>
        </return-value>
      </method>
      <method name="get_segment" c:identifier="gst_sample_get_segment">
        <doc xml:whitespace="preserve">Get the segment associated with @sample</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the segment of @sample. The segment remains valid as long as @sample is valid.</doc>
          <type name="Segment" c:type="GstSegment*"/>
        </return-value>
      </method>
    </record>
    <bitfield name="SchedulingFlags" c:type="GstSchedulingFlags">
      <doc xml:whitespace="preserve">The different scheduling flags.</doc>
      <member name="seekable"
              value="1"
              c:identifier="GST_SCHEDULING_FLAG_SEEKABLE">
        <doc xml:whitespace="preserve">if seeking is possible</doc>
      </member>
      <member name="sequential"
              value="2"
              c:identifier="GST_SCHEDULING_FLAG_SEQUENTIAL">
        <doc xml:whitespace="preserve">if sequential access is recommended</doc>
      </member>
    </bitfield>
    <enumeration name="SearchMode" c:type="GstSearchMode">
      <doc xml:whitespace="preserve">The different search modes.</doc>
      <member name="exact" value="0" c:identifier="GST_SEARCH_MODE_EXACT">
        <doc xml:whitespace="preserve">Only search for exact matches.</doc>
      </member>
      <member name="before" value="1" c:identifier="GST_SEARCH_MODE_BEFORE">
        <doc xml:whitespace="preserve">Search for an exact match or the element just before.</doc>
      </member>
      <member name="after" value="2" c:identifier="GST_SEARCH_MODE_AFTER">
        <doc xml:whitespace="preserve">Search for an exact match or the element just after.</doc>
      </member>
    </enumeration>
    <bitfield name="SeekFlags" c:type="GstSeekFlags">
      <doc xml:whitespace="preserve">Flags to be used with gst_element_seek() or gst_event_new_seek(). All flags
can be used together.

A non flushing seek might take some time to perform as the currently
playing data in the pipeline will not be cleared.

An accurate seek might be slower for formats that don't have any indexes
or timestamp markers in the stream. Specifying this flag might require a
complete scan of the file in those cases.

When performing a segment seek: after the playback of the segment completes,
no EOS will be emmited by the element that performed the seek, but a
#GST_MESSAGE_SEGMENT_DONE message will be posted on the bus by the element.
When this message is posted, it is possible to send a new seek event to
continue playback. With this seek method it is possible to perform seamless
looping or simple linear editing.

When doing fast forward (rate &gt; 1.0) or fast reverse (rate &lt; -1.0) trickmode
playback, the @GST_SEEK_FLAG_SKIP flag can be used to instruct decoders
and demuxers to adjust the playback rate by skipping frames. This can improve
performance and decrease CPU usage because not all frames need to be decoded.

The @GST_SEEK_FLAG_SNAP_BEFORE flag can be used to snap to the previous
relevant location, and the @GST_SEEK_FLAG_SNAP_AFTER flag can be used to
select the next relevant location. If KEY_UNIT is specified, the relevant
location is a keyframe. If both flags are specified, the nearest of these
locations will be selected. If none are specified, the implementation is
free to select whichever it wants.
The before and after here are in running time, so when playing backwards,
the next location refers to the one that will played in next, and not the
one that is located after in the actual source stream.

Also see part-seeking.txt in the GStreamer design documentation for more
details on the meaning of these flags and the behaviour expected of
elements that handle them.</doc>
      <member name="none" value="0" c:identifier="GST_SEEK_FLAG_NONE">
        <doc xml:whitespace="preserve">no flag</doc>
      </member>
      <member name="flush" value="1" c:identifier="GST_SEEK_FLAG_FLUSH">
        <doc xml:whitespace="preserve">flush pipeline</doc>
      </member>
      <member name="accurate" value="2" c:identifier="GST_SEEK_FLAG_ACCURATE">
        <doc xml:whitespace="preserve">accurate position is requested, this might be considerably slower for some formats.</doc>
      </member>
      <member name="key_unit" value="4" c:identifier="GST_SEEK_FLAG_KEY_UNIT">
        <doc xml:whitespace="preserve">seek to the nearest keyframe. This might be faster but less accurate.</doc>
      </member>
      <member name="segment" value="8" c:identifier="GST_SEEK_FLAG_SEGMENT">
        <doc xml:whitespace="preserve">perform a segment seek.</doc>
      </member>
      <member name="skip" value="16" c:identifier="GST_SEEK_FLAG_SKIP">
        <doc xml:whitespace="preserve">when doing fast foward or fast reverse playback, allow elements to skip frames instead of generating all frames.</doc>
      </member>
      <member name="snap_before"
              value="32"
              c:identifier="GST_SEEK_FLAG_SNAP_BEFORE">
        <doc xml:whitespace="preserve">go to a location before the requested position, if KEY_UNIT this means the keyframe at or before the requested position the one at or before the seek target.</doc>
      </member>
      <member name="snap_after"
              value="64"
              c:identifier="GST_SEEK_FLAG_SNAP_AFTER">
        <doc xml:whitespace="preserve">go to a location after the requested position, if KEY_UNIT this means the keyframe at of after the requested position.</doc>
      </member>
      <member name="snap_nearest"
              value="96"
              c:identifier="GST_SEEK_FLAG_SNAP_NEAREST">
        <doc xml:whitespace="preserve">go to a position near the requested position, if KEY_UNIT this means the keyframe closest to the requested position, if both keyframes are at an equal distance, behaves like SNAP_BEFORE.</doc>
      </member>
    </bitfield>
    <enumeration name="SeekType" c:type="GstSeekType">
      <doc xml:whitespace="preserve">The different types of seek events. When constructing a seek event with
gst_event_new_seek() or when doing gst_segment_do_seek ().</doc>
      <member name="none" value="0" c:identifier="GST_SEEK_TYPE_NONE">
        <doc xml:whitespace="preserve">no change in position is required</doc>
      </member>
      <member name="set" value="1" c:identifier="GST_SEEK_TYPE_SET">
        <doc xml:whitespace="preserve">absolute position is requested</doc>
      </member>
      <member name="end" value="2" c:identifier="GST_SEEK_TYPE_END">
        <doc xml:whitespace="preserve">relative position to duration is requested</doc>
      </member>
    </enumeration>
    <record name="Segment"
            c:type="GstSegment"
            glib:type-name="GstSegment"
            glib:get-type="gst_segment_get_type"
            c:symbol-prefix="segment">
      <doc xml:whitespace="preserve">This helper structure holds the relevant values for tracking the region of
interest in a media file, called a segment.

The structure can be used for two purposes:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;performing seeks (handling seek events)&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;tracking playback regions (handling newsegment events)&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The segment is usually configured by the application with a seek event which
is propagated upstream and eventually handled by an element that performs the seek.

The configured segment is then propagated back downstream with a newsegment event.
This information is then used to clip media to the segment boundaries.

A segment structure is initialized with gst_segment_init(), which takes a #GstFormat
that will be used as the format of the segment values. The segment will be configured
with a start value of 0 and a stop/duration of -1, which is undefined. The default
rate and applied_rate is 1.0.

The public duration field contains the duration of the segment. When using
the segment for seeking, the start and time members should normally be left
to their default 0 value. The stop position is left to -1 unless explicitly
configured to a different value after a seek event.

The current position in the segment should be set by changing the position
member in the structure.

For elements that perform seeks, the current segment should be updated with the
gst_segment_do_seek() and the values from the seek event. This method will update
all the segment fields. The position field will contain the new playback position.
If the start_type was different from GST_SEEK_TYPE_NONE, playback continues from
the position position, possibly with updated flags or rate.

For elements that want to use #GstSegment to track the playback region,
update the segment fields with the information from the newsegment event.
The gst_segment_clip() method can be used to check and clip
the media data to the segment boundaries.

For elements that want to synchronize to the pipeline clock, gst_segment_to_running_time()
can be used to convert a timestamp to a value that can be used to synchronize
to the clock. This function takes into account the base as well as
any rate or applied_rate conversions.

For elements that need to perform operations on media data in stream_time,
gst_segment_to_stream_time() can be used to convert a timestamp and the segment
info to stream time (which is always between 0 and the duration of the stream).

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <field name="flags" writable="1">
        <type name="SegmentFlags" c:type="GstSegmentFlags"/>
      </field>
      <field name="rate" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="applied_rate" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="format" writable="1">
        <type name="Format" c:type="GstFormat"/>
      </field>
      <field name="base" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="offset" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="start" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="stop" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="time" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="position" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="duration" writable="1">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gst_segment_new">
        <doc xml:whitespace="preserve">Allocate a new #GstSegment structure and initialize it using
gst_segment_init().

Free-function: gst_segment_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstSegment, free with gst_segment_free().</doc>
          <type name="Segment" c:type="GstSegment*"/>
        </return-value>
      </constructor>
      <method name="clip" c:identifier="gst_segment_clip">
        <doc xml:whitespace="preserve">Clip the given @start and @stop values to the segment boundaries given
in @segment. @start and @stop are compared and clipped to @segment
start and stop values.

If the function returns FALSE, @start and @stop are known to fall
outside of @segment and @clip_start and @clip_stop are not updated.

When the function returns TRUE, @clip_start and @clip_stop will be
updated. If @clip_start or @clip_stop are different from @start or @stop
respectively, the region fell partially in the segment.

Note that when @stop is -1, @clip_stop will be set to the end of the
segment. Depending on the use case, this may or may not be what you want.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the given @start and @stop times fall partially or completely in @segment, FALSE if the values are completely outside of the segment.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the start position in the segment</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the stop position in the segment</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="clip_start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the clipped start position in the segment</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="clip_stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     allow-none="1">
            <doc xml:whitespace="preserve">the clipped stop position in the segment</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_segment_copy">
        <doc xml:whitespace="preserve">Create a copy of given @segment.

Free-function: gst_segment_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstSegment, free with gst_segment_free().</doc>
          <type name="Segment" c:type="GstSegment*"/>
        </return-value>
      </method>
      <method name="copy_into" c:identifier="gst_segment_copy_into">
        <doc xml:whitespace="preserve">Copy the contents of @src into @dest.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstSegment</doc>
            <type name="Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="do_seek" c:identifier="gst_segment_do_seek">
        <doc xml:whitespace="preserve">Update the segment structure with the field values of a seek event (see
gst_event_new_seek()).

After calling this method, the segment field position and time will
contain the requested new position in the segment. The new requested
position in the segment depends on @rate and @start_type and @stop_type.

For positive @rate, the new position in the segment is the new @segment
start field when it was updated with a @start_type different from
#GST_SEEK_TYPE_NONE. If no update was performed on @segment start position
(#GST_SEEK_TYPE_NONE), @start is ignored and @segment position is
unmodified.

For negative @rate, the new position in the segment is the new @segment
stop field when it was updated with a @stop_type different from
#GST_SEEK_TYPE_NONE. If no stop was previously configured in the segment, the
duration of the segment will be used to update the stop position.
If no update was performed on @segment stop position (#GST_SEEK_TYPE_NONE),
@stop is ignored and @segment position is unmodified.

The applied rate of the segment will be set to 1.0 by default.
If the caller can apply a rate change, it should update @segment
rate and applied_rate after calling this function.

@update will be set to TRUE if a seek should be performed to the segment
position field. This field can be FALSE if, for example, only the @rate
has been changed but not the playback position.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the seek could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:whitespace="preserve">the rate of the segment.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">the segment flags for the segment</doc>
            <type name="SeekFlags" c:type="GstSeekFlags"/>
          </parameter>
          <parameter name="start_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek method</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek start value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="stop_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek method</doc>
            <type name="SeekType" c:type="GstSeekType"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">the seek stop value</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="update" transfer-ownership="none">
            <doc xml:whitespace="preserve">boolean holding whether position was updated.</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_segment_free">
        <doc xml:whitespace="preserve">Free the allocated segment @segment.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="init" c:identifier="gst_segment_init">
        <doc xml:whitespace="preserve">The start/position fields are set to 0 and the stop/duration
fields are set to -1 (unknown). The default rate of 1.0 and no
flags are set.

Initialize @segment to its default values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_running_time"
              c:identifier="gst_segment_set_running_time">
        <doc xml:whitespace="preserve">Adjust the start/stop and base values of @segment such that the next valid
buffer will be one with @running_time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the segment could be updated successfully. If %FALSE is returned, @running_time is -1 or not in @segment.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time in the segment</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_position" c:identifier="gst_segment_to_position">
        <doc xml:whitespace="preserve">Convert @running_time into a position in the segment so that
gst_segment_to_running_time() with that position returns @running_time.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the position in the segment for @running_time. This function returns -1 when @running_time is -1 or when it is not inside @segment.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="running_time" transfer-ownership="none">
            <doc xml:whitespace="preserve">the running_time in the segment</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_running_time"
              c:identifier="gst_segment_to_running_time">
        <doc xml:whitespace="preserve">Translate @position to the total running time using the currently configured
segment. Position is a value between @segment start and stop time.

This function is typically used by elements that need to synchronize to the
global clock in a pipeline. The runnning time is a constantly increasing value
starting from 0. When gst_segment_init() is called, this value will reset to
0.

This function returns -1 if the position is outside of @segment start and stop.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the position as the total running time or -1 when an invalid position was given.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">the position in the segment</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_stream_time" c:identifier="gst_segment_to_stream_time">
        <doc xml:whitespace="preserve">Translate @position to stream time using the currently configured
segment. The @position value must be between @segment start and
stop value.

This function is typically used by elements that need to operate on
the stream time of the buffers it receives, such as effect plugins.
In those use cases, @position is typically the buffer timestamp or
clock time that one wants to convert to the stream time.
The stream time is always between 0 and the total duration of the
media stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the position in stream_time or -1 when an invalid position was given.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the format of the segment.</doc>
            <type name="Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:whitespace="preserve">the position in the segment</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="SegmentFlags" c:type="GstSegmentFlags">
      <doc xml:whitespace="preserve">Flags for the GstSegment structure. Currently mapped to the corresponding
values of the seek flags.</doc>
      <member name="none" value="0" c:identifier="GST_SEGMENT_FLAG_NONE">
        <doc xml:whitespace="preserve">no flags</doc>
      </member>
      <member name="reset" value="1" c:identifier="GST_SEGMENT_FLAG_RESET">
        <doc xml:whitespace="preserve">reset the pipeline running_time to the segment running_time</doc>
      </member>
      <member name="skip" value="16" c:identifier="GST_SEGMENT_FLAG_SKIP">
        <doc xml:whitespace="preserve">perform skip playback</doc>
      </member>
      <member name="segment" value="8" c:identifier="GST_SEGMENT_FLAG_SEGMENT">
        <doc xml:whitespace="preserve">send SEGMENT_DONE instead of EOS</doc>
      </member>
    </bitfield>
    <enumeration name="State" c:type="GstState">
      <doc xml:whitespace="preserve">The possible states an element can be in. States can be changed using
gst_element_set_state() and checked using gst_element_get_state().</doc>
      <member name="void_pending"
              value="0"
              c:identifier="GST_STATE_VOID_PENDING">
        <doc xml:whitespace="preserve">no pending state.</doc>
      </member>
      <member name="null" value="1" c:identifier="GST_STATE_NULL">
        <doc xml:whitespace="preserve">the NULL state or initial state of an element.</doc>
      </member>
      <member name="ready" value="2" c:identifier="GST_STATE_READY">
        <doc xml:whitespace="preserve">the element is ready to go to PAUSED.</doc>
      </member>
      <member name="paused" value="3" c:identifier="GST_STATE_PAUSED">
        <doc xml:whitespace="preserve">the element is PAUSED, it is ready to accept and process data. Sink elements however only accept one buffer and then block.</doc>
      </member>
      <member name="playing" value="4" c:identifier="GST_STATE_PLAYING">
        <doc xml:whitespace="preserve">the element is PLAYING, the #GstClock is running and the data is flowing.</doc>
      </member>
    </enumeration>
    <bitfield name="StateChange" c:type="GstStateChange">
      <doc xml:whitespace="preserve">These are the different state changes an element goes through.
%GST_STATE_NULL &amp;rArr; %GST_STATE_PLAYING is called an upwards state change
and %GST_STATE_PLAYING &amp;rArr; %GST_STATE_NULL a downwards state change.</doc>
      <member name="null_to_ready"
              value="10"
              c:identifier="GST_STATE_CHANGE_NULL_TO_READY">
        <doc xml:whitespace="preserve">state change from NULL to READY. &lt;itemizedlist&gt; &lt;listitem&gt;&lt;para&gt; The element must check if the resources it needs are available. Device sinks and -sources typically try to probe the device to constrain their caps. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; The element opens the device (in case feature need to be probed). &lt;/para&gt;&lt;/listitem&gt; &lt;/itemizedlist&gt;</doc>
      </member>
      <member name="ready_to_paused"
              value="19"
              c:identifier="GST_STATE_CHANGE_READY_TO_PAUSED">
        <doc xml:whitespace="preserve">state change from READY to PAUSED. &lt;itemizedlist&gt; &lt;listitem&gt;&lt;para&gt; The element pads are activated in order to receive data in PAUSED. Streaming threads are started. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Some elements might need to return %GST_STATE_CHANGE_ASYNC and complete the state change when they have enough information. It is a requirement for sinks to return %GST_STATE_CHANGE_ASYNC and complete the state change when they receive the first buffer or %GST_EVENT_EOS (preroll). Sinks also block the dataflow when in PAUSED. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; A pipeline resets the running_time to 0. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Live sources return %GST_STATE_CHANGE_NO_PREROLL and don't generate data. &lt;/para&gt;&lt;/listitem&gt; &lt;/itemizedlist&gt;</doc>
      </member>
      <member name="paused_to_playing"
              value="28"
              c:identifier="GST_STATE_CHANGE_PAUSED_TO_PLAYING">
        <doc xml:whitespace="preserve">state change from PAUSED to PLAYING. &lt;itemizedlist&gt; &lt;listitem&gt;&lt;para&gt; Most elements ignore this state change. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; The pipeline selects a #GstClock and distributes this to all the children before setting them to PLAYING. This means that it is only alowed to synchronize on the #GstClock in the PLAYING state. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; The pipeline uses the #GstClock and the running_time to calculate the base_time. The base_time is distributed to all children when performing the state change. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Sink elements stop blocking on the preroll buffer or event and start rendering the data. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Sinks can post %GST_MESSAGE_EOS in the PLAYING state. It is not allowed to post %GST_MESSAGE_EOS when not in the PLAYING state. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; While streaming in PAUSED or PLAYING elements can create and remove sometimes pads. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Live sources start generating data and return %GST_STATE_CHANGE_SUCCESS. &lt;/para&gt;&lt;/listitem&gt; &lt;/itemizedlist&gt;</doc>
      </member>
      <member name="playing_to_paused"
              value="35"
              c:identifier="GST_STATE_CHANGE_PLAYING_TO_PAUSED">
        <doc xml:whitespace="preserve">state change from PLAYING to PAUSED. &lt;itemizedlist&gt; &lt;listitem&gt;&lt;para&gt; Most elements ignore this state change. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; The pipeline calculates the running_time based on the last selected #GstClock and the base_time. It stores this information to continue playback when going back to the PLAYING state. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Sinks unblock any #GstClock wait calls. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; When a sink does not have a pending buffer to play, it returns %GST_STATE_CHANGE_ASYNC from this state change and completes the state change when it receives a new buffer or an %GST_EVENT_EOS. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Any queued %GST_MESSAGE_EOS items are removed since they will be reposted when going back to the PLAYING state. The EOS messages are queued in #GstBin containers. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Live sources stop generating data and return %GST_STATE_CHANGE_NO_PREROLL. &lt;/para&gt;&lt;/listitem&gt; &lt;/itemizedlist&gt;</doc>
      </member>
      <member name="paused_to_ready"
              value="26"
              c:identifier="GST_STATE_CHANGE_PAUSED_TO_READY">
        <doc xml:whitespace="preserve">state change from PAUSED to READY. &lt;itemizedlist&gt; &lt;listitem&gt;&lt;para&gt; Sinks unblock any waits in the preroll. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Elements unblock any waits on devices &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Chain or get_range functions return %GST_FLOW_FLUSHING. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; The element pads are deactivated so that streaming becomes impossible and all streaming threads are stopped. &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; The sink forgets all negotiated formats &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Elements remove all sometimes pads &lt;/para&gt;&lt;/listitem&gt; &lt;/itemizedlist&gt;</doc>
      </member>
      <member name="ready_to_null"
              value="17"
              c:identifier="GST_STATE_CHANGE_READY_TO_NULL">
        <doc xml:whitespace="preserve">state change from READY to NULL. &lt;itemizedlist&gt; &lt;listitem&gt;&lt;para&gt; Elements close devices &lt;/para&gt;&lt;/listitem&gt; &lt;listitem&gt;&lt;para&gt; Elements reset any internal state. &lt;/para&gt;&lt;/listitem&gt; &lt;/itemizedlist&gt;</doc>
      </member>
    </bitfield>
    <enumeration name="StateChangeReturn" c:type="GstStateChangeReturn">
      <doc xml:whitespace="preserve">The possible return values from a state change function such as 
gst_element_set_state(). Only @GST_STATE_CHANGE_FAILURE is a real failure.</doc>
      <member name="failure" value="0" c:identifier="GST_STATE_CHANGE_FAILURE">
        <doc xml:whitespace="preserve">the state change failed</doc>
      </member>
      <member name="success" value="1" c:identifier="GST_STATE_CHANGE_SUCCESS">
        <doc xml:whitespace="preserve">the state change succeeded</doc>
      </member>
      <member name="async" value="2" c:identifier="GST_STATE_CHANGE_ASYNC">
        <doc xml:whitespace="preserve">the state change will happen asynchronously</doc>
      </member>
      <member name="no_preroll"
              value="3"
              c:identifier="GST_STATE_CHANGE_NO_PREROLL">
        <doc xml:whitespace="preserve">the state change succeeded but the element cannot produce data in %GST_STATE_PAUSED. This typically happens with live sources.</doc>
      </member>
    </enumeration>
    <record name="StaticCaps" c:type="GstStaticCaps">
      <doc xml:whitespace="preserve">Datastructure to initialize #GstCaps from a string description usually
used in conjunction with GST_STATIC_CAPS() and gst_static_caps_get() to
instantiate a #GstCaps.</doc>
      <field name="caps" writable="1">
        <type name="Caps" c:type="GstCaps*"/>
      </field>
      <field name="string" writable="1">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="cleanup" c:identifier="gst_static_caps_cleanup">
        <doc xml:whitespace="preserve">Clean up the cached caps contained in @static_caps.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get" c:identifier="gst_static_caps_get">
        <doc xml:whitespace="preserve">Converts a #GstStaticCaps to a #GstCaps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to the #GstCaps. Unref after usage. Since the core holds an additional ref to the returned caps, use gst_caps_make_writable() on the returned caps to modify it.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
    </record>
    <record name="StaticPadTemplate" c:type="GstStaticPadTemplate">
      <doc xml:whitespace="preserve">Structure describing the #GstStaticPadTemplate.</doc>
      <field name="name_template" writable="1">
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="direction" writable="1">
        <type name="PadDirection" c:type="GstPadDirection"/>
      </field>
      <field name="presence" writable="1">
        <type name="PadPresence" c:type="GstPadPresence"/>
      </field>
      <field name="static_caps" writable="1">
        <type name="StaticCaps" c:type="GstStaticCaps"/>
      </field>
      <method name="get" c:identifier="gst_static_pad_template_get">
        <doc xml:whitespace="preserve">Converts a #GstStaticPadTemplate into a #GstPadTemplate.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstPadTemplate.</doc>
          <type name="PadTemplate" c:type="GstPadTemplate*"/>
        </return-value>
      </method>
      <method name="get_caps" c:identifier="gst_static_pad_template_get_caps">
        <doc xml:whitespace="preserve">Gets the capabilities of the static pad template.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstCaps of the static pad template. Unref after usage. Since the core holds an additional ref to the returned caps, use gst_caps_make_writable() on the returned caps to modify it.</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
    </record>
    <enumeration name="StreamError"
                 c:type="GstStreamError"
                 glib:error-domain="gst-stream-error-quark">
      <doc xml:whitespace="preserve">Stream errors are for anything related to the stream being processed:
format errors, media type errors, ...
They're typically used by decoders, demuxers, converters, ...</doc>
      <member name="failed" value="1" c:identifier="GST_STREAM_ERROR_FAILED">
        <doc xml:whitespace="preserve">a general error which doesn't fit in any other category.  Make sure you add a custom message to the error call.</doc>
      </member>
      <member name="too_lazy"
              value="2"
              c:identifier="GST_STREAM_ERROR_TOO_LAZY">
        <doc xml:whitespace="preserve">do not use this except as a placeholder for deciding where to go while developing code.</doc>
      </member>
      <member name="not_implemented"
              value="3"
              c:identifier="GST_STREAM_ERROR_NOT_IMPLEMENTED">
        <doc xml:whitespace="preserve">use this when you do not want to implement this functionality yet.</doc>
      </member>
      <member name="type_not_found"
              value="4"
              c:identifier="GST_STREAM_ERROR_TYPE_NOT_FOUND">
        <doc xml:whitespace="preserve">used when the element doesn't know the stream's type.</doc>
      </member>
      <member name="wrong_type"
              value="5"
              c:identifier="GST_STREAM_ERROR_WRONG_TYPE">
        <doc xml:whitespace="preserve">used when the element doesn't handle this type of stream.</doc>
      </member>
      <member name="codec_not_found"
              value="6"
              c:identifier="GST_STREAM_ERROR_CODEC_NOT_FOUND">
        <doc xml:whitespace="preserve">used when there's no codec to handle the stream's type.</doc>
      </member>
      <member name="decode" value="7" c:identifier="GST_STREAM_ERROR_DECODE">
        <doc xml:whitespace="preserve">used when decoding fails.</doc>
      </member>
      <member name="encode" value="8" c:identifier="GST_STREAM_ERROR_ENCODE">
        <doc xml:whitespace="preserve">used when encoding fails.</doc>
      </member>
      <member name="demux" value="9" c:identifier="GST_STREAM_ERROR_DEMUX">
        <doc xml:whitespace="preserve">used when demuxing fails.</doc>
      </member>
      <member name="mux" value="10" c:identifier="GST_STREAM_ERROR_MUX">
        <doc xml:whitespace="preserve">used when muxing fails.</doc>
      </member>
      <member name="format" value="11" c:identifier="GST_STREAM_ERROR_FORMAT">
        <doc xml:whitespace="preserve">used when the stream is of the wrong format (for example, wrong caps).</doc>
      </member>
      <member name="decrypt"
              value="12"
              c:identifier="GST_STREAM_ERROR_DECRYPT">
        <doc xml:whitespace="preserve">used when the stream is encrypted and can't be decrypted because this is not supported by the element.</doc>
      </member>
      <member name="decrypt_nokey"
              value="13"
              c:identifier="GST_STREAM_ERROR_DECRYPT_NOKEY">
        <doc xml:whitespace="preserve">used when the stream is encrypted and can't be decrypted because no suitable key is available.</doc>
      </member>
      <member name="num_errors"
              value="14"
              c:identifier="GST_STREAM_ERROR_NUM_ERRORS">
        <doc xml:whitespace="preserve">the number of stream error types.</doc>
      </member>
    </enumeration>
    <enumeration name="StreamStatusType" c:type="GstStreamStatusType">
      <doc xml:whitespace="preserve">The type of a %GST_MESSAGE_STREAM_STATUS. The stream status messages inform the
application of new streaming threads and their status.</doc>
      <member name="create"
              value="0"
              c:identifier="GST_STREAM_STATUS_TYPE_CREATE">
        <doc xml:whitespace="preserve">A new thread need to be created.</doc>
      </member>
      <member name="enter"
              value="1"
              c:identifier="GST_STREAM_STATUS_TYPE_ENTER">
        <doc xml:whitespace="preserve">a thread entered its loop function</doc>
      </member>
      <member name="leave"
              value="2"
              c:identifier="GST_STREAM_STATUS_TYPE_LEAVE">
        <doc xml:whitespace="preserve">a thread left its loop function</doc>
      </member>
      <member name="destroy"
              value="3"
              c:identifier="GST_STREAM_STATUS_TYPE_DESTROY">
        <doc xml:whitespace="preserve">a thread is destroyed</doc>
      </member>
      <member name="start"
              value="8"
              c:identifier="GST_STREAM_STATUS_TYPE_START">
        <doc xml:whitespace="preserve">a thread is started</doc>
      </member>
      <member name="pause"
              value="9"
              c:identifier="GST_STREAM_STATUS_TYPE_PAUSE">
        <doc xml:whitespace="preserve">a thread is paused</doc>
      </member>
      <member name="stop"
              value="10"
              c:identifier="GST_STREAM_STATUS_TYPE_STOP">
        <doc xml:whitespace="preserve">a thread is stopped</doc>
      </member>
    </enumeration>
    <record name="Structure"
            c:type="GstStructure"
            glib:type-name="GstStructure"
            glib:get-type="gst_structure_get_type"
            c:symbol-prefix="structure">
      <doc xml:whitespace="preserve">A #GstStructure is a collection of key/value pairs. The keys are expressed
as GQuarks and the values can be of any GType.

In addition to the key/value pairs, a #GstStructure also has a name. The name
starts with a letter and can be filled by letters, numbers and any of "/-_.:".

#GstStructure is used by various GStreamer subsystems to store information
in a flexible and extensible way. A #GstStructure does not have a refcount
because it usually is part of a higher level object such as #GstCaps,
#GstMessage, #GstEvent, #GstQuery. It provides a means to enforce mutability
using the refcount of the parent with the gst_structure_set_parent_refcount()
method.

A #GstStructure can be created with gst_structure_new_empty() or
gst_structure_new(), which both take a name and an optional set of
key/value pairs along with the types of the values.

Field values can be changed with gst_structure_set_value() or
gst_structure_set().

Field values can be retrieved with gst_structure_get_value() or the more
convenient gst_structure_get_*() functions.

Fields can be removed with gst_structure_remove_field() or
gst_structure_remove_fields().

Strings in structures must be ASCII or UTF-8 encoded. Other encodings are
not allowed. Strings must not be empty either, but may be NULL.

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="GLib.Quark" c:type="GQuark"/>
      </field>
      <constructor name="new"
                   c:identifier="gst_structure_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstStructure with the given name.  Parses the
list of variable arguments and sets fields to the values listed.
Variable arguments should be passed as field name, field type,
and value.  Last variable argument should be NULL.

Free-function: gst_structure_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="firstfield" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of first field to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_empty" c:identifier="gst_structure_new_empty">
        <doc xml:whitespace="preserve">Creates a new, empty #GstStructure with the given @name.

See gst_structure_set_name() for constraints on the @name parameter.

Free-function: gst_structure_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_id"
                   c:identifier="gst_structure_new_id"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstStructure with the given name as a GQuark, followed by
fieldname quark, GType, argument(s) "triplets" in the same format as
gst_structure_id_set(). Basically a convenience wrapper around
gst_structure_new_id_empty() and gst_structure_id_set().

The last variable argument must be NULL (or 0).

Free-function: gst_structure_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name_quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="field_quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GQuark for the name of the field to set</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_id_empty"
                   c:identifier="gst_structure_new_id_empty">
        <doc xml:whitespace="preserve">Creates a new, empty #GstStructure with the given name as a GQuark.

Free-function: gst_structure_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new, empty #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="quark" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_valist"
                   c:identifier="gst_structure_new_valist"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new #GstStructure with the given @name.  Structure fields
are set according to the varargs in a manner similar to
gst_structure_new().

See gst_structure_set_name() for constraints on the @name parameter.

Free-function: gst_structure_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstStructure</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of new structure</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="firstfield" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of first field to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable argument list</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="can_intersect" c:identifier="gst_structure_can_intersect">
        <doc xml:whitespace="preserve">Tries intersecting @struct1 and @struct2 and reports whether the result
would not be empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if intersection would not be empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="struct2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstStructure</doc>
            <type name="Structure" c:type="const GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_structure_copy">
        <doc xml:whitespace="preserve">Duplicates a #GstStructure and all its fields and values.

Free-function: gst_structure_free</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a new #GstStructure.</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
      </method>
      <method name="fixate" c:identifier="gst_structure_fixate">
        <doc xml:whitespace="preserve">Fixate all values in @structure using gst_value_fixate().
@structure will be modified in-place and should be writable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="fixate_field" c:identifier="gst_structure_fixate_field">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given field with its fixated value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure field could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_boolean"
              c:identifier="gst_structure_fixate_field_boolean">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given @field_name field to the given
@target boolean if that field is not fixed yet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_nearest_double"
              c:identifier="gst_structure_fixate_field_nearest_double">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given field to the nearest
double to @target that is a subset of the existing field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_nearest_fraction"
              c:identifier="gst_structure_fixate_field_nearest_fraction">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given field to the nearest
fraction to @target_numerator/@target_denominator that is a subset
of the existing field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="target_numerator" transfer-ownership="none">
            <doc xml:whitespace="preserve">The numerator of the target value of the fixation</doc>
            <type name="gint" c:type="const gint"/>
          </parameter>
          <parameter name="target_denominator" transfer-ownership="none">
            <doc xml:whitespace="preserve">The denominator of the target value of the fixation</doc>
            <type name="gint" c:type="const gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_nearest_int"
              c:identifier="gst_structure_fixate_field_nearest_int">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given field to the nearest
integer to @target that is a subset of the existing field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="fixate_field_string"
              c:identifier="gst_structure_fixate_field_string">
        <doc xml:whitespace="preserve">Fixates a #GstStructure by changing the given @field_name field to the given
@target string if that field is not fixed yet.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure could be fixated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a field in @structure</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="target" transfer-ownership="none">
            <doc xml:whitespace="preserve">the target value of the fixation</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="gst_structure_foreach">
        <doc xml:whitespace="preserve">Calls the provided function once for each field in the #GstStructure. The
function must not modify the fields. Also see gst_structure_map_in_place().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the supplied function returns TRUE For each of the fields, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a function to call for each field</doc>
            <type name="StructureForeachFunc"
                  c:type="GstStructureForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">private data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_structure_free">
        <doc xml:whitespace="preserve">Frees a #GstStructure and all its fields and values. The structure must not
have a parent when this function is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get" c:identifier="gst_structure_get" introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
Variable arguments should be in the form field name, field type
(as a GType), pointer(s) to a variable(s) to hold the return value(s).
The last variable argument should be NULL.

For refcounted (mini)objects you will receive a new reference which
you must release with a suitable _unref() when no longer needed. For
strings and boxed types you will receive a copy which you will need to
release with either g_free() or the suitable function for the boxed type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if there was a problem reading any of the fields (e.g. because the field requested did not exist, or was of a type other than the type specified), otherwise TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the first field to read</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="gst_structure_get_boolean">
        <doc xml:whitespace="preserve">Sets the boolean pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain a boolean, this function returns FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #gboolean to set</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_clock_time"
              c:identifier="gst_structure_get_clock_time">
        <doc xml:whitespace="preserve">Sets the clock time pointed to by @value corresponding to the clock time
of the given field.  Caller is responsible for making sure the field exists
and has the correct type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain a #GstClockTime, this function returns FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #GstClockTime to set</doc>
            <type name="ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date" c:identifier="gst_structure_get_date">
        <doc xml:whitespace="preserve">Sets the date pointed to by @value corresponding to the date of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.

On success @value will point to a newly-allocated copy of the date which
should be freed with g_date_free() when no longer needed (note: this is
inconsistent with e.g. gst_structure_get_string() which doesn't return a
copy of the string).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain a data, this function returns FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #GDate to set</doc>
            <type name="GLib.Date" c:type="GDate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_time" c:identifier="gst_structure_get_date_time">
        <doc xml:whitespace="preserve">Sets the datetime pointed to by @value corresponding to the datetime of the
given field. Caller is responsible for making sure the field exists
and has the correct type.

On success @value will point to a reference of the datetime which
should be unreffed with gst_date_time_unref() when no longer needed
(note: this is inconsistent with e.g. gst_structure_get_string()
which doesn't return a copy of the string).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain a data, this function returns FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a #GstDateTime to set</doc>
            <type name="DateTime" c:type="GstDateTime**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="gst_structure_get_double">
        <doc xml:whitespace="preserve">Sets the double pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain a double, this function returns FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a gdouble to set</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_enum" c:identifier="gst_structure_get_enum">
        <doc xml:whitespace="preserve">Sets the int pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists,
has the correct type and that the enumtype is correct.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain an enum of the given type, this function returns FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="enumtype" transfer-ownership="none">
            <doc xml:whitespace="preserve">the enum type of a field</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_field_type"
              c:identifier="gst_structure_get_field_type">
        <doc xml:whitespace="preserve">Finds the field with the given name, and returns the type of the
value it contains.  If the field is not found, G_TYPE_INVALID is
returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue of the field</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_fraction" c:identifier="gst_structure_get_fraction">
        <doc xml:whitespace="preserve">Sets the integers pointed to by @value_numerator and @value_denominator
corresponding to the value of the given field.  Caller is responsible
for making sure the field exists and has the correct type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the values could be set correctly. If there was no field with @fieldname or the existing field did not contain a GstFraction, this function returns FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value_numerator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="value_denominator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="gst_structure_get_int">
        <doc xml:whitespace="preserve">Sets the int pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain an int, this function returns %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to an int to set</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="gst_structure_get_name">
        <doc xml:whitespace="preserve">Get the name of @structure as a string.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the structure.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="get_name_id" c:identifier="gst_structure_get_name_id">
        <doc xml:whitespace="preserve">Get the name of @structure as a GQuark.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the quark representing the name of the structure.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </method>
      <method name="get_string" c:identifier="gst_structure_get_string">
        <doc xml:whitespace="preserve">Finds the field corresponding to @fieldname, and returns the string
contained in the field's value.  Caller is responsible for making
sure the field exists and has the correct type.

The string should not be modified, and remains valid until the next
call to a gst_structure_*() function with the given structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the string or NULL when the field did not exist or did not contain a string.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint" c:identifier="gst_structure_get_uint">
        <doc xml:whitespace="preserve">Sets the uint pointed to by @value corresponding to the value of the
given field.  Caller is responsible for making sure the field exists
and has the correct type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the value could be set correctly. If there was no field with @fieldname or the existing field did not contain a uint, this function returns %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">a pointer to a uint to set</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist"
              c:identifier="gst_structure_get_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
valist-variant of gst_structure_get(). Look at the documentation of
gst_structure_get() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, or FALSE if there was a problem reading any of the fields</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the first field to read</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="gst_structure_get_value">
        <doc xml:whitespace="preserve">Get the value of the field with name @fieldname.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue corresponding to the field with the given name.</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_field" c:identifier="gst_structure_has_field">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @fieldname.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_field_typed"
              c:identifier="gst_structure_has_field_typed">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @fieldname and with GType @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name and type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a field</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of a value</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_name" c:identifier="gst_structure_has_name">
        <doc xml:whitespace="preserve">Checks if the structure has the given name</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if @name matches the name of the structure.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">structure name to check for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_get"
              c:identifier="gst_structure_id_get"
              introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
Variable arguments should be in the form field id quark, field type
(as a GType), pointer(s) to a variable(s) to hold the return value(s).
The last variable argument should be NULL (technically it should be a
0 quark, but we require NULL so compilers that support it can check for
the NULL terminator and warn if it's not there).

This function is just like gst_structure_get() only that it is slightly
more efficient since it saves the string-to-quark lookup in the global
quark hashtable.

For refcounted (mini)objects you will receive a new reference which
you must release with a suitable _unref() when no longer needed. For
strings and boxed types you will receive a copy which you will need to
release with either g_free() or the suitable function for the boxed type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">FALSE if there was a problem reading any of the fields (e.g. because the field requested did not exist, or was of a type other than the type specified), otherwise TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_field_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the quark of the first field to read</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="id_get_valist"
              c:identifier="gst_structure_id_get_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and reads fields from @structure accordingly.
valist-variant of gst_structure_id_get(). Look at the documentation of
gst_structure_id_get() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, or FALSE if there was a problem reading any of the fields</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="first_field_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the quark of the first field to read</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_get_value" c:identifier="gst_structure_id_get_value">
        <doc xml:whitespace="preserve">Get the value of the field with GQuark @field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue corresponding to the field with the given name identifier.</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GQuark of the field to get</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_has_field" c:identifier="gst_structure_id_has_field">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @field.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GQuark of the field name</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_has_field_typed"
              c:identifier="gst_structure_id_has_field_typed">
        <doc xml:whitespace="preserve">Check if @structure contains a field named @field and with GType @type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the structure contains a field with the given name and type</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GQuark of the field name</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the type of a value</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_set"
              c:identifier="gst_structure_id_set"
              introspectable="0">
        <doc xml:whitespace="preserve">Identical to gst_structure_set, except that field names are
passed using the GQuark for the field name. This allows more efficient
setting of the structure if the caller already knows the associated
quark values.
The last variable argument must be NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the GQuark for the name of the field to set</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="id_set_valist"
              c:identifier="gst_structure_id_set_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">va_list form of gst_structure_id_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_set_value" c:identifier="gst_structure_id_set_value">
        <doc xml:whitespace="preserve">Sets the field with the given GQuark @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark representing a field</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="id_take_value" c:identifier="gst_structure_id_take_value">
        <doc xml:whitespace="preserve">Sets the field with the given GQuark @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="field" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GQuark representing a field</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect" c:identifier="gst_structure_intersect">
        <doc xml:whitespace="preserve">Interesects @struct1 and @struct2 and returns the intersection.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">Intersection of @struct1 and @struct2</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="struct2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstStructure</doc>
            <type name="Structure" c:type="const GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_equal" c:identifier="gst_structure_is_equal">
        <doc xml:whitespace="preserve">Tests if the two #GstStructure are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the two structures have the same name and field.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="structure2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstStructure.</doc>
            <type name="Structure" c:type="const GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_subset" c:identifier="gst_structure_is_subset">
        <doc xml:whitespace="preserve">Checks if @subset is a subset of @superset, i.e. has the same
structure name and for all fields that are existing in @superset,
@subset has a value that is a subset of the value in @superset.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @subset is a subset of @superset</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="superset" transfer-ownership="none">
            <doc xml:whitespace="preserve">a potentially greater #GstStructure</doc>
            <type name="Structure" c:type="const GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="map_in_place" c:identifier="gst_structure_map_in_place">
        <doc xml:whitespace="preserve">Calls the provided function once for each field in the #GstStructure. In
contrast to gst_structure_foreach(), the function may modify but not delete the
fields. The structure must be mutable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the supplied function returns TRUE For each of the fields, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">a function to call for each field</doc>
            <type name="StructureMapFunc" c:type="GstStructureMapFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">private data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="n_fields" c:identifier="gst_structure_n_fields">
        <doc xml:whitespace="preserve">Get the number of fields in the structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of fields in the structure</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="nth_field_name"
              c:identifier="gst_structure_nth_field_name">
        <doc xml:whitespace="preserve">Get the name of the given field number, counting from 0 onwards.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the given field number</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index to get the name of</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_all_fields"
              c:identifier="gst_structure_remove_all_fields">
        <doc xml:whitespace="preserve">Removes all fields in a GstStructure.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="remove_field" c:identifier="gst_structure_remove_field">
        <doc xml:whitespace="preserve">Removes the field with the given name.  If the field with the given
name does not exist, the structure is unchanged.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_fields"
              c:identifier="gst_structure_remove_fields"
              introspectable="0">
        <doc xml:whitespace="preserve">Removes the fields with the given names. If a field does not exist, the
argument is ignored.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="remove_fields_valist"
              c:identifier="gst_structure_remove_fields_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">va_list form of gst_structure_remove_fields().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">NULL-terminated list of more fieldnames to remove</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gst_structure_set" introspectable="0">
        <doc xml:whitespace="preserve">Parses the variable arguments and sets fields accordingly.
Variable arguments should be in the form field name, field type
(as a GType), value(s).  The last variable argument should be NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="set_name" c:identifier="gst_structure_set_name">
        <doc xml:whitespace="preserve">Sets the name of the structure to the given @name.  The string
provided is copied before being used. It must not be empty, start with a
letter and can be followed by letters, numbers and any of "/-_.:".</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new name of the structure</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_parent_refcount"
              c:identifier="gst_structure_set_parent_refcount">
        <doc xml:whitespace="preserve">Sets the parent_refcount field of #GstStructure. This field is used to
determine whether a structure is mutable or not. This function should only be
called by code implementing parent objects of #GstStructure, as described in
the MT Refcounting section of the design documents.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parent refcount could be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="refcount" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the parent's refcount</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="gst_structure_set_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">va_list form of gst_structure_set().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="varargs" transfer-ownership="none">
            <doc xml:whitespace="preserve">variable arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="gst_structure_set_value">
        <doc xml:whitespace="preserve">Sets the field with the given name @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_value" c:identifier="gst_structure_take_value">
        <doc xml:whitespace="preserve">Sets the field with the given name @field to @value.  If the field
does not exist, it is created.  If the field exists, the previous
value is replaced and freed. The function will take ownership of @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of the field to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="full">
            <doc xml:whitespace="preserve">the new value of the field</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gst_structure_to_string">
        <doc xml:whitespace="preserve">Converts @structure to a human-readable string representation.

For debugging purposes its easier to do something like this:
|[
GST_LOG ("structure is %" GST_PTR_FORMAT, structure);
]|
This prints the structure in human readble form.

Free-function: g_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a pointer to string allocated by g_malloc(). g_free() after usage.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <function name="from_string" c:identifier="gst_structure_from_string">
        <doc xml:whitespace="preserve">Creates a #GstStructure from a string representation.
If end is not NULL, a pointer to the place inside the given string
where parsing ended will be returned.

Free-function: gst_structure_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstStructure or NULL when the string could not be parsed. Free with gst_structure_free() after use.</doc>
          <type name="Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string representation of a #GstStructure.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="end"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">pointer to store the end of the string in.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="StructureChangeType" c:type="GstStructureChangeType">
      <doc xml:whitespace="preserve">The type of a %GST_MESSAGE_STRUCTURE_CHANGE.</doc>
      <member name="link"
              value="0"
              c:identifier="GST_STRUCTURE_CHANGE_TYPE_PAD_LINK">
        <doc xml:whitespace="preserve">Pad linking is starting or done.</doc>
      </member>
      <member name="unlink"
              value="1"
              c:identifier="GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK">
        <doc xml:whitespace="preserve">Pad unlinking is starting or done.</doc>
      </member>
    </enumeration>
    <callback name="StructureForeachFunc" c:type="GstStructureForeachFunc">
      <doc xml:whitespace="preserve">A function that will be called in gst_structure_foreach(). The function may
not modify @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the foreach operation should continue, FALSE if the foreach operation should stop with FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="field_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GQuark of the field name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue of the field</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="StructureMapFunc" c:type="GstStructureMapFunc">
      <doc xml:whitespace="preserve">A function that will be called in gst_structure_map_in_place(). The function
may modify @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the map operation should continue, FALSE if the map operation should stop with FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="field_id" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GQuark of the field name</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue of the field</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SystemClock"
           c:symbol-prefix="system_clock"
           c:type="GstSystemClock"
           parent="Clock"
           glib:type-name="GstSystemClock"
           glib:get-type="gst_system_clock_get_type"
           glib:type-struct="SystemClockClass">
      <doc xml:whitespace="preserve">The GStreamer core provides a GstSystemClock based on the system time.
Asynchronous callbacks are scheduled from an internal thread.

Clock implementors are encouraged to subclass this systemclock as it
implements the async notification.

Subclasses can however override all of the important methods for sync and
async notifications to implement their own callback methods or blocking
wait operations.

Last reviewed on 2006-03-08 (0.10.4)</doc>
      <function name="obtain" c:identifier="gst_system_clock_obtain">
        <doc xml:whitespace="preserve">Get a handle to the default system clock. The refcount of the
clock will be increased so you need to unref the clock after
usage.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the default clock.  MT safe.</doc>
          <type name="Clock" c:type="GstClock*"/>
        </return-value>
      </function>
      <property name="clock-type"
                introspectable="0"
                writable="1"
                transfer-ownership="none">
        <type/>
      </property>
      <field name="clock">
        <type name="Clock" c:type="GstClock"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SystemClockPrivate" c:type="GstSystemClockPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="SystemClockClass"
            c:type="GstSystemClockClass"
            glib:is-gtype-struct-for="SystemClock">
      <field name="parent_class">
        <type name="ClockClass" c:type="GstClockClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SystemClockPrivate"
            c:type="GstSystemClockPrivate"
            disguised="1">
    </record>
    <constant name="TAG_ALBUM" value="album" c:type="GST_TAG_ALBUM">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_ARTIST"
              value="album-artist"
              c:type="GST_TAG_ALBUM_ARTIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_ARTIST_SORTNAME"
              value="album-artist-sortname"
              c:type="GST_TAG_ALBUM_ARTIST_SORTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_GAIN"
              value="replaygain-album-gain"
              c:type="GST_TAG_ALBUM_GAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_PEAK"
              value="replaygain-album-peak"
              c:type="GST_TAG_ALBUM_PEAK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_SORTNAME"
              value="album-sortname"
              c:type="GST_TAG_ALBUM_SORTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_VOLUME_COUNT"
              value="album-disc-count"
              c:type="GST_TAG_ALBUM_VOLUME_COUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ALBUM_VOLUME_NUMBER"
              value="album-disc-number"
              c:type="GST_TAG_ALBUM_VOLUME_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_APPLICATION_DATA"
              value="application-data"
              c:type="GST_TAG_APPLICATION_DATA">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_APPLICATION_NAME"
              value="application-name"
              c:type="GST_TAG_APPLICATION_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ARTIST" value="artist" c:type="GST_TAG_ARTIST">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ARTIST_SORTNAME"
              value="artist-sortname"
              c:type="GST_TAG_ARTIST_SORTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ATTACHMENT"
              value="attachment"
              c:type="GST_TAG_ATTACHMENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_AUDIO_CODEC"
              value="audio-codec"
              c:type="GST_TAG_AUDIO_CODEC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_BEATS_PER_MINUTE"
              value="beats-per-minute"
              c:type="GST_TAG_BEATS_PER_MINUTE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_BITRATE" value="bitrate" c:type="GST_TAG_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_CODEC" value="codec" c:type="GST_TAG_CODEC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COMMENT" value="comment" c:type="GST_TAG_COMMENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COMPOSER" value="composer" c:type="GST_TAG_COMPOSER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COMPOSER_SORTNAME"
              value="composer-sortname"
              c:type="GST_TAG_COMPOSER_SORTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_CONTACT" value="contact" c:type="GST_TAG_CONTACT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_CONTAINER_FORMAT"
              value="container-format"
              c:type="GST_TAG_CONTAINER_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COPYRIGHT"
              value="copyright"
              c:type="GST_TAG_COPYRIGHT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_COPYRIGHT_URI"
              value="copyright-uri"
              c:type="GST_TAG_COPYRIGHT_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DATE" value="date" c:type="GST_TAG_DATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DATE_TIME" value="datetime" c:type="GST_TAG_DATE_TIME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DESCRIPTION"
              value="description"
              c:type="GST_TAG_DESCRIPTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DEVICE_MANUFACTURER"
              value="device-manufacturer"
              c:type="GST_TAG_DEVICE_MANUFACTURER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DEVICE_MODEL"
              value="device-model"
              c:type="GST_TAG_DEVICE_MODEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_DURATION" value="duration" c:type="GST_TAG_DURATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ENCODED_BY"
              value="encoded-by"
              c:type="GST_TAG_ENCODED_BY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ENCODER" value="encoder" c:type="GST_TAG_ENCODER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ENCODER_VERSION"
              value="encoder-version"
              c:type="GST_TAG_ENCODER_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_EXTENDED_COMMENT"
              value="extended-comment"
              c:type="GST_TAG_EXTENDED_COMMENT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GENRE" value="genre" c:type="GST_TAG_GENRE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_CAPTURE_DIRECTION"
              value="geo-location-capture-direction"
              c:type="GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_CITY"
              value="geo-location-city"
              c:type="GST_TAG_GEO_LOCATION_CITY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_COUNTRY"
              value="geo-location-country"
              c:type="GST_TAG_GEO_LOCATION_COUNTRY">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_ELEVATION"
              value="geo-location-elevation"
              c:type="GST_TAG_GEO_LOCATION_ELEVATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_HORIZONTAL_ERROR"
              value="geo-location-horizontal-error"
              c:type="GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_LATITUDE"
              value="geo-location-latitude"
              c:type="GST_TAG_GEO_LOCATION_LATITUDE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_LONGITUDE"
              value="geo-location-longitude"
              c:type="GST_TAG_GEO_LOCATION_LONGITUDE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_MOVEMENT_DIRECTION"
              value="geo-location-movement-direction"
              c:type="GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_MOVEMENT_SPEED"
              value="geo-location-movement-speed"
              c:type="GST_TAG_GEO_LOCATION_MOVEMENT_SPEED">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_NAME"
              value="geo-location-name"
              c:type="GST_TAG_GEO_LOCATION_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GEO_LOCATION_SUBLOCATION"
              value="geo-location-sublocation"
              c:type="GST_TAG_GEO_LOCATION_SUBLOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_GROUPING" value="grouping" c:type="GST_TAG_GROUPING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_HOMEPAGE" value="homepage" c:type="GST_TAG_HOMEPAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_IMAGE" value="image" c:type="GST_TAG_IMAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_IMAGE_ORIENTATION"
              value="image-orientation"
              c:type="GST_TAG_IMAGE_ORIENTATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ISRC" value="isrc" c:type="GST_TAG_ISRC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_KEYWORDS" value="keywords" c:type="GST_TAG_KEYWORDS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LANGUAGE_CODE"
              value="language-code"
              c:type="GST_TAG_LANGUAGE_CODE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LANGUAGE_NAME"
              value="language-name"
              c:type="GST_TAG_LANGUAGE_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LICENSE" value="license" c:type="GST_TAG_LICENSE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LICENSE_URI"
              value="license-uri"
              c:type="GST_TAG_LICENSE_URI">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LOCATION" value="location" c:type="GST_TAG_LOCATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_LYRICS" value="lyrics" c:type="GST_TAG_LYRICS">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_MAXIMUM_BITRATE"
              value="maximum-bitrate"
              c:type="GST_TAG_MAXIMUM_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_MINIMUM_BITRATE"
              value="minimum-bitrate"
              c:type="GST_TAG_MINIMUM_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_NOMINAL_BITRATE"
              value="nominal-bitrate"
              c:type="GST_TAG_NOMINAL_BITRATE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_ORGANIZATION"
              value="organization"
              c:type="GST_TAG_ORGANIZATION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_PERFORMER"
              value="performer"
              c:type="GST_TAG_PERFORMER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_PREVIEW_IMAGE"
              value="preview-image"
              c:type="GST_TAG_PREVIEW_IMAGE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_REFERENCE_LEVEL"
              value="replaygain-reference-level"
              c:type="GST_TAG_REFERENCE_LEVEL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SERIAL" value="serial" c:type="GST_TAG_SERIAL">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_EPISODE_NUMBER"
              value="show-episode-number"
              c:type="GST_TAG_SHOW_EPISODE_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_NAME"
              value="show-name"
              c:type="GST_TAG_SHOW_NAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_SEASON_NUMBER"
              value="show-season-number"
              c:type="GST_TAG_SHOW_SEASON_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SHOW_SORTNAME"
              value="show-sortname"
              c:type="GST_TAG_SHOW_SORTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_SUBTITLE_CODEC"
              value="subtitle-codec"
              c:type="GST_TAG_SUBTITLE_CODEC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TITLE" value="title" c:type="GST_TAG_TITLE">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TITLE_SORTNAME"
              value="title-sortname"
              c:type="GST_TAG_TITLE_SORTNAME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_COUNT"
              value="track-count"
              c:type="GST_TAG_TRACK_COUNT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_GAIN"
              value="replaygain-track-gain"
              c:type="GST_TAG_TRACK_GAIN">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_NUMBER"
              value="track-number"
              c:type="GST_TAG_TRACK_NUMBER">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_TRACK_PEAK"
              value="replaygain-track-peak"
              c:type="GST_TAG_TRACK_PEAK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_USER_RATING"
              value="user-rating"
              c:type="GST_TAG_USER_RATING">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_VERSION" value="version" c:type="GST_TAG_VERSION">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TAG_VIDEO_CODEC"
              value="video-codec"
              c:type="GST_TAG_VIDEO_CODEC">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="TIME_FORMAT"
              value="u:%02u:%02u.%09u"
              c:type="GST_TIME_FORMAT">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="TagFlag" c:type="GstTagFlag">
      <doc xml:whitespace="preserve">Extra tag flags used when registering tags.</doc>
      <member name="undefined" value="0" c:identifier="GST_TAG_FLAG_UNDEFINED">
        <doc xml:whitespace="preserve">undefined flag</doc>
      </member>
      <member name="meta" value="1" c:identifier="GST_TAG_FLAG_META">
        <doc xml:whitespace="preserve">tag is meta data</doc>
      </member>
      <member name="encoded" value="2" c:identifier="GST_TAG_FLAG_ENCODED">
        <doc xml:whitespace="preserve">tag is encoded</doc>
      </member>
      <member name="decoded" value="3" c:identifier="GST_TAG_FLAG_DECODED">
        <doc xml:whitespace="preserve">tag is decoded</doc>
      </member>
      <member name="count" value="4" c:identifier="GST_TAG_FLAG_COUNT">
        <doc xml:whitespace="preserve">number of tag flags</doc>
      </member>
    </enumeration>
    <callback name="TagForeachFunc" c:type="GstTagForeachFunc">
      <doc xml:whitespace="preserve">A function that will be called in gst_tag_list_foreach(). The function may
not modify the tag list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstTagList</doc>
          <type name="TagList" c:type="const GstTagList*"/>
        </parameter>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">a name of a tag in @list</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TagList"
            c:type="GstTagList"
            glib:type-name="GstTagList"
            glib:get-type="gst_tag_list_get_type"
            c:symbol-prefix="tag_list">
      <doc xml:whitespace="preserve">List of tags and values used to describe media metadata.

Strings must be in ASCII or UTF-8 encoding. No other encodings are allowed.

Last reviewed on 2009-06-09 (0.10.23)</doc>
      <field name="mini_object" writable="1">
        <type name="MiniObject" c:type="GstMiniObject"/>
      </field>
      <constructor name="new"
                   c:identifier="gst_tag_list_new"
                   introspectable="0">
        <doc xml:whitespace="preserve">Creates a new taglist and appends the values for the given tags. It expects
tag-value pairs like gst_tag_list_add(), and a NULL terminator after the
last pair. The type of the values is implicit and is documented in the API
reference, but can also be queried at runtime with gst_tag_get_type(). It
is an error to pass a value of a type not matching the tag type into this
function. The tag list will make copies of any arguments passed
(e.g. strings, buffers).

After creation you might also want to set a #GstTagScope on the returned
taglist to signal if the contained tags are global or stream tags. By
default stream scope is assumes. See gst_tag_list_set_scope().

Free-function: gst_tag_list_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstTagList. Free with gst_tag_list_unref() when no longer needed.</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_empty" c:identifier="gst_tag_list_new_empty">
        <doc xml:whitespace="preserve">Creates a new empty GstTagList.

Free-function: gst_tag_list_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">An empty tag list</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="gst_tag_list_new_from_string">
        <doc xml:whitespace="preserve">Deserializes a tag list.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstTagList, or NULL in case of an error.</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
        <parameters>
          <parameter name="str" transfer-ownership="none">
            <doc xml:whitespace="preserve">a string created with gst_tag_list_to_string()</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_valist"
                   c:identifier="gst_tag_list_new_valist"
                   introspectable="0">
        <doc xml:whitespace="preserve">Just like gst_tag_list_new(), only that it takes a va_list argument.
Useful mostly for language bindings.

Free-function: gst_tag_list_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstTagList. Free with gst_tag_list_unref() when no longer needed.</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
        <parameters>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / value pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add" c:identifier="gst_tag_list_add" introspectable="0">
        <doc xml:whitespace="preserve">Sets the values for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_valist"
              c:identifier="gst_tag_list_add_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the values for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / value pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_valist_values"
              c:identifier="gst_tag_list_add_valist_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the GValues for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / GValue pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_value" c:identifier="gst_tag_list_add_value">
        <doc xml:whitespace="preserve">Sets the GValue for a given tag using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">GValue for this tag</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_values"
              c:identifier="gst_tag_list_add_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Sets the GValues for the given tags using the specified mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="gst_tag_list_foreach">
        <doc xml:whitespace="preserve">Calls the given function for each tag inside the tag list. Note that if there
is no tag, the function won't be called at all.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:whitespace="preserve">function to be called for each tag</doc>
            <type name="TagForeachFunc" c:type="GstTagForeachFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user specified data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean" c:identifier="gst_tag_list_get_boolean">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_boolean_index"
              c:identifier="gst_tag_list_get_boolean_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date" c:identifier="gst_tag_list_get_date">
        <doc xml:whitespace="preserve">Copies the first date for the given tag in the taglist into the variable
pointed to by @value. Free the date with g_date_free() when it is no longer
needed.

Free-function: g_date_free</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a date was copied, FALSE if the tag didn't exist in the given list or if it was #NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a GDate pointer variable to store the result into</doc>
            <type name="GLib.Date" c:type="GDate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_index" c:identifier="gst_tag_list_get_date_index">
        <doc xml:whitespace="preserve">Gets the date that is at the given index for the given tag in the given
list and copies it into the variable pointed to by @value. Free the date
with g_date_free() when it is no longer needed.

Free-function: g_date_free</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list or if it was #NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="GLib.Date" c:type="GDate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_time" c:identifier="gst_tag_list_get_date_time">
        <doc xml:whitespace="preserve">Copies the first datetime for the given tag in the taglist into the variable
pointed to by @value. Unref the date with gst_date_time_unref() when
it is no longer needed.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a datetime was copied, FALSE if the tag didn't exist in thegiven list or if it was #NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a #GstDateTime pointer variable to store the result into</doc>
            <type name="DateTime" c:type="GstDateTime**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_date_time_index"
              c:identifier="gst_tag_list_get_date_time_index">
        <doc xml:whitespace="preserve">Gets the datetime that is at the given index for the given tag in the given
list and copies it into the variable pointed to by @value. Unref the datetime
with gst_date_time_unref() when it is no longer needed.

Free-function: gst_date_time_unref</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list or if it was #NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="DateTime" c:type="GstDateTime**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double" c:identifier="gst_tag_list_get_double">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double_index"
              c:identifier="gst_tag_list_get_double_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float" c:identifier="gst_tag_list_get_float">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float_index"
              c:identifier="gst_tag_list_get_float_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int" c:identifier="gst_tag_list_get_int">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64" c:identifier="gst_tag_list_get_int64">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_index"
              c:identifier="gst_tag_list_get_int64_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int_index" c:identifier="gst_tag_list_get_int_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pointer" c:identifier="gst_tag_list_get_pointer">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pointer_index"
              c:identifier="gst_tag_list_get_pointer_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sample" c:identifier="gst_tag_list_get_sample">
        <doc xml:whitespace="preserve">Copies the first sample for the given tag in the taglist into the variable
pointed to by @sample. Free the sample with gst_sample_unref() when it is
no longer needed. You can retrieve the buffer from the sample using
gst_sample_get_buffer() and the associated caps (if any) with
gst_sample_get_caps().

Free-function: gst_sample_unref</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a sample was returned, FALSE if the tag didn't exist in the given list or if it was #NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="sample"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a GstSample pointer variable to store the result into</doc>
            <type name="Sample" c:type="GstSample**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sample_index"
              c:identifier="gst_tag_list_get_sample_index">
        <doc xml:whitespace="preserve">Gets the sample that is at the given index for the given tag in the given
list and copies it into the variable pointed to by @smple. Free the sample
with gst_sample_unref() when it is no longer needed. You can retrieve the
buffer from the sample using gst_sample_get_buffer() and the associated
caps (if any) with gst_sample_get_caps().

Free-function: gst_sample_unref</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a sample was copied, FALSE if the tag didn't exist in the given list or if it was #NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="sample"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">address of a GstSample pointer variable to store the result into</doc>
            <type name="Sample" c:type="GstSample**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_scope" c:identifier="gst_tag_list_get_scope">
        <doc xml:whitespace="preserve">Gets the scope of @list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The scope of @list</doc>
          <type name="TagScope" c:type="GstTagScope"/>
        </return-value>
      </method>
      <method name="get_string" c:identifier="gst_tag_list_get_string">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, possibly merging
multiple values into one if multiple values are associated with the tag.

Use gst_tag_list_get_string_index (list, tag, 0, value) if you want
to retrieve the first string associated with this tag unmodified.

The resulting string in @value will be in UTF-8 encoding and should be
freed by the caller using g_free when no longer needed. The
returned string is also guaranteed to be non-NULL and non-empty.

Free-function: g_free</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_string_index"
              c:identifier="gst_tag_list_get_string_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.

The resulting string in @value will be in UTF-8 encoding and should be
freed by the caller using g_free when no longer needed. The
returned string is also guaranteed to be non-NULL and non-empty.

Free-function: g_free</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tag_size" c:identifier="gst_tag_list_get_tag_size">
        <doc xml:whitespace="preserve">Checks how many value are stored in this tag list for the given tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of tags stored</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the tag to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint" c:identifier="gst_tag_list_get_uint">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64" c:identifier="gst_tag_list_get_uint64">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value, merging multiple values
into one if multiple values are associated with the tag.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_index"
              c:identifier="gst_tag_list_get_uint64_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint_index" c:identifier="gst_tag_list_get_uint_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_index"
              c:identifier="gst_tag_list_get_value_index">
        <doc xml:whitespace="preserve">Gets the value that is at the given index for the given tag in the given
list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The GValue for the specified entry or NULL if the tag wasn't available or the tag doesn't have as many entries</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="insert" c:identifier="gst_tag_list_insert">
        <doc xml:whitespace="preserve">Inserts the tags of the @from list into the first list using the given mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="from" transfer-ownership="none">
            <doc xml:whitespace="preserve">list to merge from</doc>
            <type name="TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="gst_tag_list_is_empty">
        <doc xml:whitespace="preserve">Checks if the given taglist is empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the taglist is empty, otherwise FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_equal" c:identifier="gst_tag_list_is_equal">
        <doc xml:whitespace="preserve">Checks if the two given taglists are equal.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the taglists are equal, otherwise FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="list2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstTagList.</doc>
            <type name="TagList" c:type="const GstTagList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="merge" c:identifier="gst_tag_list_merge">
        <doc xml:whitespace="preserve">Merges the two given lists into a new list. If one of the lists is NULL, a
copy of the other is returned. If both lists are NULL, NULL is returned.

Free-function: gst_tag_list_unref</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the new list</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
        <parameters>
          <parameter name="list2" transfer-ownership="none">
            <doc xml:whitespace="preserve">second list to merge</doc>
            <type name="TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="n_tags" c:identifier="gst_tag_list_n_tags">
        <doc xml:whitespace="preserve">Get the number of tags in @list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The number of tags in @list.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
      </method>
      <method name="nth_tag_name" c:identifier="gst_tag_list_nth_tag_name">
        <doc xml:whitespace="preserve">Get the name of the tag in @list at @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The name of the tag at @index.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">the index</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_string_index"
              c:identifier="gst_tag_list_peek_string_index">
        <doc xml:whitespace="preserve">Peeks at the value that is at the given index for the given tag in the given
list.

The resulting string in @value will be in UTF-8 encoding and doesn't need
to be freed by the caller. The returned string is also guaranteed to
be non-NULL and non-empty.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was set, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">number of entry to read out</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">location for the result</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_tag" c:identifier="gst_tag_list_remove_tag">
        <doc xml:whitespace="preserve">Removes the given tag from the taglist.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to remove</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scope" c:identifier="gst_tag_list_set_scope">
        <doc xml:whitespace="preserve">Sets the scope of @list to @scope. By default the scope
of a taglist is stream scope.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="scope" transfer-ownership="none">
            <doc xml:whitespace="preserve">new scope for @list</doc>
            <type name="TagScope" c:type="GstTagScope"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gst_tag_list_to_string">
        <doc xml:whitespace="preserve">Serializes a tag list to a string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly-allocated string, or NULL in case of an error. The string must be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <function name="copy_value" c:identifier="gst_tag_list_copy_value">
        <doc xml:whitespace="preserve">Copies the contents for the given tag into the value,
merging multiple values into one if multiple values are associated
with the tag.
You must g_value_unset() the value after use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">uninitialized #GValue to copy into</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">list to get the tag from</doc>
            <type name="TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to read out</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="TagMergeFunc" c:type="GstTagMergeFunc">
      <doc xml:whitespace="preserve">A function for merging multiple values of a tag used when registering
tags.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">the destination #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source #GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TagMergeMode" c:type="GstTagMergeMode">
      <doc xml:whitespace="preserve">The different tag merging modes are basically replace, overwrite and append,
but they can be seen from two directions. Given two taglists: (A) the tags
already in the element and (B) the ones that are supplied to the element (
e.g. via gst_tag_setter_merge_tags() / gst_tag_setter_add_tags() or a
%GST_EVENT_TAG), how are these tags merged?
In the table below this is shown for the cases that a tag exists in the list
(A) or does not exists (!A) and combinations thereof.

&lt;table frame="all" colsep="1" rowsep="1"&gt;
  &lt;title&gt;merge mode&lt;/title&gt;
  &lt;tgroup cols='5' align='left'&gt;
    &lt;thead&gt;
      &lt;row&gt;
        &lt;entry&gt;merge mode&lt;/entry&gt;
        &lt;entry&gt;A + B&lt;/entry&gt;
        &lt;entry&gt;A + !B&lt;/entry&gt;
        &lt;entry&gt;!A + B&lt;/entry&gt;
        &lt;entry&gt;!A + !B&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;row&gt;
        &lt;entry&gt;REPLACE_ALL&lt;/entry&gt;
        &lt;entry&gt;B&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
        &lt;entry&gt;B&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;REPLACE&lt;/entry&gt;
        &lt;entry&gt;B&lt;/entry&gt;
        &lt;entry&gt;A&lt;/entry&gt;
        &lt;entry&gt;B&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;APPEND&lt;/entry&gt;
        &lt;entry&gt;A, B&lt;/entry&gt;
        &lt;entry&gt;A&lt;/entry&gt;
        &lt;entry&gt;B&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;PREPEND&lt;/entry&gt;
        &lt;entry&gt;B, A&lt;/entry&gt;
        &lt;entry&gt;A&lt;/entry&gt;
        &lt;entry&gt;B&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;KEEP&lt;/entry&gt;
        &lt;entry&gt;A&lt;/entry&gt;
        &lt;entry&gt;A&lt;/entry&gt;
        &lt;entry&gt;B&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
      &lt;/row&gt;
      &lt;row&gt;
        &lt;entry&gt;KEEP_ALL&lt;/entry&gt;
        &lt;entry&gt;A&lt;/entry&gt;
        &lt;entry&gt;A&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
        &lt;entry&gt;-&lt;/entry&gt;
      &lt;/row&gt;
    &lt;/tbody&gt;
  &lt;/tgroup&gt;
&lt;/table&gt;</doc>
      <member name="undefined"
              value="0"
              c:identifier="GST_TAG_MERGE_UNDEFINED">
        <doc xml:whitespace="preserve">undefined merge mode</doc>
      </member>
      <member name="replace_all"
              value="1"
              c:identifier="GST_TAG_MERGE_REPLACE_ALL">
        <doc xml:whitespace="preserve">replace all tags (clear list and append)</doc>
      </member>
      <member name="replace" value="2" c:identifier="GST_TAG_MERGE_REPLACE">
        <doc xml:whitespace="preserve">replace tags</doc>
      </member>
      <member name="append" value="3" c:identifier="GST_TAG_MERGE_APPEND">
        <doc xml:whitespace="preserve">append tags</doc>
      </member>
      <member name="prepend" value="4" c:identifier="GST_TAG_MERGE_PREPEND">
        <doc xml:whitespace="preserve">prepend tags</doc>
      </member>
      <member name="keep" value="5" c:identifier="GST_TAG_MERGE_KEEP">
        <doc xml:whitespace="preserve">keep existing tags</doc>
      </member>
      <member name="keep_all" value="6" c:identifier="GST_TAG_MERGE_KEEP_ALL">
        <doc xml:whitespace="preserve">keep all existing tags</doc>
      </member>
      <member name="count" value="7" c:identifier="GST_TAG_MERGE_COUNT">
        <doc xml:whitespace="preserve">the number of merge modes</doc>
      </member>
    </enumeration>
    <enumeration name="TagScope" c:type="GstTagScope">
      <doc xml:whitespace="preserve">GstTagScope specifies if a taglist applies to the complete
medium or only to one single stream.</doc>
      <member name="stream" value="0" c:identifier="GST_TAG_SCOPE_STREAM">
        <doc xml:whitespace="preserve">tags specific to this single stream</doc>
      </member>
      <member name="global" value="1" c:identifier="GST_TAG_SCOPE_GLOBAL">
        <doc xml:whitespace="preserve">global tags for the complete medium</doc>
      </member>
    </enumeration>
    <interface name="TagSetter"
               c:symbol-prefix="tag_setter"
               c:type="GstTagSetter"
               glib:type-name="GstTagSetter"
               glib:get-type="gst_tag_setter_get_type"
               glib:type-struct="TagSetterInterface">
      <doc xml:whitespace="preserve">Element interface that allows setting of media metadata.

Elements that support changing a stream's metadata will implement this
interface. Examples of such elements are 'vorbisenc', 'theoraenc' and
'id3v2mux'.

If you just want to retrieve metadata in your application then all you
need to do is watch for tag messages on your pipeline's bus. This
interface is only for setting metadata, not for extracting it. To set tags
from the application, find tagsetter elements and set tags using e.g.
gst_tag_setter_merge_tags() or gst_tag_setter_add_tags(). Also consider
setting the #GstTagMergeMode that is used for tag events that arrive at the
tagsetter element (default mode is to keep existing tags).
The application should do that before the element goes to %GST_STATE_PAUSED.

Elements implementing the #GstTagSetter interface often have to merge
any tags received from upstream and the tags set by the application via
the interface. This can be done like this:

|[
GstTagMergeMode merge_mode;
const GstTagList *application_tags;
const GstTagList *event_tags;
GstTagSetter *tagsetter;
GstTagList *result;
 
tagsetter = GST_TAG_SETTER (element);
 
merge_mode = gst_tag_setter_get_tag_merge_mode (tagsetter);
application_tags = gst_tag_setter_get_tag_list (tagsetter);
event_tags = (const GstTagList *) element-&gt;event_tags;
 
GST_LOG_OBJECT (tagsetter, "merging tags, merge mode = %d", merge_mode);
GST_LOG_OBJECT (tagsetter, "event tags: %" GST_PTR_FORMAT, event_tags);
GST_LOG_OBJECT (tagsetter, "set   tags: %" GST_PTR_FORMAT, application_tags);
 
result = gst_tag_list_merge (application_tags, event_tags, merge_mode);
 
GST_LOG_OBJECT (tagsetter, "final tags: %" GST_PTR_FORMAT, result);
]|

Last reviewed on 2006-05-18 (0.10.6)</doc>
      <prerequisite name="Element"/>
      <method name="add_tag_valist"
              c:identifier="gst_tag_setter_add_tag_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / value pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / value pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_tag_valist_values"
              c:identifier="gst_tag_setter_add_tag_valist_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / GValue pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag / GValue pairs to set</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_tag_value" c:identifier="gst_tag_setter_add_tag_value">
        <doc xml:whitespace="preserve">Adds the given tag / GValue pair on the setter using the given merge mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">GValue to set for the tag</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_tag_values"
              c:identifier="gst_tag_setter_add_tag_values"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / GValue pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_tags"
              c:identifier="gst_tag_setter_add_tags"
              introspectable="0">
        <doc xml:whitespace="preserve">Adds the given tag / value pairs on the setter using the given merge mode.
The list must be terminated with NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to use</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">tag to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="get_tag_list" c:identifier="gst_tag_setter_get_tag_list">
        <doc xml:whitespace="preserve">Returns the current list of tags the setter uses.  The list should not be
modified or freed.

This function is not thread-safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a current snapshot of the taglist used in the setter or NULL if none is used.</doc>
          <type name="TagList" c:type="const GstTagList*"/>
        </return-value>
      </method>
      <method name="get_tag_merge_mode"
              c:identifier="gst_tag_setter_get_tag_merge_mode">
        <doc xml:whitespace="preserve">Queries the mode by which tags inside the setter are overwritten by tags
from events</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the merge mode used inside the element.</doc>
          <type name="TagMergeMode" c:type="GstTagMergeMode"/>
        </return-value>
      </method>
      <method name="merge_tags" c:identifier="gst_tag_setter_merge_tags">
        <doc xml:whitespace="preserve">Merges the given list into the setter's list using the given mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="list" transfer-ownership="none">
            <doc xml:whitespace="preserve">a tag list to merge from</doc>
            <type name="TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">the mode to merge with</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset_tags" c:identifier="gst_tag_setter_reset_tags">
        <doc xml:whitespace="preserve">Reset the internal taglist. Elements should call this from within the
state-change handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_tag_merge_mode"
              c:identifier="gst_tag_setter_set_tag_merge_mode">
        <doc xml:whitespace="preserve">Sets the given merge mode that is used for adding tags from events to tags
specified by this interface. The default is #GST_TAG_MERGE_KEEP, which keeps
the tags set with this interface and discards tags from events.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">The mode with which tags are added</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="TagSetterInterface"
            c:type="GstTagSetterInterface"
            glib:is-gtype-struct-for="TagSetter">
      <doc xml:whitespace="preserve">#GstTagSetterInterface interface.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <class name="Task"
           c:symbol-prefix="task"
           c:type="GstTask"
           parent="Object"
           glib:type-name="GstTask"
           glib:get-type="gst_task_get_type"
           glib:type-struct="TaskClass">
      <doc xml:whitespace="preserve">#GstTask is used by #GstElement and #GstPad to provide the data passing
threads in a #GstPipeline.

A #GstPad will typically start a #GstTask to push or pull data to/from the
peer pads. Most source elements start a #GstTask to push data. In some cases
a demuxer element can start a #GstTask to pull data from a peer element. This
is typically done when the demuxer can perform random access on the upstream
peer element for improved performance.

Although convenience functions exist on #GstPad to start/pause/stop tasks, it
might sometimes be needed to create a #GstTask manually if it is not related to
a #GstPad.

Before the #GstTask can be run, it needs a #GStaticRecMutex that can be set with
gst_task_set_lock().

The task can be started, paused and stopped with gst_task_start(), gst_task_pause()
and gst_task_stop() respectively or with the gst_task_set_state() function.

A #GstTask will repeatedly call the #GstTaskFunction with the user data
that was provided when creating the task with gst_task_new(). While calling
the function it will acquire the provided lock. The provided lock is released
when the task pauses or stops.

Stopping a task with gst_task_stop() will not immediately make sure the task is
not running anymore. Use gst_task_join() to make sure the task is completely
stopped and the thread is stopped.

After creating a #GstTask, use gst_object_unref() to free its resources. This can
only be done when the task is not running anymore.

Task functions can send a #GstMessage to send out-of-band data to the
application. The application can receive messages from the #GstBus in its
mainloop.

For debugging purposes, the task will configure its object name as the thread
name on Linux. Please note that the object name should be configured before the
task is started; changing the object name after the task has been started, has
no effect on the thread name.

Last reviewed on 2012-03-29 (0.11.3)</doc>
      <constructor name="new" c:identifier="gst_task_new">
        <doc xml:whitespace="preserve">Create a new Task that will repeatedly call the provided @func
with @user_data as a parameter. Typically the task will run in
a new thread.

The function cannot be changed after the task has been created. You
must create a new #GstTask to change the function.

This function will not yet create and start a thread. Use gst_task_start() or
gst_task_pause() to create and start the GThread.

Before the task can be used, a #GStaticRecMutex must be configured using the
gst_task_set_lock() function. This lock will always be acquired while
@func is called.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #GstTask.  MT safe.</doc>
          <type name="Task" c:type="GstTask*"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">The #GstTaskFunction to use</doc>
            <type name="TaskFunction" c:type="GstTaskFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">User data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">the function to call when @user_data is no longer needed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="cleanup_all" c:identifier="gst_task_cleanup_all">
        <doc xml:whitespace="preserve">Wait for all tasks to be stopped. This is mainly used internally
to ensure proper cleanup of internal data structures in test suites.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <method name="get_pool" c:identifier="gst_task_get_pool">
        <doc xml:whitespace="preserve">Get the #GstTaskPool that this task will use for its streaming
threads.

MT safe.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the #GstTaskPool used by @task. gst_object_unref() after usage.</doc>
          <type name="TaskPool" c:type="GstTaskPool*"/>
        </return-value>
      </method>
      <method name="get_state" c:identifier="gst_task_get_state">
        <doc xml:whitespace="preserve">Get the current state of the task.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstTaskState of the task  MT safe.</doc>
          <type name="TaskState" c:type="GstTaskState"/>
        </return-value>
      </method>
      <method name="join" c:identifier="gst_task_join">
        <doc xml:whitespace="preserve">Joins @task. After this call, it is safe to unref the task
and clean up the lock set with gst_task_set_lock().

The task will automatically be stopped with this call.

This function cannot be called from within a task function as this
would cause a deadlock. The function will detect this and print a
g_warning.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be joined.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="pause" c:identifier="gst_task_pause">
        <doc xml:whitespace="preserve">Pauses @task. This method can also be called on a task in the
stopped state, in which case a thread will be started and will remain
in the paused state. This function does not wait for the task to complete
the paused state.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be paused.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="set_enter_callback"
              c:identifier="gst_task_set_enter_callback">
        <doc xml:whitespace="preserve">Call @enter_func when the task function of @task is entered. @user_data will
be passed to @enter_func and @notify will be called when @user_data is no
longer referenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="enter_func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">a #GstTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GstTaskThreadFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @enter_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called when @user_data is no longer referenced</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_leave_callback"
              c:identifier="gst_task_set_leave_callback">
        <doc xml:whitespace="preserve">Call @leave_func when the task function of @task is left. @user_data will
be passed to @leave_func and @notify will be called when @user_data is no
longer referenced.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="leave_func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:whitespace="preserve">a #GstTaskThreadFunc</doc>
            <type name="TaskThreadFunc" c:type="GstTaskThreadFunc"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data passed to @leave_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:whitespace="preserve">called when @user_data is no longer referenced</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_lock" c:identifier="gst_task_set_lock">
        <doc xml:whitespace="preserve">Set the mutex used by the task. The mutex will be acquired before
calling the #GstTaskFunction.

This function has to be called before calling gst_task_pause() or
gst_task_start().

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="mutex" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GRecMutex to use</doc>
            <type name="GLib.RecMutex" c:type="GRecMutex*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pool" c:identifier="gst_task_set_pool">
        <doc xml:whitespace="preserve">Set @pool as the new GstTaskPool for @task. Any new streaming threads that
will be created by @task will now use @pool.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pool" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstTaskPool</doc>
            <type name="TaskPool" c:type="GstTaskPool*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_state" c:identifier="gst_task_set_state">
        <doc xml:whitespace="preserve">Sets the state of @task to @state.

The @task must have a lock associated with it using
gst_task_set_lock() when going to GST_TASK_STARTED or GST_TASK_PAUSED or
this function will return %FALSE.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the state could be changed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="state" transfer-ownership="none">
            <doc xml:whitespace="preserve">the new task state</doc>
            <type name="TaskState" c:type="GstTaskState"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_task_start">
        <doc xml:whitespace="preserve">Starts @task. The @task must have a lock associated with it using
gst_task_set_lock() or this function will return %FALSE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be started.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="stop" c:identifier="gst_task_stop">
        <doc xml:whitespace="preserve">Stops @task. This method merely schedules the task to stop and
will not wait for the task to have completely stopped. Use
gst_task_join() to stop and wait for completion.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the task could be stopped.  MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="state">
        <type name="TaskState" c:type="GstTaskState"/>
      </field>
      <field name="cond">
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <field name="lock">
        <type name="GLib.RecMutex" c:type="GRecMutex*"/>
      </field>
      <field name="func">
        <type name="TaskFunction" c:type="GstTaskFunction"/>
      </field>
      <field name="user_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="notify">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="running">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TaskPrivate" c:type="GstTaskPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="TaskClass"
            c:type="GstTaskClass"
            glib:is-gtype-struct-for="Task">
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="pool" readable="0" private="1">
        <type name="TaskPool" c:type="GstTaskPool*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TaskFunction" c:type="GstTaskFunction">
      <doc xml:whitespace="preserve">A function that will repeatedly be called in the thread created by
a #GstTask.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" closure="0">
          <doc xml:whitespace="preserve">user data passed to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="TaskPool"
           c:symbol-prefix="task_pool"
           c:type="GstTaskPool"
           parent="Object"
           glib:type-name="GstTaskPool"
           glib:get-type="gst_task_pool_get_type"
           glib:type-struct="TaskPoolClass">
      <doc xml:whitespace="preserve">This object provides an abstraction for creating threads. The default
implementation uses a regular GThreadPool to start tasks.

Subclasses can be made to create custom threads.

Last reviewed on 2009-04-23 (0.10.24)</doc>
      <constructor name="new" c:identifier="gst_task_pool_new">
        <doc xml:whitespace="preserve">Create a new default task pool. The default task pool will use a regular
GThreadPool for threads.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #GstTaskPool. gst_object_unref() after usage.</doc>
          <type name="TaskPool" c:type="GstTaskPool*"/>
        </return-value>
      </constructor>
      <virtual-method name="cleanup" invoker="cleanup">
        <doc xml:whitespace="preserve">Wait for all tasks to be stopped. This is mainly used internally
to ensure proper cleanup of internal data structures in test suites.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="join" invoker="join">
        <doc xml:whitespace="preserve">Join a task and/or return it to the pool. @id is the id obtained from 
gst_task_pool_push().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare" invoker="prepare" throws="1">
        <doc xml:whitespace="preserve">Prepare the taskpool for accepting gst_task_pool_push() operations.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </virtual-method>
      <virtual-method name="push" invoker="push" throws="1">
        <doc xml:whitespace="preserve">Start the execution of a new thread from @pool.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer that should be used for the gst_task_pool_join function. This pointer can be NULL, you must check @error to detect errors.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">the function to call</doc>
            <type name="TaskPoolFunction" c:type="GstTaskPoolFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none" closure="1">
            <doc xml:whitespace="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="cleanup" c:identifier="gst_task_pool_cleanup">
        <doc xml:whitespace="preserve">Wait for all tasks to be stopped. This is mainly used internally
to ensure proper cleanup of internal data structures in test suites.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="join" c:identifier="gst_task_pool_join">
        <doc xml:whitespace="preserve">Join a task and/or return it to the pool. @id is the id obtained from 
gst_task_pool_push().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the id</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepare" c:identifier="gst_task_pool_prepare" throws="1">
        <doc xml:whitespace="preserve">Prepare the taskpool for accepting gst_task_pool_push() operations.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="push" c:identifier="gst_task_pool_push" throws="1">
        <doc xml:whitespace="preserve">Start the execution of a new thread from @pool.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer that should be used for the gst_task_pool_join function. This pointer can be NULL, you must check @error to detect errors.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="async"
                     closure="1">
            <doc xml:whitespace="preserve">the function to call</doc>
            <type name="TaskPoolFunction" c:type="GstTaskPoolFunction"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Object" c:type="GstObject"/>
      </field>
      <field name="pool" readable="0" private="1">
        <type name="GLib.ThreadPool" c:type="GThreadPool*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="TaskPoolClass"
            c:type="GstTaskPoolClass"
            glib:is-gtype-struct-for="TaskPool">
      <doc xml:whitespace="preserve">The #GstTaskPoolClass object.</doc>
      <field name="parent_class">
        <type name="ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="prepare">
        <callback name="prepare" throws="1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="cleanup">
        <callback name="cleanup">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="push">
        <callback name="push" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer that should be used for the gst_task_pool_join function. This pointer can be NULL, you must check @error to detect errors.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
            <parameter name="func"
                       transfer-ownership="none"
                       scope="async"
                       closure="2">
              <doc xml:whitespace="preserve">the function to call</doc>
              <type name="TaskPoolFunction" c:type="GstTaskPoolFunction"/>
            </parameter>
            <parameter name="user_data" transfer-ownership="none" closure="2">
              <doc xml:whitespace="preserve">data to pass to @func</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="join">
        <callback name="join">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pool" transfer-ownership="none">
              <type name="TaskPool" c:type="GstTaskPool*"/>
            </parameter>
            <parameter name="id" transfer-ownership="none">
              <doc xml:whitespace="preserve">the id</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TaskPoolFunction" c:type="GstTaskPoolFunction">
      <doc xml:whitespace="preserve">Task function, see gst_task_pool_push().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data" transfer-ownership="none" closure="0">
          <doc xml:whitespace="preserve">user data for the task function</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TaskPrivate" c:type="GstTaskPrivate" disguised="1">
    </record>
    <enumeration name="TaskState" c:type="GstTaskState">
      <doc xml:whitespace="preserve">The different states a task can be in</doc>
      <member name="started" value="0" c:identifier="GST_TASK_STARTED">
        <doc xml:whitespace="preserve">the task is started and running</doc>
      </member>
      <member name="stopped" value="1" c:identifier="GST_TASK_STOPPED">
        <doc xml:whitespace="preserve">the task is stopped</doc>
      </member>
      <member name="paused" value="2" c:identifier="GST_TASK_PAUSED">
        <doc xml:whitespace="preserve">the task is paused</doc>
      </member>
    </enumeration>
    <callback name="TaskThreadFunc" c:type="GstTaskThreadFunc">
      <doc xml:whitespace="preserve">Custom GstTask thread callback functions that can be installed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="task" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GstTask</doc>
          <type name="Task" c:type="GstTask*"/>
        </parameter>
        <parameter name="thread" transfer-ownership="none">
          <doc xml:whitespace="preserve">The #GThread</doc>
          <type name="GLib.Thread" c:type="GThread*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="2">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TimedValue" c:type="GstTimedValue">
      <doc xml:whitespace="preserve">Structure for saving a timestamp and a value.</doc>
      <field name="timestamp" writable="1">
        <type name="ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="value" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
    </record>
    <record name="Toc"
            c:type="GstToc"
            glib:type-name="GstToc"
            glib:get-type="gst_toc_get_type"
            c:symbol-prefix="toc">
      <doc xml:whitespace="preserve">#GstToc functions are used to create/free #GstToc and #GstTocEntry structures.
Also they are used to convert #GstToc into #GstStructure and vice versa.

#GstToc lets you to inform other elements in pipeline or application that playing
source has some kind of table of contents (TOC). These may be chapters, editions,
angles or other types. For example: DVD chapters, Matroska chapters or cue sheet
TOC. Such TOC will be useful for applications to display instead of just a
playlist.

Using TOC is very easy. Firstly, create #GstToc structure which represents root
contents of the source. You can also attach TOC-specific tags to it. Then fill
it with #GstTocEntry entries by appending them to the #GstToc using
gst_toc_append_entry(), and appending subentries to a #GstTocEntry using
gst_toc_entry_append_sub_entry().

Note that root level of the TOC can contain only either editions or chapters. You
should not mix them together at the same level. Otherwise you will get serialization
/deserialization errors. Make sure that no one of the entries has negative start and
 stop values.

Use gst_event_new_toc() to create a new TOC #GstEvent, and gst_event_parse_toc() to
parse received TOC event. Use gst_event_new_toc_select() to create a new TOC select #GstEvent,
and gst_event_parse_toc_select() to parse received TOC select event. The same rule for
the #GstMessage: gst_message_new_toc() to create new TOC #GstMessage, and
gst_message_parse_toc() to parse received TOC message.

TOCs can have global scope or current scope. Global scope TOCs contain
all entries that can possibly be selected using a toc select event, and
are what an application is usually interested in. TOCs with current scope
only contain the parts of the TOC relevant to the currently selected/playing
stream; the current scope TOC is used by downstream elements such as muxers
to write correct TOC entries when transcoding files, for example. When
playing a DVD, the global TOC would contain a hierarchy of all titles,
chapters and angles, for example, while the current TOC would only contain
the chapters for the currently playing title if playback of a specific
title was requested.</doc>
      <constructor name="new" c:identifier="gst_toc_new">
        <doc xml:whitespace="preserve">Create a new #GstToc structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">newly allocated #GstToc structure, free it with gst_toc_unref().</doc>
          <type name="Toc" c:type="GstToc*"/>
        </return-value>
        <parameters>
          <parameter name="scope" transfer-ownership="none">
            <doc xml:whitespace="preserve">scope of this TOC</doc>
            <type name="TocScope" c:type="GstTocScope"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_entry" c:identifier="gst_toc_append_entry">
        <doc xml:whitespace="preserve">Appends the #GstTocEntry @entry to @toc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="entry" transfer-ownership="full">
            <doc xml:whitespace="preserve">A #GstTocEntry</doc>
            <type name="TocEntry" c:type="GstTocEntry*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="gst_toc_dump">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="find_entry" c:identifier="gst_toc_find_entry">
        <doc xml:whitespace="preserve">Find #GstTocEntry with given @uid in the @toc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">#GstTocEntry with specified @uid from the @toc, or NULL if not found.</doc>
          <type name="TocEntry" c:type="GstTocEntry*"/>
        </return-value>
        <parameters>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:whitespace="preserve">UID to find #GstTocEntry with.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_entries" c:identifier="gst_toc_get_entries">
        <doc xml:whitespace="preserve">Gets the list of #GstTocEntry of @toc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GList of #GstTocEntry for @entry</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TocEntry"/>
          </type>
        </return-value>
      </method>
      <method name="get_scope" c:identifier="gst_toc_get_scope">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">scope of @toc</doc>
          <type name="TocScope" c:type="GstTocScope"/>
        </return-value>
      </method>
      <method name="get_tags" c:identifier="gst_toc_get_tags">
        <doc xml:whitespace="preserve">Gets the tags for @toc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstTagList for @entry</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
      </method>
      <method name="merge_tags" c:identifier="gst_toc_merge_tags">
        <doc xml:whitespace="preserve">Merge @tags into the existing tags of @toc using @mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tags" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">A #GstTagList or %NULL</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GstTagMergeMode</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tags" c:identifier="gst_toc_set_tags">
        <doc xml:whitespace="preserve">Set a #GstTagList with tags for the complete @toc.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tags" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">A #GstTagList or %NULL</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="TocEntry"
            c:type="GstTocEntry"
            glib:type-name="GstTocEntry"
            glib:get-type="gst_toc_entry_get_type"
            c:symbol-prefix="toc_entry">
      <constructor name="new" c:identifier="gst_toc_entry_new">
        <doc xml:whitespace="preserve">Create new #GstTocEntry structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">newly allocated #GstTocEntry structure, free it with gst_toc_entry_unref().</doc>
          <type name="TocEntry" c:type="GstTocEntry*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">entry type.</doc>
            <type name="TocEntryType" c:type="GstTocEntryType"/>
          </parameter>
          <parameter name="uid" transfer-ownership="none">
            <doc xml:whitespace="preserve">unique ID (UID) in the whole TOC.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="append_sub_entry"
              c:identifier="gst_toc_entry_append_sub_entry">
        <doc xml:whitespace="preserve">Appends the #GstTocEntry @subentry to @entry.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="subentry" transfer-ownership="full">
            <doc xml:whitespace="preserve">A #GstTocEntry</doc>
            <type name="TocEntry" c:type="GstTocEntry*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_entry_type"
              c:identifier="gst_toc_entry_get_entry_type">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">@entry's entry type</doc>
          <type name="TocEntryType" c:type="GstTocEntryType"/>
        </return-value>
      </method>
      <method name="get_parent" c:identifier="gst_toc_entry_get_parent">
        <doc xml:whitespace="preserve">Gets the parent #GstTocEntry of @entry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The parent #GstTocEntry of @entry</doc>
          <type name="TocEntry" c:type="GstTocEntry*"/>
        </return-value>
      </method>
      <method name="get_start_stop_times"
              c:identifier="gst_toc_entry_get_start_stop_times">
        <doc xml:whitespace="preserve">Get start and stop values from the @entry and write them into appropriate storages.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if all non-NULL storage pointers were filled with appropriate values, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the storage for the start value, leave #NULL if not need.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
          <parameter name="stop"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">the storage for the stop value, leave #NULL if not need.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_sub_entries"
              c:identifier="gst_toc_entry_get_sub_entries">
        <doc xml:whitespace="preserve">Gets the sub-entries of @entry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GList of #GstTocEntry of @entry</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TocEntry"/>
          </type>
        </return-value>
      </method>
      <method name="get_tags" c:identifier="gst_toc_entry_get_tags">
        <doc xml:whitespace="preserve">Gets the tags for @entry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstTagList for @entry</doc>
          <type name="TagList" c:type="GstTagList*"/>
        </return-value>
      </method>
      <method name="get_toc" c:identifier="gst_toc_entry_get_toc">
        <doc xml:whitespace="preserve">Gets the parent #GstToc of @entry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The parent #GstToc of @entry</doc>
          <type name="Toc" c:type="GstToc*"/>
        </return-value>
      </method>
      <method name="get_uid" c:identifier="gst_toc_entry_get_uid">
        <doc xml:whitespace="preserve">Gets the UID of @entry.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The UID of @entry</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
      </method>
      <method name="is_alternative"
              c:identifier="gst_toc_entry_is_alternative">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @entry's type is an alternative type, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="is_sequence" c:identifier="gst_toc_entry_is_sequence">
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if @entry's type is a sequence type, otherwise %FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="merge_tags" c:identifier="gst_toc_entry_merge_tags">
        <doc xml:whitespace="preserve">Merge @tags into the existing tags of @entry using @mode.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tags" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">A #GstTagList or %NULL</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GstTagMergeMode</doc>
            <type name="TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_start_stop_times"
              c:identifier="gst_toc_entry_set_start_stop_times">
        <doc xml:whitespace="preserve">Set @start and @stop values for the @entry.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="start" transfer-ownership="none">
            <doc xml:whitespace="preserve">start value to set.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:whitespace="preserve">stop value to set.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tags" c:identifier="gst_toc_entry_set_tags">
        <doc xml:whitespace="preserve">Set a #GstTagList with tags for the complete @entry.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="tags" transfer-ownership="full" allow-none="1">
            <doc xml:whitespace="preserve">A #GstTagList or %NULL</doc>
            <type name="TagList" c:type="GstTagList*"/>
          </parameter>
        </parameters>
      </method>
      <function name="type_get_nick"
                c:identifier="gst_toc_entry_type_get_nick">
        <doc xml:whitespace="preserve">Converts @type to a string representation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Returns a human-readable string for @type. This string is only for debugging purpose and should not be displayed in a user interface.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GstTocEntryType.</doc>
            <type name="TocEntryType" c:type="GstTocEntryType"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="TocEntryType" c:type="GstTocEntryType">
      <doc xml:whitespace="preserve">The different types of TOC entries (see #GstTocEntry).

There are two types of TOC entries: alternatives or parts in a sequence.</doc>
      <member name="angle" value="-3" c:identifier="GST_TOC_ENTRY_TYPE_ANGLE">
        <doc xml:whitespace="preserve">entry is an angle (i.e. an alternative)</doc>
      </member>
      <member name="version"
              value="-2"
              c:identifier="GST_TOC_ENTRY_TYPE_VERSION">
        <doc xml:whitespace="preserve">entry is a version (i.e. alternative)</doc>
      </member>
      <member name="edition"
              value="-1"
              c:identifier="GST_TOC_ENTRY_TYPE_EDITION">
        <doc xml:whitespace="preserve">entry is an edition (i.e. alternative)</doc>
      </member>
      <member name="invalid"
              value="0"
              c:identifier="GST_TOC_ENTRY_TYPE_INVALID">
        <doc xml:whitespace="preserve">invalid entry type value</doc>
      </member>
      <member name="title" value="1" c:identifier="GST_TOC_ENTRY_TYPE_TITLE">
        <doc xml:whitespace="preserve">entry is a title (i.e. a part of a sequence)</doc>
      </member>
      <member name="track" value="2" c:identifier="GST_TOC_ENTRY_TYPE_TRACK">
        <doc xml:whitespace="preserve">entry is a track (i.e. a part of a sequence)</doc>
      </member>
      <member name="chapter"
              value="3"
              c:identifier="GST_TOC_ENTRY_TYPE_CHAPTER">
        <doc xml:whitespace="preserve">entry is a chapter (i.e. a part of a sequence)</doc>
      </member>
    </enumeration>
    <enumeration name="TocScope" c:type="GstTocScope">
      <doc xml:whitespace="preserve">The scope of a TOC.</doc>
      <member name="global" value="1" c:identifier="GST_TOC_SCOPE_GLOBAL">
        <doc xml:whitespace="preserve">global TOC representing all selectable options (this is what applications are usually interested in)</doc>
      </member>
      <member name="current" value="2" c:identifier="GST_TOC_SCOPE_CURRENT">
        <doc xml:whitespace="preserve">TOC for the currently active/selected stream (this is a TOC representing the current stream from start to EOS, and is what a TOC writer / muxer is usually interested in; it will usually be a subset of the global TOC, e.g. just the chapters of the current title, or the chapters selected for playback from the current title)</doc>
      </member>
    </enumeration>
    <interface name="TocSetter"
               c:symbol-prefix="toc_setter"
               c:type="GstTocSetter"
               glib:type-name="GstTocSetter"
               glib:get-type="gst_toc_setter_get_type"
               glib:type-struct="TocSetterInterface">
      <doc xml:whitespace="preserve">Element interface that allows setting of the TOC.

Elements that support some kind of chapters or editions (or tracks like in
the FLAC cue sheet) will implement this interface.

If you just want to retrieve the TOC in your application then all you
need to do is watch for TOC messages on your pipeline's bus (or you can
perform TOC query). This interface is only for setting TOC data, not for
extracting it. To set TOC from the application, find proper tocsetter element
and set TOC using gst_toc_setter_set_toc().

Elements implementing the #GstTocSetter interface can extend existing TOC
by getting extend UID for that (you can use gst_toc_find_entry() to retrieve it)
with any TOC entries received from downstream.</doc>
      <prerequisite name="Element"/>
      <method name="get_toc" c:identifier="gst_toc_setter_get_toc">
        <doc xml:whitespace="preserve">Return current TOC the setter uses. The TOC should not be
modified without making it writable first.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">TOC set, or NULL. Unref with gst_toc_unref() when no longer needed</doc>
          <type name="Toc" c:type="GstToc*"/>
        </return-value>
      </method>
      <method name="reset" c:identifier="gst_toc_setter_reset">
        <doc xml:whitespace="preserve">Reset the internal TOC. Elements should call this from within the
state-change handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="set_toc" c:identifier="gst_toc_setter_set_toc">
        <doc xml:whitespace="preserve">Set the given TOC on the setter. Previously setted TOC will be
unrefed before setting a new one.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="toc" transfer-ownership="none" allow-none="1">
            <doc xml:whitespace="preserve">a #GstToc to set.</doc>
            <type name="Toc" c:type="GstToc*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="TocSetterInterface"
            c:type="GstTocSetterInterface"
            glib:is-gtype-struct-for="TocSetter">
      <doc xml:whitespace="preserve">#GstTocSetterInterface interface.</doc>
      <field name="g_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <record name="TypeFind" c:type="GstTypeFind">
      <doc xml:whitespace="preserve">The following functions allow you to detect the media type of an unknown
stream.

Last reviewed on 2005-11-09 (0.9.4)</doc>
      <field name="peek">
        <callback name="peek">
          <return-value transfer-ownership="none">
            <type name="guint8" c:type="const guint8*"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="suggest">
        <callback name="suggest">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="probability" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="get_length">
        <callback name="get_length">
          <return-value transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </return-value>
          <parameters>
            <parameter name="data" transfer-ownership="none">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="get_length" c:identifier="gst_type_find_get_length">
        <doc xml:whitespace="preserve">Get the length of the data stream.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The length of the data stream, or 0 if it is not available.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
      </method>
      <method name="peek" c:identifier="gst_type_find_peek">
        <doc xml:whitespace="preserve">Returns the @size bytes of the stream to identify beginning at offset. If
offset is a positive number, the offset is relative to the beginning of the
stream, if offset is a negative number the offset is relative to the end of
the stream. The returned memory is valid until the typefinding function
returns and must not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the requested data, or NULL if that data is not available.</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:whitespace="preserve">The offset</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The number of bytes to return</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="suggest" c:identifier="gst_type_find_suggest">
        <doc xml:whitespace="preserve">If a #GstTypeFindFunction calls this function it suggests the caps with the
given probability. A #GstTypeFindFunction may supply different suggestions
in one call.
It is up to the caller of the #GstTypeFindFunction to interpret these values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="probability" transfer-ownership="none">
            <doc xml:whitespace="preserve">The probability in percent that the suggestion is right</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">The fixed #GstCaps to suggest</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="suggest_simple"
              c:identifier="gst_type_find_suggest_simple"
              introspectable="0">
        <doc xml:whitespace="preserve">If a #GstTypeFindFunction calls this function it suggests the caps with the
given probability. A #GstTypeFindFunction may supply different suggestions
in one call. It is up to the caller of the #GstTypeFindFunction to interpret
these values.

This function is similar to gst_type_find_suggest(), only that instead of
passing a #GstCaps argument you can create the caps on the fly in the same
way as you can with gst_caps_new_simple().

Make sure you terminate the list of arguments with a NULL argument and that
the values passed have the correct type (in terms of width in bytes when
passed to the vararg function - this applies particularly to gdouble and
guint64 arguments).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="probability" transfer-ownership="none">
            <doc xml:whitespace="preserve">The probability in percent that the suggestion is right</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the media type of the suggested caps</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="fieldname" transfer-ownership="none">
            <doc xml:whitespace="preserve">first field of the suggested caps, or NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <function name="register" c:identifier="gst_type_find_register">
        <doc xml:whitespace="preserve">Registers a new typefind function to be used for typefinding. After
registering this function will be available for typefinding.
This function is typically called during an element's plugin initialization.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE on success, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="plugin" transfer-ownership="none">
            <doc xml:whitespace="preserve">A #GstPlugin, or NULL for a static typefind function</doc>
            <type name="Plugin" c:type="GstPlugin*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name for registering</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="rank" transfer-ownership="none">
            <doc xml:whitespace="preserve">The rank (or importance) of this typefind function</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="6"
                     destroy="7">
            <doc xml:whitespace="preserve">The #GstTypeFindFunction to use</doc>
            <type name="TypeFindFunction" c:type="GstTypeFindFunction"/>
          </parameter>
          <parameter name="extensions"
                     transfer-ownership="none"
                     allow-none="1">
            <doc xml:whitespace="preserve">Optional comma-separated list of extensions that could belong to this type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="possible_caps" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optionally the caps that could be returned when typefinding succeeds</doc>
            <type name="Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">Optional user data. This user data must be available until the plugin is unloaded.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="data_notify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">a #GDestroyNotify that will be called on @data when the plugin is unloaded.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="TypeFindFactory"
           c:symbol-prefix="type_find_factory"
           c:type="GstTypeFindFactory"
           parent="PluginFeature"
           glib:type-name="GstTypeFindFactory"
           glib:get-type="gst_type_find_factory_get_type"
           glib:type-struct="TypeFindFactoryClass">
      <doc xml:whitespace="preserve">These functions allow querying informations about registered typefind
functions. How to create and register these functions is described in
the section &lt;link linkend="gstreamer-Writing-typefind-functions"&gt;
"Writing typefind functions"&lt;/link&gt;.

&lt;example&gt;
  &lt;title&gt;how to write a simple typefinder&lt;/title&gt;
  &lt;programlisting&gt;
  typedef struct {
    guint8 *data;
    guint size;
    guint probability;
    GstCaps *data;
  } MyTypeFind;
  static void
  my_peek (gpointer data, gint64 offset, guint size)
  {
    MyTypeFind *find = (MyTypeFind *) data;
    if (offset &amp;gt;= 0 &amp;amp;&amp;amp; offset + size &amp;lt;= find-&gt;size) {
      return find-&gt;data + offset;
    }
    return NULL;
  }
  static void
  my_suggest (gpointer data, guint probability, GstCaps *caps)
  {
    MyTypeFind *find = (MyTypeFind *) data;
    if (probability &amp;gt; find-&gt;probability) {
      find-&gt;probability = probability;
      gst_caps_replace (&amp;amp;find-&gt;caps, caps);
    }
  }
  static GstCaps *
  find_type (guint8 *data, guint size)
  {
    GList *walk, *type_list;
    MyTypeFind find = {data, size, 0, NULL};
    GstTypeFind gst_find = {my_peek, my_suggest, &amp;amp;find, };
    walk = type_list = gst_type_find_factory_get_list ();
    while (walk) {
      GstTypeFindFactory *factory = GST_TYPE_FIND_FACTORY (walk-&gt;data);
      walk = g_list_next (walk)
      gst_type_find_factory_call_function (factory, &amp;amp;gst_find);
    }
    g_list_free (type_list);
    return find.caps;
  };
  &lt;/programlisting&gt;
&lt;/example&gt;

The above example shows how to write a very simple typefinder that
identifies the given data. You can get quite a bit more complicated than
that though.

Last reviewed on 2005-11-09 (0.9.4)</doc>
      <function name="get_list" c:identifier="gst_type_find_factory_get_list">
        <doc xml:whitespace="preserve">Gets the list of all registered typefind factories. You must free the
list using gst_plugin_feature_list_free().

The returned factories are sorted by highest rank first, and then by
factory name.

Free-function: gst_plugin_feature_list_free</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the list of all registered #GstTypeFindFactory.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="TypeFindFactory"/>
          </type>
        </return-value>
      </function>
      <method name="call_function"
              c:identifier="gst_type_find_factory_call_function">
        <doc xml:whitespace="preserve">Calls the #GstTypeFindFunction associated with this factory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="find" transfer-ownership="none">
            <doc xml:whitespace="preserve">a properly setup #GstTypeFind entry. The get_data and suggest_type members must be set.</doc>
            <type name="TypeFind" c:type="GstTypeFind*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_caps" c:identifier="gst_type_find_factory_get_caps">
        <doc xml:whitespace="preserve">Gets the #GstCaps associated with a typefind factory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstCaps associated with this factory</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </return-value>
      </method>
      <method name="get_extensions"
              c:identifier="gst_type_find_factory_get_extensions">
        <doc xml:whitespace="preserve">Gets the extensions associated with a #GstTypeFindFactory. The returned
array should not be changed. If you need to change stuff in it, you should
copy it using g_strdupv().  This function may return NULL to indicate
a 0-length list.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">a NULL-terminated array of extensions associated with this factory</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="has_function"
              c:identifier="gst_type_find_factory_has_function">
        <doc xml:whitespace="preserve">Check whether the factory has a typefind function. Typefind factories
without typefind functions are a last-effort fallback mechanism to
e.g. assume a certain media type based on the file extension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the factory has a typefind functions set, otherwise FALSE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
    </class>
    <record name="TypeFindFactoryClass"
            c:type="GstTypeFindFactoryClass"
            disguised="1"
            glib:is-gtype-struct-for="TypeFindFactory">
    </record>
    <callback name="TypeFindFunction" c:type="GstTypeFindFunction">
      <doc xml:whitespace="preserve">A function that will be called by typefinding.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="find" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstTypeFind structure</doc>
          <type name="TypeFind" c:type="GstTypeFind*"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" closure="1">
          <doc xml:whitespace="preserve">optionnal data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TypeFindProbability" c:type="GstTypeFindProbability">
      <doc xml:whitespace="preserve">The probability of the typefind function. Higher values have more certainty
in doing a reliable typefind.</doc>
      <member name="none" value="0" c:identifier="GST_TYPE_FIND_NONE">
        <doc xml:whitespace="preserve">type undetected.</doc>
      </member>
      <member name="minimum" value="1" c:identifier="GST_TYPE_FIND_MINIMUM">
        <doc xml:whitespace="preserve">unlikely typefind.</doc>
      </member>
      <member name="possible" value="50" c:identifier="GST_TYPE_FIND_POSSIBLE">
        <doc xml:whitespace="preserve">possible type detected.</doc>
      </member>
      <member name="likely" value="80" c:identifier="GST_TYPE_FIND_LIKELY">
        <doc xml:whitespace="preserve">likely a type was detected.</doc>
      </member>
      <member name="nearly_certain"
              value="99"
              c:identifier="GST_TYPE_FIND_NEARLY_CERTAIN">
        <doc xml:whitespace="preserve">nearly certain that a type was detected.</doc>
      </member>
      <member name="maximum" value="100" c:identifier="GST_TYPE_FIND_MAXIMUM">
        <doc xml:whitespace="preserve">very certain a type was detected.</doc>
      </member>
    </enumeration>
    <enumeration name="URIError"
                 c:type="GstURIError"
                 glib:error-domain="gst-uri-error-quark">
      <doc xml:whitespace="preserve">Different URI-related errors that can occur.</doc>
      <member name="unsupported_protocol"
              value="0"
              c:identifier="GST_URI_ERROR_UNSUPPORTED_PROTOCOL">
        <doc xml:whitespace="preserve">The protocol is not supported</doc>
      </member>
      <member name="bad_uri" value="1" c:identifier="GST_URI_ERROR_BAD_URI">
        <doc xml:whitespace="preserve">There was a problem with the URI</doc>
      </member>
      <member name="bad_state"
              value="2"
              c:identifier="GST_URI_ERROR_BAD_STATE">
        <doc xml:whitespace="preserve">Could not set or change the URI because the URI handler was in a state where that is not possible or not permitted</doc>
      </member>
      <member name="bad_reference"
              value="3"
              c:identifier="GST_URI_ERROR_BAD_REFERENCE">
        <doc xml:whitespace="preserve">There was a problem with the entity that the URI references</doc>
      </member>
    </enumeration>
    <interface name="URIHandler"
               c:symbol-prefix="uri_handler"
               c:type="GstURIHandler"
               glib:type-name="GstURIHandler"
               glib:get-type="gst_uri_handler_get_type"
               glib:type-struct="URIHandlerInterface">
      <doc xml:whitespace="preserve">The URIHandler is an interface that is implemented by Source and Sink
#GstElement to simplify then handling of URI.

An application can use the following functions to quickly get an element
that handles the given URI for reading or writing
(gst_element_make_from_uri()).

Source and Sink plugins should implement this interface when possible.

Last reviewed on 2005-11-09 (0.9.4)</doc>
      <virtual-method name="get_uri" invoker="get_uri">
        <doc xml:whitespace="preserve">Gets the currently handled URI.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the URI currently handled by the @handler. Returns NULL if there are no URI currently handled. The returned string must be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="set_uri" invoker="set_uri" throws="1">
        <doc xml:whitespace="preserve">Tries to set the URI of the given handler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the URI was set successfully, else FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">URI to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_protocols"
              c:identifier="gst_uri_handler_get_protocols">
        <doc xml:whitespace="preserve">Gets the list of protocols supported by @handler. This list may not be
modified.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the supported protocols. Returns NULL if the @handler isn't implemented properly, or the @handler doesn't support any protocols.</doc>
          <array c:type="const gchar* const*">
            <type name="utf8"/>
          </array>
        </return-value>
      </method>
      <method name="get_uri" c:identifier="gst_uri_handler_get_uri">
        <doc xml:whitespace="preserve">Gets the currently handled URI.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the URI currently handled by the @handler. Returns NULL if there are no URI currently handled. The returned string must be freed with g_free() when no longer needed.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_uri_type" c:identifier="gst_uri_handler_get_uri_type">
        <doc xml:whitespace="preserve">Gets the type of the given URI handler</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GstURIType of the URI handler. Returns #GST_URI_UNKNOWN if the @handler isn't implemented correctly.</doc>
          <type name="URIType" c:type="GstURIType"/>
        </return-value>
      </method>
      <method name="set_uri" c:identifier="gst_uri_handler_set_uri" throws="1">
        <doc xml:whitespace="preserve">Tries to set the URI of the given handler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the URI was set successfully, else FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">URI to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="URIHandlerInterface"
            c:type="GstURIHandlerInterface"
            glib:is-gtype-struct-for="URIHandler">
      <doc xml:whitespace="preserve">Any #GstElement using this interface should implement these methods.</doc>
      <field name="parent">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="get_type">
        <callback name="get_type">
          <return-value transfer-ownership="none">
            <type name="URIType" c:type="GstURIType"/>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_protocols">
        <callback name="get_protocols">
          <return-value transfer-ownership="none">
            <array c:type="const gchar* const*">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="type" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_uri">
        <callback name="get_uri">
          <return-value transfer-ownership="full">
            <doc xml:whitespace="preserve">the URI currently handled by the @handler. Returns NULL if there are no URI currently handled. The returned string must be freed with g_free() when no longer needed.</doc>
            <type name="utf8" c:type="gchar*"/>
          </return-value>
          <parameters>
            <parameter name="handler" transfer-ownership="none">
              <type name="URIHandler" c:type="GstURIHandler*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_uri">
        <callback name="set_uri" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the URI was set successfully, else FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="handler" transfer-ownership="none">
              <type name="URIHandler" c:type="GstURIHandler*"/>
            </parameter>
            <parameter name="uri" transfer-ownership="none">
              <doc xml:whitespace="preserve">URI to set</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="URIType" c:type="GstURIType">
      <doc xml:whitespace="preserve">The different types of URI direction.</doc>
      <member name="unknown" value="0" c:identifier="GST_URI_UNKNOWN">
        <doc xml:whitespace="preserve">The URI direction is unknown</doc>
      </member>
      <member name="sink" value="1" c:identifier="GST_URI_SINK">
        <doc xml:whitespace="preserve">The URI is a consumer.</doc>
      </member>
      <member name="src" value="2" c:identifier="GST_URI_SRC">
        <doc xml:whitespace="preserve">The URI is a producer.</doc>
      </member>
    </enumeration>
    <constant name="USECOND" value="1000" c:type="GST_USECOND">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_EQUAL" value="0" c:type="GST_VALUE_EQUAL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_GREATER_THAN"
              value="1"
              c:type="GST_VALUE_GREATER_THAN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_LESS_THAN" value="-1" c:type="GST_VALUE_LESS_THAN">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="VALUE_UNORDERED" value="2" c:type="GST_VALUE_UNORDERED">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="ValueArray"
           c:symbol-prefix="value_array"
           c:type="GstValueArray"
           glib:type-name="GstValueArray"
           glib:get-type="gst_value_array_get_type"
           glib:fundamental="1">
      <function name="append_value"
                c:identifier="gst_value_array_append_value">
        <doc xml:whitespace="preserve">Appends @append_value to the GstValueArray in @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="append_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to append</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_size" c:identifier="gst_value_array_get_size">
        <doc xml:whitespace="preserve">Gets the number of values contained in @value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of values</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_value" c:identifier="gst_value_array_get_value">
        <doc xml:whitespace="preserve">Gets the value that is a member of the array contained in @value and
has the index @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value at the given index</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of value to get from the array</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="prepend_value"
                c:identifier="gst_value_array_prepend_value">
        <doc xml:whitespace="preserve">Prepends @prepend_value to the GstValueArray in @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_ARRAY</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="prepend_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to prepend</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <callback name="ValueCompareFunc" c:type="GstValueCompareFunc">
      <doc xml:whitespace="preserve">Used together with gst_value_compare() to compare #GValue items.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">one of GST_VALUE_LESS_THAN, GST_VALUE_EQUAL, GST_VALUE_GREATER_THAN or GST_VALUE_UNORDERED</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">first value for comparison</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">second value for comparison</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ValueDeserializeFunc" c:type="GstValueDeserializeFunc">
      <doc xml:whitespace="preserve">Used by gst_value_deserialize() to parse a non-binary form into the #GValue.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE for success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="s" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ValueList"
           c:symbol-prefix="value_list"
           glib:type-name="GstValueList"
           glib:get-type="gst_value_list_get_type"
           glib:fundamental="1">
      <function name="append_value" c:identifier="gst_value_list_append_value">
        <doc xml:whitespace="preserve">Appends @append_value to the GstValueList in @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="append_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to append</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
      <function name="concat" c:identifier="gst_value_list_concat">
        <doc xml:whitespace="preserve">Concatenates copies of @value1 and @value2 into a list.  Values that are not
of type #GST_TYPE_LIST are treated as if they were lists of length 1.
@dest will be initialized to the type #GST_TYPE_LIST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">an uninitialized #GValue to take the result</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="value1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="value2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_size" c:identifier="gst_value_list_get_size">
        <doc xml:whitespace="preserve">Gets the number of values contained in @value.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the number of values</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_value" c:identifier="gst_value_list_get_value">
        <doc xml:whitespace="preserve">Gets the value that is a member of the list contained in @value and
has the index @index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value at the given index</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:whitespace="preserve">index of value to get from the list</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="merge" c:identifier="gst_value_list_merge">
        <doc xml:whitespace="preserve">Merges copies of @value1 and @value2.  Values that are not
of type #GST_TYPE_LIST are treated as if they were lists of length 1.

The result will be put into @dest and will either be a list that will not
contain any duplicates, or a non-list type (if @value1 and @value2
were equal).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:whitespace="preserve">an uninitialized #GValue to take the result</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="value1" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
          <parameter name="value2" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
      <function name="prepend_value"
                c:identifier="gst_value_list_prepend_value">
        <doc xml:whitespace="preserve">Prepends @prepend_value to the GstValueList in @value.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">a #GValue of type #GST_TYPE_LIST</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="prepend_value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value to prepend</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <callback name="ValueSerializeFunc" c:type="GstValueSerializeFunc">
      <doc xml:whitespace="preserve">Used by gst_value_serialize() to obtain a non-binary form of the #GValue.

Free-function: g_free</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the string representation of the value</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ValueTable" c:type="GstValueTable">
      <doc xml:whitespace="preserve">VTable for the #GValue @type.</doc>
      <field name="type" writable="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="compare" writable="1">
        <type name="ValueCompareFunc" c:type="GstValueCompareFunc"/>
      </field>
      <field name="serialize" writable="1">
        <type name="ValueSerializeFunc" c:type="GstValueSerializeFunc"/>
      </field>
      <field name="deserialize" writable="1">
        <type name="ValueDeserializeFunc" c:type="GstValueDeserializeFunc"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <function name="caps_from_string"
              c:identifier="gst_caps_from_string"
              moved-to="Caps.from_string">
      <doc xml:whitespace="preserve">Converts @caps from a string representation.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated #GstCaps</doc>
        <type name="Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string to convert to #GstCaps</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="core_error_quark" c:identifier="gst_core_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="debug_add_log_function"
              c:identifier="gst_debug_add_log_function">
      <doc xml:whitespace="preserve">Adds the logging function to the list of logging functions.
Be sure to use #G_GNUC_NO_INSTRUMENT on that function, it is needed.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="notified"
                   closure="1"
                   destroy="2">
          <doc xml:whitespace="preserve">the function to use</doc>
          <type name="LogFunction" c:type="GstLogFunction"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">called when @user_data is not used anymore</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_bin_to_dot_file"
              c:identifier="gst_debug_bin_to_dot_file">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bin" transfer-ownership="none">
          <type name="Bin" c:type="GstBin*"/>
        </parameter>
        <parameter name="details" transfer-ownership="none">
          <type name="DebugGraphDetails" c:type="GstDebugGraphDetails"/>
        </parameter>
        <parameter name="file_name" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_bin_to_dot_file_with_ts"
              c:identifier="gst_debug_bin_to_dot_file_with_ts">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="bin" transfer-ownership="none">
          <type name="Bin" c:type="GstBin*"/>
        </parameter>
        <parameter name="details" transfer-ownership="none">
          <type name="DebugGraphDetails" c:type="GstDebugGraphDetails"/>
        </parameter>
        <parameter name="file_name" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_construct_term_color"
              c:identifier="gst_debug_construct_term_color">
      <doc xml:whitespace="preserve">Constructs a string that can be used for getting the desired color in color
terminals.
You need to free the string after use.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a string containing the color definition</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="colorinfo" transfer-ownership="none">
          <doc xml:whitespace="preserve">the color info</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_construct_win_color"
              c:identifier="gst_debug_construct_win_color">
      <doc xml:whitespace="preserve">Constructs an integer that can be used for getting the desired color in
windows' terminals (cmd.exe). As there is no mean to underline, we simply
ignore this attribute.

This function returns 0 on non-windows machines.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">an integer containing the color definition</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="colorinfo" transfer-ownership="none">
          <doc xml:whitespace="preserve">the color info</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_get_all_categories"
              c:identifier="gst_debug_get_all_categories">
      <doc xml:whitespace="preserve">Returns a snapshot of a all categories that are currently in use . This list
may change anytime.
The caller has to free the list after use.</doc>
      <return-value transfer-ownership="container">
        <doc xml:whitespace="preserve">the list of debug categories</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="DebugCategory"/>
        </type>
      </return-value>
    </function>
    <function name="debug_get_default_threshold"
              c:identifier="gst_debug_get_default_threshold">
      <doc xml:whitespace="preserve">Returns the default threshold that is used for new categories.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the default threshold level</doc>
        <type name="DebugLevel" c:type="GstDebugLevel"/>
      </return-value>
    </function>
    <function name="debug_is_active" c:identifier="gst_debug_is_active">
      <doc xml:whitespace="preserve">Checks if debugging output is activated.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if debugging is activated</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="debug_is_colored" c:identifier="gst_debug_is_colored">
      <doc xml:whitespace="preserve">Checks if the debugging output should be colored.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if the debug output should be colored.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="debug_level_get_name"
              c:identifier="gst_debug_level_get_name">
      <doc xml:whitespace="preserve">Get the string representation of a debugging level</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the name</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">the level to get the name for</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_log" c:identifier="gst_debug_log" introspectable="0">
      <doc xml:whitespace="preserve">Logs the given message using the currently registered debugging handlers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">category to log</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level of the message is in</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">the file that emitted the message, usually the __FILE__ identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function that emitted the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">the line from that the message was emitted, usually __LINE__</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the object this message relates to, or NULL if none</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a printf style format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter transfer-ownership="none">
          <varargs>
          </varargs>
        </parameter>
      </parameters>
    </function>
    <function name="debug_log_default" c:identifier="gst_debug_log_default">
      <doc xml:whitespace="preserve">The default logging handler used by GStreamer. Logging functions get called
whenever a macro like GST_DEBUG or similar is used. This function outputs the
message and additional info to stderr (or the log file specified via the
GST_DEBUG_FILE environment variable).

You can add other handlers by using gst_debug_add_log_function().
And you can remove this handler by calling
gst_debug_remove_log_function(gst_debug_log_default);</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">category to log</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level of the message</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">the file that emitted the message, usually the __FILE__ identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function that emitted the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">the line from that the message was emitted, usually __LINE__</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the object this message relates to, or NULL if none</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:whitespace="preserve">the actual message</doc>
          <type name="DebugMessage" c:type="GstDebugMessage*"/>
        </parameter>
        <parameter name="unused" transfer-ownership="none">
          <doc xml:whitespace="preserve">an unused variable, reserved for some user_data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_log_valist"
              c:identifier="gst_debug_log_valist"
              introspectable="0">
      <doc xml:whitespace="preserve">Logs the given message using the currently registered debugging handlers.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="category" transfer-ownership="none">
          <doc xml:whitespace="preserve">category to log</doc>
          <type name="DebugCategory" c:type="GstDebugCategory*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level of the message is in</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
        <parameter name="file" transfer-ownership="none">
          <doc xml:whitespace="preserve">the file that emitted the message, usually the __FILE__ identifier</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="function" transfer-ownership="none">
          <doc xml:whitespace="preserve">the function that emitted the message</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="line" transfer-ownership="none">
          <doc xml:whitespace="preserve">the line from that the message was emitted, usually __LINE__</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="object" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">the object this message relates to, or NULL if none</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a printf style format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:whitespace="preserve">optional arguments for the format</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_print_stack_trace"
              c:identifier="gst_debug_print_stack_trace">
      <doc xml:whitespace="preserve">If GST_ENABLE_FUNC_INSTRUMENTATION is defined a stacktrace is available for
gstreamer code, which can be printed with this function.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="debug_remove_log_function"
              c:identifier="gst_debug_remove_log_function">
      <doc xml:whitespace="preserve">Removes all registered instances of the given logging functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">How many instances of the function were removed</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:whitespace="preserve">the log function to remove</doc>
          <type name="LogFunction" c:type="GstLogFunction"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_remove_log_function_by_data"
              c:identifier="gst_debug_remove_log_function_by_data">
      <doc xml:whitespace="preserve">Removes all registered instances of log functions with the given user data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">How many instances of the function were removed</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">user data of the log function to remove</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_active" c:identifier="gst_debug_set_active">
      <doc xml:whitespace="preserve">If activated, debugging messages are sent to the debugging
handlers.
It makes sense to deactivate it for speed issues.
&lt;note&gt;&lt;para&gt;This function is not threadsafe. It makes sense to only call it
during initialization.&lt;/para&gt;&lt;/note&gt;</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="active" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to use debugging output or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_colored" c:identifier="gst_debug_set_colored">
      <doc xml:whitespace="preserve">Sets or unsets the use of coloured debugging output.

This function may be called before gst_init().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="colored" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to use colored output or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_default_threshold"
              c:identifier="gst_debug_set_default_threshold">
      <doc xml:whitespace="preserve">Sets the default threshold to the given level and updates all categories to
use this threshold.

This function may be called before gst_init().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level to set</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_set_threshold_for_name"
              c:identifier="gst_debug_set_threshold_for_name">
      <doc xml:whitespace="preserve">Sets all categories which match the given glob style pattern to the given
level.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the categories to set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:whitespace="preserve">level to set them to</doc>
          <type name="DebugLevel" c:type="GstDebugLevel"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_unset_threshold_for_name"
              c:identifier="gst_debug_unset_threshold_for_name">
      <doc xml:whitespace="preserve">Resets all categories with the given name back to the default level.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the categories to set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="deinit" c:identifier="gst_deinit">
      <doc xml:whitespace="preserve">Clean up any resources created by GStreamer in gst_init().

It is normally not needed to call this function in a normal application
as the resources will automatically be freed when the program terminates.
This function is therefore mostly used by testsuites and other memory
profiling tools.

After this call GStreamer (including this method) should not be used anymore.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="error_get_message" c:identifier="gst_error_get_message">
      <doc xml:whitespace="preserve">Get a string describing the error message in the current locale.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated string describing the error message (in UTF-8 encoding)</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:whitespace="preserve">the GStreamer error domain this error belongs to.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:whitespace="preserve">the error code belonging to the domain.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="event_type_get_flags"
              c:identifier="gst_event_type_get_flags"
              moved-to="Event.type_get_flags">
      <doc xml:whitespace="preserve">Gets the #GstEventTypeFlags associated with @type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GstEventTypeFlags.</doc>
        <type name="EventTypeFlags" c:type="GstEventTypeFlags"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstEventType</doc>
          <type name="EventType" c:type="GstEventType"/>
        </parameter>
      </parameters>
    </function>
    <function name="event_type_get_name"
              c:identifier="gst_event_type_get_name"
              moved-to="Event.type_get_name">
      <doc xml:whitespace="preserve">Get a printable name for the given event type. Do not modify or free.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a reference to the static name of the event.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the event type</doc>
          <type name="EventType" c:type="GstEventType"/>
        </parameter>
      </parameters>
    </function>
    <function name="event_type_to_quark"
              c:identifier="gst_event_type_to_quark"
              moved-to="Event.type_to_quark">
      <doc xml:whitespace="preserve">Get the unique quark for the given event type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark associated with the event type</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the event type</doc>
          <type name="EventType" c:type="GstEventType"/>
        </parameter>
      </parameters>
    </function>
    <function name="filename_to_uri"
              c:identifier="gst_filename_to_uri"
              throws="1">
      <doc xml:whitespace="preserve">Similar to g_filename_to_uri(), but attempts to handle relative file paths
as well. Before converting @filename into an URI, it will be prefixed by
the current working directory if it is a relative path, and then the path
will be canonicalised so that it doesn't contain any './' or '../' segments.

On Windows #filename should be in UTF-8 encoding.</doc>
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:whitespace="preserve">absolute or relative file name path</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="flow_get_name" c:identifier="gst_flow_get_name">
      <doc xml:whitespace="preserve">Gets a string representing the given flow return.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a static string with the name of the flow return.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn to get the name of.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </parameter>
      </parameters>
    </function>
    <function name="flow_to_quark" c:identifier="gst_flow_to_quark">
      <doc xml:whitespace="preserve">Get the unique quark for the given GstFlowReturn.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark associated with the flow return or 0 if an invalid return was specified.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="ret" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFlowReturn to get the quark of.</doc>
          <type name="FlowReturn" c:type="GstFlowReturn"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_by_nick" c:identifier="gst_format_get_by_nick">
      <doc xml:whitespace="preserve">Return the format registered with the given nick.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The format with @nick or GST_FORMAT_UNDEFINED if the format was not registered.</doc>
        <type name="Format" c:type="GstFormat"/>
      </return-value>
      <parameters>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">The nick of the format</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_details" c:identifier="gst_format_get_details">
      <doc xml:whitespace="preserve">Get details about the given format.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The #GstFormatDefinition for @format or NULL on failure.  MT safe.</doc>
        <type name="FormatDefinition" c:type="const GstFormatDefinition*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">The format to get details of</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_name" c:identifier="gst_format_get_name">
      <doc xml:whitespace="preserve">Get a printable name for the given format. Do not modify or free.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a reference to the static name of the format or NULL if the format is unknown.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFormat</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_iterate_definitions"
              c:identifier="gst_format_iterate_definitions">
      <doc xml:whitespace="preserve">Iterate all the registered formats. The format definition is read
only.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a GstIterator of #GstFormatDefinition.</doc>
        <type name="Iterator" c:type="GstIterator*"/>
      </return-value>
    </function>
    <function name="format_register" c:identifier="gst_format_register">
      <doc xml:whitespace="preserve">Create a new GstFormat based on the nick or return an
already registered format with that nick.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A new GstFormat or an already registered format with the same nick.  MT safe.</doc>
        <type name="Format" c:type="GstFormat"/>
      </return-value>
      <parameters>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">The nick of the new format</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="description" transfer-ownership="none">
          <doc xml:whitespace="preserve">The description of the new format</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_to_quark" c:identifier="gst_format_to_quark">
      <doc xml:whitespace="preserve">Get the unique quark for the given format.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark associated with the format or 0 if the format is unknown.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstFormat</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="formats_contains" c:identifier="gst_formats_contains">
      <doc xml:whitespace="preserve">See if the given format is inside the format array.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the format is found inside the array</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="formats" transfer-ownership="none">
          <doc xml:whitespace="preserve">The format array to search</doc>
          <array c:type="GstFormat*">
            <type name="Format" c:type="GstFormat"/>
          </array>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:whitespace="preserve">the format to find</doc>
          <type name="Format" c:type="GstFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="gst_init">
      <doc xml:whitespace="preserve">Initializes the GStreamer library, setting up internal path lists,
registering built-in elements, and loading standard plugins.

Unless the plugin registry is disabled at compile time, the registry will be
loaded. By default this will also check if the registry cache needs to be
updated and rescan all plugins if needed. See gst_update_registry() for
details and section
&lt;link linkend="gst-running"&gt;Running GStreamer Applications&lt;/link&gt;
for how to disable automatic registry updates.

&lt;note&gt;&lt;para&gt;
This function will terminate your program if it was unable to initialize
GStreamer for some reason.  If you want your program to fall back,
use gst_init_check() instead.
&lt;/para&gt;&lt;/note&gt;

WARNING: This function does not work in the same way as corresponding
functions in other glib-style libraries, such as gtk_init().  In
particular, unknown command line options cause this function to
abort program execution.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="argc"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argc</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="argv"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argv</doc>
          <array length="0" zero-terminated="0" c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="init_check" c:identifier="gst_init_check" throws="1">
      <doc xml:whitespace="preserve">Initializes the GStreamer library, setting up internal path lists,
registering built-in elements, and loading standard plugins.

This function will return %FALSE if GStreamer could not be initialized
for some reason.  If you want your program to fail fatally,
use gst_init() instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if GStreamer could be initialized.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="argc"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argc</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="argv"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to application's argv</doc>
          <array length="0" zero-terminated="0" c:type="char**">
            <type name="utf8" c:type="char*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="init_get_option_group"
              c:identifier="gst_init_get_option_group"
              introspectable="0">
      <doc xml:whitespace="preserve">Returns a #GOptionGroup with GStreamer's argument specifications. The
group is set up to use standard GOption callbacks, so when using this
group in combination with GOption parsing methods, all argument parsing
and initialization is automated.

This function is useful if you want to integrate GStreamer with other
libraries that use GOption (see g_option_context_add_group() ).

If you use this function, you should make sure you initialise the GLib
threading system as one of the very first things in your program
(see the example at the beginning of this section).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a pointer to GStreamer's option group.</doc>
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="is_initialized" c:identifier="gst_is_initialized">
      <doc xml:whitespace="preserve">Use this function to check if GStreamer has been initialized with gst_init()
or gst_init_check().</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if initialization has been done, FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="library_error_quark"
              c:identifier="gst_library_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="message_type_get_name"
              c:identifier="gst_message_type_get_name"
              moved-to="Message.type_get_name">
      <doc xml:whitespace="preserve">Get a printable name for the given message type. Do not modify or free.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a reference to the static name of the message.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message type</doc>
          <type name="MessageType" c:type="GstMessageType"/>
        </parameter>
      </parameters>
    </function>
    <function name="message_type_to_quark"
              c:identifier="gst_message_type_to_quark"
              moved-to="Message.type_to_quark">
      <doc xml:whitespace="preserve">Get the unique quark for the given message type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark associated with the message type</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the message type</doc>
          <type name="MessageType" c:type="GstMessageType"/>
        </parameter>
      </parameters>
    </function>
    <function name="meta_api_type_has_tag"
              c:identifier="gst_meta_api_type_has_tag"
              moved-to="Meta.api_type_has_tag">
      <doc xml:whitespace="preserve">Check if @api was registered with @tag.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if @api was registered with @tag.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="api" transfer-ownership="none">
          <doc xml:whitespace="preserve">an API</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag to check</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </parameter>
      </parameters>
    </function>
    <function name="meta_api_type_register"
              c:identifier="gst_meta_api_type_register"
              moved-to="Meta.api_type_register">
      <doc xml:whitespace="preserve">Register and return a GType for the @api and associate it with
@tags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a unique GType for @api.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="api" transfer-ownership="none">
          <doc xml:whitespace="preserve">an API to register</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="tags" transfer-ownership="none">
          <doc xml:whitespace="preserve">tags for @api</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="meta_get_info"
              c:identifier="gst_meta_get_info"
              moved-to="Meta.get_info">
      <doc xml:whitespace="preserve">Lookup a previously registered meta info structure by its implementation name
@impl.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GstMetaInfo with @impl, or #NULL when no such metainfo exists.</doc>
        <type name="MetaInfo" c:type="const GstMetaInfo*"/>
      </return-value>
      <parameters>
        <parameter name="impl" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="meta_register"
              c:identifier="gst_meta_register"
              moved-to="Meta.register">
      <doc xml:whitespace="preserve">Register a new #GstMeta implementation.

The same @info can be retrieved later with gst_meta_get_info() by using
@impl as the key.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GstMetaInfo that can be used to access metadata.</doc>
        <type name="MetaInfo" c:type="const GstMetaInfo*"/>
      </return-value>
      <parameters>
        <parameter name="api" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type of the #GstMeta API</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="impl" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the #GstMeta implementation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the #GstMeta structure</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="init_func" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">a #GstMetaInitFunction</doc>
          <type name="MetaInitFunction" c:type="GstMetaInitFunction"/>
        </parameter>
        <parameter name="free_func" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">a #GstMetaFreeFunction</doc>
          <type name="MetaFreeFunction" c:type="GstMetaFreeFunction"/>
        </parameter>
        <parameter name="transform_func"
                   transfer-ownership="none"
                   scope="async">
          <doc xml:whitespace="preserve">a #GstMetaTransformFunction</doc>
          <type name="MetaTransformFunction"
                c:type="GstMetaTransformFunction"/>
        </parameter>
      </parameters>
    </function>
    <function name="mini_object_replace"
              c:identifier="gst_mini_object_replace"
              moved-to="MiniObject.replace">
      <doc xml:whitespace="preserve">Atomically modifies a pointer to point to a new mini-object.
The reference count of @olddata is decreased and the reference count of
@newdata is increased.

Either @newdata and the value pointed to by @olddata may be NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if @newdata was different from @olddata</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="olddata"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a pointer to a mini-object to be replaced</doc>
          <type name="MiniObject" c:type="GstMiniObject**"/>
        </parameter>
        <parameter name="newdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to new mini-object</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="mini_object_take"
              c:identifier="gst_mini_object_take"
              moved-to="MiniObject.take">
      <doc xml:whitespace="preserve">Modifies a pointer to point to a new mini-object. The modification
is done atomically. This version is similar to gst_mini_object_replace()
except that it does not increase the refcount of @newdata and thus
takes ownership of @newdata.

Either @newdata and the value pointed to by @olddata may be NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if @newdata was different from @olddata</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="olddata"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a pointer to a mini-object to be replaced</doc>
          <type name="MiniObject" c:type="GstMiniObject**"/>
        </parameter>
        <parameter name="newdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to new mini-object</doc>
          <type name="MiniObject" c:type="GstMiniObject*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_fraction"
              c:identifier="gst_param_spec_fraction">
      <doc xml:whitespace="preserve">This function creates a fraction GParamSpec for use by objects/elements
that want to expose properties of fraction type. This function is typically
used in connection with g_object_class_install_property() in a GObjects's
instance_init function.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="min_num" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value (fraction numerator)</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="min_denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">minimum value (fraction denominator)</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="max_num" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value (fraction numerator)</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="max_denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">maximum value (fraction denominator)</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="default_num" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value (fraction numerator)</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="default_denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">default value (fraction denominator)</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_bin_from_description"
              c:identifier="gst_parse_bin_from_description"
              throws="1">
      <doc xml:whitespace="preserve">This is a convenience wrapper around gst_parse_launch() to create a
#GstBin from a gst-launch-style pipeline description. See
gst_parse_launch() and the gst-launch man page for details about the
syntax. Ghost pads on the bin for unlinked source or sink pads
within the bin can automatically be created (but only a maximum of
one ghost pad for each direction will be created; if you expect
multiple unlinked source pads or multiple unlinked sink pads
and want them all ghosted, you will have to create the ghost pads
yourself).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a newly-created bin, or %NULL if an error occurred.</doc>
        <type name="Bin" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="bin_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">command line describing the bin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="ghost_unlinked_pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether to automatically create ghost pads for unlinked source or sink pads within the bin</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_bin_from_description_full"
              c:identifier="gst_parse_bin_from_description_full"
              throws="1">
      <doc xml:whitespace="preserve">This is a convenience wrapper around gst_parse_launch() to create a
#GstBin from a gst-launch-style pipeline description. See
gst_parse_launch() and the gst-launch man page for details about the
syntax. Ghost pads on the bin for unlinked source or sink pads
within the bin can automatically be created (but only a maximum of
one ghost pad for each direction will be created; if you expect
multiple unlinked source pads or multiple unlinked sink pads
and want them all ghosted, you will have to create the ghost pads
yourself).</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly-created bin, or %NULL if an error occurred.</doc>
        <type name="Bin" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="bin_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">command line describing the bin</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="ghost_unlinked_pads" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether to automatically create ghost pads for unlinked source or sink pads within the bin</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="context" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a parse context allocated with gst_parse_context_new(), or %NULL</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">parsing options, or #GST_PARSE_FLAG_NONE</doc>
          <type name="ParseFlags" c:type="GstParseFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_error_quark" c:identifier="gst_parse_error_quark">
      <doc xml:whitespace="preserve">Get the error quark used by the parsing subsystem.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark of the parse errors.</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="parse_launch" c:identifier="gst_parse_launch" throws="1">
      <doc xml:whitespace="preserve">Create a new pipeline based on command line syntax.
Please note that you might get a return value that is not %NULL even though
the @error is set. In this case there was a recoverable parsing error and you
can try to play the pipeline.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a new element on success, %NULL on failure. If more than one toplevel element is specified by the @pipeline_description, all elements are put into a #GstPipeline, which than is returned.</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="pipeline_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">the command line describing the pipeline</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_launch_full"
              c:identifier="gst_parse_launch_full"
              throws="1">
      <doc xml:whitespace="preserve">Create a new pipeline based on command line syntax.
Please note that you might get a return value that is not %NULL even though
the @error is set. In this case there was a recoverable parsing error and you
can try to play the pipeline.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new element on success, %NULL on failure. If more than one toplevel element is specified by the @pipeline_description, all elements are put into a #GstPipeline, which then is returned.</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="pipeline_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">the command line describing the pipeline</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="context" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a parse context allocated with gst_parse_context_new(), or %NULL</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">parsing options, or #GST_PARSE_FLAG_NONE</doc>
          <type name="ParseFlags" c:type="GstParseFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_launchv" c:identifier="gst_parse_launchv" throws="1">
      <doc xml:whitespace="preserve">Create a new element based on command line syntax.
@error will contain an error message if an erroneuos pipeline is specified.
An error does not mean that the pipeline could not be constructed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new element on success and %NULL on failure.</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:whitespace="preserve">null-terminated array of arguments</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="parse_launchv_full"
              c:identifier="gst_parse_launchv_full"
              throws="1">
      <doc xml:whitespace="preserve">Create a new element based on command line syntax.
@error will contain an error message if an erroneous pipeline is specified.
An error does not mean that the pipeline could not be constructed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new element on success; on failure, either %NULL or a partially-constructed bin or element will be returned and @error will be set (unless you passed #GST_PARSE_FLAG_FATAL_ERRORS in @flags, then %NULL will always be returned on failure)</doc>
        <type name="Element" c:type="GstElement*"/>
      </return-value>
      <parameters>
        <parameter name="argv" transfer-ownership="none">
          <doc xml:whitespace="preserve">null-terminated array of arguments</doc>
          <array c:type="gchar**">
            <type name="utf8" c:type="gchar*"/>
          </array>
        </parameter>
        <parameter name="context" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">a parse context allocated with gst_parse_context_new(), or %NULL</doc>
          <type name="ParseContext" c:type="GstParseContext*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">parsing options, or #GST_PARSE_FLAG_NONE</doc>
          <type name="ParseFlags" c:type="GstParseFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_new"
              c:identifier="gst_poll_new"
              moved-to="Poll.new"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new file descriptor set. If @controllable, it
is possible to restart or flush a call to gst_poll_wait() with
gst_poll_restart() and gst_poll_set_flushing() respectively.

Free-function: gst_poll_free</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstPoll, or %NULL in case of an error. Free with gst_poll_free().</doc>
        <type name="Poll" c:type="GstPoll*"/>
      </return-value>
      <parameters>
        <parameter name="controllable" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether it should be possible to control a wait.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_new_timer"
              c:identifier="gst_poll_new_timer"
              moved-to="Poll.new_timer"
              introspectable="0">
      <doc xml:whitespace="preserve">Create a new poll object that can be used for scheduling cancellable
timeouts.

A timeout is performed with gst_poll_wait(). Multiple timeouts can be
performed from different threads. 

Free-function: gst_poll_free</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstPoll, or %NULL in case of an error. Free with gst_poll_free().</doc>
        <type name="Poll" c:type="GstPoll*"/>
      </return-value>
    </function>
    <function name="preset_get_app_dir"
              c:identifier="gst_preset_get_app_dir"
              moved-to="Preset.get_app_dir">
      <doc xml:whitespace="preserve">Gets the directory for application specific presets if set by the
application.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the directory or %NULL, don't free or modify the string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
    </function>
    <function name="preset_set_app_dir"
              c:identifier="gst_preset_set_app_dir"
              moved-to="Preset.set_app_dir">
      <doc xml:whitespace="preserve">Sets an extra directory as an absolute path that should be considered when
looking for presets. Any presets in the application dir will shadow the 
system presets.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE for success, %FALSE if the dir already has been set</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="app_dir" transfer-ownership="none">
          <doc xml:whitespace="preserve">the application specific preset dir</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="query_type_get_flags"
              c:identifier="gst_query_type_get_flags"
              moved-to="Query.type_get_flags">
      <doc xml:whitespace="preserve">Gets the #GstQueryTypeFlags associated with @type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a #GstQueryTypeFlags.</doc>
        <type name="QueryTypeFlags" c:type="GstQueryTypeFlags"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstQueryType</doc>
          <type name="QueryType" c:type="GstQueryType"/>
        </parameter>
      </parameters>
    </function>
    <function name="query_type_get_name"
              c:identifier="gst_query_type_get_name"
              moved-to="Query.type_get_name">
      <doc xml:whitespace="preserve">Get a printable name for the given query type. Do not modify or free.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">a reference to the static name of the query.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the query type</doc>
          <type name="QueryType" c:type="GstQueryType"/>
        </parameter>
      </parameters>
    </function>
    <function name="query_type_to_quark"
              c:identifier="gst_query_type_to_quark"
              moved-to="Query.type_to_quark">
      <doc xml:whitespace="preserve">Get the unique quark for the given query type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the quark associated with the query type</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the query type</doc>
          <type name="QueryType" c:type="GstQueryType"/>
        </parameter>
      </parameters>
    </function>
    <function name="resource_error_quark"
              c:identifier="gst_resource_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="segtrap_is_enabled" c:identifier="gst_segtrap_is_enabled">
      <doc xml:whitespace="preserve">Some functions in the GStreamer core might install a custom SIGSEGV handler
to better catch and report errors to the application. Currently this feature
is enabled by default when loading plugins.

Applications might want to disable this behaviour with the
gst_segtrap_set_enabled() function. This is typically done if the application
wants to install its own handler without GStreamer interfering.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if GStreamer is allowed to install a custom SIGSEGV handler.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="segtrap_set_enabled"
              c:identifier="gst_segtrap_set_enabled">
      <doc xml:whitespace="preserve">Applications might want to disable/enable the SIGSEGV handling of
the GStreamer core. See gst_segtrap_is_enabled() for more information.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="enabled" transfer-ownership="none">
          <doc xml:whitespace="preserve">whether a custom SIGSEGV handler should be installed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="static_caps_get_type"
              c:identifier="gst_static_caps_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="static_pad_template_get_type"
              c:identifier="gst_static_pad_template_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="stream_error_quark" c:identifier="gst_stream_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="structure_from_string"
              c:identifier="gst_structure_from_string"
              moved-to="Structure.from_string">
      <doc xml:whitespace="preserve">Creates a #GstStructure from a string representation.
If end is not NULL, a pointer to the place inside the given string
where parsing ended will be returned.

Free-function: gst_structure_free</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new #GstStructure or NULL when the string could not be parsed. Free with gst_structure_free() after use.</doc>
        <type name="Structure" c:type="GstStructure*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">a string representation of a #GstStructure.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="end"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none"
                   allow-none="1">
          <doc xml:whitespace="preserve">pointer to store the end of the string in.</doc>
          <type name="utf8" c:type="gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_exists" c:identifier="gst_tag_exists">
      <doc xml:whitespace="preserve">Checks if the given type is already registered.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the type is already registered</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of the tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_description"
              c:identifier="gst_tag_get_description">
      <doc xml:whitespace="preserve">Returns the human-readable description of this tag, You must not change or
free this string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the human-readable description of this tag</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_flag" c:identifier="gst_tag_get_flag">
      <doc xml:whitespace="preserve">Gets the flag of @tag.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the flag of this tag.</doc>
        <type name="TagFlag" c:type="GstTagFlag"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_nick" c:identifier="gst_tag_get_nick">
      <doc xml:whitespace="preserve">Returns the human-readable name of this tag, You must not change or free
this string.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the human-readable name of this tag</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_get_type" c:identifier="gst_tag_get_type">
      <doc xml:whitespace="preserve">Gets the #GType used for this tag.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the #GType of this tag</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">the tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_is_fixed" c:identifier="gst_tag_is_fixed">
      <doc xml:whitespace="preserve">Checks if the given tag is fixed. A fixed tag can only contain one value.
Unfixed tags can contain lists of values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if the given tag is fixed.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">tag to check</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_list_copy_value"
              c:identifier="gst_tag_list_copy_value"
              moved-to="TagList.copy_value">
      <doc xml:whitespace="preserve">Copies the contents for the given tag into the value,
merging multiple values into one if multiple values are associated
with the tag.
You must g_value_unset() the value after use.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE, if a value was copied, FALSE if the tag didn't exist in the given list.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">uninitialized #GValue to copy into</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="list" transfer-ownership="none">
          <doc xml:whitespace="preserve">list to get the tag from</doc>
          <type name="TagList" c:type="const GstTagList*"/>
        </parameter>
        <parameter name="tag" transfer-ownership="none">
          <doc xml:whitespace="preserve">tag to read out</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_merge_strings_with_comma"
              c:identifier="gst_tag_merge_strings_with_comma">
      <doc xml:whitespace="preserve">This is a convenience function for the func argument of gst_tag_register().
It concatenates all given strings using a comma. The tag must be registered
as a G_TYPE_STRING or this function will fail.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">uninitialized GValue to store result in</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to copy from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_merge_use_first"
              c:identifier="gst_tag_merge_use_first">
      <doc xml:whitespace="preserve">This is a convenience function for the func argument of gst_tag_register().
It creates a copy of the first value from the list.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">uninitialized GValue to store result in</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">GValue to copy from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_register"
              c:identifier="gst_tag_register"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers a new tag type for the use with GStreamer's type system. If a type
with that name is already registered, that one is used.
The old registration may have used a different type however. So don't rely
on your supplied values.

Important: if you do not supply a merge function the implication will be
that there can only be one single value for this tag in a tag list and
any additional values will silenty be discarded when being added (unless
#GST_TAG_MERGE_REPLACE, #GST_TAG_MERGE_REPLACE_ALL, or
#GST_TAG_MERGE_PREPEND is used as merge mode, in which case the new
value will replace the old one in the list).

The merge function will be called from gst_tag_list_copy_value() when
it is required that one or more values for a tag be condensed into
one single value. This may happen from gst_tag_list_get_string(),
gst_tag_list_get_int(), gst_tag_list_get_double() etc. What will happen
exactly in that case depends on how the tag was registered and if a
merge function was supplied and if so which one.

Two default merge functions are provided: gst_tag_merge_use_first() and
gst_tag_merge_strings_with_comma().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name or identifier string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flag" transfer-ownership="none">
          <doc xml:whitespace="preserve">a flag describing the type of tag info</doc>
          <type name="TagFlag" c:type="GstTagFlag"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type this data is in</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">human-readable name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">a human-readable description about this tag</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">function for merging multiple values of this tag, or NULL</doc>
          <type name="TagMergeFunc" c:type="GstTagMergeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="tag_register_static"
              c:identifier="gst_tag_register_static"
              introspectable="0">
      <doc xml:whitespace="preserve">Registers a new tag type for the use with GStreamer's type system.

Same as gst_tag_register(), but @name, @nick, and @blurb must be
static strings or inlined strings, as they will not be copied. (GStreamer
plugins will be made resident once loaded, so this function can be used
even from dynamically loaded plugins.)</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name or identifier string (string constant)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flag" transfer-ownership="none">
          <doc xml:whitespace="preserve">a flag describing the type of tag info</doc>
          <type name="TagFlag" c:type="GstTagFlag"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">the type this data is in</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:whitespace="preserve">human-readable name or short description (string constant)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:whitespace="preserve">a human-readable description for this tag (string constant)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none">
          <doc xml:whitespace="preserve">function for merging multiple values of this tag, or NULL</doc>
          <type name="TagMergeFunc" c:type="GstTagMergeFunc"/>
        </parameter>
      </parameters>
    </function>
    <function name="toc_entry_type_get_nick"
              c:identifier="gst_toc_entry_type_get_nick"
              moved-to="TocEntry.type_get_nick">
      <doc xml:whitespace="preserve">Converts @type to a string representation.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Returns a human-readable string for @type. This string is only for debugging purpose and should not be displayed in a user interface.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GstTocEntryType.</doc>
          <type name="TocEntryType" c:type="GstTocEntryType"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_get_type" c:identifier="gst_type_find_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="type_find_register"
              c:identifier="gst_type_find_register"
              moved-to="TypeFind.register">
      <doc xml:whitespace="preserve">Registers a new typefind function to be used for typefinding. After
registering this function will be available for typefinding.
This function is typically called during an element's plugin initialization.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE on success, FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="plugin" transfer-ownership="none">
          <doc xml:whitespace="preserve">A #GstPlugin, or NULL for a static typefind function</doc>
          <type name="Plugin" c:type="GstPlugin*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">The name for registering</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="rank" transfer-ownership="none">
          <doc xml:whitespace="preserve">The rank (or importance) of this typefind function</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="notified"
                   closure="6"
                   destroy="7">
          <doc xml:whitespace="preserve">The #GstTypeFindFunction to use</doc>
          <type name="TypeFindFunction" c:type="GstTypeFindFunction"/>
        </parameter>
        <parameter name="extensions" transfer-ownership="none" allow-none="1">
          <doc xml:whitespace="preserve">Optional comma-separated list of extensions that could belong to this type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="possible_caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optionally the caps that could be returned when typefinding succeeds</doc>
          <type name="Caps" c:type="GstCaps*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">Optional user data. This user data must be available until the plugin is unloaded.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="data_notify" transfer-ownership="none" scope="async">
          <doc xml:whitespace="preserve">a #GDestroyNotify that will be called on @data when the plugin is unloaded.</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="update_registry" c:identifier="gst_update_registry">
      <doc xml:whitespace="preserve">Forces GStreamer to re-scan its plugin paths and update the default
plugin registry.

Applications will almost never need to call this function, it is only
useful if the application knows new plugins have been installed (or old
ones removed) since the start of the application (or, to be precise, the
first call to gst_init()) and the application wants to make use of any
newly-installed plugins without restarting the application.

Applications should assume that the registry update is neither atomic nor
thread-safe and should therefore not have any dynamic pipelines running
(including the playbin and decodebin elements) and should also not create
any elements or access the GStreamer registry while the update is in
progress.

Note that this function may block for a significant amount of time.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the registry has been updated successfully (does not imply that there were changes), otherwise %FALSE.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="uri_construct" c:identifier="gst_uri_construct">
      <doc xml:whitespace="preserve">Constructs a URI for a given valid protocol and location.

Free-function: g_free</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a new string for this URI. Returns NULL if the given URI protocol is not valid, or the given location is NULL.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">Protocol for URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="location" transfer-ownership="none">
          <doc xml:whitespace="preserve">Location for URI</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_error_quark" c:identifier="gst_uri_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="uri_get_location" c:identifier="gst_uri_get_location">
      <doc xml:whitespace="preserve">Extracts the location out of a given valid URI, ie. the protocol and "://"
are stripped from the URI, which means that the location returned includes
the hostname if one is specified. The returned string must be freed using
g_free().

Free-function: g_free</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the location for this URI. Returns NULL if the URI isn't valid. If the URI does not contain a location, an empty string is returned.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">A URI string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_get_protocol" c:identifier="gst_uri_get_protocol">
      <doc xml:whitespace="preserve">Extracts the protocol out of a given valid URI. The returned string must be
freed using g_free().</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">The protocol for this URI.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">A URI string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_has_protocol" c:identifier="gst_uri_has_protocol">
      <doc xml:whitespace="preserve">Checks if the protocol of a given valid URI matches @protocol.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the protocol matches.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">a URI string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">a protocol string (e.g. "http")</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_is_valid" c:identifier="gst_uri_is_valid">
      <doc xml:whitespace="preserve">Tests if the given string is a valid URI identifier. URIs start with a valid
scheme followed by ":" and maybe a string identifying the location.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the string is a valid URI</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">A URI string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_protocol_is_supported"
              c:identifier="gst_uri_protocol_is_supported">
      <doc xml:whitespace="preserve">Checks if an element exists that supports the given URI protocol. Note
that a positive return value does not imply that a subsequent call to
gst_element_make_from_uri() is guaranteed to work.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:whitespace="preserve">Whether to check for a source or a sink</doc>
          <type name="URIType" c:type="const GstURIType"/>
        </parameter>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">Protocol that should be checked for (e.g. "http" or "smb")</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_protocol_is_valid"
              c:identifier="gst_uri_protocol_is_valid">
      <doc xml:whitespace="preserve">Tests if the given string is a valid protocol identifier. Protocols
must consist of alphanumeric characters, '+', '-' and '.' and must
start with a alphabetic character. See RFC 3986 Section 3.1.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the string is a valid protocol identifier, FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="protocol" transfer-ownership="none">
          <doc xml:whitespace="preserve">A string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_array_binary_search"
              c:identifier="gst_util_array_binary_search">
      <doc xml:whitespace="preserve">Searches inside @array for @search_data by using the comparison function
@search_func. @array must be sorted ascending.

As @search_data is always passed as second argument to @search_func it's
not required that @search_data has the same type as the array elements.

The complexity of this search function is O(log (num_elements)).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The address of the found element or %NULL if nothing was found</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="array" transfer-ownership="none">
          <doc xml:whitespace="preserve">the sorted input array</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="num_elements" transfer-ownership="none">
          <doc xml:whitespace="preserve">number of elements in the array</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="element_size" transfer-ownership="none">
          <doc xml:whitespace="preserve">size of every element in bytes</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="search_func"
                   transfer-ownership="none"
                   scope="call"
                   closure="6">
          <doc xml:whitespace="preserve">function to compare two elements, @search_data will always be passed as second argument</doc>
          <type name="GLib.CompareDataFunc" c:type="GCompareDataFunc"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:whitespace="preserve">search mode that should be used</doc>
          <type name="SearchMode" c:type="GstSearchMode"/>
        </parameter>
        <parameter name="search_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">element that should be found</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data to pass to @search_func</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_double_to_fraction"
              c:identifier="gst_util_double_to_fraction">
      <doc xml:whitespace="preserve">Transforms a #gdouble to a fraction and simplifies
the result.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">#gdouble to transform</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="dest_n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a #gint to hold the result numerator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="dest_d"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a #gint to hold the result denominator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_dump_mem" c:identifier="gst_util_dump_mem">
      <doc xml:whitespace="preserve">Dumps the memory block into a hex representation. Useful for debugging.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to the memory to dump</doc>
          <type name="guint8" c:type="const guchar*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:whitespace="preserve">the size of the memory block to dump</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_add" c:identifier="gst_util_fraction_add">
      <doc xml:whitespace="preserve">Adds the fractions @a_n/@a_d and @b_n/@b_d and stores
the result in @res_n and @res_d.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE on overflow, %TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="a_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="res_n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result numerator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="res_d"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result denominator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_compare"
              c:identifier="gst_util_fraction_compare">
      <doc xml:whitespace="preserve">Compares the fractions @a_n/@a_d and @b_n/@b_d and returns
-1 if a &lt; b, 0 if a = b and 1 if a &gt; b.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">-1 if a &lt; b; 0 if a = b; 1 if a &gt; b.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="a_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_multiply"
              c:identifier="gst_util_fraction_multiply">
      <doc xml:whitespace="preserve">Multiplies the fractions @a_n/@a_d and @b_n/@b_d and stores
the result in @res_n and @res_d.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%FALSE on overflow, %TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="a_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="a_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of first value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Numerator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Denominator of second value</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="res_n"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result numerator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="res_d"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">Pointer to #gint to hold the result denominator</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_fraction_to_double"
              c:identifier="gst_util_fraction_to_double">
      <doc xml:whitespace="preserve">Transforms a fraction to a #gdouble.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="src_n" transfer-ownership="none">
          <doc xml:whitespace="preserve">Fraction numerator as #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="src_d" transfer-ownership="none">
          <doc xml:whitespace="preserve">Fraction denominator #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a #gdouble for the result</doc>
          <type name="gdouble" c:type="gdouble*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_gdouble_to_guint64"
              c:identifier="gst_util_gdouble_to_guint64">
      <return-value transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_get_timestamp" c:identifier="gst_util_get_timestamp">
      <doc xml:whitespace="preserve">Get a timestamp as GstClockTime to be used for interval measurements.
The timestamp should not be interpreted in any other way.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the timestamp</doc>
        <type name="ClockTime" c:type="GstClockTime"/>
      </return-value>
    </function>
    <function name="util_greatest_common_divisor"
              c:identifier="gst_util_greatest_common_divisor">
      <doc xml:whitespace="preserve">Calculates the greatest common divisor of @a
and @b.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Greatest common divisor of @a and @b</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">First value as #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">Second value as #gint</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_greatest_common_divisor_int64"
              c:identifier="gst_util_greatest_common_divisor_int64">
      <doc xml:whitespace="preserve">Calculates the greatest common divisor of @a
and @b.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">Greatest common divisor of @a and @b</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:whitespace="preserve">First value as #gint64</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:whitespace="preserve">Second value as #gint64</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_guint64_to_gdouble"
              c:identifier="gst_util_guint64_to_gdouble">
      <return-value transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_seqnum_compare"
              c:identifier="gst_util_seqnum_compare">
      <doc xml:whitespace="preserve">Compare two sequence numbers, handling wraparound.

The current implementation just returns (gint32)(@s1 - @s2).</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A negative number if @s1 is before @s2, 0 if they are equal, or a positive number if @s1 is after @s2.</doc>
        <type name="gint32" c:type="gint32"/>
      </return-value>
      <parameters>
        <parameter name="s1" transfer-ownership="none">
          <doc xml:whitespace="preserve">A sequence number.</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="s2" transfer-ownership="none">
          <doc xml:whitespace="preserve">Another sequence number.</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_seqnum_next" c:identifier="gst_util_seqnum_next">
      <doc xml:whitespace="preserve">Return a constantly incrementing sequence number.

This function is used internally to GStreamer to be able to determine which
events and messages are "the same". For example, elements may set the seqnum
on a segment-done message to be the same as that of the last seek event, to
indicate that event and the message correspond to the same segment.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">A constantly incrementing 32-bit unsigned integer, which might overflow back to 0 at some point. Use gst_util_seqnum_compare() to make sure you handle wraparound correctly.</doc>
        <type name="guint32" c:type="guint32"/>
      </return-value>
    </function>
    <function name="util_set_object_arg"
              c:identifier="gst_util_set_object_arg">
      <doc xml:whitespace="preserve">Convertes the string value to the type of the objects argument and
sets the argument with it.

Note that this function silently returns if @object has no property named
@name or when @value cannot be converted to the type of the property.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the object to set the argument of</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the argument to set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the string value to set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_set_value_from_string"
              c:identifier="gst_util_set_value_from_string">
      <doc xml:whitespace="preserve">Converts the string to the type of the value and
sets the value with it.

Note that this function is dangerous as it does not return any indication
if the conversion worked or not.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to set</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value_str" transfer-ownership="none">
          <doc xml:whitespace="preserve">the string to get the value from</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale" c:identifier="gst_util_uint64_scale">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.

This function can potentially be very slow if val and num are both
greater than G_MAXUINT32.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this function returns G_MAXUINT64.  If the result is not exactly representable as an integer it is truncated.  See also gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil(), gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number to scale</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_ceil"
              c:identifier="gst_util_uint64_scale_ceil">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.

This function can potentially be very slow if val and num are both
greater than G_MAXUINT32.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this function returns G_MAXUINT64.  If the result is not exactly representable as an integer, it is rounded up.  See also gst_util_uint64_scale(), gst_util_uint64_scale_round(), gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number to scale</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_int"
              c:identifier="gst_util_uint64_scale_int">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.  @num must be non-negative and
@denom must be positive.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this function returns G_MAXUINT64.  If the result is not exactly representable as an integer, it is truncated.  See also gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil(), gst_util_uint64_scale(), gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 (such as a #GstClockTime) to scale.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">numerator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">denominator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_int_ceil"
              c:identifier="gst_util_uint64_scale_int_ceil">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.  @num must be non-negative and
@denom must be positive.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this function returns G_MAXUINT64.  If the result is not exactly representable as an integer, it is rounded up.  See also gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(), gst_util_uint64_scale(), gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 (such as a #GstClockTime) to scale.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">numerator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">denominator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_int_round"
              c:identifier="gst_util_uint64_scale_int_round">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.  @num must be non-negative and
@denom must be positive.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this function returns G_MAXUINT64.  If the result is not exactly representable as an integer, it is rounded to the nearest integer (half-way cases are rounded up).  See also gst_util_uint64_scale_int(), gst_util_uint64_scale_int_ceil(), gst_util_uint64_scale(), gst_util_uint64_scale_round(), gst_util_uint64_scale_ceil().</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">guint64 (such as a #GstClockTime) to scale.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">numerator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">denominator of the scale factor.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="util_uint64_scale_round"
              c:identifier="gst_util_uint64_scale_round">
      <doc xml:whitespace="preserve">Scale @val by the rational number @num / @denom, avoiding overflows and
underflows and without loss of precision.

This function can potentially be very slow if val and num are both
greater than G_MAXUINT32.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">@val * @num / @denom.  In the case of an overflow, this function returns G_MAXUINT64.  If the result is not exactly representable as an integer, it is rounded to the nearest integer (half-way cases are rounded up).  See also gst_util_uint64_scale(), gst_util_uint64_scale_ceil(), gst_util_uint64_scale_int(), gst_util_uint64_scale_int_round(), gst_util_uint64_scale_int_ceil().</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="val" transfer-ownership="none">
          <doc xml:whitespace="preserve">the number to scale</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="num" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="denom" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the scale ratio</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_compare" c:identifier="gst_value_can_compare">
      <doc xml:whitespace="preserve">Determines if @value1 and @value2 can be compared.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the values can be compared</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to compare</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to compare</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_intersect"
              c:identifier="gst_value_can_intersect">
      <doc xml:whitespace="preserve">Determines if intersecting two values will produce a valid result.
Two values will produce a valid intersection if they have the same
type, or if there is a method (registered by
gst_value_register_intersect_func()) to calculate the intersection.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the values can intersect</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to intersect</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to intersect</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_subtract" c:identifier="gst_value_can_subtract">
      <doc xml:whitespace="preserve">Checks if it's possible to subtract @subtrahend from @minuend.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if a subtraction is possible</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="minuend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="subtrahend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_can_union" c:identifier="gst_value_can_union">
      <doc xml:whitespace="preserve">Determines if @value1 and @value2 can be non-trivially unioned.
Any two values can be trivially unioned by adding both of them
to a GstValueList.  However, certain types have the possibility
to be unioned in a simpler way.  For example, an integer range
and an integer can be unioned if the integer is a subset of the
integer range.  If there is the possibility that two values can
be unioned, this function returns TRUE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if there is a function allowing the two values to be unioned.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to union</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to union</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_compare" c:identifier="gst_value_compare">
      <doc xml:whitespace="preserve">Compares @value1 and @value2.  If @value1 and @value2 cannot be
compared, the function returns GST_VALUE_UNORDERED.  Otherwise,
if @value1 is greater than @value2, GST_VALUE_GREATER_THAN is returned.
If @value1 is less than @value2, GST_VALUE_LESS_THAN is returned.
If the values are equal, GST_VALUE_EQUAL is returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">comparison result</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to compare</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to compare</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_deserialize" c:identifier="gst_value_deserialize">
      <doc xml:whitespace="preserve">Tries to deserialize a string into the type specified by the given GValue.
If the operation succeeds, TRUE is returned, FALSE otherwise.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE on success</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">#GValue to fill with contents of deserialization</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">string to deserialize</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_fixate" c:identifier="gst_value_fixate">
      <doc xml:whitespace="preserve">Fixate @src into a new value @dest.
For ranges, the first element is taken. For lists and arrays, the
first item is fixated and returned.
If @src is already fixed, this function returns FALSE.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">true if @dest contains a fixated version of @src.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue destination</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue to fixate</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_fraction_multiply"
              c:identifier="gst_value_fraction_multiply">
      <doc xml:whitespace="preserve">Multiplies the two #GValue items containing a #GST_TYPE_FRACTION and sets
@product to the product of the two fractions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">FALSE in case of an error (like integer overflow), TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="product" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="factor1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="factor2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_fraction_subtract"
              c:identifier="gst_value_fraction_subtract">
      <doc xml:whitespace="preserve">Subtracts the @subtrahend from the @minuend and sets @dest to the result.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">FALSE in case of an error (like integer overflow), TRUE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="minuend" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="subtrahend" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_bitmask" c:identifier="gst_value_get_bitmask">
      <doc xml:whitespace="preserve">Gets the bitmask specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the bitmask.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_caps" c:identifier="gst_value_get_caps">
      <doc xml:whitespace="preserve">Gets the contents of @value. The reference count of the returned
#GstCaps will not be modified, therefore the caller must take one
before getting rid of the @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the contents of @value</doc>
        <type name="Caps" c:type="const GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_CAPS</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_double_range_max"
              c:identifier="gst_value_get_double_range_max">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maxumum of the range</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DOUBLE_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_double_range_min"
              c:identifier="gst_value_get_double_range_min">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DOUBLE_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_denominator"
              c:identifier="gst_value_get_fraction_denominator">
      <doc xml:whitespace="preserve">Gets the denominator of the fraction specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the denominator of the fraction.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_numerator"
              c:identifier="gst_value_get_fraction_numerator">
      <doc xml:whitespace="preserve">Gets the numerator of the fraction specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the numerator of the fraction.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_range_max"
              c:identifier="gst_value_get_fraction_range_max">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maximum of the range</doc>
        <type name="GObject.Value" c:type="const GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_fraction_range_min"
              c:identifier="gst_value_get_fraction_range_min">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="GObject.Value" c:type="const GValue*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int64_range_max"
              c:identifier="gst_value_get_int64_range_max">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maxumum of the range</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int64_range_min"
              c:identifier="gst_value_get_int64_range_min">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int64_range_step"
              c:identifier="gst_value_get_int64_range_step">
      <doc xml:whitespace="preserve">Gets the step of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the step of the range</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int_range_max"
              c:identifier="gst_value_get_int_range_max">
      <doc xml:whitespace="preserve">Gets the maximum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the maxumum of the range</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int_range_min"
              c:identifier="gst_value_get_int_range_min">
      <doc xml:whitespace="preserve">Gets the minimum of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the minimum of the range</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_int_range_step"
              c:identifier="gst_value_get_int_range_step">
      <doc xml:whitespace="preserve">Gets the step of the range specified by @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the step of the range</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_get_structure"
              c:identifier="gst_value_get_structure">
      <doc xml:whitespace="preserve">Gets the contents of @value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">the contents of @value</doc>
        <type name="Structure" c:type="const GstStructure*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_STRUCTURE</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_init_and_copy"
              c:identifier="gst_value_init_and_copy">
      <doc xml:whitespace="preserve">Initialises the target value to be of the same type as source and then copies
the contents from source to target.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the target value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:whitespace="preserve">the source value</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_intersect" c:identifier="gst_value_intersect">
      <doc xml:whitespace="preserve">Calculates the intersection of two values.  If the values have
a non-empty intersection, the value representing the intersection
is placed in @dest, unless NULL.  If the intersection is non-empty,
@dest is not modified.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the intersection is non-empty</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">a uninitialized #GValue that will hold the calculated intersection value. May be NULL if the resulting set if not needed.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to intersect</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to intersect</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_is_fixed" c:identifier="gst_value_is_fixed">
      <doc xml:whitespace="preserve">Tests if the given GValue, if available in a GstStructure (or any other
container) contains a "fixed" (which means: one value) or an "unfixed"
(which means: multiple possible values, such as data lists or data
ranges) value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">true if the value is "fixed".</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #GValue to check</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_is_subset" c:identifier="gst_value_is_subset">
      <doc xml:whitespace="preserve">Check that @value1 is a subset of @value2.

Return: %TRUE is @value1 is a subset of @value2</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_register" c:identifier="gst_value_register">
      <doc xml:whitespace="preserve">Registers functions to perform calculations on #GValue items of a given
type. Each type can only be added once.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="table" transfer-ownership="none">
          <doc xml:whitespace="preserve">structure containing functions to register</doc>
          <type name="ValueTable" c:type="const GstValueTable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_serialize" c:identifier="gst_value_serialize">
      <doc xml:whitespace="preserve">tries to transform the given @value into a string representation that allows
getting back this string later on using gst_value_deserialize().

Free-function: g_free</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">the serialization for @value or NULL if none exists</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GValue to serialize</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_bitmask" c:identifier="gst_value_set_bitmask">
      <doc xml:whitespace="preserve">Sets @value to the bitmask specified by @bitmask.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="bitmask" transfer-ownership="none">
          <doc xml:whitespace="preserve">the bitmask</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_caps" c:identifier="gst_value_set_caps">
      <doc xml:whitespace="preserve">Sets the contents of @value to @caps. A reference to the
provided @caps will be taken by the @value.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_CAPS</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:whitespace="preserve">the caps to set the value to</doc>
          <type name="Caps" c:type="const GstCaps*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_double_range"
              c:identifier="gst_value_set_double_range">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_DOUBLE_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_fraction" c:identifier="gst_value_set_fraction">
      <doc xml:whitespace="preserve">Sets @value to the fraction specified by @numerator over @denominator.
The fraction gets reduced to the smallest numerator and denominator,
and if necessary the sign is moved to the numerator.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to #GST_TYPE_FRACTION</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="numerator" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator of the fraction</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denominator" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator of the fraction</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_fraction_range"
              c:identifier="gst_value_set_fraction_range">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range (a GST_TYPE_FRACTION GValue)</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range (a GST_TYPE_FRACTION GValue)</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_fraction_range_full"
              c:identifier="gst_value_set_fraction_range_full">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @numerator_start/@denominator_start
and @numerator_end/@denominator_end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_FRACTION_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="numerator_start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator start of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denominator_start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator start of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="numerator_end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the numerator end of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="denominator_end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the denominator end of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_int64_range"
              c:identifier="gst_value_set_int64_range">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_int64_range_step"
              c:identifier="gst_value_set_int64_range_step">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start, @end and @step.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT64_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
        <parameter name="step" transfer-ownership="none">
          <doc xml:whitespace="preserve">the step of the range</doc>
          <type name="gint64" c:type="gint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_int_range"
              c:identifier="gst_value_set_int_range">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start and @end.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_int_range_step"
              c:identifier="gst_value_set_int_range_step">
      <doc xml:whitespace="preserve">Sets @value to the range specified by @start, @end and @step.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_INT_RANGE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:whitespace="preserve">the start of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:whitespace="preserve">the end of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="step" transfer-ownership="none">
          <doc xml:whitespace="preserve">the step of the range</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_structure"
              c:identifier="gst_value_set_structure">
      <doc xml:whitespace="preserve">Sets the contents of @value to @structure.  The actual</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:whitespace="preserve">a GValue initialized to GST_TYPE_STRUCTURE</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="structure" transfer-ownership="none">
          <doc xml:whitespace="preserve">the structure to set the value to</doc>
          <type name="Structure" c:type="const GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_subtract" c:identifier="gst_value_subtract">
      <doc xml:whitespace="preserve">Subtracts @subtrahend from @minuend and stores the result in @dest.
Note that this means subtraction as in sets, not as in mathematics.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%TRUE if the subtraction is not empty</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the destination value for the result if the subtraction is not empty. May be NULL, in which case the resulting set will not be computed, which can give a fair speedup.</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="minuend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract from</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="subtrahend" transfer-ownership="none">
          <doc xml:whitespace="preserve">the value to subtract</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_union" c:identifier="gst_value_union">
      <doc xml:whitespace="preserve">Creates a GValue corresponding to the union of @value1 and @value2.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">TRUE if the union suceeded.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="dest"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:whitespace="preserve">the destination value</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="value1" transfer-ownership="none">
          <doc xml:whitespace="preserve">a value to union</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
        <parameter name="value2" transfer-ownership="none">
          <doc xml:whitespace="preserve">another value to union</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="version" c:identifier="gst_version">
      <doc xml:whitespace="preserve">Gets the version number of the GStreamer library.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="major"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the major version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="minor"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the minor version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="micro"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the micro version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
        <parameter name="nano"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:whitespace="preserve">pointer to a guint to store the nano version number</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="version_string" c:identifier="gst_version_string">
      <doc xml:whitespace="preserve">This function returns a string that is useful for describing this version
of GStreamer to the outside world: user agent strings, logging, ...</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">a newly allocated string describing this version of GStreamer.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
    </function>
  </namespace>
</repository>
