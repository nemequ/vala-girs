<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <package name="rest-0.7"/>
  <namespace name="Rest"
             version="0.7"
             shared-library="librest-0.7.so.0"
             c:identifier-prefixes="Rest"
             c:symbol-prefixes="rest">
    <enumeration name="MemoryUse" c:type="RestMemoryUse">
      <member name="static" value="0" c:identifier="REST_MEMORY_STATIC"/>
      <member name="take" value="1" c:identifier="REST_MEMORY_TAKE"/>
      <member name="copy" value="2" c:identifier="REST_MEMORY_COPY"/>
    </enumeration>
    <class name="OAuth2Proxy"
           c:symbol-prefix="oauth2_proxy"
           c:type="OAuth2Proxy"
           parent="Proxy"
           glib:type-name="OAuth2Proxy"
           glib:get-type="oauth2_proxy_get_type"
           glib:type-struct="OAuth2ProxyClass">
      <doc xml:whitespace="preserve">#OAuth2Proxy has no publicly available members.</doc>
      <constructor name="new" c:identifier="oauth2_proxy_new">
        <doc xml:whitespace="preserve">Create a new #OAuth2Proxy for the specified endpoint @url_format, using the
specified API key and secret.

This proxy won't have the Token set so will be unauthorised.  If the token is
unknown then the following steps should be taken to acquire an access token:
- Get the authentication url with oauth2_proxy_build_login_url()
- Display this url in an embedded browser widget
- wait for the browser widget to be redirected to the specified redirect_uri
- extract the token from the fragment of the redirected uri (using
convenience function oauth2_proxy_extract_access_token())
- set the token with oauth2_proxy_set_access_token()

Set @binding_required to %TRUE if the URL contains string formatting
operations (for example "http://foo.com/%&lt;!-- --&gt;s".  These must be expanded
using rest_proxy_bind() before invoking the proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #OAuth2Proxy.</doc>
          <type name="Proxy" c:type="RestProxy*"/>
        </return-value>
        <parameters>
          <parameter name="client_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the client (application) id</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="auth_endpoint" transfer-ownership="none">
            <doc xml:whitespace="preserve">the authentication endpoint URL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="url_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the endpoint URL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="binding_required" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the URL needs to be bound before calling</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_token"
                   c:identifier="oauth2_proxy_new_with_token">
        <doc xml:whitespace="preserve">Create a new #OAuth2Proxy for the specified endpoint @url_format, using the
specified client id

@access_token is used for the Access Token, so if they are still valid then
this proxy is authorised.

Set @binding_required to %TRUE if the URL contains string formatting
operations (for example "http://foo.com/%&lt;!-- --&gt;s".  These must be expanded
using rest_proxy_bind() before invoking the proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #OAuth2Proxy.</doc>
          <type name="Proxy" c:type="RestProxy*"/>
        </return-value>
        <parameters>
          <parameter name="client_id" transfer-ownership="none">
            <doc xml:whitespace="preserve">the client (application) id</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="access_token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the Access Token</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="auth_endpoint" transfer-ownership="none">
            <doc xml:whitespace="preserve">the authentication endpoint URL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="url_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the endpoint URL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="binding_required" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the URL needs to be bound before calling</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="extract_access_token"
                c:identifier="oauth2_proxy_extract_access_token">
        <doc xml:whitespace="preserve">A utility function to extract the access token from the url that results from
the redirection after the user authenticates</doc>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="url" transfer-ownership="none">
            <doc xml:whitespace="preserve">the url which contains an access token in its fragment</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="build_login_url"
              c:identifier="oauth2_proxy_build_login_url">
        <doc xml:whitespace="preserve">Builds a url at which the user can log in to the specified OAuth2-based web
service.  See the documentation for oauth2_proxy_build_login_url_full() for
detailed information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated uri string</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="redirect_uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the uri to redirect to after the user authenticates</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="build_login_url_full"
              c:identifier="oauth2_proxy_build_login_url_full">
        <doc xml:whitespace="preserve">Builds a url at which the user can log in to the specified OAuth2-based web
service.  In general, this url should be displayed in an embedded browser
widget, and you should then intercept the browser's redirect to @redirect_uri
and extract the access token from the url fragment. After the access token
has been retrieved, call oauth2_proxy_set_access_token().  This must be done
before making any API calls to the service.

See the oauth2 spec for more details about the "user-agent" authentication
flow.

The @extra_params and @redirect_uri should not be uri-encoded, that will be
done automatically</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a newly allocated uri string</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <parameter name="redirect_uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the uri to redirect to after the user authenticates</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="extra_params" transfer-ownership="none">
            <doc xml:whitespace="preserve">any extra parameters to add to the login url (e.g. facebook uses 'scope=foo,bar' to request extended permissions).</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="get_access_token"
              c:identifier="oauth2_proxy_get_access_token">
        <doc xml:whitespace="preserve">Get the current request or access token.

by #OAuth2Proxy and should not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the token, or %NULL if there is no token yet.  This string is owned</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="set_access_token"
              c:identifier="oauth2_proxy_set_access_token">
        <doc xml:whitespace="preserve">Set the access token.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="access_token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the access token</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="access-token" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="auth-endpoint"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="client-id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="RestProxy"/>
      </field>
      <field name="priv">
        <type name="OAuth2ProxyPrivate" c:type="OAuth2ProxyPrivate*"/>
      </field>
    </class>
    <class name="OAuth2ProxyCall"
           c:symbol-prefix="oauth2_proxy_call"
           c:type="OAuth2ProxyCall"
           parent="ProxyCall"
           glib:type-name="OAuth2ProxyCall"
           glib:get-type="oauth2_proxy_call_get_type"
           glib:type-struct="OAuth2ProxyCallClass">
      <doc xml:whitespace="preserve">#OAuth2ProxyCall has no publicly available members.</doc>
      <field name="parent">
        <type name="ProxyCall" c:type="RestProxyCall"/>
      </field>
    </class>
    <record name="OAuth2ProxyCallClass"
            c:type="OAuth2ProxyCallClass"
            glib:is-gtype-struct-for="OAuth2ProxyCall">
      <field name="parent_class">
        <type name="ProxyCallClass" c:type="RestProxyCallClass"/>
      </field>
      <field name="_padding_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="OAuth2ProxyClass"
            c:type="OAuth2ProxyClass"
            glib:is-gtype-struct-for="OAuth2Proxy">
      <field name="parent_class">
        <type name="ProxyClass" c:type="RestProxyClass"/>
      </field>
      <field name="_padding_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="OAuth2ProxyPrivate"
            c:type="OAuth2ProxyPrivate"
            disguised="1">
    </record>
    <class name="OAuthProxy"
           c:symbol-prefix="oauth_proxy"
           c:type="OAuthProxy"
           parent="Proxy"
           glib:type-name="OAuthProxy"
           glib:get-type="oauth_proxy_get_type"
           glib:type-struct="OAuthProxyClass">
      <doc xml:whitespace="preserve">#OAuthProxy has no publicly available members.</doc>
      <constructor name="new" c:identifier="oauth_proxy_new">
        <doc xml:whitespace="preserve">Create a new #OAuthProxy for the specified endpoint @url_format, using the
specified API key and secret.

This proxy won't have the Token or Token Secret set so as such will be
unauthorised.  If the tokens are unknown then oauth_proxy_request_token() and
oauth_proxy_access_token() should be called to do the OAuth authorisation, or
the tokens should be set using oauth_proxy_set_token() and
oauth_proxy_set_token_secret().

Set @binding_required to %TRUE if the URL contains string formatting
operations (for example "http://foo.com/%&lt;!-- --&gt;s".  These must be expanded
using rest_proxy_bind() before invoking the proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #OAuthProxy.</doc>
          <type name="Proxy" c:type="RestProxy*"/>
        </return-value>
        <parameters>
          <parameter name="consumer_key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the Consumer Key</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="consumer_secret" transfer-ownership="none">
            <doc xml:whitespace="preserve">the Consumer Secret</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="url_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the endpoint URL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="binding_required" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the URL needs to be bound before calling</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_token"
                   c:identifier="oauth_proxy_new_with_token">
        <doc xml:whitespace="preserve">Create a new #OAuthProxy for the specified endpoint @url_format, using the
specified API key and secret.

@token and @token_secret are used for the Access Token and Token Secret, so
if they are still valid then this proxy is authorised.

Set @binding_required to %TRUE if the URL contains string formatting
operations (for example "http://foo.com/%&lt;!-- --&gt;s".  These must be expanded
using rest_proxy_bind() before invoking the proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #OAuthProxy.</doc>
          <type name="Proxy" c:type="RestProxy*"/>
        </return-value>
        <parameters>
          <parameter name="consumer_key" transfer-ownership="none">
            <doc xml:whitespace="preserve">the Consumer Key</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="consumer_secret" transfer-ownership="none">
            <doc xml:whitespace="preserve">the Consumer Secret</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the Access Token</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="token_secret" transfer-ownership="none">
            <doc xml:whitespace="preserve">the Token Secret</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="url_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the endpoint URL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="binding_required" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the URL needs to be bound before calling</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="access_token"
              c:identifier="oauth_proxy_access_token"
              throws="1">
        <doc xml:whitespace="preserve">Perform the Access Token phase of OAuth, invoking @function (defaulting to
"access_token" if @function is NULL).

@verifier is only used if you are using OAuth 1.0a.  This is either the
"oauth_verifier" parameter that was passed to your callback URI, or a string
that the user enters in some other manner (for example in a popup dialog) if
"oob" was passed to oauth_proxy_request_token().  For OAuth 1.0, pass %NULL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, or %FALSE on failure. On failure @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the function name to invoke</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="verifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">the verifier</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="access_token_async"
              c:identifier="oauth_proxy_access_token_async"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Perform the Access Token phase of OAuth, invoking @function (defaulting to
"access_token" if @function is NULL).

@verifier is only used if you are using OAuth 1.0a.  This is either the
"oauth_verifier" parameter that was passed to your callback URI, or a string
that the user enters in some other manner (for example in a popup dialog) if
"oob" was passed to oauth_proxy_request_token().  For OAuth 1.0, pass %NULL.

This method will return once the method has been queued, @callback will be
invoked when it has completed.

failure. On failure @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the method was successfully queued, or %FALSE on</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the function name to invoke</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="verifier" transfer-ownership="none">
            <doc xml:whitespace="preserve">the verifier</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">a #OAuthProxyAuthCallback to invoke on completion</doc>
            <type name="OAuthProxyAuthCallback"
                  c:type="OAuthProxyAuthCallback"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GObject to weakly reference and tie the lifecycle of the method call too</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="auth_step" c:identifier="oauth_proxy_auth_step" throws="1">
        <doc xml:whitespace="preserve">Perform an OAuth authorisation step.  This calls @function and then updates
the token and token secret in the proxy.

@proxy must not require binding, the function will be invoked using
rest_proxy_call_set_function().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the function to invoke on the proxy</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="auth_step_async"
              c:identifier="oauth_proxy_auth_step_async"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Perform an OAuth authorisation step.  This calls @function and then updates
the token and token secret in the proxy.

@proxy must not require binding, the function will be invoked using
rest_proxy_call_set_function().</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the function to invoke on the proxy</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="3">
            <doc xml:whitespace="preserve">the callback to invoke when authorisation is complete</doc>
            <type name="OAuthProxyAuthCallback"
                  c:type="OAuthProxyAuthCallback"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #GObject to weakly reference and tie the lifecycle too</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_signature_host"
              c:identifier="oauth_proxy_get_signature_host">
        <doc xml:whitespace="preserve">Get the signature hostname used when creating a signature base string.

This string is owned by #OAuthProxy and should not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the signature hostname, or %NULL if there is none set.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_token" c:identifier="oauth_proxy_get_token">
        <doc xml:whitespace="preserve">Get the current request or access token.

by #OAuthProxy and should not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the token, or %NULL if there is no token yet.  This string is owned</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_token_secret"
              c:identifier="oauth_proxy_get_token_secret">
        <doc xml:whitespace="preserve">Get the current request or access token secret.

string is owned by #OAuthProxy and should not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the token secret, or %NULL if there is no token secret yet.  This</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="is_oauth10a" c:identifier="oauth_proxy_is_oauth10a">
        <doc xml:whitespace="preserve">Determines if the server supports OAuth 1.0a with this proxy. This is only
valid after oauth_proxy_request_token() or oauth_proxy_request_token_async()
has been called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the server supports OAuth 1.0a, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="new_echo_proxy"
              c:identifier="oauth_proxy_new_echo_proxy"
              introspectable="0">
        <return-value>
          <type name="Proxy" c:type="RestProxy*"/>
        </return-value>
        <parameters>
          <parameter name="service_url" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="url_format" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="binding_required" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_token"
              c:identifier="oauth_proxy_request_token"
              throws="1">
        <doc xml:whitespace="preserve">Perform the Request Token phase of OAuth, invoking @function (defaulting to
"request_token" if @function is NULL).

The value of @callback depends on whether you wish to use OAuth 1.0 or 1.0a.
If you wish to use 1.0 then callback must be NULL.  To use 1.0a then
@callback should either be your callback URI, or "oob" (out-of-band).</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE on success, or %FALSE on failure. On failure @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the function name to invoke</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="callback_uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback URI</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="request_token_async"
              c:identifier="oauth_proxy_request_token_async"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Perform the Request Token phase of OAuth, invoking @function (defaulting to
"request_token" if @function is NULL).

The value of @callback depends on whether you wish to use OAuth 1.0 or 1.0a.
If you wish to use 1.0 then callback must be NULL.  To use 1.0a then
@callback should either be your callback URI, or "oob" (out-of-band).

This method will return once the method has been queued, @callback will be
invoked when it has completed.

failure. On failure @error is set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the method was successfully queued, or %FALSE on</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">the function name to invoke</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="callback_uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback URI</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="4">
            <doc xml:whitespace="preserve">a #OAuthProxyAuthCallback to invoke on completion</doc>
            <type name="OAuthProxyAuthCallback"
                  c:type="OAuthProxyAuthCallback"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">#GObject to weakly reference and tie the lifecycle of the method call too</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="user_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">user data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_signature_host"
              c:identifier="oauth_proxy_set_signature_host">
        <doc xml:whitespace="preserve">Set the signature hostname used when creating a signature base string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="signature_host" transfer-ownership="none">
            <doc xml:whitespace="preserve">the signature host</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_token" c:identifier="oauth_proxy_set_token">
        <doc xml:whitespace="preserve">Set the access token.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token" transfer-ownership="none">
            <doc xml:whitespace="preserve">the access token</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_token_secret"
              c:identifier="oauth_proxy_set_token_secret">
        <doc xml:whitespace="preserve">Set the access token secret.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="token_secret" transfer-ownership="none">
            <doc xml:whitespace="preserve">the access token secret</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="consumer-key"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="consumer-secret"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="signature-host" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="signature-method" writable="1" transfer-ownership="none">
        <type name="OAuthSignatureMethod"/>
      </property>
      <property name="token" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="token-secret" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="Proxy" c:type="RestProxy"/>
      </field>
    </class>
    <callback name="OAuthProxyAuthCallback" c:type="OAuthProxyAuthCallback">
      <doc xml:whitespace="preserve">Callback from oauth_proxy_request_token_async() and
oauth_proxy_access_token_async().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="proxy" transfer-ownership="none">
          <doc xml:whitespace="preserve">the #OAuthProxy</doc>
          <type name="OAuthProxy" c:type="OAuthProxy*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:whitespace="preserve">a #GError if the authentication failed, otherwise %NULL</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <doc xml:whitespace="preserve">the weak object passed to the caller</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <doc xml:whitespace="preserve">the user data passed to the caller</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="OAuthProxyCall"
           c:symbol-prefix="oauth_proxy_call"
           c:type="OAuthProxyCall"
           parent="ProxyCall"
           glib:type-name="OAuthProxyCall"
           glib:get-type="oauth_proxy_call_get_type"
           glib:type-struct="OAuthProxyCallClass">
      <doc xml:whitespace="preserve">#OAuthProxyCall has no publicly available members.</doc>
      <method name="parse_token_reponse"
              c:identifier="oauth_proxy_call_parse_token_reponse">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <field name="parent">
        <type name="ProxyCall" c:type="RestProxyCall"/>
      </field>
    </class>
    <record name="OAuthProxyCallClass"
            c:type="OAuthProxyCallClass"
            glib:is-gtype-struct-for="OAuthProxyCall">
      <field name="parent_class">
        <type name="ProxyCallClass" c:type="RestProxyCallClass"/>
      </field>
      <field name="_padding_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="OAuthProxyClass"
            c:type="OAuthProxyClass"
            glib:is-gtype-struct-for="OAuthProxy">
      <field name="parent_class">
        <type name="ProxyClass" c:type="RestProxyClass"/>
      </field>
      <field name="_padding_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="OAuthSignatureMethod"
                 glib:type-name="OAuthSignatureMethod"
                 glib:get-type="oauth_signature_method_get_type"
                 c:type="OAuthSignatureMethod">
      <doc xml:whitespace="preserve">The signature method to use when signing method calls.  @PLAINTEXT is only
recommended for testing, in general @HMAC_SHA1 is well supported and more
secure.</doc>
      <member name="plaintext"
              value="0"
              c:identifier="PLAINTEXT"
              glib:nick="plaintext"/>
      <member name="hmac_sha1"
              value="1"
              c:identifier="HMAC_SHA1"
              glib:nick="hmac-sha1"/>
    </enumeration>
    <record name="Param" c:type="RestParam" disguised="1">
      <method name="get_content"
              c:identifier="rest_param_get_content"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the content of @param.  The content should be treated as read-only and
not modified in any way.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the content.</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </return-value>
      </method>
      <method name="get_content_length"
              c:identifier="rest_param_get_content_length">
        <doc xml:whitespace="preserve">Get the length of the content of @param.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the content</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
      </method>
      <method name="get_content_type"
              c:identifier="rest_param_get_content_type">
        <doc xml:whitespace="preserve">Get the MIME type of the parameter.  For example, basic strings have the MIME
type "text/plain".</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the MIME type</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_file_name" c:identifier="rest_param_get_file_name">
        <doc xml:whitespace="preserve">Get the original file name of the parameter, if one is available.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the filename if          set, or %NULL.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_name" c:identifier="rest_param_get_name">
        <doc xml:whitespace="preserve">Get the name of the parameter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the parameter name.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="is_string" c:identifier="rest_param_is_string">
        <doc xml:whitespace="preserve">Determine if the parameter is a string value, i.e. the content type is "text/plain".</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if the parameter is a string, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="rest_param_ref" introspectable="0">
        <doc xml:whitespace="preserve">Increase the reference count on @param.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the #RestParam</doc>
          <type name="Param" c:type="RestParam*"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="rest_param_unref">
        <doc xml:whitespace="preserve">Decrease the reference count on @param, destroying it if the reference count
reaches 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <function name="new_full"
                c:identifier="rest_param_new_full"
                introspectable="0">
        <doc xml:whitespace="preserve">Create a new #RestParam called @name with @length bytes of @data as the
value.  @content_type is the type of the data as a MIME type, for example
"text/plain" for simple string parameters.

If the parameter is a file upload it can be passed as @filename.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #RestParam.</doc>
          <type name="Param" c:type="RestParam*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="use" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #RestMemoryUse describing how the memory can be used</doc>
            <type name="MemoryUse" c:type="RestMemoryUse"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the start of the data</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the content type of the data</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the original filename, or %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_string"
                c:identifier="rest_param_new_string"
                introspectable="0">
        <doc xml:whitespace="preserve">A convience constructor to create a #RestParam from a given UTF-8 string.
The resulting #RestParam will have a content type of "text/plain".</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #RestParam.</doc>
          <type name="Param" c:type="RestParam*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="use" transfer-ownership="none">
            <doc xml:whitespace="preserve">the #RestMemoryUse describing how the memory can be used</doc>
            <type name="MemoryUse" c:type="RestMemoryUse"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter value</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_owner"
                c:identifier="rest_param_new_with_owner"
                introspectable="0">
        <doc xml:whitespace="preserve">Create a new #RestParam called @name with @length bytes of @data as the
value.  @content_type is the type of the data as a MIME type, for example
"text/plain" for simple string parameters.

If the parameter is a file upload it can be passed as @filename.

When the #RestParam is freed, it will call @owner_dnotify, passing @owner to
it. This allows you to do something like this:

|[
GMappedFile *map = g_mapped_file_new (filename, FALSE, &amp;error);
RestParam *param = rest_param_new_with_owner ("media",
g_mapped_file_get_contents (map),
g_mapped_file_get_length (map),
"image/jpeg",
filename,
map,
(GDestroyNotify)g_mapped_file_unref);
]|</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #RestParam.</doc>
          <type name="Param" c:type="RestParam*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the parameter name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">a pointer to the start of the data</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of the data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">the content type of the data</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:whitespace="preserve">the original filename, or %NULL</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="owner" transfer-ownership="none">
            <doc xml:whitespace="preserve">pointer to an object that owns @data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="owner_dnotify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:whitespace="preserve">a function to free/unref @owner when the buffer is freed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="Params" c:type="RestParams" disguised="1">
      <method name="add" c:identifier="rest_params_add">
        <doc xml:whitespace="preserve">Add @param to @params.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a valid #RestParam</doc>
            <type name="Param" c:type="RestParam*"/>
          </parameter>
        </parameters>
      </method>
      <method name="are_strings" c:identifier="rest_params_are_strings">
        <doc xml:whitespace="preserve">Checks if the parameters are all simple strings (have a content type of
"text/plain").</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%TRUE if all of the parameters are simple strings, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="as_string_hash_table"
              c:identifier="rest_params_as_string_hash_table"
              introspectable="0">
        <doc xml:whitespace="preserve">Create a new #GHashTable which contains the name and value of all string
(content type of text/plain) parameters.

The values are owned by the #RestParams, so don't destroy the #RestParams
before the hash table.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a new #GHashTable.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="free" c:identifier="rest_params_free">
        <doc xml:whitespace="preserve">Destroy the #RestParams and the #RestParam objects that it contains.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get" c:identifier="rest_params_get" introspectable="0">
        <doc xml:whitespace="preserve">Return the #RestParam called @name, or %NULL if it doesn't exist.</doc>
        <return-value>
          <doc xml:whitespace="preserve">a #RestParam or %NULL if the name doesn't exist</doc>
          <type name="Param" c:type="RestParam*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="rest_params_remove">
        <doc xml:whitespace="preserve">Remove the #RestParam called @name.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a parameter name</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="rest_params_new" introspectable="0">
        <doc xml:whitespace="preserve">Create a new #RestParams.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A empty #RestParams.</doc>
          <type name="Params" c:type="RestParams*"/>
        </return-value>
      </function>
    </record>
    <record name="ParamsIter" c:type="RestParamsIter" disguised="1">
      <method name="init" c:identifier="rest_params_iter_init">
        <doc xml:whitespace="preserve">Initialize a parameter iterator over @params. Modifying @params after calling
this function invalidates the returned iterator.
|[
RestParamsIter iter;
const char *name;
RestParam *param;

rest_params_iter_init (&amp;iter, params);
while (rest_params_iter_next (&amp;iter, &amp;name, &amp;param)) {
/&amp;ast; do something with name and param &amp;ast;/
}
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none">
            <doc xml:whitespace="preserve">a valid #RestParams</doc>
            <type name="Params" c:type="RestParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next" c:identifier="rest_params_iter_next">
        <doc xml:whitespace="preserve">Advances @iter and retrieves the name and/or parameter that are now pointed
at as a result of this advancement.  If FALSE is returned, @name and @param
are not set and the iterator becomes invalid.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%FALSE if the end of the #RestParams has been reached, %TRUE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the name, or %NULL</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="param" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to store the #RestParam, or %NULL</doc>
            <type name="Param" c:type="RestParam**"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="Proxy"
           c:symbol-prefix="proxy"
           c:type="RestProxy"
           parent="GObject.Object"
           glib:type-name="RestProxy"
           glib:get-type="rest_proxy_get_type"
           glib:type-struct="ProxyClass">
      <doc xml:whitespace="preserve">#RestProxy has no publicly available members.</doc>
      <constructor name="new" c:identifier="rest_proxy_new">
        <doc xml:whitespace="preserve">Create a new #RestProxy for the specified endpoint @url_format, using the
"GET" method.

Set @binding_required to %TRUE if the URL contains string formatting
operations (for example "http://foo.com/%&lt;!-- --&gt;s".  These must be expanded
using rest_proxy_bind() before invoking the proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #RestProxy.</doc>
          <type name="Proxy" c:type="RestProxy*"/>
        </return-value>
        <parameters>
          <parameter name="url_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the endpoint URL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="binding_required" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the URL needs to be bound before calling</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_authentication"
                   c:identifier="rest_proxy_new_with_authentication">
        <doc xml:whitespace="preserve">Create a new #RestProxy for the specified endpoint @url_format, using the
"GET" method.

Set @binding_required to %TRUE if the URL contains string formatting
operations (for example "http://foo.com/%&lt;!-- --&gt;s".  These must be expanded
using rest_proxy_bind() before invoking the proxy.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">A new #RestProxy.</doc>
          <type name="Proxy" c:type="RestProxy*"/>
        </return-value>
        <parameters>
          <parameter name="url_format" transfer-ownership="none">
            <doc xml:whitespace="preserve">the endpoint URL</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="binding_required" transfer-ownership="none">
            <doc xml:whitespace="preserve">whether the URL needs to be bound before calling</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="username" transfer-ownership="none">
            <doc xml:whitespace="preserve">the username provided by the user or client</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="password" transfer-ownership="none">
            <doc xml:whitespace="preserve">the password provided by the user or client</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="bind_valist"
                      invoker="bind_valist"
                      introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_call" invoker="new_call" introspectable="0">
        <return-value>
          <type name="ProxyCall" c:type="RestProxyCall*"/>
        </return-value>
      </virtual-method>
      <virtual-method name="simple_run_valist"
                      invoker="simple_run_valist"
                      introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="payload" transfer-ownership="none">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gint64" c:type="goffset*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="bind" c:identifier="rest_proxy_bind" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="bind_valist"
              c:identifier="rest_proxy_bind_valist"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_agent" c:identifier="rest_proxy_get_user_agent">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="new_call"
              c:identifier="rest_proxy_new_call"
              introspectable="0">
        <return-value>
          <type name="ProxyCall" c:type="RestProxyCall*"/>
        </return-value>
      </method>
      <method name="set_user_agent" c:identifier="rest_proxy_set_user_agent">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="user_agent" transfer-ownership="none">
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="simple_run"
              c:identifier="rest_proxy_simple_run"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="payload" transfer-ownership="none">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gint64" c:type="goffset*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="simple_run_valist"
              c:identifier="rest_proxy_simple_run_valist"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="payload" transfer-ownership="none">
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gint64" c:type="goffset*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <property name="binding-required" writable="1" transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="disable-cookies"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean"/>
      </property>
      <property name="password"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="url-format" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="user-agent" writable="1" transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <property name="username"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="ProxyCall"
           c:symbol-prefix="proxy_call"
           c:type="RestProxyCall"
           parent="GObject.Object"
           glib:type-name="RestProxyCall"
           glib:get-type="rest_proxy_call_get_type"
           glib:type-struct="ProxyCallClass">
      <doc xml:whitespace="preserve">#RestProxyCall has no publicly available members.</doc>
      <virtual-method name="prepare" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </virtual-method>
      <virtual-method name="serialize_params"
                      invoker="serialize_params"
                      throws="1">
        <doc xml:whitespace="preserve">Invoker for a virtual method to serialize the parameters for this
#RestProxyCall.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the serialization was successful, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Content type of the payload</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="content"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The payload</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="content_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Length of the payload data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_header" c:identifier="rest_proxy_call_add_header">
        <doc xml:whitespace="preserve">Add a header called @header with the value @value to the call.  If a
header with this name already exists, the new value will replace the old.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="header" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the header to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the header</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_headers"
              c:identifier="rest_proxy_call_add_headers"
              introspectable="0">
        <doc xml:whitespace="preserve">Add the specified header name and value pairs to the call.  If a header
already exists, the new value will replace the old.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_headers_from_valist"
              c:identifier="rest_proxy_call_add_headers_from_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Add the specified header name and value pairs to the call.  If a header
already exists, the new value will replace the old.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="headers" transfer-ownership="none">
            <doc xml:whitespace="preserve">Header name and value pairs, followed by %NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_param" c:identifier="rest_proxy_call_add_param">
        <doc xml:whitespace="preserve">Add a query parameter called @param with the string value @value to the call.
If a parameter with this name already exists, the new value will replace the
old.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the parameter to set</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">The value of the parameter</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_param_full"
              c:identifier="rest_proxy_call_add_param_full">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="param" transfer-ownership="none">
            <type name="Param" c:type="RestParam*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_params"
              c:identifier="rest_proxy_call_add_params"
              introspectable="0">
        <doc xml:whitespace="preserve">Add the specified parameter name and value pairs to the call.  If a parameter
already exists, the new value will replace the old.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter transfer-ownership="none">
            <varargs>
            </varargs>
          </parameter>
        </parameters>
      </method>
      <method name="add_params_from_valist"
              c:identifier="rest_proxy_call_add_params_from_valist"
              introspectable="0">
        <doc xml:whitespace="preserve">Add the specified parameter name and value pairs to the call.  If a parameter
already exists, the new value will replace the old.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="params" transfer-ownership="none">
            <doc xml:whitespace="preserve">Parameter name and value pairs, followed by %NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="async"
              c:identifier="rest_proxy_call_async"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Asynchronously invoke @call.

When the call has finished, @callback will be called.  If @weak_object is
disposed during the call then this call will be cancelled. If the call is
cancelled then the callback will be invoked with an error state.

You may unref the call after calling this function since there is an
internal reference, or you may unref in the callback.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="callback" transfer-ownership="none" closure="2">
            <doc xml:whitespace="preserve">a #RestProxyCallAsyncCallback to invoke on completion of the call</doc>
            <type name="ProxyCallAsyncCallback"
                  c:type="RestProxyCallAsyncCallback"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GObject to weakly reference and tie the lifecycle too</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="cancel" c:identifier="rest_proxy_call_cancel">
        <doc xml:whitespace="preserve">Cancel this call.  It may be too late to not actually send the message, but
the callback will not be invoked.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="continuous"
              c:identifier="rest_proxy_call_continuous"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Asynchronously invoke @call but expect a continuous stream of content. This
means that the body data will not be accumulated and thus you cannot use
rest_proxy_call_get_payload()

When there is data @callback will be called and when the connection is
closed or the stream ends @callback will also be called. 

If @weak_object is disposed during the call then this call will be
cancelled. If the call is cancelled then the callback will be invoked with
an error state.

You may unref the call after calling this function since there is an
internal reference, or you may unref in the callback.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cb" transfer-ownership="none" closure="2">
            <type name="ProxyCallContinuousCallback"
                  c:type="RestProxyCallContinuousCallback"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GObject to weakly reference and tie the lifecycle to</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_method" c:identifier="rest_proxy_call_get_method">
        <doc xml:whitespace="preserve">Get the HTTP method to use when making the call, for example GET or POST.</doc>
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="get_params"
              c:identifier="rest_proxy_call_get_params"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the parameters as a #GHashTable of parameter names to values.  The caller
should call g_hash_table_unref() when they have finished using it.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A #GHashTable.</doc>
          <type name="Params" c:type="RestParams*"/>
        </return-value>
      </method>
      <method name="get_payload" c:identifier="rest_proxy_call_get_payload">
        <doc xml:whitespace="preserve">Get the return payload.

not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">A pointer to the payload. This is owned by #RestProxyCall and should</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="get_payload_length"
              c:identifier="rest_proxy_call_get_payload_length">
        <doc xml:whitespace="preserve">Get the length of the return payload.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the payload in bytes.</doc>
          <type name="gint64" c:type="goffset"/>
        </return-value>
      </method>
      <method name="get_response_headers"
              c:identifier="rest_proxy_call_get_response_headers"
              introspectable="0">
        <doc xml:whitespace="preserve">changed. You should call g_hash_table_unref() when you have finished with
it.</doc>
        <return-value>
          <doc xml:whitespace="preserve">pointer to a hash table of headers. This hash table must not be</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
      </method>
      <method name="get_status_code"
              c:identifier="rest_proxy_call_get_status_code">
        <doc xml:whitespace="preserve">Get the HTTP status code for the call.</doc>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
      </method>
      <method name="get_status_message"
              c:identifier="rest_proxy_call_get_status_message">
        <doc xml:whitespace="preserve">Get the human-readable HTTP status message for the call.

should not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The status message. This string is owned by #RestProxyCall and</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
      </method>
      <method name="lookup_header"
              c:identifier="rest_proxy_call_lookup_header">
        <doc xml:whitespace="preserve">Get the value of the header called @header.

owned by the #RestProxyCall and should not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The header value, or %NULL if it does not exist. This string is</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="header" transfer-ownership="none">
            <doc xml:whitespace="preserve">The header name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_param"
              c:identifier="rest_proxy_call_lookup_param"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the value of the parameter called @name.

owned by the #RestProxyCall and should not be freed.</doc>
        <return-value>
          <doc xml:whitespace="preserve">The parameter value, or %NULL if it does not exist. This string is</doc>
          <type name="Param" c:type="RestParam*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The paramter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_response_header"
              c:identifier="rest_proxy_call_lookup_response_header">
        <doc xml:whitespace="preserve">Get the string value of the header @header or %NULL if that header is not
present or there are no headers.</doc>
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="header" transfer-ownership="none">
            <doc xml:whitespace="preserve">The name of the header to lookup.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_header"
              c:identifier="rest_proxy_call_remove_header">
        <doc xml:whitespace="preserve">Remove the header named @header from the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="header" transfer-ownership="none">
            <doc xml:whitespace="preserve">The header name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_param" c:identifier="rest_proxy_call_remove_param">
        <doc xml:whitespace="preserve">Remove the parameter named @name from the call.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:whitespace="preserve">The paramter name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="rest_proxy_call_run" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="loop" transfer-ownership="none">
            <type name="GLib.MainLoop" c:type="GMainLoop**"/>
          </parameter>
        </parameters>
      </method>
      <method name="serialize_params"
              c:identifier="rest_proxy_call_serialize_params"
              throws="1">
        <doc xml:whitespace="preserve">Invoker for a virtual method to serialize the parameters for this
#RestProxyCall.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">TRUE if the serialization was successful, FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="content_type"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Content type of the payload</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="content"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">The payload</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="content_len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:whitespace="preserve">Length of the payload data</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_function" c:identifier="rest_proxy_call_set_function">
        <doc xml:whitespace="preserve">Set the REST "function" to call on the proxy.  This is appended to the URL,
so that for example a proxy with the URL
&lt;literal&gt;http://www.example.com/&lt;/literal&gt; and the function
&lt;literal&gt;test&lt;/literal&gt; would actually access the URL
&lt;literal&gt;http://www.example.com/test&lt;/literal&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none">
            <doc xml:whitespace="preserve">The function to call</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_method" c:identifier="rest_proxy_call_set_method">
        <doc xml:whitespace="preserve">Set the HTTP method to use when making the call, for example GET or POST.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:whitespace="preserve">The HTTP method to use</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync" c:identifier="rest_proxy_call_sync" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
      </method>
      <method name="upload"
              c:identifier="rest_proxy_call_upload"
              introspectable="0"
              throws="1">
        <doc xml:whitespace="preserve">Asynchronously invoke @call but expect to have the callback invoked every time a
chunk of our request's body is written.

When the callback is invoked with the uploaded byte count equaling the message
byte count, the call has completed.

If @weak_object is disposed during the call then this call will be
cancelled. If the call is cancelled then the callback will be invoked with
an error state.

You may unref the call after calling this function since there is an
internal reference, or you may unref in the callback.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="cb" transfer-ownership="none" closure="2">
            <type name="ProxyCallUploadCallback"
                  c:type="RestProxyCallUploadCallback"/>
          </parameter>
          <parameter name="weak_object" transfer-ownership="none">
            <doc xml:whitespace="preserve">The #GObject to weakly reference and tie the lifecycle to</doc>
            <type name="GObject.Object" c:type="GObject*"/>
          </parameter>
          <parameter name="userdata" transfer-ownership="none">
            <doc xml:whitespace="preserve">data to pass to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="proxy"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Proxy"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ProxyCallPrivate" c:type="RestProxyCallPrivate*"/>
      </field>
    </class>
    <callback name="ProxyCallAsyncCallback"
              c:type="RestProxyCallAsyncCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="call" transfer-ownership="none">
          <type name="ProxyCall" c:type="RestProxyCall*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ProxyCallClass"
            c:type="RestProxyCallClass"
            glib:is-gtype-struct-for="ProxyCall">
      <doc xml:whitespace="preserve">Class structure for #RestProxyCall for subclasses to implement specialised
behaviour.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="prepare">
        <callback name="prepare" throws="1">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="call" transfer-ownership="none">
              <type name="ProxyCall" c:type="RestProxyCall*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="serialize_params">
        <callback name="serialize_params" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:whitespace="preserve">TRUE if the serialization was successful, FALSE otherwise.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="call" transfer-ownership="none">
              <type name="ProxyCall" c:type="RestProxyCall*"/>
            </parameter>
            <parameter name="content_type"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:whitespace="preserve">Content type of the payload</doc>
              <type name="utf8" c:type="gchar**"/>
            </parameter>
            <parameter name="content"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:whitespace="preserve">The payload</doc>
              <type name="utf8" c:type="gchar**"/>
            </parameter>
            <parameter name="content_len"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:whitespace="preserve">Length of the payload data</doc>
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="7">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="ProxyCallContinuousCallback"
              c:type="RestProxyCallContinuousCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="call" transfer-ownership="none">
          <type name="ProxyCall" c:type="RestProxyCall*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <type name="utf8" c:type="gchar*"/>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="ProxyCallError"
                 glib:type-name="RestProxyCallError"
                 glib:get-type="rest_proxy_call_error_get_type"
                 c:type="RestProxyCallError"
                 glib:error-domain="rest-proxy-call-error-quark">
      <doc xml:whitespace="preserve">Error domain used when returning errors from #RestProxyCall.</doc>
      <member name="failed"
              value="0"
              c:identifier="REST_PROXY_CALL_FAILED"
              glib:nick="failed"/>
      <function name="quark" c:identifier="rest_proxy_call_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="ProxyCallPrivate"
            c:type="RestProxyCallPrivate"
            disguised="1">
    </record>
    <callback name="ProxyCallUploadCallback"
              c:type="RestProxyCallUploadCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="call" transfer-ownership="none">
          <type name="ProxyCall" c:type="RestProxyCall*"/>
        </parameter>
        <parameter name="total" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="uploaded" transfer-ownership="none">
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="weak_object" transfer-ownership="none">
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="userdata" transfer-ownership="none">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ProxyClass"
            c:type="RestProxyClass"
            glib:is-gtype-struct-for="Proxy">
      <doc xml:whitespace="preserve">Class structure for #RestProxy for subclasses to implement specialised
behaviour.

Typically subclasses will override @new_call to construct a subclass of
#RestProxyCall.</doc>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="bind_valist" introspectable="0">
        <callback name="bind_valist" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="Proxy" c:type="RestProxy*"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="va_list" c:type="va_list"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_call" introspectable="0">
        <callback name="new_call" introspectable="0">
          <return-value>
            <type name="ProxyCall" c:type="RestProxyCall*"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="Proxy" c:type="RestProxy*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="simple_run_valist" introspectable="0">
        <callback name="simple_run_valist" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="proxy" transfer-ownership="none">
              <type name="Proxy" c:type="RestProxy*"/>
            </parameter>
            <parameter name="payload" transfer-ownership="none">
              <type name="utf8" c:type="gchar**"/>
            </parameter>
            <parameter name="len" transfer-ownership="none">
              <type name="gint64" c:type="goffset*"/>
            </parameter>
            <parameter name="error" transfer-ownership="none">
              <type name="GLib.Error" c:type="GError**"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="va_list" c:type="va_list"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding_dummy" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="ProxyError"
                 glib:type-name="RestProxyError"
                 glib:get-type="rest_proxy_error_get_type"
                 c:type="RestProxyError"
                 glib:error-domain="rest-proxy-error-quark">
      <doc xml:whitespace="preserve">Error domain used when returning errors from a #RestProxy.</doc>
      <member name="cancelled"
              value="1"
              c:identifier="REST_PROXY_ERROR_CANCELLED"
              glib:nick="cancelled"/>
      <member name="resolution"
              value="2"
              c:identifier="REST_PROXY_ERROR_RESOLUTION"
              glib:nick="resolution"/>
      <member name="connection"
              value="3"
              c:identifier="REST_PROXY_ERROR_CONNECTION"
              glib:nick="connection"/>
      <member name="ssl"
              value="4"
              c:identifier="REST_PROXY_ERROR_SSL"
              glib:nick="ssl"/>
      <member name="io"
              value="5"
              c:identifier="REST_PROXY_ERROR_IO"
              glib:nick="io"/>
      <member name="failed"
              value="6"
              c:identifier="REST_PROXY_ERROR_FAILED"
              glib:nick="failed"/>
      <member name="http_multiple_choices"
              value="300"
              c:identifier="REST_PROXY_ERROR_HTTP_MULTIPLE_CHOICES"
              glib:nick="http-multiple-choices"/>
      <member name="http_moved_permanently"
              value="301"
              c:identifier="REST_PROXY_ERROR_HTTP_MOVED_PERMANENTLY"
              glib:nick="http-moved-permanently"/>
      <member name="http_found"
              value="302"
              c:identifier="REST_PROXY_ERROR_HTTP_FOUND"
              glib:nick="http-found"/>
      <member name="http_see_other"
              value="303"
              c:identifier="REST_PROXY_ERROR_HTTP_SEE_OTHER"
              glib:nick="http-see-other"/>
      <member name="http_not_modified"
              value="304"
              c:identifier="REST_PROXY_ERROR_HTTP_NOT_MODIFIED"
              glib:nick="http-not-modified"/>
      <member name="http_use_proxy"
              value="305"
              c:identifier="REST_PROXY_ERROR_HTTP_USE_PROXY"
              glib:nick="http-use-proxy"/>
      <member name="http_threeohsix"
              value="306"
              c:identifier="REST_PROXY_ERROR_HTTP_THREEOHSIX"
              glib:nick="http-threeohsix"/>
      <member name="http_temporary_redirect"
              value="307"
              c:identifier="REST_PROXY_ERROR_HTTP_TEMPORARY_REDIRECT"
              glib:nick="http-temporary-redirect"/>
      <member name="http_bad_request"
              value="400"
              c:identifier="REST_PROXY_ERROR_HTTP_BAD_REQUEST"
              glib:nick="http-bad-request"/>
      <member name="http_unauthorized"
              value="401"
              c:identifier="REST_PROXY_ERROR_HTTP_UNAUTHORIZED"
              glib:nick="http-unauthorized"/>
      <member name="http_fourohtwo"
              value="402"
              c:identifier="REST_PROXY_ERROR_HTTP_FOUROHTWO"
              glib:nick="http-fourohtwo"/>
      <member name="http_forbidden"
              value="403"
              c:identifier="REST_PROXY_ERROR_HTTP_FORBIDDEN"
              glib:nick="http-forbidden"/>
      <member name="http_not_found"
              value="404"
              c:identifier="REST_PROXY_ERROR_HTTP_NOT_FOUND"
              glib:nick="http-not-found"/>
      <member name="http_method_not_allowed"
              value="405"
              c:identifier="REST_PROXY_ERROR_HTTP_METHOD_NOT_ALLOWED"
              glib:nick="http-method-not-allowed"/>
      <member name="http_not_acceptable"
              value="406"
              c:identifier="REST_PROXY_ERROR_HTTP_NOT_ACCEPTABLE"
              glib:nick="http-not-acceptable"/>
      <member name="http_proxy_authentication_required"
              value="407"
              c:identifier="REST_PROXY_ERROR_HTTP_PROXY_AUTHENTICATION_REQUIRED"
              glib:nick="http-proxy-authentication-required"/>
      <member name="http_request_timeout"
              value="408"
              c:identifier="REST_PROXY_ERROR_HTTP_REQUEST_TIMEOUT"
              glib:nick="http-request-timeout"/>
      <member name="http_conflict"
              value="409"
              c:identifier="REST_PROXY_ERROR_HTTP_CONFLICT"
              glib:nick="http-conflict"/>
      <member name="http_gone"
              value="410"
              c:identifier="REST_PROXY_ERROR_HTTP_GONE"
              glib:nick="http-gone"/>
      <member name="http_length_required"
              value="411"
              c:identifier="REST_PROXY_ERROR_HTTP_LENGTH_REQUIRED"
              glib:nick="http-length-required"/>
      <member name="http_precondition_failed"
              value="412"
              c:identifier="REST_PROXY_ERROR_HTTP_PRECONDITION_FAILED"
              glib:nick="http-precondition-failed"/>
      <member name="http_request_entity_too_large"
              value="413"
              c:identifier="REST_PROXY_ERROR_HTTP_REQUEST_ENTITY_TOO_LARGE"
              glib:nick="http-request-entity-too-large"/>
      <member name="http_request_uri_too_long"
              value="414"
              c:identifier="REST_PROXY_ERROR_HTTP_REQUEST_URI_TOO_LONG"
              glib:nick="http-request-uri-too-long"/>
      <member name="http_unsupported_media_type"
              value="415"
              c:identifier="REST_PROXY_ERROR_HTTP_UNSUPPORTED_MEDIA_TYPE"
              glib:nick="http-unsupported-media-type"/>
      <member name="http_requested_range_not_satisfiable"
              value="416"
              c:identifier="REST_PROXY_ERROR_HTTP_REQUESTED_RANGE_NOT_SATISFIABLE"
              glib:nick="http-requested-range-not-satisfiable"/>
      <member name="http_expectation_failed"
              value="417"
              c:identifier="REST_PROXY_ERROR_HTTP_EXPECTATION_FAILED"
              glib:nick="http-expectation-failed"/>
      <member name="http_internal_server_error"
              value="500"
              c:identifier="REST_PROXY_ERROR_HTTP_INTERNAL_SERVER_ERROR"
              glib:nick="http-internal-server-error"/>
      <member name="http_not_implemented"
              value="501"
              c:identifier="REST_PROXY_ERROR_HTTP_NOT_IMPLEMENTED"
              glib:nick="http-not-implemented"/>
      <member name="http_bad_gateway"
              value="502"
              c:identifier="REST_PROXY_ERROR_HTTP_BAD_GATEWAY"
              glib:nick="http-bad-gateway"/>
      <member name="http_service_unavailable"
              value="503"
              c:identifier="REST_PROXY_ERROR_HTTP_SERVICE_UNAVAILABLE"
              glib:nick="http-service-unavailable"/>
      <member name="http_gateway_timeout"
              value="504"
              c:identifier="REST_PROXY_ERROR_HTTP_GATEWAY_TIMEOUT"
              glib:nick="http-gateway-timeout"/>
      <member name="http_http_version_not_supported"
              value="505"
              c:identifier="REST_PROXY_ERROR_HTTP_HTTP_VERSION_NOT_SUPPORTED"
              glib:nick="http-http-version-not-supported"/>
      <function name="quark" c:identifier="rest_proxy_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="XmlNode"
            c:type="RestXmlNode"
            glib:type-name="RestXmlNode"
            glib:get-type="rest_xml_node_get_type"
            c:symbol-prefix="xml_node">
      <field name="ref_count" readable="0" private="1">
        <type name="gint" c:type="int"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="content" writable="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="children" writable="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="attrs" writable="1">
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="gpointer" c:type="gpointer"/>
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <field name="next" writable="1">
        <type name="XmlNode" c:type="RestXmlNode*"/>
      </field>
      <method name="add_attr" c:identifier="rest_xml_node_add_attr">
        <doc xml:whitespace="preserve">Adds attribute to the given node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="attribute" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the attribute</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">value to set attribute to</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_child" c:identifier="rest_xml_node_add_child">
        <doc xml:whitespace="preserve">Adds a new node to the given parent node; to create the top-level node,
parent should be %NULL.

is owned by, and valid for the life time of, the #RestXmlCreator.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the newly added #RestXmlNode; the node object</doc>
          <type name="XmlNode" c:type="RestXmlNode*"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">name of the child node</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find" c:identifier="rest_xml_node_find">
        <doc xml:whitespace="preserve">Searches for the first child node of @start named @tag.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the first child node, or %NULL if it doesn't exist.</doc>
          <type name="XmlNode" c:type="RestXmlNode*"/>
        </return-value>
        <parameters>
          <parameter name="tag" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of a node</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="rest_xml_node_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_attr" c:identifier="rest_xml_node_get_attr">
        <doc xml:whitespace="preserve">Get the value of the attribute named @attr_name, or %NULL if it doesn't
exist.

not be freed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the attribute value. This string is owned by #RestXmlNode and should</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="attr_name" transfer-ownership="none">
            <doc xml:whitespace="preserve">the name of an attribute</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print" c:identifier="rest_xml_node_print">
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="char*"/>
        </return-value>
      </method>
      <method name="ref" c:identifier="rest_xml_node_ref">
        <doc xml:whitespace="preserve">Increases the reference count of @node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">the same @node.</doc>
          <type name="XmlNode" c:type="RestXmlNode*"/>
        </return-value>
      </method>
      <method name="set_content" c:identifier="rest_xml_node_set_content">
        <doc xml:whitespace="preserve">Sets content for the given node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the content</doc>
            <type name="utf8" c:type="char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="rest_xml_node_unref">
        <doc xml:whitespace="preserve">Decreases the reference count of @node. When its reference count drops to 0,
the node is finalized (i.e. its memory is freed).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
    </record>
    <class name="XmlParser"
           c:symbol-prefix="xml_parser"
           c:type="RestXmlParser"
           parent="GObject.Object"
           glib:type-name="RestXmlParser"
           glib:get-type="rest_xml_parser_get_type"
           glib:type-struct="XmlParserClass">
      <constructor name="new" c:identifier="rest_xml_parser_new">
        <doc xml:whitespace="preserve">Create a new #RestXmlParser, for parsing XML documents.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #RestXmlParser.</doc>
          <type name="XmlParser" c:type="RestXmlParser*"/>
        </return-value>
      </constructor>
      <method name="parse_from_data"
              c:identifier="rest_xml_parser_parse_from_data">
        <doc xml:whitespace="preserve">Parse the XML in @data, and return a new #RestXmlNode.  If @data is invalid
XML, %NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:whitespace="preserve">a new #RestXmlNode, or %NULL if the XML was invalid.</doc>
          <type name="XmlNode" c:type="RestXmlNode*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:whitespace="preserve">the XML content to parse</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of @data</doc>
            <type name="gint64" c:type="goffset"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="XmlParserClass"
            c:type="RestXmlParserClass"
            glib:is-gtype-struct-for="XmlParser">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <function name="hmac_sha1" c:identifier="hmac_sha1">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="key" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <type name="utf8" c:type="char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="proxy_call_error_quark"
              c:identifier="rest_proxy_call_error_quark"
              moved-to="ProxyCallError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="proxy_error_quark"
              c:identifier="rest_proxy_error_quark"
              moved-to="ProxyError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
  </namespace>
</repository>
