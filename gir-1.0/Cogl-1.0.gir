<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GL" version="1.0"/>
  <include name="GObject" version="2.0"/>
  <package name="cogl-1.0"/>
  <c:include name="cogl/cogl.h"/>
  <namespace name="Cogl"
             version="1.0"
             shared-library="libcogl.so.20"
             c:identifier-prefixes="Cogl"
             c:symbol-prefixes="cogl">
    <alias name="Angle" c:type="CoglAngle">
      <doc xml:space="preserve">Integer representation of an angle such that 1024 corresponds to
full circle (i.e., 2 * pi).</doc>
      <type name="gint32" c:type="int32_t"/>
    </alias>
    <alias name="Bool" c:type="CoglBool" stability="Stable">
      <doc xml:space="preserve">A boolean data type used throughout the Cogl C api. This should be
used in conjunction with the %TRUE and %FALSE macro defines for
setting and testing boolean values.</doc>
      <type name="gint" c:type="int"/>
    </alias>
    <alias name="Handle" c:type="CoglHandle">
      <doc xml:space="preserve">Type used for storing references to cogl objects, the CoglHandle is
a fully opaque type without any public data members.</doc>
      <type name="gpointer" c:type="void*"/>
    </alias>
    <constant name="AFIRST_BIT" value="64" c:type="COGL_AFIRST_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="A_BIT" value="16" c:type="COGL_A_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="AttributeType"
                 version="1.0"
                 glib:type-name="CoglAttributeType"
                 glib:get-type="cogl_attribute_type_get_type"
                 c:type="CoglAttributeType">
      <doc xml:space="preserve">Data types for the components of a vertex attribute.</doc>
      <member name="byte"
              value="5120"
              c:identifier="COGL_ATTRIBUTE_TYPE_BYTE"
              glib:nick="byte">
        <doc xml:space="preserve">Data is the same size of a byte</doc>
      </member>
      <member name="unsigned_byte"
              value="5121"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE"
              glib:nick="unsigned-byte">
        <doc xml:space="preserve">Data is the same size of an
  unsigned byte</doc>
      </member>
      <member name="short"
              value="5122"
              c:identifier="COGL_ATTRIBUTE_TYPE_SHORT"
              glib:nick="short">
        <doc xml:space="preserve">Data is the same size of a short integer</doc>
      </member>
      <member name="unsigned_short"
              value="5123"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT"
              glib:nick="unsigned-short">
        <doc xml:space="preserve">Data is the same size of
  an unsigned short integer</doc>
      </member>
      <member name="float"
              value="5126"
              c:identifier="COGL_ATTRIBUTE_TYPE_FLOAT"
              glib:nick="float">
        <doc xml:space="preserve">Data is the same size of a float</doc>
      </member>
    </enumeration>
    <constant name="BGR_BIT" value="32" c:type="COGL_BGR_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Bitmap"
           c:symbol-prefix="bitmap"
           c:type="CoglBitmap"
           glib:type-name="CoglBitmap"
           glib:get-type="cogl_bitmap_get_gtype"
           glib:fundamental="1">
      <constructor name="new_from_file"
                   c:identifier="cogl_bitmap_new_from_file"
                   version="1.0"
                   throws="1">
        <doc xml:space="preserve">Loads an image file from disk. This function can be safely called from
within a thread.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #CoglBitmap to the new loaded
              image data, or %NULL if loading the image failed.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the file to load.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_size_from_file"
                c:identifier="cogl_bitmap_get_size_from_file"
                version="1.0">
        <doc xml:space="preserve">Parses an image file enough to extract the width and height
of the bitmap.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the image was successfully parsed</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">the file to check</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the bitmap width, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the bitmap height, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <enumeration name="BitmapError"
                 version="1.4"
                 glib:type-name="CoglBitmapError"
                 glib:get-type="cogl_bitmap_error_get_type"
                 c:type="CoglBitmapError">
      <doc xml:space="preserve">Error codes that can be thrown when performing bitmap
operations. Note that gdk_pixbuf_new_from_file() can also throw
errors directly from the underlying image loading library. For
example, if GdkPixbuf is used then errors #GdkPixbufError&lt;!-- --&gt;s
will be used directly.</doc>
      <member name="failed"
              value="0"
              c:identifier="COGL_BITMAP_ERROR_FAILED"
              glib:nick="failed">
        <doc xml:space="preserve">Generic failure code, something went
  wrong.</doc>
      </member>
      <member name="unknown_type"
              value="1"
              c:identifier="COGL_BITMAP_ERROR_UNKNOWN_TYPE"
              glib:nick="unknown-type">
        <doc xml:space="preserve">Unknown image type.</doc>
      </member>
      <member name="corrupt_image"
              value="2"
              c:identifier="COGL_BITMAP_ERROR_CORRUPT_IMAGE"
              glib:nick="corrupt-image">
        <doc xml:space="preserve">An image file was broken somehow.</doc>
      </member>
      <function name="quark" c:identifier="cogl_bitmap_error_quark">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="BlendStringError"
                 version="1.0"
                 glib:type-name="CoglBlendStringError"
                 glib:get-type="cogl_blend_string_error_get_type"
                 c:type="CoglBlendStringError">
      <doc xml:space="preserve">Error enumeration for the blend strings parser</doc>
      <member name="parse_error"
              value="0"
              c:identifier="COGL_BLEND_STRING_ERROR_PARSE_ERROR"
              glib:nick="parse-error">
        <doc xml:space="preserve">Generic parse error</doc>
      </member>
      <member name="argument_parse_error"
              value="1"
              c:identifier="COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR"
              glib:nick="argument-parse-error">
        <doc xml:space="preserve">Argument parse error</doc>
      </member>
      <member name="invalid_error"
              value="2"
              c:identifier="COGL_BLEND_STRING_ERROR_INVALID_ERROR"
              glib:nick="invalid-error">
        <doc xml:space="preserve">Internal parser error</doc>
      </member>
      <member name="gpu_unsupported_error"
              value="3"
              c:identifier="COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR"
              glib:nick="gpu-unsupported-error">
        <doc xml:space="preserve">Blend string not
  supported by the GPU</doc>
      </member>
      <function name="quark" c:identifier="cogl_blend_string_error_quark">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="BufferBit"
              version="1.0"
              glib:type-name="CoglBufferBit"
              glib:get-type="cogl_buffer_bit_get_type"
              c:type="CoglBufferBit">
      <doc xml:space="preserve">Types of auxiliary buffers</doc>
      <member name="color"
              value="1"
              c:identifier="COGL_BUFFER_BIT_COLOR"
              glib:nick="color">
        <doc xml:space="preserve">Selects the primary color buffer</doc>
      </member>
      <member name="depth"
              value="2"
              c:identifier="COGL_BUFFER_BIT_DEPTH"
              glib:nick="depth">
        <doc xml:space="preserve">Selects the depth buffer</doc>
      </member>
      <member name="stencil"
              value="4"
              c:identifier="COGL_BUFFER_BIT_STENCIL"
              glib:nick="stencil">
        <doc xml:space="preserve">Selects the stencil buffer</doc>
      </member>
    </bitfield>
    <bitfield name="BufferTarget"
              version="0.8"
              glib:type-name="CoglBufferTarget"
              glib:get-type="cogl_buffer_target_get_type"
              c:type="CoglBufferTarget">
      <doc xml:space="preserve">Target flags for FBOs.</doc>
      <member name="window_buffer"
              value="2"
              c:identifier="COGL_WINDOW_BUFFER"
              glib:nick="window-buffer">
        <doc xml:space="preserve">FIXME</doc>
      </member>
      <member name="offscreen_buffer"
              value="4"
              c:identifier="COGL_OFFSCREEN_BUFFER"
              glib:nick="offscreen-buffer">
        <doc xml:space="preserve">FIXME</doc>
      </member>
    </bitfield>
    <record name="Color"
            c:type="CoglColor"
            version="1.0"
            glib:type-name="CoglColor"
            glib:get-type="cogl_color_get_gtype"
            c:symbol-prefix="color">
      <doc xml:space="preserve">A structure for holding a color definition. The contents of
the CoglColor structure are private and should never by accessed
directly.</doc>
      <field name="private_member_red" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_green" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_blue" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_alpha" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_padding0" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding1" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding2" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <constructor name="new" c:identifier="cogl_color_new" version="1.0">
        <doc xml:space="preserve">Creates a new (empty) color</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocated resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="cogl_color_copy" version="1.0">
        <doc xml:space="preserve">Creates a copy of @color</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocate resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the color to copy</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_color_free" version="1.0">
        <doc xml:space="preserve">Frees the resources allocated by cogl_color_new() and cogl_color_copy()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the color to free</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha"
              c:identifier="cogl_color_get_alpha"
              version="1.0">
        <doc xml:space="preserve">Retrieves the alpha channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_byte"
              c:identifier="cogl_color_get_alpha_byte"
              version="1.0">
        <doc xml:space="preserve">Retrieves the alpha channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the alpha channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_float"
              c:identifier="cogl_color_get_alpha_float"
              version="1.0">
        <doc xml:space="preserve">Retrieves the alpha channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue" c:identifier="cogl_color_get_blue" version="1.0">
        <doc xml:space="preserve">Retrieves the blue channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_byte"
              c:identifier="cogl_color_get_blue_byte"
              version="1.0">
        <doc xml:space="preserve">Retrieves the blue channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blue channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_float"
              c:identifier="cogl_color_get_blue_float"
              version="1.0">
        <doc xml:space="preserve">Retrieves the blue channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green"
              c:identifier="cogl_color_get_green"
              version="1.0">
        <doc xml:space="preserve">Retrieves the green channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_byte"
              c:identifier="cogl_color_get_green_byte"
              version="1.0">
        <doc xml:space="preserve">Retrieves the green channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the green channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_float"
              c:identifier="cogl_color_get_green_float"
              version="1.0">
        <doc xml:space="preserve">Retrieves the green channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red" c:identifier="cogl_color_get_red" version="1.0">
        <doc xml:space="preserve">Retrieves the red channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_byte"
              c:identifier="cogl_color_get_red_byte"
              version="1.0">
        <doc xml:space="preserve">Retrieves the red channel of @color as a byte value
between 0 and 255</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the red channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_float"
              c:identifier="cogl_color_get_red_float"
              version="1.0">
        <doc xml:space="preserve">Retrieves the red channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_from_4f"
              c:identifier="cogl_color_init_from_4f"
              version="1.4">
        <doc xml:space="preserve">Sets the values of the passed channels into a #CoglColor</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">value of the red channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">value of the green channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">value of the blue channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">value of the alpha channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4fv"
              c:identifier="cogl_color_init_from_4fv"
              version="1.4">
        <doc xml:space="preserve">Sets the values of the passed channels into a #CoglColor</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="color_array" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to an array of 4 float color components</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4ub"
              c:identifier="cogl_color_init_from_4ub"
              version="1.4">
        <doc xml:space="preserve">Sets the values of the passed channels into a #CoglColor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="premultiply"
              c:identifier="cogl_color_premultiply"
              version="1.0">
        <doc xml:space="preserve">Converts a non-premultiplied color to a pre-multiplied color. For
example, semi-transparent red is (1.0, 0, 0, 0.5) when non-premultiplied
and (0.5, 0, 0, 0.5) when premultiplied.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the color to premultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_alpha"
              c:identifier="cogl_color_set_alpha"
              version="1.4">
        <doc xml:space="preserve">Sets the alpha channel of @color to @alpha.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_byte"
              c:identifier="cogl_color_set_alpha_byte"
              version="1.4">
        <doc xml:space="preserve">Sets the alpha channel of @color to @alpha.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_float"
              c:identifier="cogl_color_set_alpha_float"
              version="1.4">
        <doc xml:space="preserve">Sets the alpha channel of @color to @alpha.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue" c:identifier="cogl_color_set_blue" version="1.4">
        <doc xml:space="preserve">Sets the blue channel of @color to @blue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_byte"
              c:identifier="cogl_color_set_blue_byte"
              version="1.4">
        <doc xml:space="preserve">Sets the blue channel of @color to @blue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_float"
              c:identifier="cogl_color_set_blue_float"
              version="1.4">
        <doc xml:space="preserve">Sets the blue channel of @color to @blue.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4f"
              c:identifier="cogl_color_set_from_4f"
              version="1.0"
              deprecated="1"
              deprecated-version="1.4">
        <doc xml:space="preserve">Sets the values of the passed channels into a #CoglColor</doc>
        <doc-deprecated xml:space="preserve">Use cogl_color_init_from_4f instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">value of the red channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">value of the green channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">value of the blue channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">value of the alpha channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4ub"
              c:identifier="cogl_color_set_from_4ub"
              version="1.0"
              deprecated="1"
              deprecated-version="1.4">
        <doc xml:space="preserve">Sets the values of the passed channels into a #CoglColor.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_color_init_from_4ub instead.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green"
              c:identifier="cogl_color_set_green"
              version="1.4">
        <doc xml:space="preserve">Sets the green channel of @color to @green.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_byte"
              c:identifier="cogl_color_set_green_byte"
              version="1.4">
        <doc xml:space="preserve">Sets the green channel of @color to @green.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_float"
              c:identifier="cogl_color_set_green_float"
              version="1.4">
        <doc xml:space="preserve">Sets the green channel of @color to @green.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red" c:identifier="cogl_color_set_red" version="1.4">
        <doc xml:space="preserve">Sets the red channel of @color to @red.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_byte"
              c:identifier="cogl_color_set_red_byte"
              version="1.4">
        <doc xml:space="preserve">Sets the red channel of @color to @red.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_float"
              c:identifier="cogl_color_set_red_float"
              version="1.4">
        <doc xml:space="preserve">Sets the red channel of @color to @red.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hsl" c:identifier="cogl_color_to_hsl" version="1.16">
        <doc xml:space="preserve">Converts @color to the HLS format.

The @hue value is in the 0 .. 360 range. The @luminance and
@saturation values are in the 0 .. 1 range.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
          <parameter name="hue"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the hue value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="saturation"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the saturation value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="luminance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the luminance value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpremultiply"
              c:identifier="cogl_color_unpremultiply"
              version="1.4">
        <doc xml:space="preserve">Converts a pre-multiplied color to a non-premultiplied color. For
example, semi-transparent red is (0.5, 0, 0, 0.5) when premultiplied
and (1.0, 0, 0, 0.5) when non-premultiplied.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the color to unpremultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_color_equal" version="1.0">
        <doc xml:space="preserve">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the two colors are the same.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_from_hsl"
                c:identifier="cogl_color_init_from_hsl"
                version="1.16">
        <doc xml:space="preserve">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve">hue value, in the 0 .. 360 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="saturation" transfer-ownership="none">
            <doc xml:space="preserve">saturation value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="luminance" transfer-ownership="none">
            <doc xml:space="preserve">luminance value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="ColorMask"
              glib:type-name="CoglColorMask"
              glib:get-type="cogl_color_mask_get_type"
              c:type="CoglColorMask">
      <doc xml:space="preserve">Defines a bit mask of color channels. This can be used with
cogl_pipeline_set_color_mask() for example to define which color
channels should be written to the current framebuffer when
drawing something.</doc>
      <member name="none"
              value="0"
              c:identifier="COGL_COLOR_MASK_NONE"
              glib:nick="none">
        <doc xml:space="preserve">None of the color channels are masked</doc>
      </member>
      <member name="red"
              value="1"
              c:identifier="COGL_COLOR_MASK_RED"
              glib:nick="red">
        <doc xml:space="preserve">Masks the red color channel</doc>
      </member>
      <member name="green"
              value="2"
              c:identifier="COGL_COLOR_MASK_GREEN"
              glib:nick="green">
        <doc xml:space="preserve">Masks the green color channel</doc>
      </member>
      <member name="blue"
              value="4"
              c:identifier="COGL_COLOR_MASK_BLUE"
              glib:nick="blue">
        <doc xml:space="preserve">Masks the blue color channel</doc>
      </member>
      <member name="alpha"
              value="8"
              c:identifier="COGL_COLOR_MASK_ALPHA"
              glib:nick="alpha">
        <doc xml:space="preserve">Masks the alpha color channel</doc>
      </member>
      <member name="all"
              value="15"
              c:identifier="COGL_COLOR_MASK_ALL"
              glib:nick="all">
        <doc xml:space="preserve">All of the color channels are masked</doc>
      </member>
    </bitfield>
    <constant name="DEPTH_BIT" value="256" c:type="COGL_DEPTH_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="DepthTestFunction"
                 glib:type-name="CoglDepthTestFunction"
                 glib:get-type="cogl_depth_test_function_get_type"
                 c:type="CoglDepthTestFunction">
      <doc xml:space="preserve">When using depth testing one of these functions is used to compare
the depth of an incoming fragment against the depth value currently
stored in the depth buffer. The function is changed using
cogl_depth_state_set_test_function().

The test is only done when depth testing is explicitly enabled. (See
cogl_depth_state_set_test_enabled())</doc>
      <member name="never"
              value="512"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NEVER"
              glib:nick="never">
        <doc xml:space="preserve">Never passes.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LESS"
              glib:nick="less">
        <doc xml:space="preserve">Passes if the fragment's depth
value is less than the value currently in the depth buffer.</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_EQUAL"
              glib:nick="equal">
        <doc xml:space="preserve">Passes if the fragment's depth
value is equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LEQUAL"
              glib:nick="lequal">
        <doc xml:space="preserve">Passes if the fragment's depth
value is less or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GREATER"
              glib:nick="greater">
        <doc xml:space="preserve">Passes if the fragment's depth
value is greater than the value currently in the depth buffer.</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL"
              glib:nick="notequal">
        <doc xml:space="preserve">Passes if the fragment's depth
value is not equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GEQUAL"
              glib:nick="gequal">
        <doc xml:space="preserve">Passes if the fragment's depth
value greater than or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_ALWAYS"
              glib:nick="always">
        <doc xml:space="preserve">Always passes.</doc>
      </member>
    </enumeration>
    <record name="Euler" c:type="CoglEuler" disguised="1">
    </record>
    <constant name="FIXED_0_5"
              value="32768"
              c:type="COGL_FIXED_0_5"
              version="1.0">
      <doc xml:space="preserve">The number 0.5 expressed as a #CoglFixed number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_1" value="1" c:type="COGL_FIXED_1" version="1.0">
      <doc xml:space="preserve">The number 1 expressed as a #CoglFixed number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_2_PI"
              value="411775"
              c:type="COGL_FIXED_2_PI"
              version="1.0">
      <doc xml:space="preserve">Two times pi, expressed as a #CoglFixed number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_BITS"
              value="32"
              c:type="COGL_FIXED_BITS"
              version="1.0">
      <doc xml:space="preserve">Evaluates to the number of bits used by the #CoglFixed type.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_EPSILON"
              value="1"
              c:type="COGL_FIXED_EPSILON"
              version="1.0">
      <doc xml:space="preserve">A very small number expressed as a #CoglFixed number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_MAX"
              value="2147483647"
              c:type="COGL_FIXED_MAX"
              version="1.0">
      <doc xml:space="preserve">The biggest number representable using #CoglFixed</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_MIN"
              value="2147483648"
              c:type="COGL_FIXED_MIN"
              version="1.0">
      <doc xml:space="preserve">The smallest number representable using #CoglFixed</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_PI"
              value="205887"
              c:type="COGL_FIXED_PI"
              version="1.0">
      <doc xml:space="preserve">The number pi, expressed as a #CoglFixed number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_PI_2"
              value="102944"
              c:type="COGL_FIXED_PI_2"
              version="1.0">
      <doc xml:space="preserve">Half pi, expressed as a #CoglFixed number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_PI_4"
              value="51472"
              c:type="COGL_FIXED_PI_4"
              version="1.0">
      <doc xml:space="preserve">pi / 4, expressed as #CoglFixed number.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="FIXED_Q" value="-16" c:type="COGL_FIXED_Q" version="1.0">
      <doc xml:space="preserve">Evaluates to the number of bits used for the non-integer part
of the #CoglFixed type.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="FeatureFlags"
              version="0.8"
              glib:type-name="CoglFeatureFlags"
              glib:get-type="cogl_feature_flags_get_type"
              c:type="CoglFeatureFlags">
      <doc xml:space="preserve">Flags for the supported features.</doc>
      <member name="texture_rectangle"
              value="2"
              c:identifier="COGL_FEATURE_TEXTURE_RECTANGLE"
              glib:nick="texture-rectangle">
        <doc xml:space="preserve">ARB_texture_rectangle support</doc>
      </member>
      <member name="texture_npot"
              value="4"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT"
              glib:nick="texture-npot">
        <doc xml:space="preserve">Non power of two textures are supported
   by the hardware. This is a equivalent to the
   %COGL_FEATURE_TEXTURE_NPOT_BASIC, %COGL_FEATURE_TEXTURE_NPOT_MIPMAP
   and %COGL_FEATURE_TEXTURE_NPOT_REPEAT features combined.</doc>
      </member>
      <member name="texture_yuv"
              value="8"
              c:identifier="COGL_FEATURE_TEXTURE_YUV"
              glib:nick="texture-yuv">
        <doc xml:space="preserve">ycbcr conversion support</doc>
      </member>
      <member name="texture_read_pixels"
              value="16"
              c:identifier="COGL_FEATURE_TEXTURE_READ_PIXELS"
              glib:nick="texture-read-pixels">
        <doc xml:space="preserve">glReadPixels() support</doc>
      </member>
      <member name="shaders_glsl"
              value="32"
              c:identifier="COGL_FEATURE_SHADERS_GLSL"
              glib:nick="shaders-glsl">
        <doc xml:space="preserve">GLSL support</doc>
      </member>
      <member name="offscreen"
              value="64"
              c:identifier="COGL_FEATURE_OFFSCREEN"
              glib:nick="offscreen">
        <doc xml:space="preserve">FBO support</doc>
      </member>
      <member name="offscreen_multisample"
              value="128"
              c:identifier="COGL_FEATURE_OFFSCREEN_MULTISAMPLE"
              glib:nick="offscreen-multisample">
        <doc xml:space="preserve">Multisample support on FBOs</doc>
      </member>
      <member name="offscreen_blit"
              value="256"
              c:identifier="COGL_FEATURE_OFFSCREEN_BLIT"
              glib:nick="offscreen-blit">
        <doc xml:space="preserve">Blit support on FBOs</doc>
      </member>
      <member name="four_clip_planes"
              value="512"
              c:identifier="COGL_FEATURE_FOUR_CLIP_PLANES"
              glib:nick="four-clip-planes">
        <doc xml:space="preserve">At least 4 clip planes available</doc>
      </member>
      <member name="stencil_buffer"
              value="1024"
              c:identifier="COGL_FEATURE_STENCIL_BUFFER"
              glib:nick="stencil-buffer">
        <doc xml:space="preserve">Stencil buffer support</doc>
      </member>
      <member name="vbos"
              value="2048"
              c:identifier="COGL_FEATURE_VBOS"
              glib:nick="vbos">
        <doc xml:space="preserve">VBO support</doc>
      </member>
      <member name="pbos"
              value="4096"
              c:identifier="COGL_FEATURE_PBOS"
              glib:nick="pbos">
        <doc xml:space="preserve">PBO support</doc>
      </member>
      <member name="unsigned_int_indices"
              value="8192"
              c:identifier="COGL_FEATURE_UNSIGNED_INT_INDICES"
              glib:nick="unsigned-int-indices">
        <doc xml:space="preserve">Set if
    %COGL_INDICES_TYPE_UNSIGNED_INT is supported in
    cogl_vertex_buffer_indices_new().</doc>
      </member>
      <member name="depth_range"
              value="16384"
              c:identifier="COGL_FEATURE_DEPTH_RANGE"
              glib:nick="depth-range">
        <doc xml:space="preserve">cogl_material_set_depth_range() support</doc>
      </member>
      <member name="texture_npot_basic"
              value="32768"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_BASIC"
              glib:nick="texture-npot-basic">
        <doc xml:space="preserve">The hardware supports non power
    of two textures, but you also need to check the
    %COGL_FEATURE_TEXTURE_NPOT_MIPMAP and %COGL_FEATURE_TEXTURE_NPOT_REPEAT
    features to know if the hardware supports npot texture mipmaps
    or repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE respectively.</doc>
      </member>
      <member name="texture_npot_mipmap"
              value="65536"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_MIPMAP"
              glib:nick="texture-npot-mipmap">
        <doc xml:space="preserve">Mipmapping is supported in
    conjuntion with non power of two textures.</doc>
      </member>
      <member name="texture_npot_repeat"
              value="131072"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_REPEAT"
              glib:nick="texture-npot-repeat">
        <doc xml:space="preserve">Repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE are supported by the
    hardware.</doc>
      </member>
      <member name="point_sprite"
              value="262144"
              c:identifier="COGL_FEATURE_POINT_SPRITE"
              glib:nick="point-sprite">
        <doc xml:space="preserve">Whether
    cogl_material_set_layer_point_sprite_coords_enabled() is supported.</doc>
      </member>
      <member name="texture_3d"
              value="524288"
              c:identifier="COGL_FEATURE_TEXTURE_3D"
              glib:nick="texture-3d">
        <doc xml:space="preserve">3D texture support</doc>
      </member>
      <member name="shaders_arbfp"
              value="1048576"
              c:identifier="COGL_FEATURE_SHADERS_ARBFP"
              glib:nick="shaders-arbfp">
        <doc xml:space="preserve">ARBFP support</doc>
      </member>
      <member name="map_buffer_for_read"
              value="2097152"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_READ"
              glib:nick="map-buffer-for-read">
        <doc xml:space="preserve">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including read support.</doc>
      </member>
      <member name="map_buffer_for_write"
              value="4194304"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_WRITE"
              glib:nick="map-buffer-for-write">
        <doc xml:space="preserve">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including write support.</doc>
      </member>
      <member name="onscreen_multiple"
              value="8388608"
              c:identifier="COGL_FEATURE_ONSCREEN_MULTIPLE"
              glib:nick="onscreen-multiple">
      </member>
      <member name="depth_texture"
              value="16777216"
              c:identifier="COGL_FEATURE_DEPTH_TEXTURE"
              glib:nick="depth-texture">
        <doc xml:space="preserve">Whether #CoglFramebuffer support rendering the
    depth buffer to a texture.</doc>
      </member>
    </bitfield>
    <enumeration name="FilterReturn"
                 stability="Unstable"
                 c:type="CoglFilterReturn">
      <doc xml:space="preserve">Return values for the #CoglXlibFilterFunc and #CoglWin32FilterFunc functions.</doc>
      <member name="continue" value="0" c:identifier="COGL_FILTER_CONTINUE">
        <doc xml:space="preserve">The event was not handled, continues the
                       processing</doc>
      </member>
      <member name="remove" value="1" c:identifier="COGL_FILTER_REMOVE">
        <doc xml:space="preserve">Remove the event, stops the processing</doc>
      </member>
    </enumeration>
    <class name="Fixed"
           c:symbol-prefix="fixed"
           glib:type-name="CoglFixed"
           glib:get-type="cogl_fixed_get_type"
           glib:fundamental="1">
      <doc xml:space="preserve">Fixed point number using a (16.16) notation.</doc>
      <function name="log2"
                c:identifier="cogl_fixed_log2"
                version="1.0"
                introspectable="0">
        <doc xml:space="preserve">Calculates base 2 logarithm.

This function is some 2.5 times faster on x86, and over 12 times faster on
fpu-less arm, than using libc log().</doc>
        <return-value>
          <doc xml:space="preserve">base 2 logarithm.</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">value to calculate base 2 logarithm from</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </function>
      <function name="pow" c:identifier="cogl_fixed_pow" version="1.0">
        <doc xml:space="preserve">Calculates @x to the @y power.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the power of @x to the @y</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">base</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">#CoglFixed exponent</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </function>
      <method name="atan"
              c:identifier="cogl_fixed_atan"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Computes the arc tangent of @a.</doc>
        <return-value>
          <doc xml:space="preserve">the arc tangent of the passed value, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="atan2"
              c:identifier="cogl_fixed_atan2"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Computes the arc tangent of @a / @b but uses the sign of both
arguments to return the angle in right quadrant.</doc>
        <return-value>
          <doc xml:space="preserve">the arc tangent of the passed fraction, in fixed point
  notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">the numerator as a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">the denominator as a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="cos"
              c:identifier="cogl_fixed_cos"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Computes the cosine of @angle.</doc>
        <return-value>
          <doc xml:space="preserve">the cosine of the passed angle, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="div" c:identifier="cogl_fixed_div" introspectable="0">
        <return-value>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="mul" c:identifier="cogl_fixed_mul" introspectable="0">
        <return-value>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="mul_div"
              c:identifier="cogl_fixed_mul_div"
              introspectable="0">
        <return-value>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
          <parameter name="c" transfer-ownership="none">
            <type name="Fixed" c:type="CoglFixed"/>
          </parameter>
        </parameters>
      </method>
      <method name="pow2" c:identifier="cogl_fixed_pow2" version="1.0">
        <doc xml:space="preserve">Calculates 2 to the @x power.

This function is around 11 times faster on x86, and around 22 times faster
on fpu-less arm than libc pow(2, x).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the power of 2 to the passed value</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sin"
              c:identifier="cogl_fixed_sin"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Computes the sine of @angle.</doc>
        <return-value>
          <doc xml:space="preserve">the sine of the passed angle, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sqrt"
              c:identifier="cogl_fixed_sqrt"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Computes the square root of @x.</doc>
        <return-value>
          <doc xml:space="preserve">the square root of the passed value, in floating point
  notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="tan"
              c:identifier="cogl_fixed_tan"
              version="1.0"
              introspectable="0">
        <doc xml:space="preserve">Computes the tangent of @angle.</doc>
        <return-value>
          <doc xml:space="preserve">the tangent of the passed angle, in fixed point notation</doc>
          <type name="Fixed" c:type="CoglFixed"/>
        </return-value>
        <parameters>
          <instance-parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglFixed number</doc>
            <type name="Fixed" c:type="CoglFixed"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="FogMode"
                 version="1.0"
                 glib:type-name="CoglFogMode"
                 glib:get-type="cogl_fog_mode_get_type"
                 c:type="CoglFogMode">
      <doc xml:space="preserve">The fog mode determines the equation used to calculate the fogging blend
factor while fogging is enabled. The simplest %COGL_FOG_MODE_LINEAR mode
determines f as:

|[
  f = end - eye_distance / end - start
]|

Where eye_distance is the distance of the current fragment in eye
coordinates from the origin.</doc>
      <member name="linear"
              value="0"
              c:identifier="COGL_FOG_MODE_LINEAR"
              glib:nick="linear">
        <doc xml:space="preserve">Calculates the fog blend factor as:
|[
  f = end - eye_distance / end - start
]|</doc>
      </member>
      <member name="exponential"
              value="1"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL"
              glib:nick="exponential">
        <doc xml:space="preserve">Calculates the fog blend factor as:
|[
  f = e ^ -(density * eye_distance)
]|</doc>
      </member>
      <member name="exponential_squared"
              value="2"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL_SQUARED"
              glib:nick="exponential-squared">
        <doc xml:space="preserve">Calculates the fog blend factor as:
|[
  f = e ^ -(density * eye_distance)^2
]|</doc>
      </member>
    </enumeration>
    <callback name="FuncPtr" c:type="CoglFuncPtr">
      <doc xml:space="preserve">The type used by cogl for function pointers, note that this type
is used as a generic catch-all cast for function pointers and the
actual arguments and return type may be different.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <enumeration name="IndicesType"
                 glib:type-name="CoglIndicesType"
                 glib:get-type="cogl_indices_type_get_type"
                 c:type="CoglIndicesType">
      <doc xml:space="preserve">You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.

Note that %COGL_INDICES_TYPE_UNSIGNED_INT is only supported if the
%COGL_FEATURE_ID_UNSIGNED_INT_INDICES feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized.</doc>
      <member name="byte"
              value="0"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_BYTE"
              glib:nick="byte">
        <doc xml:space="preserve">Your indices are unsigned bytes</doc>
      </member>
      <member name="short"
              value="1"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_SHORT"
              glib:nick="short">
        <doc xml:space="preserve">Your indices are unsigned shorts</doc>
      </member>
      <member name="int"
              value="2"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_INT"
              glib:nick="int">
        <doc xml:space="preserve">Your indices are unsigned ints</doc>
      </member>
    </enumeration>
    <record name="Material" c:type="CoglMaterial" disguised="1">
      <method name="copy"
              c:identifier="cogl_material_copy"
              version="1.2"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Creates a new material with the configuration copied from the
source material.

We would strongly advise developers to always aim to use
cogl_material_copy() instead of cogl_material_new() whenever there will
be any similarity between two materials. Copying a material helps Cogl
keep track of a materials ancestry which we may use to help minimize GPU
state changes.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_copy() instead</doc-deprecated>
        <return-value>
          <doc xml:space="preserve">a pointer to the newly allocated #CoglMaterial</doc>
          <type name="Material" c:type="CoglMaterial*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglMaterial object to copy</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ambient"
              c:identifier="cogl_material_get_ambient"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the current ambient color for @material</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve">The location to store the ambient color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color"
              c:identifier="cogl_material_get_color"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the current material color.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_color() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">The location to store the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_diffuse"
              c:identifier="cogl_material_get_diffuse"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the current diffuse color for @material</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve">The location to store the diffuse color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_emission"
              c:identifier="cogl_material_get_emission"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the materials current emission color.</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve">The location to store the emission color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_point_sprite_coords_enabled"
              c:identifier="cogl_material_get_layer_point_sprite_coords_enabled"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Gets whether point sprite coordinate generation is enabled for this
texture layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_point_sprite_coords_enabled()
                 instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the texture coordinates will be replaced with
point sprite coordinates.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglHandle to a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to check.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_p"
              c:identifier="cogl_material_get_layer_wrap_mode_p"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Returns the wrap mode for the 'p' coordinate of texture lookups on this
layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_wrap_mode_p() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the wrap mode for the 'p' coordinate of texture lookups on
this layer.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_s"
              c:identifier="cogl_material_get_layer_wrap_mode_s"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Returns the wrap mode for the 's' coordinate of texture lookups on this
layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_wrap_mode_s() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the wrap mode for the 's' coordinate of texture lookups on
this layer.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_t"
              c:identifier="cogl_material_get_layer_wrap_mode_t"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Returns the wrap mode for the 't' coordinate of texture lookups on this
layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_layer_wrap_mode_t() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the wrap mode for the 't' coordinate of texture lookups on
this layer.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layers" c:identifier="cogl_material_get_layers">
        <doc xml:space="preserve">This function lets you access a material's internal list of layers
for iteration.

&lt;note&gt;You should avoid using this API if possible since it was only
made public by mistake and will be deprecated when we have
suitable alternative.&lt;/note&gt;

&lt;note&gt;It's important to understand that the list returned may not
remain valid if you modify the material or any of the layers in any
way and so you would have to re-get the list in that
situation.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A
   list of #CoglMaterialLayer&lt;!-- --&gt;'s that can be passed to the
   cogl_material_layer_* functions. The list is owned by Cogl and it
   should not be modified or freed
   Deprecated: 1.16: Use cogl_pipeline_get_layers() instead</doc>
          <type name="GLib.List" c:type="const GList*">
            <type name="MaterialLayer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_layers"
              c:identifier="cogl_material_get_n_layers"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the number of layers defined for the given @material</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_n_layers() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of layers</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point_size"
              c:identifier="cogl_material_get_point_size"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Get the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_point_size() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the point size of the material.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglHandle to a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shininess"
              c:identifier="cogl_material_get_shininess"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the materials current emission color.</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The materials current shininess value</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specular"
              c:identifier="cogl_material_get_specular"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the materials current specular color.</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve">The location to store the specular color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_program"
              c:identifier="cogl_material_get_user_program"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Queries what user program has been associated with the given
@material using cogl_material_set_user_program().</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current user program
  or %COGL_INVALID_HANDLE.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglMaterial object.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_layer"
              c:identifier="cogl_material_remove_layer"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">This function removes a layer from your material</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_remove_layer() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">Specifies the layer you want to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_test_function"
              c:identifier="cogl_material_set_alpha_test_function"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.

The default is %COGL_MATERIAL_ALPHA_FUNC_ALWAYS</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_alpha_test_function() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="alpha_func" transfer-ownership="none">
            <doc xml:space="preserve">A @CoglMaterialAlphaFunc constant</doc>
            <type name="MaterialAlphaFunc" c:type="CoglMaterialAlphaFunc"/>
          </parameter>
          <parameter name="alpha_reference" transfer-ownership="none">
            <doc xml:space="preserve">A reference point that the chosen alpha function uses
  to compare incoming fragments to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient"
              c:identifier="cogl_material_set_ambient"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the material's ambient color, in the standard OpenGL lighting
model. The ambient color affects the overall color of the object.

Since the diffuse color will be intense when the light hits the surface
directly, the ambient will be most apparent where the light hits at a
slant.

The default value is (0.2, 0.2, 0.2, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve">The components of the desired ambient color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient_and_diffuse"
              c:identifier="cogl_material_set_ambient_and_diffuse"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Conveniently sets the diffuse and ambient color of @material at the same
time. See cogl_material_set_ambient() and cogl_material_set_diffuse().

The default ambient color is (0.2, 0.2, 0.2, 1.0)

The default diffuse color is (0.8, 0.8, 0.8, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">The components of the desired ambient and diffuse colors</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend"
              c:identifier="cogl_material_set_blend"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16"
              throws="1">
        <doc xml:space="preserve">If not already familiar; please refer &lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt;
for an overview of what blend strings are, and their syntax.

Blending occurs after the alpha test function, and combines fragments with
the framebuffer.

Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:

|[
  &amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
]|

&lt;warning&gt;The brackets around blend factors are currently not
optional!&lt;/warning&gt;

This is the list of source-names usable as blend factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;SRC_COLOR: The color of the in comming fragment&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;DST_COLOR: The color of the framebuffer&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;CONSTANT: The constant set via cogl_material_set_blend_constant()&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The source names can be used according to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source and factor syntax&lt;/link&gt;,
so for example "(1-SRC_COLOR[A])" would be a valid factor, as would
"(CONSTANT[RGB])"

These can also be used as factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;0: (0, 0, 0, 0)&lt;/listitem&gt;
  &lt;listitem&gt;1: (1, 1, 1, 1)&lt;/listitem&gt;
  &lt;listitem&gt;SRC_ALPHA_SATURATE_FACTOR: (f,f,f,1) where f = MIN(SRC_COLOR[A],1-DST_COLOR[A])&lt;/listitem&gt;
&lt;/itemizedlist&gt;

&lt;note&gt;Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.&lt;/note&gt;

&lt;example id="cogl-Blend-Strings-blend-unpremul"&gt;
  &lt;title&gt;Blend Strings/1&lt;/title&gt;
  &lt;para&gt;Blend a non-premultiplied source over a destination with
  premultiplied alpha:&lt;/para&gt;
  &lt;programlisting&gt;
"RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
"A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

&lt;example id="cogl-Blend-Strings-blend-premul"&gt;
  &lt;title&gt;Blend Strings/2&lt;/title&gt;
  &lt;para&gt;Blend a premultiplied source over a destination with
  premultiplied alpha&lt;/para&gt;
  &lt;programlisting&gt;
"RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

The default blend string is:
|[
   RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
]|

That gives normal alpha-blending when the calculated color for the material
is in premultiplied form.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_blend() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the blend string was successfully parsed, and the
  described blending is supported by the underlying driver/hardware. If
  there was an error, %FALSE is returned and @error is set accordingly (if
  present).</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
  describing the desired blend function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend_constant"
              c:identifier="cogl_material_set_blend_constant"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_blend_constant() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="constant_color" transfer-ownership="none">
            <doc xml:space="preserve">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color"
              c:identifier="cogl_material_set_color"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the basic color of the material, used when no lighting is enabled.

Note that if you don't add any layers to the material then the color
will be blended unmodified with the destination; the default blend
expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
semi-transparent red. See cogl_color_premultiply().

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_color() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">The components of the color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4f"
              c:identifier="cogl_material_set_color4f"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the basic color of the material, used when no lighting is enabled.

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_color4f() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">The red component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">The green component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">The blue component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">The alpha component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4ub"
              c:identifier="cogl_material_set_color4ub"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the basic color of the material, used when no lighting is enabled.

The default value is (0xff, 0xff, 0xff, 0xff)</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_color4ub() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">The red component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">The green component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">The blue component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">The alpha component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_diffuse"
              c:identifier="cogl_material_set_diffuse"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the material's diffuse color, in the standard OpenGL lighting
model. The diffuse color is most intense where the light hits the
surface directly - perpendicular to the surface.

The default value is (0.8, 0.8, 0.8, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve">The components of the desired diffuse color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_emission"
              c:identifier="cogl_material_set_emission"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the material's emissive color, in the standard OpenGL lighting
model. It will look like the surface is a light source emitting this
color.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve">The components of the desired emissive color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer"
              c:identifier="cogl_material_set_layer"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">In addition to the standard OpenGL lighting model a Cogl material may have
one or more layers comprised of textures that can be blended together in
order, with a number of different texture combine modes. This function
defines a new texture layer.

The index values of multiple layers do not have to be consecutive; it is
only their relative order that is important.

&lt;note&gt;In the future, we may define other types of material layers, such
as purely GLSL based layers.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the index of the layer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglHandle for the layer object</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine"
              c:identifier="cogl_material_set_layer_combine"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16"
              throws="1">
        <doc xml:space="preserve">If not already familiar; you can refer
&lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt; for an overview of what blend
strings are and there syntax.

These are all the functions available for texture combining:
&lt;itemizedlist&gt;
  &lt;listitem&gt;REPLACE(arg0) = arg0&lt;/listitem&gt;
  &lt;listitem&gt;MODULATE(arg0, arg1) = arg0 x arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD(arg0, arg1) = arg0 + arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5&lt;/listitem&gt;
  &lt;listitem&gt;INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)&lt;/listitem&gt;
  &lt;listitem&gt;SUBTRACT(arg0, arg1) = arg0 - arg1&lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                             (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                             (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                              (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                              (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;

Refer to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source syntax&lt;/link&gt; for
describing the arguments. The valid source names for texture combining
are:
&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE&lt;/term&gt;
    &lt;listitem&gt;Use the color from the current texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE_0, TEXTURE_1, etc&lt;/term&gt;
    &lt;listitem&gt;Use the color from the specified texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;CONSTANT&lt;/term&gt;
    &lt;listitem&gt;Use the color from the constant given with
    cogl_material_set_layer_constant()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PRIMARY&lt;/term&gt;
    &lt;listitem&gt;Use the color of the material as set with
    cogl_material_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PREVIOUS&lt;/term&gt;
    &lt;listitem&gt;Either use the texture color from the previous layer, or
    if this is layer 0, use the color of the material as set with
    cogl_material_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

&lt;refsect2 id="cogl-Layer-Combine-Examples"&gt;
  &lt;title&gt;Layer Combine Examples&lt;/title&gt;
  &lt;para&gt;This is effectively what the default blending is:&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = MODULATE (PREVIOUS, TEXTURE)
  &lt;/programlisting&gt;&lt;/informalexample&gt;
  &lt;para&gt;This could be used to cross-fade between two images, using
  the alpha component of a constant as the interpolator. The constant
  color is given by calling cogl_material_set_layer_constant.&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
  &lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;/refsect2&gt;

&lt;note&gt;You can't give a multiplication factor for arguments as you can
with blending.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_combine() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the blend string was successfully parsed, and the
  described texture combining is supported by the underlying driver and
  or hardware. On failure, %FALSE is returned and @error is set</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">Specifies the layer you want define a combine function for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
   describing the desired texture combine function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine_constant"
              c:identifier="cogl_material_set_layer_combine_constant"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">When you are using the 'CONSTANT' color source in a layer combine
description then you can use this function to define its value.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_combine_constant()
instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">Specifies the layer you want to specify a constant used
              for texture combining</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:space="preserve">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_filters"
              c:identifier="cogl_material_set_layer_filters"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_filters() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:space="preserve">the filter used when scaling a texture down.</doc>
            <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:space="preserve">the filter used when magnifying a texture.</doc>
            <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_matrix"
              c:identifier="cogl_material_set_layer_matrix"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a material used to fill your geometry.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_matrix() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the index for the layer inside @material</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">the transformation matrix for the layer</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_point_sprite_coords_enabled"
              c:identifier="cogl_material_set_layer_point_sprite_coords_enabled"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16"
              throws="1">
        <doc xml:space="preserve">When rendering points, if @enable is %TRUE then the texture
coordinates for this layer will be replaced with coordinates that
vary from 0.0 to 1.0 across the primitive. The top left of the
point will have the coordinates 0.0,0.0 and the bottom right will
have 1.0,1.0. If @enable is %FALSE then the coordinates will be
fixed for the entire point.

This function will only work if %COGL_FEATURE_POINT_SPRITE is
available. If the feature is not available then the function will
return %FALSE and set @error.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_point_sprite_coords_enabled()
                 instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the function succeeds, %FALSE otherwise.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglHandle to a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve">whether to enable point sprite coord generation.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode"
              c:identifier="cogl_material_set_layer_wrap_mode"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the wrap mode for all three coordinates of texture lookups on
this layer. This is equivalent to calling
cogl_material_set_layer_wrap_mode_s(),
cogl_material_set_layer_wrap_mode_t() and
cogl_material_set_layer_wrap_mode_p() separately.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_p"
              c:identifier="cogl_material_set_layer_wrap_mode_p"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode_p() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_s"
              c:identifier="cogl_material_set_layer_wrap_mode_s"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode_s() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_t"
              c:identifier="cogl_material_set_layer_wrap_mode_t"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_layer_wrap_mode_t() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the new wrap mode</doc>
            <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_point_size"
              c:identifier="cogl_material_set_point_size"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API. Note that typically the GPU will
only support a limited minimum and maximum range of point sizes. If
the chosen point size is outside that range then the nearest value
within that range will be used instead. The size of a point is in
screen space so it will be the same regardless of any
transformations. The default point size is 1.0.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_point_size() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a material.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="point_size" transfer-ownership="none">
            <doc xml:space="preserve">the new point size.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_shininess"
              c:identifier="cogl_material_set_shininess"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the shininess of the material, in the standard OpenGL lighting
model, which determines the size of the specular highlights. A
higher @shininess will produce smaller highlights which makes the
object appear more shiny.

The default value is 0.0</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="shininess" transfer-ownership="none">
            <doc xml:space="preserve">The desired shininess; must be &gt;= 0.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_specular"
              c:identifier="cogl_material_set_specular"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Sets the material's specular color, in the standard OpenGL lighting
model. The intensity of the specular color depends on the viewport
position, and is brightest along the lines of reflection.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <doc-deprecated xml:space="preserve">Use the #CoglSnippet shader api for lighting</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterial object</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve">The components of the desired specular color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_program"
              c:identifier="cogl_material_set_user_program"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Associates a linked CoglProgram with the given material so that the
program can take full control of vertex and/or fragment processing.

This is an example of how it can be used to associate an ARBfp
program with a #CoglMaterial:
|[
CoglHandle shader;
CoglHandle program;
CoglMaterial *material;

shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
cogl_shader_source (shader,
                    "!!ARBfp1.0\n"
                    "MOV result.color,fragment.color;\n"
                    "END\n");
cogl_shader_compile (shader);

program = cogl_create_program ();
cogl_program_attach_shader (program, shader);
cogl_program_link (program);

material = cogl_material_new ();
cogl_material_set_user_program (material, program);

cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
cogl_rectangle (0, 0, 100, 100);
]|

It is possibly worth keeping in mind that this API is not part of
the long term design for how we want to expose shaders to Cogl
developers (We are planning on deprecating the cogl_program and
cogl_shader APIs in favour of a "snippet" framework) but in the
meantime we hope this will handle most practical GLSL and ARBfp
requirements.

Also remember you need to check for either the
%COGL_FEATURE_SHADERS_GLSL or %COGL_FEATURE_SHADERS_ARBFP before
using the cogl_program or cogl_shader API.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglMaterial object.</doc>
            <type name="Material" c:type="CoglMaterial*"/>
          </instance-parameter>
          <parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglHandle to a linked CoglProgram</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="cogl_material_new"
                introspectable="0"
                deprecated="1"
                deprecated-version="1.16">
        <doc xml:space="preserve">Allocates and initializes a blank white material</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_new() instead</doc-deprecated>
        <return-value>
          <doc xml:space="preserve">a pointer to a new #CoglMaterial</doc>
          <type name="Material" c:type="CoglMaterial*"/>
        </return-value>
      </function>
      <function name="ref"
                c:identifier="cogl_material_ref"
                version="1.0"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Increment the reference count for a #CoglMaterial.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the @material.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglMaterial object.</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_material_unref"
                version="1.0"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Decrement the reference count for a #CoglMaterial.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="material" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglMaterial object.</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="MaterialAlphaFunc"
                 glib:type-name="CoglMaterialAlphaFunc"
                 glib:get-type="cogl_material_alpha_func_get_type"
                 c:type="CoglMaterialAlphaFunc">
      <doc xml:space="preserve">Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglMaterialAlphaFunc
determines how the comparison is done.</doc>
      <member name="never"
              value="512"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NEVER"
              glib:nick="never">
        <doc xml:space="preserve">Never let the fragment through.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LESS"
              glib:nick="less">
        <doc xml:space="preserve">Let the fragment through if the incoming
  alpha value is less than the reference alpha value</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_EQUAL"
              glib:nick="equal">
        <doc xml:space="preserve">Let the fragment through if the incoming
  alpha value equals the reference alpha value</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LEQUAL"
              glib:nick="lequal">
        <doc xml:space="preserve">Let the fragment through if the incoming
  alpha value is less than or equal to the reference alpha value</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GREATER"
              glib:nick="greater">
        <doc xml:space="preserve">Let the fragment through if the incoming
  alpha value is greater than the reference alpha value</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL"
              glib:nick="notequal">
        <doc xml:space="preserve">Let the fragment through if the incoming
  alpha value does not equal the reference alpha value</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GEQUAL"
              glib:nick="gequal">
        <doc xml:space="preserve">Let the fragment through if the incoming
  alpha value is greater than or equal to the reference alpha value.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_ALWAYS"
              glib:nick="always">
        <doc xml:space="preserve">Always let the fragment through.</doc>
      </member>
    </enumeration>
    <enumeration name="MaterialFilter"
                 glib:type-name="CoglMaterialFilter"
                 glib:get-type="cogl_material_filter_get_type"
                 c:type="CoglMaterialFilter">
      <doc xml:space="preserve">Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel.</doc>
      <member name="nearest"
              value="9728"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST"
              glib:nick="nearest">
        <doc xml:space="preserve">Measuring in manhatten distance from the,
  current pixel center, use the nearest texture texel</doc>
      </member>
      <member name="linear"
              value="9729"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR"
              glib:nick="linear">
        <doc xml:space="preserve">Use the weighted average of the 4 texels
  nearest the current pixel center</doc>
      </member>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST"
              glib:nick="nearest-mipmap-nearest">
        <doc xml:space="preserve">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_MATERIAL_FILTER_NEAREST criterion</doc>
      </member>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST"
              glib:nick="linear-mipmap-nearest">
        <doc xml:space="preserve">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_MATERIAL_FILTER_LINEAR criterion</doc>
      </member>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR"
              glib:nick="nearest-mipmap-linear">
        <doc xml:space="preserve">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_MATERIAL_FILTER_NEAREST criterion on each one and take
  their weighted average</doc>
      </member>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR"
              glib:nick="linear-mipmap-linear">
        <doc xml:space="preserve">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_MATERIAL_FILTER_LINEAR criterion on each one and take
  their weighted average</doc>
      </member>
    </enumeration>
    <record name="MaterialLayer" c:type="CoglMaterialLayer" disguised="1">
      <method name="get_mag_filter"
              c:identifier="cogl_material_layer_get_mag_filter"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Queries the currently set downscaling filter for a material later</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current downscaling filter</doc>
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_filter"
              c:identifier="cogl_material_layer_get_min_filter"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Queries the currently set downscaling filter for a material layer</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the current downscaling filter</doc>
          <type name="MaterialFilter" c:type="CoglMaterialFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglHandle for a material layer</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_texture"
              c:identifier="cogl_material_layer_get_texture"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Extracts a texture handle for a specific layer.

&lt;note&gt;In the future Cogl may support purely GLSL based layers; for those
layers this function which will likely return %COGL_INVALID_HANDLE if you
try to get the texture handle from them. Considering this scenario, you
should call cogl_material_layer_get_type() first in order check it is of
type %COGL_MATERIAL_LAYER_TYPE_TEXTURE before calling this function.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle for the texture inside the layer</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type"
              c:identifier="cogl_material_layer_get_type"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Retrieves the type of the layer

Currently there is only one type of layer defined:
%COGL_MATERIAL_LAYER_TYPE_TEXTURE, but considering we may add purely GLSL
based layers in the future, you should write code that checks the type
first.</doc>
        <doc-deprecated xml:space="preserve">No replacement</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the type of the layer</doc>
          <type name="MaterialLayerType" c:type="CoglMaterialLayerType"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wrap_mode_p"
              c:identifier="cogl_material_layer_get_wrap_mode_p"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Gets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_layer_get_wrap_mode_p() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the wrap mode value for the p coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wrap_mode_s"
              c:identifier="cogl_material_layer_get_wrap_mode_s"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Gets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_layer_get_wrap_mode_s() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the wrap mode value for the s coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_wrap_mode_t"
              c:identifier="cogl_material_layer_get_wrap_mode_t"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve">Gets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_pipeline_layer_get_wrap_mode_t() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the wrap mode value for the t coordinate.</doc>
          <type name="MaterialWrapMode" c:type="CoglMaterialWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMaterialLayer object</doc>
            <type name="MaterialLayer" c:type="CoglMaterialLayer*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="MaterialLayerType"
                 version="1.0"
                 glib:type-name="CoglMaterialLayerType"
                 glib:get-type="cogl_material_layer_type_get_type"
                 c:type="CoglMaterialLayerType">
      <doc xml:space="preserve">Available types of layers for a #CoglMaterial. This enumeration
might be expanded in later versions.</doc>
      <member name="texture"
              value="0"
              c:identifier="COGL_MATERIAL_LAYER_TYPE_TEXTURE"
              glib:nick="texture">
        <doc xml:space="preserve">The layer represents a
  &lt;link linkend="cogl-Textures"&gt;texture&lt;/link&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="MaterialWrapMode"
                 version="1.4"
                 glib:type-name="CoglMaterialWrapMode"
                 glib:get-type="cogl_material_wrap_mode_get_type"
                 c:type="CoglMaterialWrapMode">
      <doc xml:space="preserve">The wrap mode specifies what happens when texture coordinates
outside the range 01 are used. Note that if the filter mode is
anything but %COGL_MATERIAL_FILTER_NEAREST then texels outside the
range 01 might be used even when the coordinate is exactly 0 or 1
because OpenGL will try to sample neighbouring pixels. For example
if you are trying to render the full texture then you may get
artifacts around the edges when the pixels from the other side are
merged in if the wrap mode is set to repeat.</doc>
      <member name="repeat"
              value="10497"
              c:identifier="COGL_MATERIAL_WRAP_MODE_REPEAT"
              glib:nick="repeat">
        <doc xml:space="preserve">The texture will be repeated. This
  is useful for example to draw a tiled background.</doc>
      </member>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE"
              glib:nick="clamp-to-edge">
        <doc xml:space="preserve">The coordinates outside the
  range 01 will sample copies of the edge pixels of the
  texture. This is useful to avoid artifacts if only one copy of
  the texture is being rendered.</doc>
      </member>
      <member name="automatic"
              value="519"
              c:identifier="COGL_MATERIAL_WRAP_MODE_AUTOMATIC"
              glib:nick="automatic">
        <doc xml:space="preserve">Cogl will try to automatically
  decide which of the above two to use. For cogl_rectangle(), it
  will use repeat mode if any of the texture coordinates are
  outside the range 01, otherwise it will use clamp to edge. For
  cogl_polygon() it will always use repeat mode. For
  cogl_vertex_buffer_draw() it will use repeat mode except for
  layers that have point sprite coordinate generation enabled. This
  is the default value.</doc>
      </member>
    </enumeration>
    <record name="Matrix"
            c:type="CoglMatrix"
            glib:type-name="CoglMatrix"
            glib:get-type="cogl_matrix_get_gtype"
            c:symbol-prefix="matrix">
      <doc xml:space="preserve">A CoglMatrix holds a 4x4 transform matrix. This is a single precision,
column-major matrix which means it is compatible with what OpenGL expects.

A CoglMatrix can represent transforms such as, rotations, scaling,
translation, sheering, and linear projections. You can combine these
transforms by multiplying multiple matrices in the order you want them
applied.

The transformation of a vertex (x, y, z, w) by a CoglMatrix is given by:

|[
  x_new = xx * x + xy * y + xz * z + xw * w
  y_new = yx * x + yy * y + yz * z + yw * w
  z_new = zx * x + zy * y + zz * z + zw * w
  w_new = wx * x + wy * y + wz * z + ww * w
]|

Where w is normally 1

&lt;note&gt;You must consider the members of the CoglMatrix structure read only,
and all matrix modifications must be done via the cogl_matrix API. This
allows Cogl to annotate the matrices internally. Violation of this will give
undefined results. If you need to initialize a matrix with a constant other
than the identity matrix you can use cogl_matrix_init_from_array().&lt;/note&gt;</doc>
      <field name="xx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ww" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="private_member_inv" readable="0" private="1">
        <array zero-terminated="0" c:type="float" fixed-size="16">
          <type name="gfloat" c:type="float"/>
        </array>
      </field>
      <field name="private_member_type" readable="0" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="private_member_flags" readable="0" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <field name="private_member__padding3" readable="0" private="1">
        <type name="guint" c:type="unsigned"/>
      </field>
      <method name="copy" c:identifier="cogl_matrix_copy" version="1.6">
        <doc xml:space="preserve">Allocates a new #CoglMatrix on the heap and initializes it with
the same values as @matrix.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #CoglMatrix which
should be freed using cogl_matrix_free()</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix you want to copy</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_matrix_free" version="1.6">
        <doc xml:space="preserve">Frees a #CoglMatrix that was previously allocated via a call to
cogl_matrix_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix you want to free</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="frustum" c:identifier="cogl_matrix_frustum">
        <doc xml:space="preserve">Multiplies @matrix by the given frustum perspective matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array" c:identifier="cogl_matrix_get_array">
        <doc xml:space="preserve">Casts @matrix to a float array which can be directly passed to OpenGL.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the float array</doc>
          <type name="gfloat" c:type="const float*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_inverse"
              c:identifier="cogl_matrix_get_inverse"
              version="1.2">
        <doc xml:space="preserve">Gets the inverse transform of a given matrix and uses it to initialize
a new #CoglMatrix.

&lt;note&gt;Although the first parameter is annotated as const to indicate
that the transform it represents isn't modified this function may
technically save a copy of the inverse transform within the given
#CoglMatrix so that subsequent requests for the inverse transform may
avoid costly inversion calculations.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the inverse was successfully calculated or %FALSE
  for degenerate transformations that can't be inverted (in this case the
  @inverse matrix will simply be initialized with the identity matrix)</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="inverse"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">The destination for a 4x4 inverse transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_array"
              c:identifier="cogl_matrix_init_from_array">
        <doc xml:space="preserve">Initializes @matrix with the contents of @array</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve">A linear array of 16 floats (column-major order)</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity" c:identifier="cogl_matrix_init_identity">
        <doc xml:space="preserve">Resets matrix to the identity matrix:

|[
  .xx=1; .xy=0; .xz=0; .xw=0;
  .yx=0; .yy=1; .yz=0; .yw=0;
  .zx=0; .zy=0; .zz=1; .zw=0;
  .wx=0; .wy=0; .wz=0; .ww=1;
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_translation"
              c:identifier="cogl_matrix_init_translation"
              version="2.0">
        <doc xml:space="preserve">Resets matrix to the (tx, ty, tz) translation matrix:

|[
  .xx=1; .xy=0; .xz=0; .xw=tx;
  .yx=0; .yy=1; .yz=0; .yw=ty;
  .zx=0; .zy=0; .zz=1; .zw=tz;
  .wx=0; .wy=0; .wz=0; .ww=1;
]|</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="tx" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="ty" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve">z coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_identity"
              c:identifier="cogl_matrix_is_identity"
              version="1.8">
        <doc xml:space="preserve">Determines if the given matrix is an identity matrix.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @matrix is an identity matrix else %FALSE</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMatrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="look_at"
              c:identifier="cogl_matrix_look_at"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve">Applies a view transform @matrix that positions the camera at
the coordinate (@eye_position_x, @eye_position_y, @eye_position_z)
looking towards an object at the coordinate (@object_x, @object_y,
@object_z). The top of the camera is aligned to the given world up
vector, which is normally simply (0, 1, 0) to map up to the
positive direction of the y axis.

Because there is a lot of missleading documentation online for
gluLookAt regarding the up vector we want to try and be a bit
clearer here.

The up vector should simply be relative to your world coordinates
and does not need to change as you move the eye and object
positions.  Many online sources may claim that the up vector needs
to be perpendicular to the vector between the eye and object
position (partly because the man page is somewhat missleading) but
that is not necessary for this function.

&lt;note&gt;You should never look directly along the world-up
vector.&lt;/note&gt;

&lt;note&gt;It is assumed you are using a typical projection matrix where
your origin maps to the center of your viewport.&lt;/note&gt;

&lt;note&gt;Almost always when you use this function it should be the first
transform applied to a new modelview transform&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="eye_position_x" transfer-ownership="none">
            <doc xml:space="preserve">The X coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_y" transfer-ownership="none">
            <doc xml:space="preserve">The Y coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_z" transfer-ownership="none">
            <doc xml:space="preserve">The Z coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_x" transfer-ownership="none">
            <doc xml:space="preserve">The X coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_y" transfer-ownership="none">
            <doc xml:space="preserve">The Y coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_z" transfer-ownership="none">
            <doc xml:space="preserve">The Z coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_x" transfer-ownership="none">
            <doc xml:space="preserve">The X component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_y" transfer-ownership="none">
            <doc xml:space="preserve">The Y component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_z" transfer-ownership="none">
            <doc xml:space="preserve">The Z component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="cogl_matrix_multiply">
        <doc xml:space="preserve">Multiplies the two supplied matrices together and stores
the resulting matrix inside @result.

&lt;note&gt;It is possible to multiply the @a matrix in-place, so
@result can be equal to @a but can't be equal to @b.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">The address of a 4x4 matrix to store the result in</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ortho"
              c:identifier="cogl_matrix_ortho"
              deprecated="1"
              deprecated-version="1.10">
        <doc xml:space="preserve">Multiplies @matrix by a parallel projection matrix.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_matrix_orthographic()</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">The coordinate for the left clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">The coordinate for the right clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve">The coordinate for the bottom clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve">The coordinate for the top clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="cogl_matrix_perspective">
        <doc xml:space="preserve">Multiplies @matrix by the described perspective matrix

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_matrix_rotate">
        <doc xml:space="preserve">Multiplies @matrix with a rotation matrix that applies a rotation
of @angle degrees around the specified 3D vector.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve">The angle you want to rotate in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">X component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">Y component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">Z component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_matrix_scale">
        <doc xml:space="preserve">Multiplies @matrix with a transform matrix that scales along the X,
Y and Z axis.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="sx" transfer-ownership="none">
            <doc xml:space="preserve">The X scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <doc xml:space="preserve">The Y scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sz" transfer-ownership="none">
            <doc xml:space="preserve">The Z scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="cogl_matrix_transform_point">
        <doc xml:space="preserve">Transforms a point whos position is given and returned as four float
components.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The X component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="y"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The Y component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="z"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The Z component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="w"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The W component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_matrix_translate">
        <doc xml:space="preserve">Multiplies @matrix with a transform matrix that translates along
the X, Y and Z axis.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">The X translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">The Y translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">The Z translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transpose"
              c:identifier="cogl_matrix_transpose"
              version="1.10">
        <doc xml:space="preserve">Replaces @matrix with its transpose. Ie, every element (i,j) in the
new matrix is taken from element (j,i) in the old matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglMatrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_matrix_equal" version="1.4">
        <doc xml:space="preserve">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
        <return-value transfer-ownership="none">
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="Offscreen"
           c:symbol-prefix="offscreen"
           c:type="CoglOffscreen"
           glib:type-name="CoglOffscreen"
           glib:get-type="cogl_offscreen_get_gtype"
           glib:fundamental="1">
      <constructor name="new_to_texture"
                   c:identifier="cogl_offscreen_new_to_texture"
                   deprecated="1"
                   deprecated-version="1.16">
        <doc xml:space="preserve">This creates an offscreen buffer object using the given @texture as the
primary color buffer. It doesn't just initialize the contents of the
offscreen buffer with the @texture; they are tightly bound so that
drawing to the offscreen buffer effectivly updates the contents of the
given texture. You don't need to destroy the offscreen buffer before
you can use the @texture again.

&lt;note&gt;This only works with low-level #CoglTexture types such as
#CoglTexture2D, #CoglTexture3D and #CoglTextureRectangle, and not
with meta-texture types such as #CoglTexture2DSliced.&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use cogl_offscreen_new_with_texture instead.</doc-deprecated>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly instantiated #CoglOffscreen
  framebuffer or %NULL if it wasn't possible to create the
  buffer.</doc>
          <type name="Offscreen" c:type="CoglOffscreen*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_texture"
                   c:identifier="cogl_offscreen_new_with_texture">
        <doc xml:space="preserve">This creates an offscreen framebuffer object using the given
@texture as the primary color buffer. It doesn't just initialize
the contents of the offscreen buffer with the @texture; they are
tightly bound so that drawing to the offscreen buffer effectively
updates the contents of the given texture. You don't need to
destroy the offscreen buffer before you can use the @texture again.

&lt;note&gt;This api only works with low-level #CoglTexture types such as
#CoglTexture2D, #CoglTexture3D and #CoglTextureRectangle, and not
with meta-texture types such as #CoglTexture2DSliced.&lt;/note&gt;

The storage for the framebuffer is actually allocated lazily
so this function will never return %NULL to indicate a runtime
error. This means it is still possible to configure the framebuffer
before it is really allocated.

Simple applications without full error handling can simply rely on
Cogl to lazily allocate the storage of framebuffers but you should
be aware that if Cogl encounters an error (such as running out of
GPU memory) then your application will simply abort with an error
message. If you need to be able to catch such exceptions at runtime
then you can explicitly allocate your framebuffer when you have
finished configuring it by calling cogl_framebuffer_allocate() and
passing in a #CoglError argument to catch any exceptions.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly instantiated #CoglOffscreen
  framebuffer.</doc>
          <type name="Offscreen" c:type="CoglOffscreen*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="ref"
                c:identifier="cogl_offscreen_ref"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Increments the reference count on the @offscreen framebuffer.</doc>
        <doc-deprecated xml:space="preserve">cogl_object_ref() should be used in new code.</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">For convenience it returns the
                               given @offscreen</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="offscreen"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to a #CoglOffscreen framebuffer</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_offscreen_unref"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Decreases the reference count for the @offscreen buffer and frees it when
the count reaches 0.</doc>
        <doc-deprecated xml:space="preserve">cogl_object_unref() should be used in new code.</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="offscreen"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A pointer to a #CoglOffscreen framebuffer</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <constant name="PREMULT_BIT" value="128" c:type="COGL_PREMULT_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="PixelFormat"
                 version="0.8"
                 glib:type-name="CoglPixelFormat"
                 glib:get-type="cogl_pixel_format_get_type"
                 c:type="CoglPixelFormat">
      <doc xml:space="preserve">Pixel formats used by Cogl. For the formats with a byte per
component, the order of the components specify the order in
increasing memory addresses. So for example
%COGL_PIXEL_FORMAT_RGB_888 would have the red component in the
lowest address, green in the next address and blue after that
regardless of the endianness of the system.

For the formats with non byte aligned components the component
order specifies the order within a 16-bit or 32-bit number from
most significant bit to least significant. So for
%COGL_PIXEL_FORMAT_RGB_565, the red component would be in bits
11-15, the green component would be in 6-11 and the blue component
would be in 1-5. Therefore the order in memory depends on the
endianness of the system.

When uploading a texture %COGL_PIXEL_FORMAT_ANY can be used as the
internal format. Cogl will try to pick the best format to use
internally and convert the texture data if necessary.</doc>
      <member name="any"
              value="0"
              c:identifier="COGL_PIXEL_FORMAT_ANY"
              glib:nick="any">
        <doc xml:space="preserve">Any format</doc>
      </member>
      <member name="a_8"
              value="17"
              c:identifier="COGL_PIXEL_FORMAT_A_8"
              glib:nick="a-8">
        <doc xml:space="preserve">8 bits alpha mask</doc>
      </member>
      <member name="rgb_565"
              value="4"
              c:identifier="COGL_PIXEL_FORMAT_RGB_565"
              glib:nick="rgb-565">
        <doc xml:space="preserve">RGB, 16 bits</doc>
      </member>
      <member name="rgba_4444"
              value="21"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444"
              glib:nick="rgba-4444">
        <doc xml:space="preserve">RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551"
              value="22"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551"
              glib:nick="rgba-5551">
        <doc xml:space="preserve">RGBA, 16 bits</doc>
      </member>
      <member name="yuv"
              value="7"
              c:identifier="COGL_PIXEL_FORMAT_YUV"
              glib:nick="yuv">
        <doc xml:space="preserve">Not currently supported</doc>
      </member>
      <member name="g_8"
              value="8"
              c:identifier="COGL_PIXEL_FORMAT_G_8"
              glib:nick="g-8">
        <doc xml:space="preserve">Single luminance component</doc>
      </member>
      <member name="rg_88"
              value="9"
              c:identifier="COGL_PIXEL_FORMAT_RG_88"
              glib:nick="rg-88">
        <doc xml:space="preserve">RG, 16 bits. Note that red-green textures
  are only available if %COGL_FEATURE_ID_TEXTURE_RG is advertised.
  See cogl_texture_set_components() for details.</doc>
      </member>
      <member name="rgb_888"
              value="2"
              c:identifier="COGL_PIXEL_FORMAT_RGB_888"
              glib:nick="rgb-888">
        <doc xml:space="preserve">RGB, 24 bits</doc>
      </member>
      <member name="bgr_888"
              value="34"
              c:identifier="COGL_PIXEL_FORMAT_BGR_888"
              glib:nick="bgr-888">
        <doc xml:space="preserve">BGR, 24 bits</doc>
      </member>
      <member name="rgba_8888"
              value="19"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888"
              glib:nick="rgba-8888">
        <doc xml:space="preserve">RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888"
              value="51"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888"
              glib:nick="bgra-8888">
        <doc xml:space="preserve">BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888"
              value="83"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888"
              glib:nick="argb-8888">
        <doc xml:space="preserve">ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888"
              value="115"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888"
              glib:nick="abgr-8888">
        <doc xml:space="preserve">ABGR, 32 bits</doc>
      </member>
      <member name="rgba_1010102"
              value="29"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102"
              glib:nick="rgba-1010102">
        <doc xml:space="preserve">RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102"
              value="61"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102"
              glib:nick="bgra-1010102">
        <doc xml:space="preserve">BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010"
              value="93"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010"
              glib:nick="argb-2101010">
        <doc xml:space="preserve">ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010"
              value="125"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010"
              glib:nick="abgr-2101010">
        <doc xml:space="preserve">ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="rgba_8888_pre"
              value="147"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888_PRE"
              glib:nick="rgba-8888-pre">
        <doc xml:space="preserve">Premultiplied RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888_pre"
              value="179"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888_PRE"
              glib:nick="bgra-8888-pre">
        <doc xml:space="preserve">Premultiplied BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888_pre"
              value="211"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888_PRE"
              glib:nick="argb-8888-pre">
        <doc xml:space="preserve">Premultiplied ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888_pre"
              value="243"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888_PRE"
              glib:nick="abgr-8888-pre">
        <doc xml:space="preserve">Premultiplied ABGR, 32 bits</doc>
      </member>
      <member name="rgba_4444_pre"
              value="149"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444_PRE"
              glib:nick="rgba-4444-pre">
        <doc xml:space="preserve">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551_pre"
              value="150"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551_PRE"
              glib:nick="rgba-5551-pre">
        <doc xml:space="preserve">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_1010102_pre"
              value="157"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102_PRE"
              glib:nick="rgba-1010102-pre">
        <doc xml:space="preserve">Premultiplied RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102_pre"
              value="189"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102_PRE"
              glib:nick="bgra-1010102-pre">
        <doc xml:space="preserve">Premultiplied BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010_pre"
              value="221"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010_PRE"
              glib:nick="argb-2101010-pre">
        <doc xml:space="preserve">Premultiplied ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010_pre"
              value="253"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010_PRE"
              glib:nick="abgr-2101010-pre">
        <doc xml:space="preserve">Premultiplied ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="depth_16"
              value="265"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_16"
              glib:nick="depth-16">
      </member>
      <member name="depth_32"
              value="259"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_32"
              glib:nick="depth-32">
      </member>
      <member name="depth_24_stencil_8"
              value="771"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8"
              glib:nick="depth-24-stencil-8">
      </member>
    </enumeration>
    <record name="Quaternion" c:type="CoglQuaternion" disguised="1">
    </record>
    <constant name="RADIANS_TO_DEGREES"
              value="3754936"
              c:type="COGL_RADIANS_TO_DEGREES"
              version="1.0">
      <doc xml:space="preserve">Evaluates to 180 / pi in fixed point notation.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="ReadPixelsFlags"
              version="1.0"
              glib:type-name="CoglReadPixelsFlags"
              glib:get-type="cogl_read_pixels_flags_get_type"
              c:type="CoglReadPixelsFlags">
      <doc xml:space="preserve">Flags for cogl_framebuffer_read_pixels_into_bitmap()</doc>
      <member name="color_buffer"
              value="1"
              c:identifier="COGL_READ_PIXELS_COLOR_BUFFER"
              glib:nick="color-buffer">
        <doc xml:space="preserve">Read from the color buffer</doc>
      </member>
    </bitfield>
    <enumeration name="RendererError"
                 glib:type-name="CoglRendererError"
                 glib:get-type="cogl_renderer_error_get_type"
                 c:type="CoglRendererError">
      <member name="xlib_display_open"
              value="0"
              c:identifier="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN"
              glib:nick="xlib-display-open">
      </member>
      <member name="bad_constraint"
              value="1"
              c:identifier="COGL_RENDERER_ERROR_BAD_CONSTRAINT"
              glib:nick="bad-constraint">
      </member>
    </enumeration>
    <constant name="SQRTI_ARG_10_PERCENT"
              value="5590"
              c:type="COGL_SQRTI_ARG_10_PERCENT"
              version="1.0">
      <doc xml:space="preserve">Maximum argument that can be passed to cogl_sqrti() for which the
resulting error is &lt; 10%</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SQRTI_ARG_5_PERCENT"
              value="210"
              c:type="COGL_SQRTI_ARG_5_PERCENT"
              version="1.0">
      <doc xml:space="preserve">Maximum argument that can be passed to cogl_sqrti() for which the
resulting error is &lt; 5%</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="SQRTI_ARG_MAX"
              value="4194303"
              c:type="COGL_SQRTI_ARG_MAX"
              version="1.0">
      <doc xml:space="preserve">Maximum argument that can be passed to cogl_sqrti() function.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="STENCIL_BIT" value="512" c:type="COGL_STENCIL_BIT">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="ShaderType"
                 version="1.0"
                 glib:type-name="CoglShaderType"
                 glib:get-type="cogl_shader_type_get_type"
                 c:type="CoglShaderType">
      <doc xml:space="preserve">Types of shaders</doc>
      <member name="vertex"
              value="0"
              c:identifier="COGL_SHADER_TYPE_VERTEX"
              glib:nick="vertex">
        <doc xml:space="preserve">A program for proccessing vertices</doc>
      </member>
      <member name="fragment"
              value="1"
              c:identifier="COGL_SHADER_TYPE_FRAGMENT"
              glib:nick="fragment">
        <doc xml:space="preserve">A program for processing fragments</doc>
      </member>
    </enumeration>
    <enumeration name="StereoMode"
                 glib:type-name="CoglStereoMode"
                 glib:get-type="cogl_stereo_mode_get_type"
                 c:type="CoglStereoMode">
      <doc xml:space="preserve">Represents how draw should affect the two buffers
of a stereo framebuffer. See cogl_framebuffer_set_stereo_mode().</doc>
      <member name="both"
              value="0"
              c:identifier="COGL_STEREO_BOTH"
              glib:nick="both">
        <doc xml:space="preserve">draw to both stereo buffers</doc>
      </member>
      <member name="left"
              value="1"
              c:identifier="COGL_STEREO_LEFT"
              glib:nick="left">
        <doc xml:space="preserve">draw only to the left stereo buffer</doc>
      </member>
      <member name="right"
              value="2"
              c:identifier="COGL_STEREO_RIGHT"
              glib:nick="right">
        <doc xml:space="preserve">draw only to the left stereo buffer</doc>
      </member>
    </enumeration>
    <enumeration name="SystemError"
                 version="1.4"
                 stability="Unstable"
                 glib:type-name="CoglSystemError"
                 glib:get-type="cogl_system_error_get_type"
                 c:type="CoglSystemError">
      <doc xml:space="preserve">Error enumeration for Cogl

The @COGL_SYSTEM_ERROR_UNSUPPORTED error can be thrown for a
variety of reasons. For example:

&lt;itemizedlist&gt;
 &lt;listitem&gt;&lt;para&gt;You've tried to use a feature that is not
  advertised by cogl_has_feature(). This could happen if you create
  a 2d texture with a non-power-of-two size when
  %COGL_FEATURE_ID_TEXTURE_NPOT is not advertised.&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The GPU can not handle the configuration you have
  requested. An example might be if you try to use too many texture
  layers in a single #CoglPipeline&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The driver does not support some
  configuration.&lt;/para&gt;&lt;/listiem&gt;
&lt;/itemizedlist&gt;

Currently this is only used by Cogl API marked as experimental so
this enum should also be considered experimental.</doc>
      <member name="cogl_system_error_unsupported"
              value="0"
              c:identifier="COGL_SYSTEM_ERROR_UNSUPPORTED"
              glib:nick="cogl-system-error-unsupported">
        <doc xml:space="preserve">You tried to use a feature or
   configuration not currently available.</doc>
      </member>
      <member name="cogl_system_error_no_memory"
              value="1"
              c:identifier="COGL_SYSTEM_ERROR_NO_MEMORY"
              glib:nick="cogl-system-error-no-memory">
        <doc xml:space="preserve">You tried to allocate a resource
   such as a texture and there wasn't enough memory.</doc>
      </member>
    </enumeration>
    <constant name="TEXTURE_MAX_WASTE"
              value="127"
              c:type="COGL_TEXTURE_MAX_WASTE">
      <type name="gint" c:type="gint"/>
    </constant>
    <interface name="Texture"
               c:symbol-prefix="texture"
               glib:type-name="CoglTexture"
               glib:get-type="cogl_texture_get_gtype">
      <function name="ref"
                c:identifier="cogl_texture_ref"
                introspectable="0"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Increment the reference count for a cogl texture.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">the @texture pointer.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="texture"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CoglTexture.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_texture_unref"
                introspectable="0"
                deprecated="1"
                deprecated-version="1.2">
        <doc xml:space="preserve">Decrement the reference count for a cogl texture.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="texture"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #CoglTexture.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <method name="allocate" c:identifier="cogl_texture_allocate" throws="1">
        <doc xml:space="preserve">Explicitly allocates the storage for the given @texture which
allows you to be sure that there is enough memory for the
texture and if not then the error can be handled gracefully.

&lt;note&gt;Normally applications don't need to use this api directly
since the texture will be implicitly allocated when data is set on
the texture, or if the texture is attached to a #CoglOffscreen
framebuffer and rendered too.&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the texture was successfully allocated,
              otherwise %FALSE and @error will be updated if it
              wasn't %NULL.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">A #CoglTexture</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_components"
              c:identifier="cogl_texture_get_components"
              version="1.18">
        <doc xml:space="preserve">Queries what components the given @texture stores internally as set
via cogl_texture_set_components().

For textures created by the _with_size constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.</doc>
        <return-value transfer-ownership="none">
          <type name="TextureComponents" c:type="CoglTextureComponents"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="cogl_texture_get_data">
        <doc xml:space="preserve">Copies the pixel data from a cogl texture to system memory.

&lt;note&gt;Don't pass the value of cogl_texture_get_rowstride() as the
@rowstride argument, the rowstride should be the rowstride you
want for the destination @data buffer not the rowstride of the
source texture&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size of the texture data in bytes</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the #CoglPixelFormat to store the texture as.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve">the rowstride of @data in bytes or pass 0 to calculate
            from the bytes-per-pixel of @format multiplied by the
            @texture width.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">memory location to write the @texture's contents, or %NULL
to only query the data size through the return value.</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_gl_texture" c:identifier="cogl_texture_get_gl_texture">
        <doc xml:space="preserve">Queries the GL handles for a GPU side texture through its #CoglTexture.

If the texture is spliced the data for the first sub texture will be
queried.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the handle was successfully retrieved, %FALSE
  if the handle was invalid</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="out_gl_handle"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to return location for the
  textures GL handle, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
          <parameter name="out_gl_target"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to return location for the
  GL target type, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_texture_get_height">
        <doc xml:space="preserve">Queries the height of a cogl texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the height of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_waste" c:identifier="cogl_texture_get_max_waste">
        <doc xml:space="preserve">Queries the maximum wasted (unused) pixels in one dimension of a GPU side
texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the maximum waste</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_premultiplied"
              c:identifier="cogl_texture_get_premultiplied"
              version="1.18">
        <doc xml:space="preserve">Queries the pre-multiplied alpha status for internally stored red,
green and blue components for the given @texture as set by
cogl_texture_set_premultiplied().

By default the pre-multipled state is @TRUE.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if red, green and blue components are
              internally stored pre-multiplied by the alpha
              value or %FALSE if not.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_texture_get_width">
        <doc xml:space="preserve">Queries the width of a cogl texture.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the width of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_sliced" c:identifier="cogl_texture_is_sliced">
        <doc xml:space="preserve">Queries if a texture is sliced (stored as multiple GPU side tecture
objects).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the texture is sliced, %FALSE if the texture
  is stored as a single GPU texture</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_components"
              c:identifier="cogl_texture_set_components"
              version="1.18">
        <doc xml:space="preserve">Affects the internal storage format for this texture by specifying
what components will be required for sampling later.

This api affects how data is uploaded to the GPU since unused
components can potentially be discarded from source data.

For textures created by the _with_size constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.

Note that the %COGL_TEXTURE_COMPONENTS_RG format is not available
on all drivers. The availability can be determined by checking for
the %COGL_FEATURE_ID_TEXTURE_RG feature. If this format is used on
a driver where it is not available then %COGL_TEXTURE_ERROR_FORMAT
will be raised when the texture is allocated. Even if the feature
is not available then %COGL_PIXEL_FORMAT_RG_88 can still be used as
an image format as long as %COGL_TEXTURE_COMPONENTS_RG isn't used
as the texture's components.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="components" transfer-ownership="none">
            <type name="TextureComponents" c:type="CoglTextureComponents"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_premultiplied"
              c:identifier="cogl_texture_set_premultiplied"
              version="1.18">
        <doc xml:space="preserve">Affects the internal storage format for this texture by specifying
whether red, green and blue color components should be stored as
pre-multiplied alpha values.

This api affects how data is uploaded to the GPU since Cogl will
convert source data to have premultiplied or unpremultiplied
components according to this state.

For example if you create a texture via
cogl_texture_2d_new_with_size() and then upload data via
cogl_texture_set_data() passing a source format of
%COGL_PIXEL_FORMAT_RGBA_8888 then Cogl will internally multiply the
red, green and blue components of the source data by the alpha
component, for each pixel so that the internally stored data has
pre-multiplied alpha components. If you instead upload data that
already has pre-multiplied components by passing
%COGL_PIXEL_FORMAT_RGBA_8888_PRE as the source format to
cogl_texture_set_data() then the data can be uploaded without being
converted.

By default the @premultipled state is @TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="premultiplied" transfer-ownership="none">
            <doc xml:space="preserve">Whether any internally stored red, green or blue
                components are pre-multiplied by an alpha
                component.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region" c:identifier="cogl_texture_set_region">
        <doc xml:space="preserve">Sets the pixels in a rectangular subregion of @texture from an in-memory
buffer containing pixel data.

&lt;note&gt;The region set can't be larger than the source @data&lt;/note&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve">a #CoglTexture.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve">width of destination region to write. (Must be less
  than or equal to @width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve">height of destination region to write. (Must be less
  than or equal to @height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the #CoglPixelFormat used in the source buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve">rowstride of source buffer (computed from width if none
specified)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the actual pixel data.</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <enumeration name="TextureComponents"
                 version="1.18"
                 glib:type-name="CoglTextureComponents"
                 glib:get-type="cogl_texture_components_get_type"
                 c:type="CoglTextureComponents">
      <doc xml:space="preserve">See cogl_texture_set_components().</doc>
      <member name="a"
              value="1"
              c:identifier="COGL_TEXTURE_COMPONENTS_A"
              glib:nick="a">
        <doc xml:space="preserve">Only the alpha component</doc>
      </member>
      <member name="rg"
              value="2"
              c:identifier="COGL_TEXTURE_COMPONENTS_RG"
              glib:nick="rg">
        <doc xml:space="preserve">Red and green components. Note that
  this can only be used if the %COGL_FEATURE_ID_TEXTURE_RG feature
  is advertised.</doc>
      </member>
      <member name="rgb"
              value="3"
              c:identifier="COGL_TEXTURE_COMPONENTS_RGB"
              glib:nick="rgb">
        <doc xml:space="preserve">Red, green and blue components</doc>
      </member>
      <member name="rgba"
              value="4"
              c:identifier="COGL_TEXTURE_COMPONENTS_RGBA"
              glib:nick="rgba">
        <doc xml:space="preserve">Red, green, blue and alpha components</doc>
      </member>
      <member name="depth"
              value="5"
              c:identifier="COGL_TEXTURE_COMPONENTS_DEPTH"
              glib:nick="depth">
        <doc xml:space="preserve">Only a depth component</doc>
      </member>
    </enumeration>
    <enumeration name="TextureError"
                 version="1.8"
                 stability="Unstable"
                 glib:type-name="CoglTextureError"
                 glib:get-type="cogl_texture_error_get_type"
                 c:type="CoglTextureError">
      <doc xml:space="preserve">Error codes that can be thrown when allocating textures.</doc>
      <member name="size"
              value="0"
              c:identifier="COGL_TEXTURE_ERROR_SIZE"
              glib:nick="size">
        <doc xml:space="preserve">Unsupported size</doc>
      </member>
      <member name="format"
              value="1"
              c:identifier="COGL_TEXTURE_ERROR_FORMAT"
              glib:nick="format">
        <doc xml:space="preserve">Unsupported format</doc>
      </member>
      <member name="bad_parameter"
              value="2"
              c:identifier="COGL_TEXTURE_ERROR_BAD_PARAMETER"
              glib:nick="bad-parameter">
      </member>
      <member name="type"
              value="3"
              c:identifier="COGL_TEXTURE_ERROR_TYPE"
              glib:nick="type">
        <doc xml:space="preserve">A primitive texture type that is
  unsupported by the driver was used</doc>
      </member>
      <function name="quark" c:identifier="cogl_texture_error_quark">
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="TextureFlags"
              version="1.0"
              glib:type-name="CoglTextureFlags"
              glib:get-type="cogl_texture_flags_get_type"
              c:type="CoglTextureFlags">
      <doc xml:space="preserve">Flags to pass to the cogl_texture_new_* family of functions.</doc>
      <member name="none"
              value="0"
              c:identifier="COGL_TEXTURE_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No flags specified</doc>
      </member>
      <member name="no_auto_mipmap"
              value="1"
              c:identifier="COGL_TEXTURE_NO_AUTO_MIPMAP"
              glib:nick="no-auto-mipmap">
        <doc xml:space="preserve">Disables the automatic generation of
  the mipmap pyramid from the base level image whenever it is
  updated. The mipmaps are only generated when the texture is
  rendered with a mipmap filter so it should be free to leave out
  this flag when using other filtering modes</doc>
      </member>
      <member name="no_slicing"
              value="2"
              c:identifier="COGL_TEXTURE_NO_SLICING"
              glib:nick="no-slicing">
        <doc xml:space="preserve">Disables the slicing of the texture</doc>
      </member>
      <member name="no_atlas"
              value="4"
              c:identifier="COGL_TEXTURE_NO_ATLAS"
              glib:nick="no-atlas">
        <doc xml:space="preserve">Disables the insertion of the texture inside
  the texture atlas used by Cogl</doc>
      </member>
    </bitfield>
    <enumeration name="TextureType"
                 version="1.10"
                 stability="Unstable"
                 glib:type-name="CoglTextureType"
                 glib:get-type="cogl_texture_type_get_type"
                 c:type="CoglTextureType">
      <doc xml:space="preserve">Constants representing the underlying hardware texture type of a
#CoglTexture.</doc>
      <member name="2d"
              value="0"
              c:identifier="COGL_TEXTURE_TYPE_2D"
              glib:nick="2d">
        <doc xml:space="preserve">A #CoglTexture2D</doc>
      </member>
      <member name="3d"
              value="1"
              c:identifier="COGL_TEXTURE_TYPE_3D"
              glib:nick="3d">
        <doc xml:space="preserve">A #CoglTexture3D</doc>
      </member>
      <member name="rectangle"
              value="2"
              c:identifier="COGL_TEXTURE_TYPE_RECTANGLE"
              glib:nick="rectangle">
        <doc xml:space="preserve">A #CoglTextureRectangle</doc>
      </member>
    </enumeration>
    <record name="TextureVertex" c:type="CoglTextureVertex">
      <doc xml:space="preserve">Used to specify vertex information when calling cogl_polygon()</doc>
      <field name="x" writable="1">
        <doc xml:space="preserve">Model x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve">Model y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve">Model z-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="tx" writable="1">
        <doc xml:space="preserve">Texture x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ty" writable="1">
        <doc xml:space="preserve">Texture y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <doc xml:space="preserve">The color to use at this vertex. This is ignored if
  use_color is %FALSE when calling cogl_polygon()</doc>
        <type name="Color" c:type="CoglColor"/>
      </field>
    </record>
    <enumeration name="VerticesMode"
                 version="1.0"
                 glib:type-name="CoglVerticesMode"
                 glib:get-type="cogl_vertices_mode_get_type"
                 c:type="CoglVerticesMode">
      <doc xml:space="preserve">Different ways of interpreting vertices when drawing.</doc>
      <member name="points"
              value="0"
              c:identifier="COGL_VERTICES_MODE_POINTS"
              glib:nick="points">
        <doc xml:space="preserve">FIXME, equivalent to
&lt;constant&gt;GL_POINTS&lt;/constant&gt;</doc>
      </member>
      <member name="lines"
              value="1"
              c:identifier="COGL_VERTICES_MODE_LINES"
              glib:nick="lines">
        <doc xml:space="preserve">FIXME, equivalent to &lt;constant&gt;GL_LINES&lt;/constant&gt;</doc>
      </member>
      <member name="line_loop"
              value="2"
              c:identifier="COGL_VERTICES_MODE_LINE_LOOP"
              glib:nick="line-loop">
        <doc xml:space="preserve">FIXME, equivalent to
&lt;constant&gt;GL_LINE_LOOP&lt;/constant&gt;</doc>
      </member>
      <member name="line_strip"
              value="3"
              c:identifier="COGL_VERTICES_MODE_LINE_STRIP"
              glib:nick="line-strip">
        <doc xml:space="preserve">FIXME, equivalent to
&lt;constant&gt;GL_LINE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangles"
              value="4"
              c:identifier="COGL_VERTICES_MODE_TRIANGLES"
              glib:nick="triangles">
        <doc xml:space="preserve">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLES&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_strip"
              value="5"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_STRIP"
              glib:nick="triangle-strip">
        <doc xml:space="preserve">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_fan"
              value="6"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_FAN"
              glib:nick="triangle-fan">
        <doc xml:space="preserve">FIXME, equivalent to &lt;constant&gt;GL_TRIANGLE_FAN&lt;/constant&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="Winding"
                 glib:type-name="CoglWinding"
                 glib:get-type="cogl_winding_get_type"
                 c:type="CoglWinding">
      <doc xml:space="preserve">Enum used to represent the two directions of rotation. This can be
used to set the front face for culling by calling
cogl_pipeline_set_front_face_winding().</doc>
      <member name="clockwise"
              value="0"
              c:identifier="COGL_WINDING_CLOCKWISE"
              glib:nick="clockwise">
        <doc xml:space="preserve">Vertices are in a clockwise order</doc>
      </member>
      <member name="counter_clockwise"
              value="1"
              c:identifier="COGL_WINDING_COUNTER_CLOCKWISE"
              glib:nick="counter-clockwise">
        <doc xml:space="preserve">Vertices are in a counter-clockwise order</doc>
      </member>
    </enumeration>
    <enumeration name="WinsysFeature"
                 glib:type-name="CoglWinsysFeature"
                 glib:get-type="cogl_winsys_feature_get_type"
                 c:type="CoglWinsysFeature">
      <member name="multiple_onscreen"
              value="0"
              c:identifier="COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN"
              glib:nick="multiple-onscreen">
      </member>
      <member name="swap_throttle"
              value="1"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_THROTTLE"
              glib:nick="swap-throttle">
      </member>
      <member name="vblank_counter"
              value="2"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_COUNTER"
              glib:nick="vblank-counter">
      </member>
      <member name="vblank_wait"
              value="3"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_WAIT"
              glib:nick="vblank-wait">
      </member>
      <member name="texture_from_pixmap"
              value="4"
              c:identifier="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP"
              glib:nick="texture-from-pixmap">
      </member>
      <member name="swap_buffers_event"
              value="5"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT"
              glib:nick="swap-buffers-event">
      </member>
      <member name="swap_region"
              value="6"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION"
              glib:nick="swap-region">
      </member>
      <member name="swap_region_throttle"
              value="7"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE"
              glib:nick="swap-region-throttle">
      </member>
      <member name="swap_region_synchronized"
              value="8"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED"
              glib:nick="swap-region-synchronized">
      </member>
      <member name="buffer_age"
              value="9"
              c:identifier="COGL_WINSYS_FEATURE_BUFFER_AGE"
              glib:nick="buffer-age">
      </member>
      <member name="sync_and_complete_event"
              value="10"
              c:identifier="COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT"
              glib:nick="sync-and-complete-event">
      </member>
      <member name="n_features"
              value="11"
              c:identifier="COGL_WINSYS_FEATURE_N_FEATURES"
              glib:nick="n-features">
      </member>
    </enumeration>
    <callback name="XlibFilterFunc"
              c:type="CoglXlibFilterFunc"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="event" transfer-ownership="none">
          <type c:type="XEvent*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="_ColorSizeCheck" c:type="_CoglColorSizeCheck">
      <field name="compile_time_assert_CoglColor_size" writable="1">
        <array zero-terminated="0" c:type="char" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_MatrixSizeCheck" c:type="_CoglMatrixSizeCheck">
      <field name="compile_time_assert_CoglMatrix_size" writable="1">
        <array zero-terminated="0" c:type="char" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_TextureVertexSizeCheck"
            c:type="_CoglTextureVertexSizeCheck">
      <field name="compile_time_assert_CoglTextureVertex_size" writable="1">
        <array zero-terminated="0" c:type="char" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <function name="angle_cos"
              c:identifier="cogl_angle_cos"
              version="1.0"
              introspectable="0">
      <doc xml:space="preserve">Computes the cosine of @angle</doc>
      <return-value>
        <doc xml:space="preserve">the cosine of the passed angle</doc>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve">an angle expressed using #CoglAngle</doc>
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="angle_sin"
              c:identifier="cogl_angle_sin"
              version="1.0"
              introspectable="0">
      <doc xml:space="preserve">Computes the sine of @angle</doc>
      <return-value>
        <doc xml:space="preserve">the sine of the passed angle</doc>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve">an angle expressed using #CoglAngle</doc>
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="angle_tan"
              c:identifier="cogl_angle_tan"
              version="1.0"
              introspectable="0">
      <doc xml:space="preserve">Computes the tangent of @angle</doc>
      <return-value>
        <doc xml:space="preserve">the tangent of the passed angle</doc>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve">an angle expressed using #CoglAngle</doc>
          <type name="Angle" c:type="CoglAngle"/>
        </parameter>
      </parameters>
    </function>
    <function name="begin_gl"
              c:identifier="cogl_begin_gl"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">We do not advise nor reliably support the interleaving of raw GL drawing and
Cogl drawing functions, but if you insist, cogl_begin_gl() and cogl_end_gl()
provide a simple mechanism that may at least give you a fighting chance of
succeeding.

Note: this doesn't help you modify the behaviour of Cogl drawing functions
through the modification of GL state; that will never be reliably supported,
but if you are trying to do something like:

|[
{
   - setup some OpenGL state.
   - draw using OpenGL (e.g. glDrawArrays() )
   - reset modified OpenGL state.
   - continue using Cogl to draw
}
]|

You should surround blocks of drawing using raw GL with cogl_begin_gl()
and cogl_end_gl():

|[
{
   cogl_begin_gl ();
   - setup some OpenGL state.
   - draw using OpenGL (e.g. glDrawArrays() )
   - reset modified OpenGL state.
   cogl_end_gl ();
   - continue using Cogl to draw
}
]|

Don't ever try and do:

|[
{
   - setup some OpenGL state.
   - use Cogl to draw
   - reset modified OpenGL state.
}
]|

When the internals of Cogl evolves, this is very liable to break.

This function will flush all batched primitives, and subsequently flush
all internal Cogl state to OpenGL as if it were going to draw something
itself.

The result is that the OpenGL modelview matrix will be setup; the state
corresponding to the current source material will be set up and other world
state such as backface culling, depth and fogging enabledness will be sent
to OpenGL.

&lt;note&gt;No special material state is flushed, so if you want Cogl to setup a
simplified material state it is your responsibility to set a simple source
material before calling cogl_begin_gl(). E.g. by calling
cogl_set_source_color4ub().&lt;/note&gt;

&lt;note&gt;It is your responsibility to restore any OpenGL state that you modify
to how it was after calling cogl_begin_gl() if you don't do this then the
result of further Cogl calls is undefined.&lt;/note&gt;

&lt;note&gt;You can not nest begin/end blocks.&lt;/note&gt;

Again we would like to stress, we do not advise the use of this API and if
possible we would prefer to improve Cogl than have developers require raw
OpenGL.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglGLES2Context api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="bitmap_error_quark"
              c:identifier="cogl_bitmap_error_quark"
              moved-to="BitmapError.quark">
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="blend_string_error_quark"
              c:identifier="cogl_blend_string_error_quark"
              moved-to="BlendStringError.quark">
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="check_extension"
              c:identifier="cogl_check_extension"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Check whether @name occurs in list of extensions in @ext.</doc>
      <doc-deprecated xml:space="preserve">OpenGL is an implementation detail for Cogl and so it's
  not appropriate to expose OpenGL extensions through the Cogl API. This
  function can be replaced by the following equivalent code:
|[
  CoglBool retval = (strstr (ext, name) != NULL) ? TRUE : FALSE;
]|</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the extension occurs in the list, %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">extension to check for</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <doc xml:space="preserve">list of extensions</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clear"
              c:identifier="cogl_clear"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_clear() api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">Background color to clear to</doc>
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
        <parameter name="buffers" transfer-ownership="none">
          <doc xml:space="preserve">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
          <type name="gulong" c:type="unsigned long"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_ensure"
              c:identifier="cogl_clip_ensure"
              version="1.0"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Ensures that the current clipping region has been set in GL. This
will automatically be called before any Cogl primitives but it
maybe be neccessary to call if you are using raw GL calls with
clipping.</doc>
      <doc-deprecated xml:space="preserve">Calling this function has no effect</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_pop"
              c:identifier="cogl_clip_pop"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Reverts the clipping region to the state before the last call to
cogl_clip_push().</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_pop_clip() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_push"
              c:identifier="cogl_clip_push"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().</doc>
      <doc-deprecated xml:space="preserve">The x, y, width, height arguments are inconsistent
  with other API that specify rectangles in model space, and when used
  with a coordinate space that puts the origin at the center and y+
  extending up, it's awkward to use. Please use
  cogl_framebuffer_push_rectangle_clip()</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <doc xml:space="preserve">left edge of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <doc xml:space="preserve">top edge of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">width of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">height of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_primitive"
              c:identifier="cogl_clip_push_primitive"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
      <doc xml:space="preserve">Sets a new clipping area using a 2D shaped described with a
#CoglPrimitive. The shape must not contain self overlapping
geometry and must lie on a single 2D plane. A bounding box of the
2D shape in local coordinates (the same coordinates used to
describe the shape) must be given. It is acceptable for the bounds
to be larger than the true bounds but behaviour is undefined if the
bounds are smaller than the true bounds.

The primitive is transformed by the current model-view matrix and
the silhouette is intersected with the previous clipping area.  To
restore the previous clipping area, call
cogl_clip_pop().</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_push_primitive_clip()
                  instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="primitive" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglPrimitive describing a flat 2D shape</doc>
          <type c:type="CoglPrimitive*"/>
        </parameter>
        <parameter name="bounds_x1" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate for the top-left corner of the primitives
            bounds</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bounds_y1" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate for the top-left corner of the primitives
            bounds</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bounds_x2" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate for the bottom-right corner of the primitives
            bounds</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bounds_y2" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate for the bottom-right corner of the
            primitives bounds.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_rectangle"
              c:identifier="cogl_clip_push_rectangle"
              version="1.2"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_push_rectangle_clip()
                  instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x0" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate for top left corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y0" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate for top left corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate for bottom right corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate for bottom right corner of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_window_rect"
              c:identifier="cogl_clip_push_window_rect"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_push_scissor_clip() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <doc xml:space="preserve">left edge of the clip rectangle in window coordinates</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <doc xml:space="preserve">top edge of the clip rectangle in window coordinates</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">width of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">height of the clip rectangle</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_push_window_rectangle"
              c:identifier="cogl_clip_push_window_rectangle"
              version="1.2"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_clip_pop().</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_push_scissor_clip() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_offset" transfer-ownership="none">
          <doc xml:space="preserve">left edge of the clip rectangle in window coordinates</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y_offset" transfer-ownership="none">
          <doc xml:space="preserve">top edge of the clip rectangle in window coordinates</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">width of the clip rectangle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">height of the clip rectangle</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="clip_stack_restore"
              c:identifier="cogl_clip_stack_restore"
              version="0.8.2"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Restore the state of the clipping stack that was previously saved
by cogl_clip_stack_save().</doc>
      <doc-deprecated xml:space="preserve">This was originally added to allow us to restore
  the clip stack when switching back from an offscreen framebuffer,
  but it's not necessary anymore given that framebuffers now own
  separate clip stacks which will be automatically switched between
  when a new buffer is set. Calling this function has no effect</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clip_stack_save"
              c:identifier="cogl_clip_stack_save"
              version="0.8.2"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Save the entire state of the clipping stack and then clear all
clipping. The previous state can be returned to with
cogl_clip_stack_restore(). Each call to cogl_clip_push() after this
must be matched by a call to cogl_clip_pop() before calling
cogl_clip_stack_restore().</doc>
      <doc-deprecated xml:space="preserve">This was originally added to allow us to save the
  clip stack when switching to an offscreen framebuffer, but it's
  not necessary anymore given that framebuffers now own separate
  clip stacks which will be automatically switched between when a
  new buffer is set. Calling this function has no effect</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="clutter_check_extension_CLUTTER"
              c:identifier="cogl_clutter_check_extension_CLUTTER">
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="ext" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="clutter_winsys_has_feature_CLUTTER"
              c:identifier="cogl_clutter_winsys_has_feature_CLUTTER">
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <type name="WinsysFeature" c:type="CoglWinsysFeature"/>
        </parameter>
      </parameters>
    </function>
    <function name="clutter_winsys_xlib_get_visual_info_CLUTTER"
              c:identifier="cogl_clutter_winsys_xlib_get_visual_info_CLUTTER"
              introspectable="0">
      <return-value>
        <type c:type="XVisualInfo*"/>
      </return-value>
    </function>
    <function name="color_equal"
              c:identifier="cogl_color_equal"
              moved-to="Color.equal"
              version="1.0">
      <doc xml:space="preserve">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the two colors are the same.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_init_from_hsl"
              c:identifier="cogl_color_init_from_hsl"
              moved-to="Color.init_from_hsl"
              version="1.16">
      <doc xml:space="preserve">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">return location for a #CoglColor</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="hue" transfer-ownership="none">
          <doc xml:space="preserve">hue value, in the 0 .. 360 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="saturation" transfer-ownership="none">
          <doc xml:space="preserve">saturation value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="luminance" transfer-ownership="none">
          <doc xml:space="preserve">luminance value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_program"
              c:identifier="cogl_create_program"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Create a new cogl program object that can be used to replace parts of the GL
rendering pipeline with custom code.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new cogl program.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
    </function>
    <function name="create_shader"
              c:identifier="cogl_create_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Create a new shader handle, use cogl_shader_source() to set the
source code to be used on it.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new shader handle.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="shader_type" transfer-ownership="none">
          <doc xml:space="preserve">COGL_SHADER_TYPE_VERTEX or COGL_SHADER_TYPE_FRAGMENT.</doc>
          <type name="ShaderType" c:type="CoglShaderType"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_matrix_print"
              c:identifier="cogl_debug_matrix_print"
              version="2.0">
      <doc xml:space="preserve">Prints the contents of a #CoglMatrix to stdout.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglMatrix</doc>
          <type name="Matrix" c:type="const CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="disable_fog"
              c:identifier="cogl_disable_fog"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This function disables fogging, so primitives drawn afterwards will not be
blended with any previously set fog color.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet shader api for fog</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="double_to_fixed"
              c:identifier="cogl_double_to_fixed"
              introspectable="0">
      <return-value>
        <type name="Fixed" c:type="CoglFixed"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_to_int" c:identifier="cogl_double_to_int">
      <return-value transfer-ownership="none">
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="double_to_uint" c:identifier="cogl_double_to_uint">
      <return-value transfer-ownership="none">
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gdouble" c:type="double"/>
        </parameter>
      </parameters>
    </function>
    <function name="end_gl"
              c:identifier="cogl_end_gl"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This is the counterpart to cogl_begin_gl() used to delimit blocks of drawing
code using raw OpenGL. Please refer to cogl_begin_gl() for full details.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglGLES2Context api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="features_available"
              c:identifier="cogl_features_available"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Checks whether the given COGL features are available. Multiple
features can be checked for by or-ing them together with the '|'
operator. %TRUE is only returned if all of the requested features
are available.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_has_feature() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the features are available, %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="features" transfer-ownership="none">
          <doc xml:space="preserve">A bitmask of features to check for</doc>
          <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="flush" c:identifier="cogl_flush" version="1.0">
      <doc xml:space="preserve">This function should only need to be called in exceptional circumstances.

As an optimization Cogl drawing functions may batch up primitives
internally, so if you are trying to use raw GL outside of Cogl you stand a
better chance of being successful if you ask Cogl to flush any batched
geometry before making your state changes.

It only ensure that the underlying driver is issued all the commands
necessary to draw the batched primitives. It provides no guarantees about
when the driver will complete the rendering.

This provides no guarantees about the GL state upon returning and to avoid
confusing Cogl you should aim to restore any changes you make before
resuming use of Cogl.

If you are making state changes with the intention of affecting Cogl drawing
primitives you are 100% on your own since you stand a good chance of
conflicting with Cogl internals. For example clutter-gst which currently
uses direct GL calls to bind ARBfp programs will very likely break when Cogl
starts to use ARBfb programs itself for the material API.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="framebuffer_get_color_format"
              c:identifier="cogl_framebuffer_get_color_format"
              version="1.8"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve">Queries the common #CoglPixelFormat of all color buffers attached
to this framebuffer. For an offscreen framebuffer created with
cogl_offscreen_new_with_texture() this will correspond to the format
of the texture.

This API is deprecated because it is missleading to report a
#CoglPixelFormat for the internal format of the @framebuffer since
#CoglPixelFormat is such a precise format description and it's
only the set of components and the premultiplied alpha status
that is really known.</doc>
      <doc-stability xml:space="preserve">
Deprecated 1.18: Removed since it is misleading</doc-stability>
      <return-value transfer-ownership="none">
        <type name="PixelFormat" c:type="CoglPixelFormat"/>
      </return-value>
      <parameters>
        <parameter name="framebuffer" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglFramebuffer framebuffer</doc>
          <type c:type="CoglFramebuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="frustum"
              c:identifier="cogl_frustum"
              version="0.8.2"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_frustum() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:space="preserve">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:space="preserve">The distance to the near clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:space="preserve">The distance to the far clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_backface_culling_enabled"
              c:identifier="cogl_get_backface_culling_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Queries if backface culling has been enabled via
cogl_set_backface_culling_enabled()</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_get_cull_face_mode() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if backface culling is enabled, and %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
    </function>
    <function name="get_bitmasks"
              c:identifier="cogl_get_bitmasks"
              deprecated="1"
              deprecated-version="1.8">
      <doc xml:space="preserve">Gets the number of bitplanes used for each of the color components
in the color buffer. Pass %NULL for any of the arguments if the
value is not required.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_red/green/blue/alpha_bits()
                 instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Return location for the number of red bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="green"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Return location for the number of green bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="blue"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Return location for the number of blue bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="alpha"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Return location for the number of alpha bits or %NULL</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_depth_test_enabled"
              c:identifier="cogl_get_depth_test_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Queries if depth testing has been enabled via cogl_set_depth_test_enable()</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_depth_state() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if depth testing is enabled, and %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
    </function>
    <function name="get_features"
              c:identifier="cogl_get_features"
              version="0.8"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Returns all of the features supported by COGL.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_foreach_feature() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A logical OR of all the supported COGL features.</doc>
        <type name="FeatureFlags" c:type="CoglFeatureFlags"/>
      </return-value>
    </function>
    <function name="get_modelview_matrix"
              c:identifier="cogl_get_modelview_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Stores the current model-view matrix in @matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_modelview_matrix()
                  instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">return location for the model-view matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_option_group"
              c:identifier="cogl_get_option_group"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Retrieves the #GOptionGroup used by Cogl to parse the command
line options. Clutter uses this to handle the Cogl command line
options during its initialization process.</doc>
      <doc-deprecated xml:space="preserve">Not replaced</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GOptionGroup</doc>
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="get_proc_address"
              c:identifier="cogl_get_proc_address"
              introspectable="0">
      <doc xml:space="preserve">Gets a pointer to a given GL or GL ES extension function. This acts
as a wrapper around glXGetProcAddress() or whatever is the
appropriate function for the current backend.

&lt;note&gt;This function should not be used to query core opengl API
symbols since eglGetProcAddress for example doesn't allow this and
and may return a junk pointer if you do.&lt;/note&gt;</doc>
      <return-value>
        <doc xml:space="preserve">a pointer to the requested function or %NULL if the
  function is not available.</doc>
        <type name="FuncPtr" c:type="CoglFuncPtr"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">the name of the function.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_projection_matrix"
              c:identifier="cogl_get_projection_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Stores the current projection matrix in @matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_projection_matrix()
                  instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">return location for the projection matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_source"
              c:identifier="cogl_get_source"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Returns the current source material as previously set using
cogl_set_source().

&lt;note&gt;You should typically consider the returned material immutable
and not try to change any of its properties unless you own a
reference to that material. At times you may be able to get a
reference to an internally managed materials and the result of
modifying such materials is undefined.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">The current source material.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
    </function>
    <function name="get_viewport"
              c:identifier="cogl_get_viewport"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Stores the current viewport in @v. @v[0] and @v[1] get the x and y
position of the viewport and @v[2] and @v[3] get the width and
height.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_get_viewport4fv()
                  instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="v"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">pointer to a 4 element array
  of #float&lt;!-- --&gt;s to receive the viewport dimensions.</doc>
          <array zero-terminated="0" c:type="float*" fixed-size="4">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="gtype_matrix_get_type"
              c:identifier="cogl_gtype_matrix_get_type"
              deprecated="1"
              deprecated-version="1.18">
      <doc-deprecated xml:space="preserve">Use cogl_matrix_get_gtype() instead.</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the GType for the registered "CoglMatrix" boxed type. This
can be used for example to define GObject properties that accept a
#CoglMatrix value.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="handle_get_type" c:identifier="cogl_handle_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="handle_ref" c:identifier="cogl_handle_ref">
      <doc xml:space="preserve">Increases the reference count of @handle by 1</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the handle, with its reference count increased</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref" c:identifier="cogl_handle_unref">
      <doc xml:space="preserve">Drecreases the reference count of @handle by 1; if the reference
count reaches 0, the resources allocated by @handle will be freed</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_bitmap" c:identifier="cogl_is_bitmap" version="1.0">
      <doc xml:space="preserve">Checks whether @object is a #CoglBitmap</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the passed @object represents a bitmap,
  and %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_material"
              c:identifier="cogl_is_material"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Gets whether the given handle references an existing material object.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_is_pipeline() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle references a #CoglMaterial,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_offscreen" c:identifier="cogl_is_offscreen">
      <doc xml:space="preserve">Determines whether the given #CoglObject references an offscreen
framebuffer object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @object is a #CoglOffscreen framebuffer,
         %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A pointer to a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_program"
              c:identifier="cogl_is_program"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Gets whether the given handle references an existing program object.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle references a program,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_shader"
              c:identifier="cogl_is_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Gets whether the given handle references an existing shader object.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle references a shader,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture" c:identifier="cogl_is_texture">
      <doc xml:space="preserve">Gets whether the given object references a texture object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the @object references a texture, and
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_vertex_buffer"
              c:identifier="cogl_is_vertex_buffer"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Checks whether @handle is a Vertex Buffer Object</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle is a VBO, and %FALSE
  otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle for a vertex buffer object</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_vertex_buffer_indices"
              c:identifier="cogl_is_vertex_buffer_indices"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Checks whether @handle is a handle to the indices for a vertex
buffer object</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the handle is indices, and %FALSE
  otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_ref"
              c:identifier="cogl_material_ref"
              moved-to="Material.ref"
              version="1.0"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Increment the reference count for a #CoglMaterial.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the @material.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglMaterial object.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="material_unref"
              c:identifier="cogl_material_unref"
              moved-to="Material.unref"
              version="1.0"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Decrement the reference count for a #CoglMaterial.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglMaterial object.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_equal"
              c:identifier="cogl_matrix_equal"
              moved-to="Matrix.equal"
              version="1.4">
      <doc xml:space="preserve">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="onscreen_clutter_backend_set_size_CLUTTER"
              c:identifier="cogl_onscreen_clutter_backend_set_size_CLUTTER">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="ortho"
              c:identifier="cogl_ortho"
              version="1.0"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Replaces the current projection matrix with an orthographic projection
matrix. See &lt;xref linkend="cogl-ortho-matrix"/&gt; to see how the matrix is
calculated.

&lt;figure id="cogl-ortho-matrix"&gt;
  &lt;title&gt;&lt;/title&gt;
  &lt;graphic fileref="cogl_ortho.png" format="PNG"/&gt;
&lt;/figure&gt;

&lt;note&gt;This function copies the arguments from OpenGL's glOrtho() even
though they are unnecessarily confusing due to the z near and z far
arguments actually being a "distance" from the origin, where
negative values are behind the viewer, instead of coordinates for
the z clipping planes which would have been consistent with the
left, right bottom and top arguments.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_orthographic() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="left" transfer-ownership="none">
          <doc xml:space="preserve">The coordinate for the left clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="right" transfer-ownership="none">
          <doc xml:space="preserve">The coordinate for the right clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="bottom" transfer-ownership="none">
          <doc xml:space="preserve">The coordinate for the bottom clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="top" transfer-ownership="none">
          <doc xml:space="preserve">The coordinate for the top clipping plane</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="near" transfer-ownership="none">
          <doc xml:space="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (negative if the plane is behind the viewer)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="far" transfer-ownership="none">
          <doc xml:space="preserve">The &lt;emphasis&gt;distance&lt;/emphasis&gt; for the far clipping
  plane (negative if the plane is behind the viewer)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="perspective"
              c:identifier="cogl_perspective"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Replaces the current projection matrix with a perspective matrix
based on the provided values.

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_perspective() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fovy" transfer-ownership="none">
          <doc xml:space="preserve">Vertical field of view angle in degrees.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="aspect" transfer-ownership="none">
          <doc xml:space="preserve">The (width over height) aspect ratio for display</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:space="preserve">The distance to the near clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:space="preserve">The distance to the far clipping plane (Must be positive)</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="polygon" c:identifier="cogl_polygon" version="1.0">
      <doc xml:space="preserve">Draws a convex polygon using the current source material to fill / texture
with according to the texture coordinates passed.

If @use_color is %TRUE then the color will be changed for each vertex using
the value specified in the color member of #CoglTextureVertex. This can be
used for example to make the texture fade out by setting the alpha value of
the color.

All of the texture coordinates must be in the range [0,1] and repeating the
texture is not supported.

Because of the way this function is implemented it will currently
only work if either the texture is not sliced or the backend is not
OpenGL ES and the minifying and magnifying functions are both set
to COGL_MATERIAL_FILTER_NEAREST.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vertices" transfer-ownership="none">
          <doc xml:space="preserve">An array of #CoglTextureVertex structs</doc>
          <type name="TextureVertex" c:type="const CoglTextureVertex*"/>
        </parameter>
        <parameter name="n_vertices" transfer-ownership="none">
          <doc xml:space="preserve">The length of the vertices array</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="use_color" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the color member of #CoglTextureVertex should be used</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
      </parameters>
    </function>
    <function name="pop_draw_buffer"
              c:identifier="cogl_pop_draw_buffer"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Restore cogl_set_draw_buffer() state.</doc>
      <doc-deprecated xml:space="preserve">The latest drawing apis take explicit
                  #CoglFramebuffer arguments so this stack of
                  framebuffers shouldn't be used anymore.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_framebuffer"
              c:identifier="cogl_pop_framebuffer"
              version="1.2"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Restores the framebuffer that was previously at the top of the stack.
All subsequent drawing will be redirected to this framebuffer.</doc>
      <doc-deprecated xml:space="preserve">The latest drawing apis take explicit
                  #CoglFramebuffer arguments so this stack of
                  framebuffers shouldn't be used anymore.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_matrix"
              c:identifier="cogl_pop_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Restores the current model-view matrix from the matrix stack.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_pop_matrix() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="pop_source"
              c:identifier="cogl_pop_source"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Removes the material at the top of the source stack. The material
at the top of this stack defines the GPU state used to process
later primitives as defined by cogl_set_source().</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="program_attach_shader"
              c:identifier="cogl_program_attach_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Attaches a shader to a program object. A program can have multiple
vertex or fragment shaders but only one of them may provide a
main() function. It is allowed to use a program with only a vertex
shader or only a fragment shader.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program_handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle for a shdaer program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="shader_handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle for a vertex of fragment shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_get_uniform_location"
              c:identifier="cogl_program_get_uniform_location"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Retrieve the location (offset) of a uniform variable in a shader program,
a uniform is a variable that is constant for all vertices/fragments for a
shader object and is possible to modify as an external parameter.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the offset of a uniform in a specified program.
  This uniform can be set using cogl_program_uniform_1f() when the
  program is in use.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_name" transfer-ownership="none">
          <doc xml:space="preserve">the name of a uniform.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_link"
              c:identifier="cogl_program_link"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Links a program making it ready for use. Note that calling this
function is optional. If it is not called the program will
automatically be linked the first time it is used.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_ref"
              c:identifier="cogl_program_ref"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Add an extra reference to a program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@handle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle to a program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1f"
              c:identifier="cogl_program_set_uniform_1f"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a floating point uniform for the given linked
@program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1i"
              c:identifier="cogl_program_set_uniform_1i"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of an integer uniform for the given linked
@program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_float"
              c:identifier="cogl_program_set_uniform_float"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a float vector uniform, or uniform array for
the given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_int"
              c:identifier="cogl_program_set_uniform_int"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a int vector uniform, or uniform array for
the given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="const int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_matrix"
              c:identifier="cogl_program_set_uniform_matrix"
              version="1.4"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a matrix uniform, or uniform array in the
given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dimensions" transfer-ownership="none">
          <doc xml:space="preserve">The dimensions of the matrix. So for for example pass
   2 for a 2x2 matrix or 3 for 3x3.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <doc xml:space="preserve">Whether to transpose the matrix when setting the uniform.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <array length="3" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1f"
              c:identifier="cogl_program_uniform_1f"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a floating point uniform in the currently
used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_1i"
              c:identifier="cogl_program_uniform_1i"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of an integer uniform in the currently
used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_float"
              c:identifier="cogl_program_uniform_float"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a float vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">Size of float vector.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_int"
              c:identifier="cogl_program_uniform_int"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a int vector uniform, or uniform array in the
currently used (see cogl_program_use()) shader program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">Size of int vector.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="const int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_uniform_matrix"
              c:identifier="cogl_program_uniform_matrix"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Changes the value of a matrix uniform, or uniform array in the
currently used (see cogl_program_use()) shader program. The @size
parameter is used to determine the square size of the matrix.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="uniform_no" transfer-ownership="none">
          <doc xml:space="preserve">the uniform to set.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">Size of matrix.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">Size of array of uniforms.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <doc xml:space="preserve">Whether to transpose the matrix when setting the uniform.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the new value of the uniform.</doc>
          <array length="2" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_unref"
              c:identifier="cogl_program_unref"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Removes a reference to a program. If it was the last reference the
program object will be destroyed.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle to a program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_use"
              c:identifier="cogl_program_use"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Activate a specific shader program replacing that part of the GL
rendering pipeline, if passed in %COGL_INVALID_HANDLE the default
behavior of GL is reinstated.

This function affects the global state of the current Cogl
context. It is much more efficient to attach the shader to a
specific material used for rendering instead by calling
cogl_material_set_user_program().</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglHandle for a shader program or %COGL_INVALID_HANDLE.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_draw_buffer"
              c:identifier="cogl_push_draw_buffer"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Save cogl_set_draw_buffer() state.</doc>
      <doc-deprecated xml:space="preserve">The latest drawing apis take explicit
                  #CoglFramebuffer arguments so this stack of
                  framebuffers shouldn't be used anymore.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="push_framebuffer"
              c:identifier="cogl_push_framebuffer"
              version="1.2"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
or in the future it may be an onscreen framebuffer too.

You should understand that a framebuffer owns the following state:
&lt;itemizedlist&gt;
 &lt;listitem&gt;&lt;simpara&gt;The projection matrix&lt;/simpara&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;simpara&gt;The modelview matrix stack&lt;/simpara&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;simpara&gt;The viewport&lt;/simpara&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;simpara&gt;The clip stack&lt;/simpara&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;
So these items will automatically be saved and restored when you
push and pop between different framebuffers.

Also remember a newly allocated framebuffer will have an identity matrix for
the projection and modelview matrices which gives you a coordinate space
like OpenGL with (-1, -1) corresponding to the top left of the viewport,
(1, 1) corresponding to the bottom right and +z coming out towards the
viewer.

If you want to set up a coordinate space like Clutter does with (0, 0)
corresponding to the top left and (framebuffer_width, framebuffer_height)
corresponding to the bottom right you can do so like this:

|[
static void
setup_viewport (unsigned int width,
                unsigned int height,
                float fovy,
                float aspect,
                float z_near,
                float z_far)
{
  float z_camera;
  CoglMatrix projection_matrix;
  CoglMatrix mv_matrix;

  cogl_set_viewport (0, 0, width, height);
  cogl_perspective (fovy, aspect, z_near, z_far);

  cogl_get_projection_matrix (&amp;amp;projection_matrix);
  z_camera = 0.5 * projection_matrix.xx;

  cogl_matrix_init_identity (&amp;amp;mv_matrix);
  cogl_matrix_translate (&amp;amp;mv_matrix, -0.5f, -0.5f, -z_camera);
  cogl_matrix_scale (&amp;amp;mv_matrix, 1.0f / width, -1.0f / height, 1.0f / width);
  cogl_matrix_translate (&amp;amp;mv_matrix, 0.0f, -1.0 * height, 0.0f);
  cogl_set_modelview_matrix (&amp;amp;mv_matrix);
}

static void
my_init_framebuffer (ClutterStage *stage,
                     CoglFramebuffer *framebuffer,
                     unsigned int framebuffer_width,
                     unsigned int framebuffer_height)
{
  ClutterPerspective perspective;

  clutter_stage_get_perspective (stage, &amp;perspective);

  cogl_push_framebuffer (framebuffer);
  setup_viewport (framebuffer_width,
                  framebuffer_height,
                  perspective.fovy,
                  perspective.aspect,
                  perspective.z_near,
                  perspective.z_far);
}
]|

The previous framebuffer can be restored by calling cogl_pop_framebuffer()</doc>
      <doc-deprecated xml:space="preserve">The latest drawing apis take explicit
                  #CoglFramebuffer arguments so this stack of
                  framebuffers shouldn't be used anymore.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglFramebuffer object, either onscreen or offscreen.</doc>
          <type c:type="CoglFramebuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_matrix"
              c:identifier="cogl_push_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Stores the current model-view matrix on the matrix stack. The matrix
can later be restored with cogl_pop_matrix().</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_push_matrix() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="push_source"
              c:identifier="cogl_push_source"
              version="1.6"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Pushes the given @material to the top of the source stack. The
material at the top of this stack defines the GPU state used to
process later primitives as defined by cogl_set_source().</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A #CoglMaterial</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="read_pixels"
              c:identifier="cogl_read_pixels"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This reads a rectangle of pixels from the current framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and the data is returned with a rowstride of (width * 4).

Currently Cogl assumes that the framebuffer is in a premultiplied
format so if @format is non-premultiplied it will convert it. To
read the pixel values without any conversion you should either
specify a format that doesn't use an alpha channel or use one of
the formats ending in PRE.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_read_pixels() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">The window x position to start reading from</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">The window y position to start reading from</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">The width of the rectangle you want to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">The height of the rectangle you want to read</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">Identifies which auxillary buffer you want to read
         (only COGL_READ_PIXELS_COLOR_BUFFER supported currently)</doc>
          <type name="ReadPixelsFlags" c:type="CoglReadPixelsFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">The pixel format you want the result in
         (only COGL_PIXEL_FORMAT_RGBA_8888 supported currently)</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="pixels" transfer-ownership="none">
          <doc xml:space="preserve">The location to write the pixel data.</doc>
          <type name="guint8" c:type="uint8_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle" c:identifier="cogl_rectangle">
      <doc xml:space="preserve">Fills a rectangle at the given coordinates with the current source material</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x_1" transfer-ownership="none">
          <doc xml:space="preserve">X coordinate of the top-left corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_1" transfer-ownership="none">
          <doc xml:space="preserve">Y coordinate of the top-left corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x_2" transfer-ownership="none">
          <doc xml:space="preserve">X coordinate of the bottom-right corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y_2" transfer-ownership="none">
          <doc xml:space="preserve">Y coordinate of the bottom-right corner</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_multitexture_coords"
              c:identifier="cogl_rectangle_with_multitexture_coords"
              version="1.0">
      <doc xml:space="preserve">This function draws a rectangle using the current source material to
texture or fill with. As a material may contain multiple texture layers
this interface lets you supply texture coordinates for each layer of the
material.

The first pair of coordinates are for the first layer (with the smallest
layer index) and if you supply less texture coordinates than there are
layers in the current source material then default texture coordinates
(0.0, 0.0, 1.0, 1.0) are generated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tex_coords" transfer-ownership="none">
          <doc xml:space="preserve">An array containing groups of
  4 float values: [tx1, ty1, tx2, ty2] that are interpreted as two texture
  coordinates; one for the upper left texel, and one for the lower right
  texel. Each value should be between 0.0 and 1.0, where the coordinate
  (0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the
  bottom right.</doc>
          <array zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="tex_coords_len" transfer-ownership="none">
          <doc xml:space="preserve">The length of the tex_coords array. (e.g. for one layer
  and one group of texture coordinates, this would be 4)</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_with_texture_coords"
              c:identifier="cogl_rectangle_with_texture_coords"
              version="1.0">
      <doc xml:space="preserve">Draw a rectangle using the current material and supply texture coordinates
to be used for the first texture layer of the material. To draw the entire
texture pass in @tx1=0.0 @ty1=0.0 @tx2=1.0 @ty2=1.0.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x1" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y1" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate upper left on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x2" transfer-ownership="none">
          <doc xml:space="preserve">x coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y2" transfer-ownership="none">
          <doc xml:space="preserve">y coordinate lower right on screen.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tx1" transfer-ownership="none">
          <doc xml:space="preserve">x part of texture coordinate to use for upper left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty1" transfer-ownership="none">
          <doc xml:space="preserve">y part of texture coordinate to use for upper left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tx2" transfer-ownership="none">
          <doc xml:space="preserve">x part of texture coordinate to use for lower right pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty2" transfer-ownership="none">
          <doc xml:space="preserve">y part of texture coordinate to use for left pixel</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles" c:identifier="cogl_rectangles" version="1.0">
      <doc xml:space="preserve">Draws a series of rectangles in the same way that
cogl_rectangle() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle() separately for each rectangle.

@verts should point to an array of #float&lt;!-- --&gt;s with
@n_rects * 4 elements. Each group of 4 values corresponds to the
parameters x1, y1, x2, and y2, and have the same
meaning as in cogl_rectangle().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts" transfer-ownership="none">
          <doc xml:space="preserve">an array of vertices</doc>
          <array zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <doc xml:space="preserve">number of rectangles to draw</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangles_with_texture_coords"
              c:identifier="cogl_rectangles_with_texture_coords"
              version="0.8.6">
      <doc xml:space="preserve">Draws a series of rectangles in the same way that
cogl_rectangle_with_texture_coords() does. In some situations it can give a
significant performance boost to use this function rather than
calling cogl_rectangle_with_texture_coords() separately for each rectangle.

@verts should point to an array of #float&lt;!-- --&gt;s with
@n_rects * 8 elements. Each group of 8 values corresponds to the
parameters x1, y1, x2, y2, tx1, ty1, tx2 and ty2 and have the same
meaning as in cogl_rectangle_with_texture_coords().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="verts" transfer-ownership="none">
          <doc xml:space="preserve">an array of vertices</doc>
          <array zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
        <parameter name="n_rects" transfer-ownership="none">
          <doc xml:space="preserve">number of rectangles to draw</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="rotate"
              c:identifier="cogl_rotate"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Multiplies the current model-view matrix by one that rotates the
model around the vertex specified by @x, @y and @z. The rotation
follows the right-hand thumb rule so for example rotating by 10
degrees about the vertex (0, 0, 1) causes a small counter-clockwise
rotation.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_rotate() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="angle" transfer-ownership="none">
          <doc xml:space="preserve">Angle in degrees to rotate.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">X-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">Y-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:space="preserve">Z-component of vertex to rotate around.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="scale"
              c:identifier="cogl_scale"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_pop_matrix() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">Amount to scale along the x-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">Amount to scale along the y-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:space="preserve">Amount to scale along the z-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_backface_culling_enabled"
              c:identifier="cogl_set_backface_culling_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Sets whether textures positioned so that their backface is showing
should be hidden. This can be used to efficiently draw two-sided
textures or fully closed cubes without enabling depth testing. This
only affects calls to the cogl_rectangle* family of functions and
cogl_vertex_buffer_draw*. Backface culling is disabled by default.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_cull_face_mode() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to enable backface culling or %FALSE to disable.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_depth_test_enabled"
              c:identifier="cogl_set_depth_test_enabled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Sets whether depth testing is enabled. If it is disabled then the
order that actors are layered on the screen depends solely on the
order specified using clutter_actor_raise() and
clutter_actor_lower(), otherwise it will also take into account the
actor's depth. Depth testing is disabled by default.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_pipeline_set_depth_state() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="setting" transfer-ownership="none">
          <doc xml:space="preserve">%TRUE to enable depth testing or %FALSE to disable.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_draw_buffer"
              c:identifier="cogl_set_draw_buffer"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Redirects all subsequent drawing to the specified framebuffer. This
can either be an offscreen buffer created with
cogl_offscreen_new_to_texture () or you can revert to your original
on screen window buffer.</doc>
      <doc-deprecated xml:space="preserve">The latest drawing apis take explicit
                  #CoglFramebuffer arguments so this stack of
                  framebuffers shouldn't be used anymore.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglBufferTarget that specifies what kind of framebuffer you
         are setting as the render target.</doc>
          <type name="BufferTarget" c:type="CoglBufferTarget"/>
        </parameter>
        <parameter name="offscreen" transfer-ownership="none">
          <doc xml:space="preserve">If you are setting a framebuffer of type COGL_OFFSCREEN_BUFFER
            then this is a CoglHandle for the offscreen buffer.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_fog"
              c:identifier="cogl_set_fog"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Enables fogging. Fogging causes vertices that are further away from the eye
to be rendered with a different color. The color is determined according to
the chosen fog mode; at it's simplest the color is linearly interpolated so
that vertices at @z_near are drawn fully with their original color and
vertices at @z_far are drawn fully with @fog_color. Fogging will remain
enabled until you call cogl_disable_fog().

&lt;note&gt;The fogging functions only work correctly when primitives use
unmultiplied alpha colors. By default Cogl will premultiply textures
and cogl_set_source_color() will premultiply colors, so unless you
explicitly load your textures requesting an unmultiplied internal format
and use cogl_material_set_color() you can only use fogging with fully
opaque primitives. This might improve in the future when we can depend
on fragment shaders.&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet shader api for fog</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fog_color" transfer-ownership="none">
          <doc xml:space="preserve">The color of the fog</doc>
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglFogMode that determines the equation used to calculate the
  fogging blend factor.</doc>
          <type name="FogMode" c:type="CoglFogMode"/>
        </parameter>
        <parameter name="density" transfer-ownership="none">
          <doc xml:space="preserve">Used by %COGL_FOG_MODE_EXPONENTIAL and by
  %COGL_FOG_MODE_EXPONENTIAL_SQUARED equations.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_near" transfer-ownership="none">
          <doc xml:space="preserve">Position along Z axis where no fogging should be applied</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z_far" transfer-ownership="none">
          <doc xml:space="preserve">Position along Z axis where full fogging should be applied</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_framebuffer"
              c:identifier="cogl_set_framebuffer"
              version="1.2"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This redirects all subsequent drawing to the specified framebuffer. This can
either be an offscreen buffer created with cogl_offscreen_new_to_texture ()
or in the future it may be an onscreen framebuffers too.</doc>
      <doc-deprecated xml:space="preserve">The latest drawing apis take explicit
                  #CoglFramebuffer arguments so this stack of
                  framebuffers shouldn't be used anymore.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglFramebuffer object, either onscreen or offscreen.</doc>
          <type c:type="CoglFramebuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_modelview_matrix"
              c:identifier="cogl_set_modelview_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Loads @matrix as the new model-view matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_modelview_matrix()
                  instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">the new model-view matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_projection_matrix"
              c:identifier="cogl_set_projection_matrix"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Loads matrix as the new projection matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_projection_matrix()
                  instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">the new projection matrix</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source"
              c:identifier="cogl_set_source"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This function changes the material at the top of the source stack.
The material at the top of this stack defines the GPU state used to
process subsequent primitives, such as rectangles drawn with
cogl_rectangle() or vertices drawn using cogl_vertex_buffer_draw().</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="material"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A #CoglMaterial</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color"
              c:identifier="cogl_set_source_color"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This is a convenience function for creating a solid fill source material
from the given color. This color will be used for any subsequent drawing
operation.

The color will be premultiplied by Cogl, so the color should be
non-premultiplied. For example: use (1.0, 0.0, 0.0, 0.5) for
semi-transparent red.

See also cogl_set_source_color4ub() and cogl_set_source_color4f()
if you already have the color components.</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglColor</doc>
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4f"
              c:identifier="cogl_set_source_color4f"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This is a convenience function for creating a solid fill source material
from the given color using normalized values for each component. This color
will be used for any subsequent drawing operation.

The value for each component is a fixed point number in the range
between 0 and %1.0. If the values passed in are outside that
range, they will be clamped.</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve">value of the red channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve">value of the green channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve">value of the blue channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:space="preserve">value of the alpha channel, between 0 and %1.0</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_color4ub"
              c:identifier="cogl_set_source_color4ub"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This is a convenience function for creating a solid fill source material
from the given color using unsigned bytes for each component. This
color will be used for any subsequent drawing operation.

The value for each component is an unsigned byte in the range
between 0 and 255.</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="red" transfer-ownership="none">
          <doc xml:space="preserve">value of the red channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="green" transfer-ownership="none">
          <doc xml:space="preserve">value of the green channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="blue" transfer-ownership="none">
          <doc xml:space="preserve">value of the blue channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="alpha" transfer-ownership="none">
          <doc xml:space="preserve">value of the alpha channel, between 0 and 255</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_source_texture"
              c:identifier="cogl_set_source_texture"
              version="1.0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This is a convenience function for creating a material with the first
layer set to @texture and setting that material as the source with
cogl_set_source.

Note: There is no interaction between calls to cogl_set_source_color
and cogl_set_source_texture. If you need to blend a texture with a color then
you can create a simple material like this:
&lt;programlisting&gt;
material = cogl_material_new ();
cogl_material_set_color4ub (material, 0xff, 0x00, 0x00, 0x80);
cogl_material_set_layer (material, 0, tex_handle);
cogl_set_source (material);
&lt;/programlisting&gt;</doc>
      <doc-deprecated xml:space="preserve">Latest drawing apis all take an explicit
                  #CoglPipeline argument so this stack of
                  #CoglMaterial&lt;!-- --&gt;s shouldn't be used.</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:space="preserve">The #CoglTexture you want as your source</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_viewport"
              c:identifier="cogl_set_viewport"
              version="1.2"
              deprecated="1"
              deprecated-version="1.8">
      <doc xml:space="preserve">Replaces the current viewport with the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_viewport() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">X offset of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">Y offset of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">Width of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">Height of the viewport</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_compile"
              c:identifier="cogl_shader_compile"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Compiles the shader, no return value, but the shader is now ready
for linking into a program. Note that calling this function is
optional. If it is not called then the shader will be automatically
compiled when it is linked.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_info_log"
              c:identifier="cogl_shader_get_info_log"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Retrieves the information log for a coglobject, can be used in conjunction
with cogl_shader_get_parameteriv() to retrieve the compiler warnings/error
messages that caused a shader to not compile correctly, mainly useful for
debugging purposes.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string containing the info log. Use
  g_free() to free it</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_type"
              c:identifier="cogl_shader_get_type"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Retrieves the type of a shader #CoglHandle</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%COGL_SHADER_TYPE_VERTEX if the shader is a vertex processor
         or %COGL_SHADER_TYPE_FRAGMENT if the shader is a frament processor</doc>
        <type name="ShaderType" c:type="CoglShaderType"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_is_compiled"
              c:identifier="cogl_shader_is_compiled"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Retrieves whether a shader #CoglHandle has been compiled</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the shader object has sucessfully be compiled</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_ref"
              c:identifier="cogl_shader_ref"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Add an extra reference to a shader.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">@handle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle to a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_source"
              c:identifier="cogl_shader_source"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Replaces the current source associated with a shader with a new
one.

Please see &lt;link
linkend="cogl-Shaders-and-Programmable-Pipeline.description"&gt;above&lt;/link&gt;
for a description of the recommended format for the shader code.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="shader" transfer-ownership="none">
          <doc xml:space="preserve">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve">Shader source.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_unref"
              c:identifier="cogl_shader_unref"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Removes a reference to a shader. If it was the last reference the
shader object will be destroyed.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglHandle to a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="sqrti" c:identifier="cogl_sqrti" version="1.0">
      <doc xml:space="preserve">Very fast fixed point implementation of square root for integers.

This function is at least 6x faster than clib sqrt() on x86, and (this is
not a typo!) about 500x faster on ARM without FPU. It's error is less than
5% for arguments smaller than %COGL_SQRTI_ARG_5_PERCENT and less than 10%
for narguments smaller than %COGL_SQRTI_ARG_10_PERCENT. The maximum
argument that can be passed to this function is %COGL_SQRTI_ARG_MAX.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">integer square root.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">integer value</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_error_quark"
              c:identifier="cogl_texture_error_quark"
              moved-to="TextureError.quark">
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="texture_ref"
              c:identifier="cogl_texture_ref"
              moved-to="Texture.ref"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Increment the reference count for a cogl texture.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the @texture pointer.</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="texture"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #CoglTexture.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="texture_unref"
              c:identifier="cogl_texture_unref"
              moved-to="Texture.unref"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Decrement the reference count for a cogl texture.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="texture"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #CoglTexture.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="transform"
              c:identifier="cogl_transform"
              version="1.4"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Multiplies the current model-view matrix by the given matrix.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_transform() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">the matrix to multiply with the current model-view</doc>
          <type name="Matrix" c:type="const CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="translate"
              c:identifier="cogl_translate"
              deprecated="1"
              deprecated-version="1.10">
      <doc xml:space="preserve">Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_translate() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve">Distance to translate along the x-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve">Distance to translate along the y-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:space="preserve">Distance to translate along the z-axis</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_add"
              c:identifier="cogl_vertex_buffer_add"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Adds an attribute to a buffer, or replaces a previously added
attribute with the same name.

You either can use one of the built-in names such as "gl_Vertex", or
"gl_MultiTexCoord0" to add standard attributes, like positions, colors
and normals, or you can add custom attributes for use in shaders.

The number of vertices declared when calling cogl_vertex_buffer_new()
determines how many attribute values will be read from the supplied
@pointer.

The data for your attribute isn't copied anywhere until you call
cogl_vertex_buffer_submit(), or issue a draw call which automatically
submits pending attribute changes. so the supplied pointer must remain
valid until then. If you are updating an existing attribute (done by
re-adding it) then you still need to re-call cogl_vertex_buffer_submit()
to commit the changes to the GPU. Be carefull to minimize the number
of calls to cogl_vertex_buffer_submit(), though.

&lt;note&gt;If you are interleving attributes it is assumed that each interleaved
attribute starts no farther than +- stride bytes from the other attributes
it is interleved with. I.e. this is ok:
&lt;programlisting&gt;
|-0-0-0-0-0-0-0-0-0-0|
&lt;/programlisting&gt;
This is not ok:
&lt;programlisting&gt;
|- - - - -0-0-0-0-0-0 0 0 0 0|
&lt;/programlisting&gt;
(Though you can have multiple groups of interleved attributes)&lt;/note&gt;</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of your attribute. It should be a valid GLSL
  variable name and standard attribute types must use one of following
  built-in names: (Note: they correspond to the built-in names of GLSL)
  &lt;itemizedlist&gt;
    &lt;listitem&gt;"gl_Color"&lt;/listitem&gt;
    &lt;listitem&gt;"gl_Normal"&lt;/listitem&gt;
    &lt;listitem&gt;"gl_MultiTexCoord0, gl_MultiTexCoord1, ..."&lt;/listitem&gt;
    &lt;listitem&gt;"gl_Vertex"&lt;/listitem&gt;
  &lt;/itemizedlist&gt;
  To support adding multiple variations of the same attribute the name
  can have a detail component, E.g. "gl_Color::active" or
  "gl_Color::inactive"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve">The number of components per attribute and must be 1, 2,
  3 or 4</doc>
          <type name="guint8" c:type="uint8_t"/>
        </parameter>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglAttributeType specifying the data type of each component.</doc>
          <type name="AttributeType" c:type="CoglAttributeType"/>
        </parameter>
        <parameter name="normalized" transfer-ownership="none">
          <doc xml:space="preserve">If %TRUE, this specifies that values stored in an integer
  format should be mapped into the range [-1.0, 1.0] or [0.0, 1.0]
  for unsigned values. If %FALSE they are converted to floats
  directly.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
        <parameter name="stride" transfer-ownership="none">
          <doc xml:space="preserve">This specifies the number of bytes from the start of one attribute
  value to the start of the next value (for the same attribute). So, for
  example, with a position interleved with color like this:
  XYRGBAXYRGBAXYRGBA, then if each letter represents a byte, the
  stride for both attributes is 6. The special value 0 means the
  values are stored sequentially in memory.</doc>
          <type name="guint16" c:type="uint16_t"/>
        </parameter>
        <parameter name="pointer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">This addresses the first attribute in the vertex array. This
  must remain valid until you either call cogl_vertex_buffer_submit() or
  issue a draw call.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_delete"
              c:identifier="cogl_vertex_buffer_delete"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Deletes an attribute from a buffer. You will need to call
cogl_vertex_buffer_submit() or issue a draw call to commit this
change to the GPU.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of a previously added attribute</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_disable"
              c:identifier="cogl_vertex_buffer_disable"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Disables a previosuly added attribute.

Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.

You don't need to call cogl_vertex_buffer_submit() after using this
function.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute you want to disable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw"
              c:identifier="cogl_vertex_buffer_draw"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Allows you to draw geometry using all or a subset of the
vertices in a vertex buffer.

Any un-submitted attribute changes are automatically submitted before
drawing.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglVerticesMode specifying how the vertices should be
  interpreted.</doc>
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="first" transfer-ownership="none">
          <doc xml:space="preserve">Specifies the index of the first vertex you want to draw with</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">Specifies the number of vertices you want to draw.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_draw_elements"
              c:identifier="cogl_vertex_buffer_draw_elements"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">This function lets you use an array of indices to specify the vertices
within your vertex buffer that you want to draw. The indices themselves
are created by calling cogl_vertex_buffer_indices_new ()

Any un-submitted attribute changes are automatically submitted before
drawing.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="mode" transfer-ownership="none">
          <doc xml:space="preserve">A #CoglVerticesMode specifying how the vertices should be
   interpreted.</doc>
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </parameter>
        <parameter name="indices" transfer-ownership="none">
          <doc xml:space="preserve">A CoglHandle for a set of indices allocated via
   cogl_vertex_buffer_indices_new ()</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="min_index" transfer-ownership="none">
          <doc xml:space="preserve">Specifies the minimum vertex index contained in indices</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="max_index" transfer-ownership="none">
          <doc xml:space="preserve">Specifies the maximum vertex index contained in indices</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="indices_offset" transfer-ownership="none">
          <doc xml:space="preserve">An offset into named indices. The offset marks the first
   index to use for drawing.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">Specifies the number of vertices you want to draw.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_enable"
              c:identifier="cogl_vertex_buffer_enable"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Enables a previosuly disabled attribute.

Since it can be costly to add and remove new attributes to buffers; to make
individual buffers more reuseable it is possible to enable and disable
attributes before using a buffer for drawing.

You don't need to call cogl_vertex_buffer_submit() after using this function</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="attribute_name" transfer-ownership="none">
          <doc xml:space="preserve">The name of the attribute you want to enable</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_get_n_vertices"
              c:identifier="cogl_vertex_buffer_get_n_vertices"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Retrieves the number of vertices that @handle represents</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of vertices</doc>
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_for_quads"
              c:identifier="cogl_vertex_buffer_indices_get_for_quads"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Creates a vertex buffer containing the indices needed to draw pairs
of triangles from a list of vertices grouped as quads. There will
be at least @n_indices entries in the buffer (but there may be
more).

The indices will follow this pattern:

0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7 ... etc

For example, if you submit vertices for a quad like like that shown
in &lt;xref linkend="quad-indices-order"/&gt; then you can request 6
indices to render two triangles like those shown in &lt;xref
linkend="quad-indices-triangles"/&gt;.

&lt;figure id="quad-indices-order"&gt;
  &lt;title&gt;Example of vertices submitted to form a quad&lt;/title&gt;
  &lt;graphic fileref="quad-indices-order.png" format="PNG"/&gt;
&lt;/figure&gt;

&lt;figure id="quad-indices-triangles"&gt;
  &lt;title&gt;Illustration of the triangle indices that will be generated&lt;/title&gt;
  &lt;graphic fileref="quad-indices-triangles.png" format="PNG"/&gt;
&lt;/figure&gt;</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A %CoglHandle containing the indices. The handled is
owned by Cogl and should not be modified or unref'd.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_indices" transfer-ownership="none">
          <doc xml:space="preserve">the number of indices in the vertex buffer.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_get_type"
              c:identifier="cogl_vertex_buffer_indices_get_type"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Queries back the data type used for the given indices</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The CoglIndicesType used</doc>
        <type name="IndicesType" c:type="CoglIndicesType"/>
      </return-value>
      <parameters>
        <parameter name="indices" transfer-ownership="none">
          <doc xml:space="preserve">An indices handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_indices_new"
              c:identifier="cogl_vertex_buffer_indices_new"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Depending on how much geometry you are submitting it can be worthwhile
optimizing the number of redundant vertices you submit. Using an index
array allows you to reference vertices multiple times, for example
during triangle strips.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A CoglHandle for the indices which you can pass to
  cogl_vertex_buffer_draw_elements().</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="indices_type" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglIndicesType specifying the data type used for
   the indices.</doc>
          <type name="IndicesType" c:type="CoglIndicesType"/>
        </parameter>
        <parameter name="indices_array" transfer-ownership="none">
          <doc xml:space="preserve">Specifies the address of
  your array of indices</doc>
          <array length="2" zero-terminated="0" c:type="void*">
            <type name="gpointer" c:type="void"/>
          </array>
        </parameter>
        <parameter name="indices_len" transfer-ownership="none">
          <doc xml:space="preserve">The number of indices in indices_array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_new"
              c:identifier="cogl_vertex_buffer_new"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Creates a new vertex buffer that you can use to add attributes.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a new #CoglHandle</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="n_vertices" transfer-ownership="none">
          <doc xml:space="preserve">The number of vertices that your attributes will correspond to.</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_ref"
              c:identifier="cogl_vertex_buffer_ref"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Increment the reference count for a vertex buffer</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_ref() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the @handle.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a @CoglHandle.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_submit"
              c:identifier="cogl_vertex_buffer_submit"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve">Submits all the user added attributes to the GPU; once submitted, the
attributes can be used for drawing.

You should aim to minimize calls to this function since it implies
validating your data; it potentially incurs a transport cost (especially if
you are using GLX indirect rendering) and potentially a format conversion
cost if the GPU doesn't natively support any of the given attribute formats.</doc>
      <doc-deprecated xml:space="preserve">Use the #CoglPrimitive api instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">A vertex buffer handle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="vertex_buffer_unref"
              c:identifier="cogl_vertex_buffer_unref"
              deprecated="1"
              deprecated-version="1.2">
      <doc xml:space="preserve">Decrement the reference count for a vertex buffer</doc>
      <doc-deprecated xml:space="preserve">Use cogl_object_unref() instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve">a @CoglHandle.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="viewport"
              c:identifier="cogl_viewport"
              version="0.8.2"
              deprecated="1"
              deprecated-version="1.8">
      <doc xml:space="preserve">Replace the current viewport with the given values.</doc>
      <doc-deprecated xml:space="preserve">Use cogl_framebuffer_set_viewport instead</doc-deprecated>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">Width of the viewport</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve">Height of the viewport</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_add_filter"
              c:identifier="cogl_xlib_renderer_add_filter"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_display"
              c:identifier="cogl_xlib_renderer_get_display"
              introspectable="0">
      <return-value>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_foreign_display"
              c:identifier="cogl_xlib_renderer_get_foreign_display"
              introspectable="0">
      <return-value>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_visual_info"
              c:identifier="cogl_xlib_renderer_get_visual_info"
              introspectable="0">
      <return-value>
        <type c:type="XVisualInfo*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_handle_event"
              c:identifier="cogl_xlib_renderer_handle_event"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <type c:type="XEvent*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_remove_filter"
              c:identifier="cogl_xlib_renderer_remove_filter"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_event_retrieval_enabled"
              c:identifier="cogl_xlib_renderer_set_event_retrieval_enabled"
              version="1.10"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve">Sets whether Cogl should automatically retrieve events from the X
display. This defaults to %TRUE unless
cogl_xlib_renderer_set_foreign_display() is called. It can be set
to %FALSE if the application wants to handle its own event
retrieval. Note that Cogl still needs to see all of the X events to
function properly so the application should call
cogl_xlib_renderer_handle_event() for each event if it disables
automatic event retrieval.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="enable" transfer-ownership="none">
          <doc xml:space="preserve">The new value</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_foreign_display"
              c:identifier="cogl_xlib_renderer_set_foreign_display"
              introspectable="0">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none">
          <type c:type="Display*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
