/* vsgi.vapi generated by valac 0.32.1, do not modify. */

/**
 * VSGI is an set of abstraction and implementations used to build generic web
 * application in Vala.
 *
 * It is minimalist and relies on libsoup-2.4, a good and stable HTTP library.
 *
 * Two implementation are available: libsoup built-in Soup.Server and FastCGI.
 * The latter integrates with pretty much any web server.
 */
[CCode (gir_namespace = "VSGI", gir_version = "0.2")]
namespace VSGI {
	/**
	 * CGI implementation of VSGI.
	 *
	 * This implementation is sufficiently general to implement other CGI-like
	 * protocol such as FastCGI and SCGI.
	 *
	 * @since 0.2
	 */
	[CCode (gir_namespace = "VSGI.CGI", gir_version = "0.2")]
	namespace CGI {
		[CCode (cheader_filename = "vsgi.h")]
		public class Request : VSGI.Request {
			/**
			 * Create a request from the provided environment variables.
			 *
			 * Although not part of CGI/1.1 specification, the 'REQUEST_URI' and
			 * 'HTTPS' environment variables are reckognized.
			 *
			 * {@inheritDoc}
			 *
			 * @since 0.2
			 *
			 * @param environment environment variables
			 */
			public Request (GLib.IOStream connection, GLib.HashTable<string,string> environment);
			/**
			 * CGI environment variables.
			 *
			 * @since 0.2
			 */
			public GLib.HashTable<string,string> environment { get; construct; }
			public override global::Soup.MessageHeaders headers { get; }
			public override global::Soup.HTTPVersion http_version { get; }
			public override string method { owned get; }
			public override GLib.HashTable<string,string>? query { get; }
			public override global::Soup.URI uri { get; }
		}
		[CCode (cheader_filename = "vsgi.h")]
		public class Response : VSGI.Response {
			public Response (VSGI.CGI.Request request);
			/**
			 * {@inheritDoc}
			 *
			 * CGI protocols does not have a status line. They use the 'Status'
			 * header instead.
			 */
			protected override uint8[]? build_head ();
			public override global::Soup.MessageHeaders headers { get; }
		}
		/**
		 * {@inheritDoc}
		 *
		 * Unlike other VSGI implementations, which are actively awaiting upon
		 * requests, CGI handles a single request and then wait until the underlying
		 * {@link GLib.Application} quits. Longstanding operations can invoke
		 * {@link GLib.Application.hold} and {@link GLib.Application.release} to
		 * keep the server alive as long as necessary.
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Server : VSGI.Server {
			public Server (string application_id, owned VSGI.ApplicationCallback application);
			public override int command_line (GLib.ApplicationCommandLine command_line);
		}
	}
	namespace Cookies {
		/**
		 * Extract cookies from the 'Cookie' headers.
		 *
		 * @since 0.2
		 *
		 * @param request request from which cookies will be extracted
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public static GLib.SList<global::Soup.Cookie> from_request (VSGI.Request request);
		/**
		 * Extract cookies from the 'Set-Cookie' headers.
		 *
		 * @since 0.2
		 *
		 * @param response response from which cookies will be extracted
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public static GLib.SList<global::Soup.Cookie> from_response (VSGI.Response response);
		/**
		 * Lookup a cookie by its name.
		 *
		 * The last occurence is returned using a case-sensitive match.
		 *
		 * @since 0.2
		 *
		 * @param cookies cookies typically extracted from {@link VSGI.Cookies.from_request}
		 * @param name    name of the cookie to lookup
		 * @return the cookie if found, otherwise null
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public static global::Soup.Cookie? lookup (GLib.SList<global::Soup.Cookie> cookies, string name);
		/**
		 * Sign the provided cookie name and value using HMAC.
		 *
		 * The returned value will be 'HMAC(checksum_type, name + HMAC(checksum_type, value)) + value'
		 * suitable for a cookie value which can the be verified with {@link VSGI.Cookies.verify}.
		 *
		 * {{{
		 * cookie.@value = Cookies.sign (cookie, ChecksumType.SHA512, "super-secret".data);
		 * }}}
		 *
		 * @param cookie        cookie to sign
		 * @param checksum_type hash algorithm used to compute the HMAC
		 * @param key           secret used to sign the cookie name and value
		 * @return              the signed value for the provided cookie, which can
		 *                      be reassigned in the cookie
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public static string sign (global::Soup.Cookie cookie, GLib.ChecksumType checksum_type, uint8[] key);
		/**
		 * Verify a signed cookie from {@link VSGI.Cookies.sign}.
		 *
		 * The signature is verified in constant time, more specifically a number
		 * of comparisons equal to length of the checksum.
		 *
		 * @param cookie        cookie which signature will be verified
		 * @param checksum_type hash algorithm used to compute the HMAC
		 * @param key           secret used to sign the cookie's value
		 * @param value         cookie's value extracted from its signature if the
		 *                      verification succeeds, null otherwise
		 * @return              true if the cookie is signed by the secret
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public static bool verify (global::Soup.Cookie cookie, GLib.ChecksumType checksum_type, uint8[] key, out string? value = null);
	}
	/**
	 * FastCGI implementation of VSGI.
	 *
	 * @since 0.1
	 */
	[CCode (gir_namespace = "VSGI.FastCGI", gir_version = "0.2")]
	namespace FastCGI {
		/**
		 * {@inheritDoc}
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Request : VSGI.CGI.Request {
			/**
			 * {@inheritDoc}
			 *
			 * Initialize FastCGI-specific environment variables.
			 */
			public Request (GLib.IOStream connection, GLib.HashTable<string,string> environment);
		}
		/**
		 * FastCGI Response
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Response : VSGI.CGI.Response {
			/**
			 * {@inheritDoc}
			 */
			public Response (VSGI.FastCGI.Request req);
		}
		/**
		 * FastCGI Server using GLib.MainLoop.
		 *
		 * @since 0.1
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Server : VSGI.Server {
			/**
			 * {@inheritDoc}
			 */
			public Server (string application_id, owned VSGI.ApplicationCallback application);
			public override int command_line (GLib.ApplicationCommandLine command_line);
		}
		/**
		 * @since 0.3
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public errordomain RequestError {
			FAILED
		}
	}
	/**
	 * SCGI implementation of VSGI.
	 *
	 * This implementation takes a maximum advantage of non-blocking I/O as it is
	 * fully implemented with GIO APIs.
	 *
	 * The request InputStream is initially consumed as a netstring to extract the
	 * environment variables using a {@link GLib.DataInputStream}. The resulting
	 * stream is then exposed as the request body.
	 *
	 * @since 0.2
	 */
	[CCode (gir_namespace = "VSGI.SCGI", gir_version = "0.2")]
	namespace SCGI {
		/**
		 * {@inheritDoc}
		 *
		 * The connection {@link GLib.InputStream} is ignored as it is being
		 * typically consumed for its netstring. This is why the constructor
		 * expects a separate body stream.
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Request : VSGI.CGI.Request {
			/**
			 * {@inheritDoc}
			 *
			 * @since 2.3.3
			 *
			 * @param reader stream holding the request body
			 */
			public Request (GLib.IOStream connection, VSGI.SCGI.SCGIInputStream reader, GLib.HashTable<string,string> environment);
			public override GLib.InputStream body { get; }
		}
		/**
		 * {@inheritDoc}
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Response : VSGI.CGI.Response {
			public Response (VSGI.SCGI.Request request);
		}
		/**
		 * Filter a SCGI request stream to provide the end-of-file behaviour of a
		 * typical {@link GLib.InputStream}.
		 *
		 * @since 0.2.3
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class SCGIInputStream : GLib.FilterInputStream {
			/**
			 * {@inheritDoc}
			 *
			 * @param content_length number of bytes that can be read from the base
			 *                       stream
			 */
			public SCGIInputStream (GLib.InputStream base_stream, int64 content_length);
			/**
			 * {@inheritDoc}
			 */
			public override bool close (GLib.Cancellable? cancellable = null) throws GLib.IOError;
			/**
			 * {@inheritDoc}
			 *
			 * Ensures that the read buffer is smaller than the remaining bytes to
			 * read from the base stream. If no more data is available, it produces
			 * an artificial EOF.
			 */
			public override ssize_t read (uint8[] buffer, GLib.Cancellable? cancellable = null) throws GLib.IOError;
			/**
			 * The {@link int64} type is used to remain consistent with
			 * {@link Soup.MessageHeaders.get_content_length}
			 *
			 * @since 0.2.3
			 */
			public int64 content_length { get; construct; }
		}
		/**
		 * {@inheritDoc}
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Server : VSGI.Server {
			public Server (string application_id, owned VSGI.ApplicationCallback application);
			public override int command_line (GLib.ApplicationCommandLine command_line);
			/**
			 * @since 0.2.4
			 */
			public GLib.SocketService listener { get; protected set; }
		}
	}
	/**
	 * Soup implementation of VSGI.
	 *
	 * @since 0.1
	 */
	[CCode (gir_namespace = "VSGI.Soup", gir_version = "0.2")]
	namespace Soup {
		/**
		 * Soup Request
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Request : VSGI.Request {
			/**
			 * {@inheritDoc}
			 *
			 * @since 0.2
			 *
			 * @param connection contains the connection obtain from
			 *                   {@link Soup.ClientContext.steal_connection} or a
			 *                   stud if it is not available
			 * @param msg        message underlying this request
			 * @param query      parsed HTTP query provided by {@link Soup.ServerCallback}
			 */
			public Request (GLib.IOStream connection, global::Soup.Message msg, GLib.HashTable<string,string>? query);
			/**
			 * {@inheritDoc}
			 */
			public override uint8[] flatten (GLib.Cancellable? cancellable = null);
			/**
			 * {@inheritDoc}
			 */
			public override async uint8[] flatten_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null);
			/**
			 * {@inheritDoc}
			 *
			 * The body from the connection is already consumed, so we provide a
			 * memory-based stream over the message data.
			 */
			public override GLib.InputStream body { get; }
			public override global::Soup.MessageHeaders headers { get; }
			public override global::Soup.HTTPVersion http_version { get; }
			/**
			 * Message underlying this request.
			 *
			 * @since 0.2
			 */
			public global::Soup.Message message { get; construct; }
			public override string method { owned get; }
			public override GLib.HashTable<string,string>? query { get; }
			public override global::Soup.URI uri { get; }
		}
		/**
		 * Soup Response
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Response : VSGI.Response {
			/**
			 * {@inheritDoc}
			 *
			 * @since 0.2
			 *
			 * @param msg message underlying this response
			 */
			public Response (VSGI.Soup.Request req, global::Soup.Message msg);
			/**
			 * {@inheritDoc}
			 *
			 * If libsoup-2.4 (>=2.50) is available and the http_version in the
			 * {@link Request} is set to 'HTTP/1.1', chunked encoding will be
			 * applied.
			 */
			protected override GLib.OutputStream body { get; }
			public override global::Soup.MessageHeaders headers { get; }
			/**
			 * Message underlying this response.
			 *
			 * @since 0.2
			 */
			public global::Soup.Message message { get; construct; }
			public override uint status { get; set; }
		}
		/**
		 * Implementation of VSGI.Server based on Soup.Server.
		 *
		 * @since 0.1
		 */
		[CCode (cheader_filename = "vsgi.h")]
		public class Server : VSGI.Server {
			/**
			 * {@inheritDoc}
			 */
			public Server (string application_id, owned VSGI.ApplicationCallback application);
			public override int command_line (GLib.ApplicationCommandLine command_line);
		}
	}
	/**
	 * Chunks data according to RFC2616 section 3.6.1.
	 *
	 * [[http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1]]
	 *
	 * This process has an expansion factor of ceil (log_16 (size)) + 4 due to
	 * the presence of predicted size and newlines.
	 *
	 * The process will always try to convert as much data as possible, chunking
	 * a single bloc per convert call.
	 *
	 * @since 0.2
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public class ChunkedEncoder : GLib.Object, GLib.Converter {
		public ChunkedEncoder ();
	}
	/**
	 * Apply a {@link GLib.Converter} on the base request body.
	 *
	 * @since 0.2
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public class ConvertedRequest : VSGI.FilteredRequest {
		/**
		 * @since 0.2
		 */
		public ConvertedRequest (VSGI.Request base_request, GLib.Converter converter);
		public override GLib.InputStream body { get; }
		/**
		 * @since 0.2
		 */
		public GLib.Converter converter { get; construct; }
	}
	/**
	 * Apply a {@link GLib.Converter} on the base response body.
	 *
	 * @since 0.2
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public class ConvertedResponse : VSGI.FilteredResponse {
		/**
		 * @since 0.2
		 */
		public ConvertedResponse (VSGI.Response base_response, GLib.Converter converter);
		public override GLib.OutputStream body { get; }
		/**
		 * @since 0.2
		 */
		public GLib.Converter converter { get; construct; }
	}
	/**
	 * Base to build {@link VSGI.Request} filters.
	 *
	 * @since 0.2
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public abstract class FilteredRequest : VSGI.Request {
		public FilteredRequest ();
		public override uint8[] flatten (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		public override async uint8[] flatten_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * @since 0.2
		 */
		public VSGI.Request base_request { get; construct; }
		public override GLib.InputStream body { get; }
		public override global::Soup.MessageHeaders headers { get; }
		public override global::Soup.HTTPVersion http_version { get; }
		public override string method { owned get; }
		public override GLib.HashTable<string,string>? query { get; }
		public override global::Soup.URI uri { get; }
	}
	/**
	 * Base to build {@link VSGI.Response} filters.
	 *
	 * @since 0.2
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public abstract class FilteredResponse : VSGI.Response {
		public FilteredResponse ();
		protected override uint8[]? build_head ();
		/**
		 * @since 0.2
		 */
		public VSGI.Response base_response { get; construct; }
		public override GLib.OutputStream body { get; }
		public override bool head_written { get; protected set; }
		public override global::Soup.MessageHeaders headers { get; }
		public override uint status { get; set; }
	}
	/**
	 * Request representing a request of a resource.
	 *
	 * @since 0.0.1
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public abstract class Request : GLib.Object {
		public const string CONNECT;
		public const string DELETE;
		public const string GET;
		public const string HEAD;
		/**
		 * List of all supported HTTP methods.
		 *
		 * @since 0.1
		 */
		public const string[] METHODS;
		/**
		 * HTTP/1.1 standard methods.
		 *
		 * [[http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html]]
		 *
		 * @since 0.1
		 */
		public const string OPTIONS;
		/**
		 * PATCH method defined in RFC5789.
		 *
		 * [[http://tools.ietf.org/html/rfc5789]]
		 *
		 * This is a proposed standard, it is not part of the current HTTP/1.1
		 * protocol.
		 *
		 * @since 0.1
		 */
		public const string PATCH;
		public const string POST;
		public const string PUT;
		public const string TRACE;
		public Request ();
		/**
		 * Buffer the body stream.
		 *
		 * This function consumes the body stream. Any subsequent calls will
		 * yield an empty buffer.
		 *
		 * If the 'Content-Length' header is set, a fixed-size buffer is used
		 * instead of dynamically resizing the buffer to fit the stream content.
		 *
		 * @since 0.2.3
		 *
		 * @return buffer containing the stream data
		 */
		public virtual uint8[] flatten (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * Buffer the body stream asynchronously.
		 *
		 * @since 0.2.3
		 *
		 * @return buffer containing the stream data
		 */
		public virtual async uint8[] flatten_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * @since 0.2.3
		 */
		public GLib.Bytes flatten_bytes (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * @since 0.2.3
		 */
		public async GLib.Bytes flatten_bytes_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * @since 0.2.4
		 */
		public string flatten_utf8 (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * @since 0.2.4
		 */
		public async string flatten_utf8_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * Request body.
		 *
		 * The provided stream is filtered by the implementation according to
		 * the 'Transfer-Encoding' header value.
		 *
		 * The default implementation returns the connection stream unmodified.
		 *
		 * @since 0.2
		 */
		public virtual GLib.InputStream body { get; }
		/**
		 * Connection containing raw streams.
		 *
		 * @since 0.2
		 */
		public GLib.IOStream connection { get; construct; }
		/**
		 * Request headers.
		 *
		 * @since 0.0.1
		 */
		public abstract global::Soup.MessageHeaders headers { get; }
		/**
		 * Request HTTP version.
		 */
		public abstract global::Soup.HTTPVersion http_version { get; }
		/**
		 * Request HTTP method
		 *
		 * Should be one of OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT
		 * or PATCH.
		 *
		 * Constants for every standard HTTP methods are providen as constants in
		 * this class.
		 *
		 * @since 0.0.1
		 */
		public abstract string method { owned get; }
		/**
		 * Parameters for the request.
		 *
		 * These should be extracted from the URI path.
		 *
		 * @since 0.0.1
		 */
		[Deprecated (since = "0.2")]
		public GLib.HashTable<string,string?>? @params { get; set; }
		/**
		 * HTTP query.
		 *
		 * This is null if the query hasn't been set.
		 *
		 * /path/? empty query
		 * /path/  null query
		 *
		 * @since 0.1
		 */
		public abstract GLib.HashTable<string,string>? query { get; }
		/**
		 * Request URI.
		 *
		 * The URI, protocol and HTTP query and other request information is
		 * made available through this property.
		 *
		 * @since 0.1
		 */
		public abstract global::Soup.URI uri { get; }
	}
	/**
	 * Response representing a request resource.
	 *
	 * @since 0.0.1
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public abstract class Response : GLib.Object {
		public Response ();
		/**
		 * Produce the head of this response including the status line, the
		 * headers and the newline preceeding the body as it would be written in
		 * the base stream.
		 *
		 * The default implementation will produce a valid HTTP/1.1 head
		 * including the status line and headers.
		 *
		 * @since 0.2
		 */
		protected virtual uint8[]? build_head ();
		/**
		 * Write the head before disposing references to other objects.
		 */
		public override void dispose ();
		/**
		 * Write status line and headers into the base stream.
		 *
		 * This is invoked automatically when accessing the response body for
		 * the first time.
		 *
		 * @since 0.2
		 *
		 * @param bytes_written number of bytes written in the stream see
		 *                      {@link GLib.OutputStream.write_all}
		 * @return wether the head was effectively written
		 */
		public bool write_head (out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * Write status line and headers asynchronously.
		 *
		 * @since 0.2
		 *
		 * @param bytes_written number of bytes written in the stream see
		 *                      {@link GLib.OutputStream.write_all_async}
		 * @return wether the head was effectively written
		 */
		public async bool write_head_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null, out size_t bytes_written) throws GLib.Error;
		/**
		 * Response body.
		 *
		 * On the first attempt to access the response body stream, the status
		 * line and headers will be written synchronously in the response
		 * stream. 'write_head_async' have to be used explicitly to perform a
		 * non-blocking operation.
		 *
		 * The provided stream is safe for transfer encoding and will filter
		 * the stream properly if it's chunked.
		 *
		 * Typically, this would involve appling chunked encoding, buffering,
		 * transparent compression and other kind of filters required by the
		 * implementation.
		 *
		 * For CGI-ish protocols, the server will generally deal with transfer
		 * encoding automatically, so the default implementation is to simply
		 * return the base_stream.
		 *
		 * @since 0.2
		 */
		public virtual GLib.OutputStream body { get; }
		/**
		 * Tells if the head has been written in the connection
		 * {@link GLib.OutputStream}.
		 *
		 * This property can only be set internally.
		 *
		 * @since 0.2
		 */
		public virtual bool head_written { get; protected set; }
		/**
		 * Response headers.
		 *
		 * @since 0.0.1
		 */
		public abstract global::Soup.MessageHeaders headers { get; }
		/**
		 * Request to which this response is responding.
		 *
		 * @since 0.1
		 */
		public VSGI.Request request { get; construct; }
		/**
		 * Response status.
		 *
		 * @since 0.0.1
		 */
		public virtual uint status { get; set; }
	}
	/**
	 * Server that feeds a {@link VSGI.ApplicationCallback} with incoming
	 * requests.
	 *
	 * Once you have initialized a Server instance, start it by calling
	 * {@link GLib.Application.run} with the command-line arguments or a set of
	 * predefined arguments.
	 *
	 * The server should be implemented by overriding the
	 * {@link GLib.Application.command_line} signal.
	 *
	 * @since 0.1
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public class Server : GLib.Application {
		/**
		 * Enforces implementation to take the application as a sole argument
		 * and set the {@link GLib.ApplicationFlags.HANDLES_COMMAND_LINE},
		 * {@link GLib.ApplicationFlags.SEND_ENVIRONMENT} and
		 * {@link GLib.ApplicationFlags.NON_UNIQUE} flags.
		 *
		 * @param application served application
		 *
		 * @since 0.2
		 */
		public Server (string application_id, owned VSGI.ApplicationCallback application);
		/**
		 * Dispatch the request to the application callback.
		 *
		 * The application must call {@link Response.write_head} at some point.
		 *
		 * Once dispatched, the {@link Response.head_written} property is
		 * expected to be true unless its reference still held somewhere else.
		 */
		protected void dispatch (VSGI.Request req, VSGI.Response res);
		/**
		 * Assign the callback used when {@link VSGI.Server.dispatch} is
		 * called.
		 */
		public void set_application_callback (owned VSGI.ApplicationCallback application);
	}
	/**
	 * Process a pair of {@link VSGI.Request} and {@link VSGI.Response}.
	 *
	 * The end continuation must be invoked when the application processing
	 * finishes. It may be invoked in an asynchronous context even after the
	 * callback returns to the callee.
	 *
	 * @since 0.2
	 *
	 * @param req a resource being requested
	 * @param res the response to that request
	 */
	[CCode (cheader_filename = "vsgi.h")]
	public delegate void ApplicationCallback (VSGI.Request req, VSGI.Response res);
}
