/* gxml-0.20.vapi generated by valac 0.50.0.13-bab5f, do not modify. */

[CCode (gir_namespace = "GXml", gir_version = "0.20")]
namespace GXml {
	/**
	 * A class implementing {@link Collection} to store references to
	 * child {@link DomElement} of {@link Collection.element}, using an index.
	 *
	 * {{{
	 *   public class YourObject : GXml.Element {
	 *    [Description (nick="::Name")]
	 *    public string name { get; set; }
	 *   }
	 *   public class YourList : GXml.ArrayList {
	 *    construct {
	 *      try { initialize (typeof (YourObject)); }
	 *      catch (GLib.Error e) {
	 *        warning ("Initialization error for collection type: %s : %s"
	 *             .printf (get_type ().name(), e.message));
	 *      }
	 *    }
	 *   }
	 * }}}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class ArrayList : GXml.BaseCollection, GXml.List {
		public ArrayList ();
		public override bool validate_append (int index, GXml.DomElement element) throws GLib.Error;
	}
	/**
	 * Convenient class to handle a {@link Element}'s attribute
	 * using a list of pre-defined and unmutable values.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class ArrayString : GXml.BaseProperty {
		protected string _value;
		protected string[] _values;
		public ArrayString ();
		public unowned string[] get_values ();
		/**
		 * Convenient method to initialize array of values from an array of strings.
		 * Values are taken and should not be freed after call initialization.
		 */
		public void initialize_strings (owned string[] strs);
		/**
		 * Returns true if current value in attribute is included
		 * in the array of values.
		 */
		public bool is_valid_value ();
		/**
		 * Check if string is in array
		 */
		public bool search (string str);
		/**
		 * Select one string from array at index:
		 */
		public void select (int index);
		/**
		 * {inheritDoc}
		 */
		public override string? value { owned get; set; }
	}
	/**
	 * DOM4 implementation of {@link DomAttr}.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Attr : GXml.Node, GXml.DomAttr {
		protected string _namespace_uri;
		protected GXml.Property prop;
		public Attr (GXml.DomElement element, string name, string val);
		public Attr.@namespace (GXml.DomElement element, string namespace_uri, string? prefix, string name, string val);
		public Attr.reference (GXml.DomElement element, string name);
		public bool is_referenced { get; }
	}
	/**
	 * Base class for collections implementing {@link Collection}, providing basic
	 * infrastructure.
	 *
	 * Collections properties should be initialized with current container element
	 * in order to be able to add new references to elements. Use {@link initialize_element}
	 * to set parent element and {@link search} to find elements for collection.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class BaseCollection : GLib.Object, Gee.Traversable<GXml.DomElement>, Gee.Iterable<GXml.DomElement>, GXml.Collection {
		/**
		 * Element used to refer of containier element. You should define it at construction time
		 * our set it as a construction property.
		 */
		protected GXml.Element _element;
		/**
		 * Local name of {@link DomElement} objects of {@link element}, which could be
		 * contained in this collection.
		 *
		 * Used when reading to add elements to collection. You can set it at construction time,
		 * by, for example, instantiating a object of the type {@link Collection.items_type}
		 * then use {@link GXml.Element.local_name}'s value.
		 */
		protected string _items_name;
		/**
		 * Objects' type to be referenced by this collection and to deserialize objects.
		 * Derived classes, can initialize this value at constructor or as construct property.
		 *
		 * Used when reading and at initialization time, to know {@link GXml.Element.local_name}
		 * at runtime.
		 */
		protected GLib.Type _items_type;
		/**
		 * A collection of node's index referred. Don't modify it manually.
		 */
		protected GLib.Queue<int> _nodes_index;
		protected BaseCollection ();
		/**
		 * {@inheritDoc}
		 */
		public virtual void clear () throws GLib.Error;
		/**
		 * Initialize an {@link Collection} to use an element as children's parent.
		 * Searches for all nodes, calling {@link Collection.search}
		 * with {@link Collection.items_type}, using its
		 * {@link DomElement.local_name} to find it.
		 *
		 * Implementation classes, should initialize collection to hold a {@link GXml.Element}
		 * derived type using {@link Collection.initialize}.
		 */
		public void initialize_element (GXml.Element e) throws GLib.Error;
		/**
		 * {@inheritDoc}
		 */
		public abstract bool validate_append (int index, GXml.DomElement element) throws GLib.Error;
	}
	/**
	 * Base class for properties implementing {@link Property} interface.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class BaseProperty : GLib.Object, GXml.Property {
		protected BaseProperty ();
		/**
		 * Takes a string and check if it can be valid for this property.
		 */
		public virtual bool validate_value (string? val);
		/**
		 * {@inheritDoc}
		 */
		public abstract string? value { owned get; set; }
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using a boolean ('true' and 'false') as sources of values.
	 *
	 * Property is represented as a string, using 'true' or 'false'.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Boolean : GXml.BaseProperty {
		protected bool _value;
		public Boolean ();
		/**
		 * Retrieve current value.
		 */
		public bool get_boolean ();
		/**
		 * Sets current value.
		 */
		public void set_boolean (bool value);
		public override string? value { owned get; set; }
	}
	/**
	 * A DOM4 implementation of {@link DomCharacterData}, for one step parsing.
	 *
	 * This object avoids pre and post XML parsing, by using a one step parsing
	 * to translate text XML tree to an GObject based tree.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CharacterData : GXml.Node, GXml.DomNonDocumentTypeChildNode, GXml.DomChildNode, GXml.DomCharacterData {
		public CharacterData ();
	}
	/**
	 * A DOM4 implementation of {@link DomComment}, for one step parsing.
	 *
	 * This object avoids pre and post XML parsing, by using a one step parsing
	 * to translate text XML tree to an GObject based tree.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Comment : GXml.CharacterData, GXml.DomComment {
		public Comment (GXml.DomDocument doc, string data);
	}
	/**
	 * CssSelector for attributes
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CssAttributeSelector : GXml.CssSelector {
		public CssAttributeSelector (string? prefix = null, string local_name = "");
		public string local_name { get; set; }
		public string? prefix { get; set; }
	}
	/**
	 * CssSelector for elements
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CssElementSelector : GXml.CssSelector {
		public CssElementSelector (string? prefix = null, string local_name = "");
		public string local_name { owned get; set; }
		public string? prefix { owned get; set; }
		public bool prefixed { get; }
	}
	/**
	 * CssSelector for 'not' pseudo class 
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CssNotSelector : GXml.CssSelector {
		public CssNotSelector ();
		/**
		 * a list of {@link GXml.CssSelector} that shouldn't match as a
		 * {@link Gee.List} of {@link GXml.CssSelector}
		 */
		public Gee.List<GXml.CssSelector> selectors { get; }
	}
	/**
	 * generic CSS selector, used by {@link GXml.CssSelectorParser}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CssSelector : GLib.Object {
		public CssSelector (GXml.CssSelectorType t = GXml.CssSelectorType.ELEMENT, string name = "");
		public CssSelector.with_value (GXml.CssSelectorType t = GXml.CssSelectorType.ELEMENT, string name, string value);
		public GXml.CssCombiner combiner { get; set; }
		public string name { get; set construct; }
		public GXml.CssSelectorType selector_type { get; set construct; }
		public string value { get; set construct; }
	}
	/**
	 * CSS Selectors Level 3 parser. 
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CssSelectorParser : GLib.Object {
		public CssSelectorParser ();
		/**
		 * Test if provided {@link GXml.DomElement} match with parsed selectors
		 * @param element a {@link GXml.DomElement} to match
		 * @return true if element match, or false 
		 */
		public bool match (GXml.DomElement element) throws GLib.Error;
		/**
		 * parse selectors string. If data isn't valid, error is throwed
		 * 
		 * @param selectors CSS selectors Level 3 string 
		 */
		public void parse (string selectors) throws GLib.Error;
		/**
		 * Retrieve children and descendent nodes that match parsed selectors.
		 * @param element a {@link GXml.DomElement}
		 * @return a {@link GXml.DomNodeList} of selected nodes
		 */
		public GXml.DomNodeList query_selector_all (GXml.DomElement element) throws GLib.Error;
		/**
		 * a list of parsed {@link GXml.CssSelector}  as a
		 * {@link Gee.List} of {@link GXml.CssSelector}
		 */
		public Gee.List<GXml.CssSelector> selectors { get; }
	}
	/**
	 * Custom event handler, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class CustomEvent : GXml.Event {
		protected GLib.Value _detail;
		public CustomEvent ();
		public void init_custom_event (string type, bool bubbles, bool cancelable, GLib.Value? detail);
		public GLib.Value detail { get; }
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using a {@link GLib.Date} as sources of values.
	 *
	 * Property is represented as a string using a %Y-%m-%d format
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Date : GXml.BaseProperty {
		protected GLib.Date _value;
		public Date ();
		/**
		 * Retrieves current value.
		 */
		public GLib.Date get_date ();
		/**
		 * Sets current value.
		 */
		public void set_date (GLib.Date date);
		public override string? value { owned get; set; }
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using a {@link GLib.DateTime} as sources of values.
	 *
	 * Timestamp is considered in UTC time.
	 *
	 * Property is represented as a string using a {@link DateTime.format}
	 * and {@link GLib.DateTime.format} method. If {@link DateTime.format}
	 * is not set '%FT%T' format is used by default.
	 *
	 * For limitations on text parsing, see at {@link GLib.DateTime.DateTime.from_iso8601}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DateTime : GXml.BaseProperty {
		protected GLib.DateTime _value;
		public DateTime ();
		/**
		 * Retrieves current value.
		 */
		public GLib.DateTime get_datetime ();
		/**
		 * Sets current value.
		 */
		public void set_datetime (GLib.DateTime dt);
		public string format { get; set; }
		public override string? value { owned get; set; }
	}
	/**
	 * A DOM4 implementation of {@link DomDocument}, for one step parsing.
	 *
	 * This object avoids pre and post XML parsing, by using a one step parsing
	 * to translate text XML tree to an GObject based tree.
	 *
	 * If you define a property in a derived class with a nick's name '::ROOT' it
	 * will be initialized and used as root node to parse documents, when you call
	 * {@link DomDocument.read_from_string}, {@link DomDocument.read_from_file} or
	 * the like.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Document : GXml.Node, GXml.DomParentNode, GXml.DomNonElementParentNode, GXml.DomDocument, GXml.DomXMLDocument {
		protected string _character_set;
		protected string _compat_mode;
		protected GXml.DomEvent _constructor;
		protected string _content_type;
		protected GXml.DomImplementation _implementation;
		protected string _origin;
		protected GXml.Parser _parser;
		protected string _url;
		public Document ();
		/**
		 * Creates a document parsing a file.
		 */
		public Document.from_file (GLib.File file) throws GLib.Error;
		public Document.from_path (string path) throws GLib.Error;
		/**
		 * Creates a document parsing a stream.
		 */
		public Document.from_stream (GLib.InputStream stream) throws GLib.Error;
		/**
		 * Creates a document parsing a string.
		 */
		public Document.from_string (string str) throws GLib.Error;
		/**
		 * Creates a document parsing a URI file.
		 */
		public Document.from_uri (string uri) throws GLib.Error;
		/**
		 * Search, instantiate and append the element marked as root,
		 * with the nick equal to '::ROOT' (without ').
		 */
		public GXml.Element search_root_element_property ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DocumentFragment : GXml.Node, GXml.DomParentNode, GXml.DomNonElementParentNode, GXml.DomDocumentFragment {
		public DocumentFragment (GXml.DomDocument doc);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DocumentType : GXml.Node, GXml.DomChildNode, GXml.DomDocumentType {
		protected string _name;
		protected string _public_id;
		protected string _system_id;
		public DocumentType (GXml.DomDocument doc, string name, string? public_id, string? system_id);
		public DocumentType.with_ids (GXml.DomDocument doc, string name, string public_id, string system_id);
		public DocumentType.with_name (GXml.DomDocument doc, string name);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomCustomEventInit : GXml.DomEventInit {
		public DomCustomEventInit ();
		public GLib.Value detail { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomElementList : Gee.ArrayList<GXml.DomElement>, GXml.DomHTMLCollection {
		public DomElementList ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomErrorName : GLib.Object {
		public DomErrorName ();
		public int get_code (string error_name);
		public string get_name (int error_code);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomEventInit : GLib.Object {
		public DomEventInit ();
		public bool bubbles { get; set; }
		public bool cancelable { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomMutationObserverInit : GLib.Object {
		public DomMutationObserverInit ();
		public Gee.List<string> attribute_filter { get; set; }
		public bool attribute_old_value { get; set; }
		public bool attributes { get; set; }
		public bool character_data { get; set; }
		public bool character_data_old_value { get; set; }
		public bool child_list { get; set; }
		public bool subtree { get; set; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomNodeFilter : GLib.Object {
		public enum Filter {
			ACCEPT,
			REJECT,
			SKIP
		}
		public const int SHOW_ALL;
		public const int SHOW_ATTRIBUTE;
		public const int SHOW_CDATA_SECTION;
		public const int SHOW_COMMENT;
		public const int SHOW_DOCUMENT;
		public const int SHOW_DOCUMENT_FRAGMENT;
		public const int SHOW_DOCUMENT_TYPE;
		public const int SHOW_ELEMENT;
		public const int SHOW_ENTITY;
		public const int SHOW_ENTITY_REFERENCE;
		public const int SHOW_NOTATION;
		public const int SHOW_PROCESSING_INSTRUCTION;
		public const int SHOW_TEXT;
		public DomNodeFilter ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class DomTimeStamp : GLib.Object {
		public DomTimeStamp ();
		public string to_string ();
		public GLib.DateTime time { get; set; }
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using double precision floats as sources of values.
	 *
	 * Property is represented as a string.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Double : GXml.BaseProperty {
		protected double _value;
		public Double ();
		/**
		 * Retrieve current value.
		 */
		public double get_double ();
		/**
		 * Sets current value.
		 */
		public void set_double (double value);
		/**
		 * Set number of decimals to write out as {@link Element}'s property.
		 * Default is 4.
		 */
		public uint decimals { get; set; }
		public override string? value { owned get; set; }
	}
	/**
	 * A DOM4 implementation of {@link DomElement}, for one-step-parsing.
	 *
	 * This object avoids pre and post XML parsing, by using a one step parsing
	 * to translate text XML tree to an GObject based tree.
	 *
	 * A GXml Object Model (GOM) implementation of {@link GXml.Element}. It can be
	 * used transparently as {@link DomElement} in a XML tree.
	 *
	 * It also allows delayed parsing, so you can read large documents by parsing
	 * just a XML element node and its attributes but not its children; save its
	 * children as a text, for a post-on-step-parsing.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Element : GXml.Node, GXml.DomChildNode, GXml.DomNonDocumentTypeChildNode, GXml.DomParentNode, GXml.DomElement, GXml.Object {
		/**
		 * Holds attributes in current node, using attribute's name as key
		 * and it's value as value. Appends namespace prefix to attribute's name as
		 * key if is a namespaced attribute.
		 */
		public class Attributes : Gee.HashMap<string,GXml.DomNode>, GXml.DomNamedNodeMap {
			/**
			 * Holds {@link GXml.Element} reference to attributes' parent element.
			 * Derived classes should not modify, but set at construction time.
			 */
			protected GXml.Element _element;
			public Attributes (GXml.Element element);
			public void add_reference (string name);
		}
		/**
		 * Reference to {@link Attributes} for element's attributes.
		 * Derived classes should avoid to modify it.
		 */
		protected GXml.Element.Attributes _attributes;
		/**
		 * Use this field to set node's namespace URI. Can used to set it at construction time.
		 */
		protected string _namespace_uri;
		public Element ();
		/**
		 * Convenient function to initialize, at construction time, a {@link GXml.Element}
		 * using given local name. If {@link GXml.Element.initialize_with_namespace}
		 * has been called in any base class, this method just change element node's name
		 * and keeps previous namespace and prefix.
		 *
		 * No {@link DomDocument} is set by default, if this is a top level element in a
		 * document, you can call {@link DomNode.owner_document} to set one if not set
		 * already.
		 *
		 * Any instance properties of type {@link GXml.Element} or {@link Collection}
		 * should be initialized using {@link GXml.Object.set_instance_property}
		 */
		public void initialize (string local_name);
		/**
		 * Convenient function to initialize, at construction time, a {@link GXml.Element}
		 * using given local name and document.
		 */
		public void initialize_document (GXml.DomDocument doc, string local_name);
		/**
		 * Convenient function to initialize, at construction time, a {@link GXml.Element}
		 * using given local name, document and namespace.
		 */
		public void initialize_document_with_namespace (GXml.DomDocument doc, string? namespace_uri, string? prefix, string local_name);
		/**
		 * Convenient function to initialize, at construction time, a {@link GXml.Element}
		 * using given local name and namespace.
		 */
		public void initialize_with_namespace (string? namespace_uri, string? prefix, string local_name);
		public new string? lookup_namespace_uri (string? prefix);
		public new string? lookup_prefix (string? nspace);
		/**
		 * Synchronically parse {@link read_buffer}
		 */
		public void parse_buffer () throws GLib.Error;
		/**
		 * Asynchronically parse {@link read_buffer}
		 */
		public async void parse_buffer_async () throws GLib.Error;
		/**
		 * Monitor multi-threading parsing
		 */
		public uint parse_pending ();
		/**
		 * Parse all children, adding them to current node, stored in {@link unparsed}.
		 * Once it finish, sets {@link unparsed} to null.
		 */
		public void read_unparsed () throws GLib.Error;
		/**
		 * If true all children are parsed. If false, all its children are stored
		 * as plain string in {@link unparsed}. In order to generate an XML tree
		 * use {@link read_unparsed}.
		 */
		public bool parse_children { get; set; }
		/**
		 * On memory {@link GLib.MemoryOutputStream} with the unparsed
		 * string of the element
		 */
		public GLib.MemoryOutputStream read_buffer { get; set; }
		/**
		 * Temporally stores, all unparsed children as plain string. See {@link parse_children}.
		 *
		 * If it is null, means all children have been already parsed.
		 */
		public string unparsed { get; set; }
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using a {@link GLib.Type.ENUM} as a source of values.
	 *
	 * Enumeration is represented as a string, using its name, independent of
	 * value position in enumeration.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Enum : GXml.BaseProperty {
		protected GLib.Type _enum_type;
		protected string _val;
		protected int _value;
		public Enum ();
		/**
		 * Retrieve current value.
		 */
		public int get_enum ();
		/**
		 * Convenient method to initialize internal enum type.
		 */
		public void initialize_enum (GLib.Type enum_type);
		/**
		 *
		 */
		public bool is_valid ();
		/**
		 * Sets current value.
		 */
		public void set_enum (int value);
		/**
		 * Tries to convert the value to CamelCase using its nick non canonical name. Defaults to FALSE.
		 *
		 * An enum declared as 'ENUM_VALUE', its value is converted to 'EnumValue'. See
		 * {@link use_nick} for details.
		 */
		public bool camel_case { get; set construct; }
		/**
		 * Enum type used by property.
		 */
		public GLib.Type enum_type { get; set construct; }
		/**
		 * The value output, is always converted to upper cases. See
		 * {@link use_nick} for details.
		 */
		public bool upper_case { get; set construct; }
		/**
		 * Introspect the enumeration and use its nick to produce the value. Defaults to TRUE.
		 *
		 * An enum declared as 'ENUM_VALUE', its value is converted to 'enum-value'. Without
		 * this option the output is a complete name definition as declared by GLib.
		 *
		 * An enum value like : Myenum.ENUM_VALUE, is converted to 'enum-value' if no {@link camel_case}
		 * is enable and {@link use_nick} is enable; to 'EnumValue' if {@link camel_case} is true and
		 * {@link use_nick} is enable; and to 'MYENUM_ENUM_VALUE' if {@link use_nick} is set to false.
		 *
		 * An enum value like : Myenum.VALUE, is converted to 'value' if if no {@link camel_case}
		 * is enable; to 'Value' if  if no {@link camel_case} is enable; and to 'MYENUM_VALUE'
		 * if {@link use_nick} is set to false.
		 *
		 * The value can be converted to upper cases if {@link upper_case} is set to true.
		 *
		 * If  {@link use_nick} is set to false and {@link upper_case} is set to false, the value
		 * will be the lower case of the GLib default representation. For Myenum.ENUM_VALUE, the
		 * value will be 'myenum_enum_value'. Set {@link upper_case} to true, to keep the default
		 * GLib upper cases representation.
		 */
		public bool use_nick { get; set construct; }
		public override string? value { owned get; set; }
	}
	/**
	 * Convenient static methods for enumeration serialization to string.
	 * 
	 * Enumerations have a set of utility methods to better represent on
	 * serialisation/deserialization.
	 * 
	 * Enumerations could be converted to string using its definition on {@link GLib.EnumClass},
	 * by taking its nick name directly or converting to its camel case representation.
	 * 
	 * Any enumeration value type in a <code>GLib.Object</code>'s property could be
	 * deserialized from its definition given on {@link GLib.EnumClass} (name and
	 * nick) or from its camel case representation.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Enumeration {
		public Enumeration ();
		/**
		 * Introspect an enumeration to get value's nick name.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @enumeration.
		 */
		public static string get_nick (GLib.Type enumeration, int val) throws GLib.Error;
		/**
		 * Introspect an enumeration to get value's nick name and transform
		 * to camel case representation.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @param enumeration.
		 */
		public static string get_nick_camelcase (GLib.Type enumeration, int val) throws GLib.Error;
		/**
		 * Transform enumeration's value to its string representation.
		 *
		 * Returns: an string representing an enumeration's value.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer to parse an enum value of type @enumeration.
		 * @param use_nick makes to returns value's nick name in {@link GLib.EnumClass}
		 * @param camelcase makes to returns value's nick name in {@link GLib.EnumClass}
		 * as camel case representation. If @use_nick is set this take no effect.
		 */
		public static string get_string (GLib.Type enumeration, int val, bool use_nick = false, bool camelcase = false) throws GLib.Error;
		/**
		 * Parse @val to an enumeration's value.
		 * 
		 * Returns: an {@link GLib.EnumValue} representing an enumeration's value.
		 * 
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val a string to parse an enum value of type @param enumeration.
		 * as camel case representation. If @use_nick is set this take no effect.
		 */
		public static GLib.EnumValue? parse (GLib.Type enumeration, string val) throws GLib.Error;
		/**
		 * From a integer valuer calculates a valid {@link GLib.EnumValue} for a
		 * {@link GLib.Type}. 
		 *
		 * Returns: a {@link GLib.EnumValue} or null if fails.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 * @param val an integer in a valid range in the enumeration.
		 */
		public static GLib.EnumValue? parse_integer (GLib.Type enumeration, int val);
		/**
		 * Transform an enumeration in an array of {@link GLib.EnumValue}.
		 * 
		 * Returns: an array of {@link GLib.EnumValue} representing an enumeration.
		 * 
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 */
		public static unowned GLib.EnumValue[] to_array (GLib.Type enumeration);
		/**
		 * Transform an enumeration in an array of strings representing enumeration values.
		 *
		 * Returns: an array of strings representing an enumeration.
		 *
		 * @param enumeration a {@link GLib.Type} of type {@link GLib.Type.ENUM}
		 */
		public static string[] to_string_array (GLib.Type enumeration) throws GLib.Error;
	}
	/**
	 * DOM4 An event handler, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Event : GLib.Object, GXml.DomEvent {
		protected bool _bubbles;
		protected bool _cancelable;
		protected GXml.DomEventTarget _current_target;
		protected bool _default_prevented;
		protected string _etype;
		protected GXml.DomEvent.Phase _event_phase;
		protected GXml.DomEventTarget _event_target;
		protected GXml.DomEvent.Flags _flags;
		protected bool _is_trusted;
		protected GXml.DomTimeStamp _time_stamp;
		public Event ();
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using floats as sources of values.
	 *
	 * Property is represented as a string.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Float : GXml.Double {
		public Float ();
		/**
		 * Retrieve current value.
		 */
		public float get_float ();
		/**
		 * Sets current value.
		 */
		public void set_float (float value);
	}
	/**
	 * DOM4 HTML Collection
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HTMLCollection : Gee.ArrayList<GXml.DomElement>, GXml.DomHTMLCollection {
		public HTMLCollection ();
	}
	/**
	 * A class implementing {@link Collection} to store references to
	 * child {@link DomElement} of {@link Collection.element}, using an attribute in
	 * items as key or {@link MappeableElement.get_map_key} method if implemented
	 * by items to be added. If key is not defined in node, it is not added; but
	 * keeps it as a child node of actual {@link Collection.element}.
	 *
	 * If {@link GXml.Element} to be added is of type {@link Collection.items_type}
	 * and implements {@link MappeableElement}, you should set {@link GXml.HashMap.attribute_key}
	 * to null in order to use returned value of {@link MappeableElement.get_map_key}
	 * as key.
	 *
	 * {{{
	 *   public class YourObject : GXml.Element {
	 *    [Description (nick="::Name")]
	 *    public string name { get; set; }
	 *   }
	 *   public class YourList : GXml.HashMap {
	 *    construct {
	 *      try { initialize_with_key (typeof (YourObject),"Name"); }
	 *      catch (GLib.Error e) {
	 *        warning ("Initialization error for collection type: %s : %s"
	 *             .printf (get_type ().name(), e.message));
	 *      }
	 *    }
	 *   }
	 * }}}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HashMap : GXml.BaseCollection, GXml.Map {
		/**
		 * Element's attribute name used to refer of container's element.
		 * You should define it at construction time
		 * our set it as a construction property.
		 */
		protected string _attribute_key;
		/**
		 * A hashtable with all keys as string to node's index referred. Don't modify it manually.
		 */
		protected Gee.HashMap<string,int> _hashtable;
		public HashMap ();
		public override void clear ();
		/**
		 * Returns an {@link DomElement} in the collection using a string key.
		 */
		public new GXml.DomElement? @get (string key);
		/**
		 * Returns list of keys used in collection.
		 */
		public GLib.List<string> get_keys ();
		/**
		 * Convenient function to initialize a {@link GXml.HashMap} collection, using
		 * given element, items' type and name.
		 */
		public void initialize_element_with_key (GXml.Element element, GLib.Type items_type, string attribute_key) throws GLib.Error;
		/**
		 * Convenient function to initialize a {@link GXml.HashMap} collection, using
		 * given element, items' type and name.
		 *
		 * Using this method at construction time of derived classes.
		 */
		public void initialize_with_key (GLib.Type items_type, string attribute_key) throws GLib.Error;
		/**
		 * Validates if given element has a {@link GXml.HashMap.attribute_key} set,
		 * if so adds a new key pointing to given index and returns true.
		 *
		 * Attribute should be a valid {@link DomElement} attribute or
		 * a {@link GXml.Object} property identified using a nick with a '::' prefix.
		 *
		 * If there are more elements with same key, they are kept as child nodes
		 * but the one in collection will be the last one to be found.
		 *
		 * Return: false if element should not be added to collection.
		 */
		public override bool validate_append (int index, GXml.DomElement element) throws GLib.Error;
	}
	/**
	 * A class implementing {@link Collection} to store references to
	 * child {@link DomElement} of {@link Collection.element}, using two attributes in
	 * items as primary and secondary keys or {@link MappeableElementPairKey.get_map_primary_key}
	 * and {@link MappeableElementPairKey.get_map_secondary_key} methods if
	 * {@link MappeableElementPairKey} are implemented
	 * by items to be added. If one or both keys are not defined in node,
	 * it is not added; but keeps it as a child node of actual
	 * {@link Collection.element}.
	 *
	 * If {@link GXml.Element} to be added is of type {@link Collection.items_type}
	 * and implements {@link MappeableElementPairKey}, you should set
	 * {@link attribute_primary_key} and {@link attribute_secondary_key}
	 * to null in order to use returned value of {@link MappeableElementPairKey.get_map_primary_key}
	 * and {@link MappeableElementPairKey.get_map_secondary_key}
	 * as keys.
	 *
	 * {{{
	 *   public class YourObject : GXml.Element, MappeableElementPairKey {
	 *    [Description (nick="::Name")]
	 *    public string name { get; set; }
	 *    public string code { get; set; }
	 *    public string get_map_primary_key () { return code; }
	 *    public string get_map_secondary_key () { return name; }
	 *   }
	 *   public class YourList : HashPairedMap {
	 *    construct {
	 *      try { initialize_with (typeof (YourObject)); }
	 *      catch (GLib.Error e) {
	 *        warning ("Initialization error for collection type: %s : %s"
	 *             .printf (get_type ().name(), e.message));
	 *      }
	 *    }
	 *   }
	 * }}}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HashPairedMap : GXml.BaseCollection, GXml.PairedMap {
		/**
		 * Element's attribute name used to refer of container's element as primary key.
		 * You should define it at construction time
		 * our set it as a construction property.
		 */
		protected string _attribute_primary_key;
		/**
		 * Element's attribute name used to refer of container's element as secondary key.
		 * You should define it at construction time
		 * our set it as a construction property.
		 */
		protected string _attribute_secondary_key;
		/**
		 * A hashtable with all keys as string to node's index referred. Don't modify it manually.
		 */
		protected Gee.HashMap<string,Gee.HashMap<string,int>> _hashtable;
		public HashPairedMap ();
		public override void clear ();
		/**
		 * Returns an {@link DomElement} in the collection using given string keys.
		 */
		public new GXml.DomElement? @get (string primary_key, string secondary_key);
		/**
		 * Returns list of primary keys used in collection.
		 */
		public GLib.List<string> get_primary_keys ();
		/**
		 * Returns list of secondary keys used in collection with @pkey as primary key.
		 */
		public GLib.List<string> get_secondary_keys (string pkey);
		/**
		 * Convenient function to initialize a {@link GXml.HashMap} collection, using
		 * given element, items' type and name.
		 */
		public void initialize_element_with_keys (GXml.Element element, GLib.Type items_type, string attribute_primary_key, string attribute_secondary_key) throws GLib.Error;
		/**
		 * Convenient function to initialize a {@link GXml.HashMap} collection, using
		 * given element, items' type and name.
		 *
		 * Using this method at construction time of derived classes.
		 */
		public void initialize_with_keys (GLib.Type items_type, string attribute_primary_key, string attribute_secondary_key) throws GLib.Error;
		/**
		 * Validates if given element has a {@link attribute_primary_key}
		 * and {@link attribute_secondary_key} set,
		 * if so adds a new keys pointing to given index and returns true.
		 *
		 * Attribute should be a valid {@link DomElement} attribute or
		 * a {@link GXml.Object} property identified using a nick with a '::' prefix.
		 *
		 * If there are more elements with same keys, they are kept as child nodes
		 * but the one in collection will be the last one to be found.
		 *
		 * Return: false if element should not be added to collection.
		 */
		public override bool validate_append (int index, GXml.DomElement element) throws GLib.Error;
	}
	/**
	 * A class implementing {@link Collection} to store references to
	 * child {@link DomElement} of {@link Collection.element}, using three attributes in
	 * items as primary, secondary tertiary keys or {@link MappeableElementThreeKey.get_map_pkey},
	 * {@link MappeableElementThreeKey.get_map_skey}
	 * and {@link MappeableElementThreeKey.get_map_tkey}
	 * methods if {@link MappeableElementThreeKey} are implemented
	 * by items to be added. All keys should be defined in node, otherwise
	 * it is not added; but keeps it as a child node of actual
	 * {@link Collection.element}.
	 *
	 * If {@link GXml.Element} to be added is of type {@link Collection.items_type}
	 * and implements {@link MappeableElementThreeKey}, you should set
	 * {@link attribute_primary_key}, {@link attribute_secondary_key}
	 * and  {@link attribute_third_key}
	 * to null in order to use returned value of {@link MappeableElementThreeKey.get_map_pkey},
	 * {@link MappeableElementThreeKey.get_map_skey}
	 * and {@link MappeableElementThreeKey.get_map_tkey}
	 * as keys.
	 *
	 * {{{
	 *   public class YourObject : GXml.Element, MappeableElementThreeKey {
	 *    [Description (nick="::Name")]
	 *    public string name { get; set; }
	 *    public string code { get; set; }
	 *    public string category { get; set; }
	 *    public string get_map_primary_key () { return code; }
	 *    public string get_map_secondary_key () { return name; }
	 *    public string get_map_third_key () { return category; }
	 *   }
	 *   public class YourList : HashThreeMap {
	 *    construct {
	 *      try { initialize_with (typeof (YourObject)); }
	 *      catch (GLib.Error e) {
	 *        warning ("Initialization error for collection type: %s : %s"
	 *             .printf (get_type ().name(), e.message));
	 *      }
	 *    }
	 *   }
	 * }}}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HashThreeMap : GXml.BaseCollection, GXml.ThreeMap {
		/**
		 * Element's attribute name used to refer of container's element as primary key.
		 * You should define it at construction time
		 * our set it as a construction property.
		 */
		protected string _attribute_primary_key;
		/**
		 * Element's attribute name used to refer of container's element as secondary key.
		 * You should define it at construction time
		 * our set it as a construction property.
		 */
		protected string _attribute_secondary_key;
		/**
		 * Element's attribute name used to refer of container's element as third key.
		 * You should define it at construction time
		 * our set it as a construction property.
		 */
		protected string _attribute_third_key;
		/**
		 * A hashtable with all keys as string to node's index referred. Don't modify it manually.
		 */
		protected Gee.HashMap<string,Gee.HashMap<string,Gee.HashMap<string,int>>> _hashtable;
		public HashThreeMap ();
		public override void clear ();
		/**
		 * Returns an {@link DomElement} in the collection using given string keys.
		 */
		public new GXml.DomElement? @get (string primary_key, string secondary_key, string third_key);
		/**
		 * Returns list of primary keys used in collection.
		 */
		public GLib.List<string> get_primary_keys ();
		/**
		 * Returns list of secondary keys used in collection with pkey as primary key.
		 */
		public GLib.List<string> get_secondary_keys (string pkey);
		/**
		 * Returns list of third keys used in collection with pkey as primary key
		 * and skey as secondary key.
		 */
		public GLib.List<string> get_third_keys (string pkey, string skey);
		/**
		 * Convenient function to initialize a {@link GXml.HashMap} collection, using
		 * given element, items' type and name.
		 */
		public void initialize_element_with_keys (GXml.Element element, GLib.Type items_type, string attribute_primary_key, string attribute_secondary_key, string attribute_third_key) throws GLib.Error;
		/**
		 * Convenient function to initialize a {@link GXml.HashMap} collection, using
		 * given element, items' type and name.
		 *
		 * Using this method at construction time of derived classes.
		 */
		public void initialize_with_keys (GLib.Type items_type, string attribute_primary_key, string attribute_secondary_key, string attribute_third_key) throws GLib.Error;
		/**
		 * Validates if given element has a {@link attribute_primary_key},
		 * {@link attribute_secondary_key} and
		 * {@link attribute_third_key} set,
		 * if so adds a new keys pointing to given index and returns true.
		 *
		 * Attribute should be a valid {@link DomElement} attribute or
		 * a {@link GXml.Object} property identified using a nick with a '::' prefix.
		 *
		 * If there are more elements with same keys, they are kept as child nodes
		 * but the one in collection will be the last one to be found.
		 *
		 * Return: false if element should not be added to collection.
		 */
		public override bool validate_append (int index, GXml.DomElement element) throws GLib.Error;
	}
	/**
	 * DOM4 HTML Document
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HtmlDocument : GXml.Document {
		public HtmlDocument ();
		[Description (nick = "::ROOT")]
		public GXml.DomElement html { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class HtmlElement : GXml.Element {
		public HtmlElement ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Implementation : GLib.Object, GXml.DomImplementation {
		public Implementation ();
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using a integers as sources of values.
	 *
	 * Property is represented as a string.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Int : GXml.BaseProperty {
		protected int _value;
		public Int ();
		/**
		 * Retrieve current value.
		 */
		public int get_integer ();
		/**
		 * Sets current value.
		 */
		public void set_integer (int value);
		public override string? value { owned get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class LXPathObject : GLib.Object, GXml.XPathObject {
		public LXPathObject (GXml.XDocument document, Xml.XPath.Object* pointer);
	}
	/**
	 * A DOM4 implementation of {@link DomNode}, for one step parsing.
	 *
	 * This object avoids pre and post XML parsing, by using a one step parsing
	 * to translate text XML tree to an GObject based tree.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Node : GLib.Object, GXml.DomEventTarget, GXml.DomNode {
		/**
		 * Use this field to set node's base URI. Can be set at construction time.
		 *
		 * See [[https://www.w3.org/TR/dom/#concept-node-base-url]]
		 */
		protected string _base_uri;
		/**
		 * Use this field to set node's child nodes. Derived classes should avoid to modify it.
		 */
		protected GXml.NodeList _child_nodes;
		protected GXml.DomDocument _document;
		/**
		 * Use this field to set node's local name. Can be set at construction time.
		 */
		protected string _local_name;
		/**
		 * Use this field to set node's Type. Derived classes should avoid to modify it.
		 */
		protected GXml.DomNode.NodeType _node_type;
		/**
		 * Use this field to hold node's value. Can be set at construction time.
		 */
		protected string _node_value;
		/**
		 * Use this field to holding node's parent node. Derived classes should avoid to modify it.
		 */
		protected GXml.DomNode _parent;
		/**
		 * Use this field to set node's prefix. Can be set at construction time.
		 */
		protected string _prefix;
		public Node ();
	}
	/**
	 * Implementation of {@link DomNodeIterator}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NodeIterator : GLib.Object, GXml.DomNodeIterator {
		protected bool _pointer_before_reference_node;
		protected GXml.DomNode _reference_node;
		protected GXml.DomNode _root;
		protected int _what_to_show;
		public NodeIterator (GXml.DomNode n, int what_to_show);
	}
	/**
	 * List of {@link DomNode} implementing {@link DomNodeList}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class NodeList : Gee.ArrayList<GXml.DomNode>, GXml.DomNodeList {
		public NodeList ();
	}
	/**
	 * A DOM4 implementation of {@link DomProcessingInstruction}, for one step parsing.
	 *
	 * This object avoids pre and post XML parsing, by using a one step parsing
	 * to translate text XML tree to an GObject based tree.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class ProcessingInstruction : GXml.CharacterData, GXml.DomProcessingInstruction {
		public ProcessingInstruction (GXml.DomDocument doc, string target, string data);
	}
	/**
	 * DOM4 Range implementation, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Range : GLib.Object, GXml.DomRange {
		protected bool _collapse;
		protected GXml.DomNode _common_ancestor_container;
		protected GXml.DomDocument _document;
		protected GXml.DomNode _end_container;
		protected int _end_offset;
		protected GXml.DomNode _start_container;
		protected int _start_offset;
		public Range (GXml.DomDocument doc);
	}
	/**
	 * DOM4 Setteable token list, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class SettableTokenList : GXml.TokenList, GXml.DomSettableTokenList {
		public SettableTokenList (GXml.DomElement e, string? attr);
	}
	/**
	 * Convenient class to handle {@link Element}'s attributes
	 * using validated string using Regular Expressions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class String : GXml.BaseProperty {
		protected string _value;
		public String ();
		public String.with_string (string str);
		public override string? value { owned get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class StringRef : GLib.Object, GXml.Property {
		public StringRef (GXml.Object obj, string name);
	}
	/**
	 * A DOM4 implementation of {@link DomText}, for one step parsing.
	 *
	 * This object avoids pre and post XML parsing, by using a one step parsing
	 * to translate text XML tree to an GObject based tree.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class Text : GXml.CharacterData, GXml.DomText {
		public Text (GXml.DomDocument doc, string data);
	}
	/**
	 * DOM4 List of string tokens, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TokenList : Gee.ArrayList<string>, GXml.DomTokenList {
		protected string _attr;
		protected GXml.DomElement _element;
		public TokenList (GXml.DomElement e, string? attr);
		public void update ();
	}
	/**
	 * Implementation of {@link DomTreeWalker}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class TreeWalker : GLib.Object, GXml.DomTreeWalker {
		protected GXml.DomNode _current_node;
		protected GXml.DomNode _root;
		protected int _what_to_show;
		public TreeWalker (GXml.DomNode root, int w);
	}
	/**
	 * Class implementing {@link GXml.DomAttr} interface, not tied to libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XAttribute : GXml.XNode, GXml.DomAttr {
		public XAttribute (GXml.XDocument doc, Xml.Attr* node);
		public override GXml.DomNode parent { owned get; }
	}
	/**
	 * DOM4 Base class for character data, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XCharacterData : GXml.XNonDocumentChildNode, GXml.DomCharacterData {
		public XCharacterData ();
		public string str { owned get; set; }
	}
	/**
	 * DOM4 class for child nodes, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XChildNode : GXml.XNode, GXml.DomChildNode {
		public XChildNode ();
	}
	/**
	 * DOM4 Class implementing {@link GXml.Comment} and {@link GXml.DomComment} interface, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XComment : GXml.XCharacterData, GXml.DomComment {
		public XComment (GXml.XDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	/**
	 * DOM4 class implementing {@link GXml.DomDocument} and {GXml.DomDocument} interface,
	 * powered by libxml-2.0 library.
	 *
	 * This class use {@link Xml.TextWriter} to write down XML documents using
	 * its contained {@link GXml.DomNode} children or other XML structures.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XDocument : GXml.XNode, GXml.DomParentNode, GXml.DomNonElementParentNode, GXml.DomDocument, GXml.DomXMLDocument, GXml.XPathContext {
		protected Xml.Buffer _buffer;
		protected string _character_set;
		protected string _compat_mode;
		protected GXml.DomEvent _constructor;
		protected string _content_type;
		protected GXml.DomImplementation _implementation;
		protected string _origin;
		protected GXml.Parser _parser;
		protected string _url;
		public XDocument ();
		public GXml.DomNode create_pi (string target, string data);
		public GXml.DomNode create_text (string text);
		public XDocument.from_doc (Xml.Doc doc);
		public XDocument.from_file (GLib.File file, int options = 0, GLib.Cancellable? cancel = null) throws GLib.Error;
		public XDocument.from_path (string path, int options = 0) throws GLib.Error;
		public XDocument.from_stream (GLib.InputStream istream) throws GLib.Error;
		public XDocument.from_string (string str, int options = 0) throws GLib.Error;
		public XDocument.from_uri (string uri, int options = 0) throws GLib.Error;
		/**
		 * Uses libxml2 internal dump to memory function over owned
		 */
		public string libxml_to_string ();
		public virtual bool save (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual bool save_as (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public override bool set_namespace (string uri, string? prefix);
		public override string to_string ();
		public override Gee.Map<string,GXml.DomNode> attrs { owned get; }
		public bool backup { get; set; }
		public override Gee.BidirList<GXml.DomNode> children_nodes { owned get; }
		public override GXml.DomDocument document { get; }
		public GLib.File file { get; set; }
		public bool indent { get; set; }
		public bool ns_top { get; set; }
		public bool prefix_default_ns { get; set; }
		public GXml.DomNode root { owned get; }
	}
	/**
	 * DOM4 Class implementing {@link GXml.DomElement} interface,
	 * powered by libxml-2.0 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XElement : GXml.XNonDocumentChildNode, GXml.DomParentNode, GXml.DomElement, GXml.XPathContext {
		public XElement (GXml.XDocument doc, Xml.Node* node);
		public GXml.DomNode? get_attr (string name);
		public GXml.DomNode? get_ns_attr (string name, string uri);
		public new void normalize ();
		public void remove_attr (string name);
		public void remove_ns_attr (string name, string uri);
		public void set_attr (string aname, string avalue);
		public void set_ns_attr (string ns, string aname, string value);
		public override string to_string ();
		public string content { owned get; set; }
		public override string value { owned get; set; }
	}
	/**
	 * Implementation of {@link Gee.AbstractMap} to handle {@link Xml.Node} attributes,
	 * powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XHashMapAttr : Gee.AbstractMap<string,GXml.XNode>, GXml.DomNamedNodeMap {
		public class Entry : Gee.Map.Entry<string,GXml.XNode> {
			public Entry (GXml.XDocument doc, Xml.Attr* attr);
			public override string key { get; }
			public override bool read_only { get; }
			public override GXml.XNode value { get; set; }
		}
		public class Iterator : GLib.Object, Gee.MapIterator<string,GXml.XNode> {
			public Iterator (GXml.XDocument doc, Xml.Node* node);
		}
		public XHashMapAttr (GXml.XDocument doc, Xml.Node* node);
		public override void clear ();
		public override GXml.XNode @get (string key);
		public override bool has (string key, GXml.XNode value);
		public override bool has_key (string key);
		public override Gee.MapIterator<string,GXml.XNode> map_iterator ();
		public override void @set (string key, GXml.XNode value);
		public override bool unset (string key, out GXml.XNode value = null);
		public override Gee.Set<Gee.Map.Entry<string,GXml.XNode>> entries { owned get; }
		public override Gee.Set<string> keys { owned get; }
		public override bool read_only { get; }
		public override int size { get; }
		public override Gee.Collection<GXml.XNode> values { owned get; }
	}
	/**
	 * HML parsing support. Document handling
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XHtmlDocument : GXml.XDocument, GXml.DomHtmlDocument {
		public XHtmlDocument ();
		/**
		 * This method parse strings in a {@link GLib.File} using {@link Html.Doc.read_memory} method.
		 * Refer to libxml2 documentation about limitations on parsing.
		 *
		 * In order to use a different parser, may you want to load in memory your file,
		 * then create a new {@link XHtmlDocument} using a constructor better fitting
		 * your document content or source.
		 */
		public XHtmlDocument.from_file (GLib.File file, int options = 0, GLib.Cancellable? cancel = null) throws GLib.Error;
		public XHtmlDocument.from_path (string path, int options = 0) throws GLib.Error;
		/**
		 * This method parse strings using {@link Html.Doc.read_memory} method.
		 * Refer to libxml2 documentation about limitations on parsing.
		 */
		public XHtmlDocument.from_string (string html, int options = 0);
		/**
		 * This method parse strings using {@link Html.ParserCtxt} class.
		 * Refer to libxml2 documentation about limitations on parsing.
		 */
		public XHtmlDocument.from_string_context (string html, int options = 0);
		/**
		 * This method parse strings using {@link Html.Doc.read_doc} method.
		 * Refer to libxml2 documentation about limitations on parsing.
		 */
		public XHtmlDocument.from_string_doc (string html, int options = 0);
		public XHtmlDocument.from_uri (string uri, int options = 0) throws GLib.Error;
		public static int default_options { get; }
	}
	/**
	 * A {@link Gee.AbstractBidirList} implementation to access {@link Xml.Node} collection
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XListChildren : Gee.AbstractBidirList<GXml.DomNode>, GXml.DomNodeList, GXml.DomHTMLCollection {
		public class Iterator : GLib.Object, Gee.Traversable<GXml.DomNode>, Gee.Iterator<GXml.DomNode>, Gee.BidirIterator<GXml.DomNode>, Gee.ListIterator<GXml.DomNode>, Gee.BidirListIterator<GXml.DomNode> {
			public Iterator (GXml.XDocument doc, Xml.Node* node);
		}
		public XListChildren (GXml.XDocument doc, Xml.Node* node);
		public override bool add (GXml.DomNode item);
		public new override Gee.BidirListIterator<GXml.DomNode> bidir_list_iterator ();
		public override void clear ();
		public override bool contains (GXml.DomNode item);
		public override GXml.DomNode @get (int index);
		public override int index_of (GXml.DomNode item);
		/**
		 * Insert @item before @index
		 */
		public override void insert (int index, GXml.DomNode item);
		public override Gee.Iterator<GXml.DomNode> iterator ();
		public override Gee.ListIterator<GXml.DomNode> list_iterator ();
		public override bool remove (GXml.DomNode item);
		/**
		 * Removes a node at @index. This method never returns a valid pointer.
		 */
		public override GXml.DomNode remove_at (int index);
		/**
		 * This method is ignored by default.
		 */
		public override void @set (int index, GXml.DomNode item);
		public override Gee.List<GXml.DomNode>? slice (int start, int stop);
		public override bool read_only { get; }
		public override int size { get; }
	}
	/**
	 * DOM4 Base interface providing basic functionalities to all libxml2 DOM4 implementations.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public abstract class XNode : GLib.Object, GXml.DomEventTarget, GXml.DomNode {
		protected string _base_uri;
		protected GXml.XDocument _doc;
		protected Xml.Node* _node;
		protected XNode ();
		public GXml.DomNode clone_node (bool deep = false);
		public Xml.Node* get_internal_node ();
		public virtual bool set_namespace (string uri, string? prefix);
		public static GXml.DomNode to_gnode (GXml.XDocument doc, Xml.Node* node);
		public virtual string to_string ();
		public virtual Gee.Map<string,GXml.DomNode> attrs { owned get; }
		public virtual Gee.BidirList<GXml.DomNode> children_nodes { owned get; }
		public virtual GXml.DomDocument document { get; }
		public virtual string name { owned get; }
		public virtual GXml.DomNode parent { owned get; }
		public virtual GXml.NodeType type_node { get; }
		public virtual string value { owned get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XNonDocumentChildNode : GXml.XChildNode, GXml.DomNonDocumentTypeChildNode {
		public XNonDocumentChildNode ();
	}
	/**
	 * {@link Parser} implementation using libxml2 engine
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XParser : GLib.Object, GXml.Parser {
		public XParser (GXml.DomNode node);
		public async void read_child_nodes_stream_async (GLib.InputStream istream) throws GLib.Error;
		/**
		 * Reads a node using current parser.
		 */
		public void read_node (GXml.DomNode node) throws GLib.Error;
	}
	/**
	 * DOM4 Class implementing {@link GXml.ProcessingInstruction} and
	 * {@link DomProcessingInstruction} interface, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XProcessingInstruction : GXml.XCharacterData, GXml.DomProcessingInstruction {
		public XProcessingInstruction (GXml.XDocument doc, Xml.Node* node);
		public new string data { owned get; set; }
	}
	/**
	 * DOM4 Class implementing {@link GXml.Text}
	 * and {@link DomText} interface, powered by libxml2 library.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XText : GXml.XCharacterData, GXml.DomText {
		public XText (GXml.XDocument doc, Xml.Node* node);
		public override string name { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdAnnotation : GXml.Element {
		public XsdAnnotation ();
	}
	/**
	 * Convenient class to handle a {@link Element}'s attribute
	 * using a list of pre-defined and unmutable values, taken from
	 * an {@link IXsdSimpleType} definition
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdArrayString : GXml.ArrayString {
		protected string _simple_type;
		protected GLib.File _source;
		public XsdArrayString ();
		/**
		 * Load list of strings from a {@link GLib.File}, parsing using an
		 * {@link XsdSchema} object and searching for {@link IXsdSimpleType}
		 * definition with name {@link simple_type}.
		 */
		public void load () throws GLib.Error;
		/**
		 * Name of {@link IXsdSimpleType} to use as source.
		 */
		public string simple_type { get; set; }
		/**
		 * A {@link GLib.File} source to read from, simple type definitions in
		 * an XSD file type.
		 */
		public GLib.File source { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdAttribute : GXml.XsdBaseAttribute {
		public XsdAttribute ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdAttributeGroup : GXml.XsdBaseAttribute {
		public XsdAttributeGroup ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdBaseAttribute : GXml.Element {
		public XsdBaseAttribute ();
		public GXml.XsdAnnotation anotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdBaseContent : GXml.Element {
		public XsdBaseContent ();
		public GXml.XsdAnnotation anotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdBaseType : GXml.Element {
		public XsdBaseType ();
		public GXml.XsdAnnotation anotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdComplexContent : GXml.XsdBaseContent {
		public XsdComplexContent ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdComplexType : GXml.XsdBaseType {
		protected GXml.XsdList _group_attributes;
		protected GXml.XsdList _type_attributes;
		public XsdComplexType ();
		/**
		 * attribute name = abstract
		 */
		public bool @abstract { get; set; }
		/**
		 * (#all | List of (extension | restriction))
		 */
		public string block { get; set; }
		/**
		 * A {@link XsdComplexType} or {@link XsdSimpleType}
		 */
		public GXml.XsdBaseContent content_type { get; set; }
		/**
		 * defaultAttributesApply
		 */
		public bool default_attributes_apply { get; set; }
		/**
		 * (#all | List of (extension | restriction))
		 */
		public string final { get; set; }
		/**
		 * List of group {@link XsdAttribute} definitions
		 */
		public GXml.XsdList group_attributes { get; }
		public bool mixed { get; set; }
		public string name { get; set; }
		/**
		 * List of type {@link XsdAttribute} definitions
		 */
		public GXml.XsdList type_attributes { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdElement : GXml.Element {
		public XsdElement ();
		/**
		 * attribute name = abstract
		 */
		[Description (nick = "::abstract")]
		public bool @abstract { get; set; }
		[Description (nick = "::annotation")]
		public GXml.XsdAnnotation anotation { get; set; }
		/**
		 * (#all | List of (extension | restriction | substitution))
		 */
		[Description (nick = "::block")]
		public string block { get; set; }
		[Description (nick = "::ComplexType")]
		public GXml.XsdComplexType complex_type { get; set; }
		[Description (nick = "::default")]
		public string @default { get; set; }
		/**
		 * (#all | List of (extension | restriction))
		 */
		[Description (nick = "::final")]
		public string final { get; set; }
		[Description (nick = "::fixed")]
		public string fixed { get; set; }
		/**
		 * (qualified | unqualified)
		 */
		[Description (nick = "::form")]
		public string form { get; set; }
		/**
		 * (nonNegativeInteger | unbounded)  : 1
		 */
		[Description (nick = "::maxOccurs")]
		public string max_occurs { get; set; }
		/**
		 * nonNegativeInteger : 1
		 */
		[Description (nick = "::minOccurs")]
		public string min_occurs { get; set; }
		[Description (nick = "::name")]
		public string name { get; set; }
		[Description (nick = "::nillable")]
		public bool nillable { get; set; }
		/**
		 * attribute name = 'type'
		 */
		[Description (nick = "::type")]
		public string object_type { get; set; }
		[Description (nick = "::ref")]
		public new string @ref { get; set; }
		[Description (nick = "::SimpleType")]
		public GXml.XsdSimpleType simple_type { get; set; }
		/**
		 * substitutionGroup
		 */
		[Description (nick = "::substitutionGroup")]
		public GXml.DomTokenList substitution_group { get; set; }
		/**
		 * targetNamespace
		 */
		[Description (nick = "::targetNamespace")]
		public string target_namespace { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdExtension : GXml.Element {
		public XsdExtension ();
		[Description (nick = "::base")]
		public string @base { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdList : GXml.ArrayList {
		public XsdList ();
		public int index_of (GXml.DomElement element);
		public void remove (int index);
		public new int length { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdListComplexTypes : GXml.XsdList {
		public XsdListComplexTypes ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdListElements : GXml.XsdList {
		public XsdListElements ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdListSimpleTypes : GXml.XsdList {
		public XsdListSimpleTypes ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdListTypeRestrictionEnumerations : GXml.XsdList {
		public XsdListTypeRestrictionEnumerations ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdListTypeRestrictionWhiteSpaces : GXml.XsdList {
		public XsdListTypeRestrictionWhiteSpaces ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdOpenContent : GXml.XsdBaseContent {
		public XsdOpenContent ();
	}
	/**
	 * Reference interfaces for XSD support.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdSchema : GXml.Element {
		public XsdSchema ();
		public GXml.XsdListComplexTypes complex_type_definitions { get; set; }
		public GXml.XsdListElements element_definitions { get; set; }
		public GXml.XsdListSimpleTypes simple_type_definitions { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdSimpleContent : GXml.XsdBaseContent {
		public XsdSimpleContent ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdSimpleType : GXml.Element {
		public XsdSimpleType ();
		public GXml.XsdAnnotation annotation { get; set; }
		/**
		 * (#all | List of (list | union | restriction | extension))
		 */
		[Description (nick = "::final")]
		public string final { get; set; }
		public GXml.XsdTypeList list { get; set; }
		[Description (nick = "::name")]
		public string name { get; set; }
		public GXml.XsdTypeRestriction restriction { get; set; }
		public GXml.XsdTypeUnion union { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeDefinition : GXml.Element {
		public XsdTypeDefinition ();
		public GXml.XsdAnnotation annotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeList : GXml.XsdTypeDefinition {
		public XsdTypeList ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestriction : GXml.XsdTypeDefinition {
		public XsdTypeRestriction ();
		[Description (nick = "::base")]
		public string @base { get; set; }
		public GXml.XsdListTypeRestrictionEnumerations enumerations { get; set; }
		public GXml.XsdSimpleType simple_type { get; set; }
		public GXml.XsdListTypeRestrictionWhiteSpaces white_spaces { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionAssertion : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionAssertion ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionDef : GXml.Element {
		public XsdTypeRestrictionDef ();
		public GXml.XsdAnnotation annotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionEnumeration : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionEnumeration ();
		[Description (nick = "::value")]
		public string value { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionExplicitTimezone : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionExplicitTimezone ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionFractionDigits : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionFractionDigits ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionLength : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionLength ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionMaxExclusive : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionMaxExclusive ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionMaxInclusive : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionMaxInclusive ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionMaxLength : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionMaxLength ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionMinExclusive : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionMinExclusive ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionMinInclusive : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionMinInclusive ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionMinLength : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionMinLength ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionPattern : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionPattern ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionTotalDigits : GXml.XsdTypeRestrictionDef {
		public XsdTypeRestrictionTotalDigits ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeRestrictionWhiteSpace : GXml.XsdTypeRestrictionDef {
		public class Fixed : GXml.Boolean {
			public Fixed ();
		}
		public XsdTypeRestrictionWhiteSpace ();
		[Description (nick = "::fixed")]
		public GXml.XsdTypeRestrictionWhiteSpace.Fixed fixed { get; set; }
		/**
		 * (collapse | preserve | replace)
		 */
		[Description (nick = "::value")]
		public string value { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public class XsdTypeUnion : GXml.XsdTypeDefinition {
		public XsdTypeUnion ();
	}
	/**
	 * A DOM4 interface to keep references to {@link DomElement} children of a {@link element}.
	 *
	 * A collection should call {@link initialize} with the object's type to be added to
	 * the connection and, at construction time, set the {@link element} this collection
	 * should take its members from.
	 *
	 * This way, you can have a property to access all child elements of a given type,
	 * the node will be added automatically to both as a child of your element and as
	 * a member of the collection.
	 *
	 * {{{
	 *   // This is your object definition and a collection one
	 *   public class YourObject : GXml.Element {
	 *    [Description (nick="::Name")]
	 *    public string name { get; set; }
	 *    construct {
	 *      // This is the Element's node's name to be used
	 *      try { initialize ("NodeName"); }
	 *      catch (GLib.Error e ) {
	 *        warning ("Error: "+e.message);
	 *      }
	 *    }
	 *   }
	 *   public class YourList : GXml.ArrayList {
	 *    construct {
	 *      // With this, your collection will find a add all elements
	 *      // with the node's name 'NodeName' as declared to YourObject class
	 *      try { initialize (typeof (YourObject)); }
	 *      catch (GLib.Error e) {
	 *        warning ("Initialization error for collection type: %s : %s"
	 *             .printf (get_type ().name(), e.message));
	 *      }
	 *    }
	 *   }
	 *   // This is your element object definition with a collection of nodes
	 *   // with the type YourObject
	 *   public class YourElement : GXml.Element {
	 *     public YourObject.YourList your_objects { get; set; }
	 *     construct {
	 *       // This is initializing the property 'your_objects' which is the type
	 *       // YourList collection and set YourElement object as its element to
	 *       // to take its members from. Use canonical names for properties as shown
	 *       set_instance_property ('your-objects');
	 *       // This is the node's name to use for YourElement class
	 *        try { initialize ("YourElement"); }
	 *        catch (GLib.Error e) {
	 *          warning ("Initialization error for element type: %s", e.message));
	 *        }
	 *      }
	 *    }
	 * }}}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Collection : GLib.Object {
		/**
		 * Adds a {@link DomElement} node to this collection. Depending on type of
		 * collection, this method will take information from node to initialize
		 * how to find it.
		 */
		public abstract void append (GXml.DomElement node) throws GLib.Error;
		/**
		 * Clear this collection in preparation for a search
		 */
		public abstract void clear () throws GLib.Error;
		/**
		 * Creates a new instance of {@link items_type}, with same
		 * {@link DomNode.owner_document} than {@link element}. New instance
		 * is not set as a child of collection's {@link element}; to do so,
		 * use {@link append}
		 *
		 * Returns: a new instance object or null if type is not a {@link DomElement} or no parent has been set
		 */
		public virtual GXml.DomElement? create_item ();
		/**
		 * Gets a child {@link DomElement} of {@link element} referenced in
		 * {@link nodes_index}.
		 */
		public virtual GXml.DomElement? get_item (int index) throws GLib.Error;
		/**
		 * Initialize collection to use a given {@link GXml.Collection} derived type.
		 * Internally, this method create an instance of given type to initialize
		 * {@link items_type} and {@link items_name}.
		 *
		 * This method can be used at construction time of classes implementing
		 * {@link GXml.Collection} to initialize object type to refer in the collection.
		 */
		public abstract void initialize (GLib.Type t) throws GLib.Error;
		/**
		 * Search and add references to all {@link GXml.Object} nodes as child of
		 * {@link element} with same, case insensitive, name of {@link items_name}
		 */
		public abstract void search () throws GLib.Error;
		/**
		 * Validate if given node and index, should be added to collection.
		 *
		 * Implementations should use this method to perform any action before
		 * element is added to collection, like setup internal pointers to given
		 * index, in order to get access to referenced node.
		 *
		 * Return: true if node and index should be added to collection.
		 */
		public abstract bool validate_append (int index, GXml.DomElement element) throws GLib.Error;
		/**
		 * A {@link GXml.DomElement} with all child elements in collection.
		 */
		public abstract GXml.DomElement element { get; set construct; }
		/**
		 * Local name of {@link DomElement} objects of {@link element}, which could be
		 * contained in this collection.
		 *
		 * Used when reading to add elements to collection.
		 */
		public abstract string items_name { get; }
		/**
		 * A {@link GLib.Type} of {@link DomElement} child objects of {@link element},
		 * which could be contained in this collection.
		 *
		 * Type should be an {@link GXml.Object}.
		 */
		public abstract GLib.Type items_type { get; set construct; }
		/**
		 * Number of items referenced in {@link nodes_index}
		 */
		public virtual int length { get; }
		/**
		 * A list of child {@link DomElement} objects of {@link element}
		 */
		public abstract GLib.Queue<int> nodes_index { get; }
	}
	/**
	 * Collection to manage child {@link GXml.DomElement} objects
	 * mapped to different classes, derived or child type of
	 * {@link Collection.items_type}
	 *
	 * A collection using {@link Collection.items_type} as a common
	 * parent {@link GLib.Type} of a set of instantiatable {@link GLib.Type}.
	 *
	 * In the next example, is possible to setup a class for Top element,
	 * having a {@link GXml.CollectionParent} implementation class, supporting
	 * reading any kind of derived classes from the {@link Collection.items_type};
	 * for the example, Time, Goal and Reque are implementations of, say, Child
	 * interface, so they will be added to the collection and deserialized
	 * as an instance of the object, based in the node's name.
	 *
	 * {{{
	 * <Top>
	 *   <Time/>
	 *   <Goal/>
	 *   <Resque/>
	 * }}}
	 *
	 * Implementators, should override {@link types} property
	 * setting up a hash table and use {@link add_supported_type} or
	 * {@link add_supported_types} to add one or a set of types to be supported.
	 * {@link types} is used by {@link GXml.Parser} to detect the types
	 * suuported in a collection to create the corresponding objects of the
	 * currect instantiable {@link GLib.Type} at runtime, adding them to the
	 * collection, corresponding to the element's tag's name.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface CollectionParent : GLib.Object, GXml.Collection {
		/**
		 * Insert a new supported instantiatable type in given hash table, by
		 * instantiating the type, getting its node's local name
		 * as key.
		 *
		 * @param types a {@link GLib.HashTable} to hold supported types
		 * @param parent_type a {@link GLib.Type} as parent of supported types, it is
		 * not necesarry to be an instantiatable type, like interfaces, should be
		 * the same of {@link GXml.Collection.items_type}
		 * @param type a supported instantiatable {@link GLib.Type}
		 * to be added in the collection
		 */
		public static void add_supported_type (GLib.HashTable<string,GLib.Type> types, GLib.Type parent_type, GLib.Type type);
		/**
		 * Insert a set of supported instantiatable type in given hash table, by
		 * instantiating the type, getting its node's local name
		 * as key.
		 *
		 * @param table a {@link GLib.HashTable} to hold supported types
		 * @param parent_type a {@link GLib.Type} as parent of supported types, it is
		 * not necesarry to be an instantiatable type, like interfaces, should be
		 * the same of {@link GXml.Collection.items_type}
		 * @param types an array of supported instantiatable {@link GLib.Type}
		 * to be added in the collection
		 */
		public static void add_supported_types (GLib.HashTable<string,GLib.Type> table, GLib.Type parent_type, GLib.Type[] types);
		/**
		 * Creates a hash map with a set of child instantiable {@link GLib.Type}
		 * of the {@link Collection.items_type}
		 *
		 * Implementators, should override this property in order to create
		 * its own collection of supported instantiatable types.
		 */
		public virtual GLib.HashTable<string,GLib.Type> types { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomAttr : GLib.Object {
		public abstract string local_name { owned get; }
		public abstract string name { owned get; }
		public abstract string? namespace_uri { owned get; }
		public abstract string? prefix { owned get; }
		public virtual bool specified { get; }
		public abstract string value { owned get; set; }
	}
	/**
	 * DOM4 character handling interface
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomCharacterData : GLib.Object, GXml.DomNode, GXml.DomNonDocumentTypeChildNode, GXml.DomChildNode {
		public virtual void append_data (string data);
		public virtual void delete_data (int offset, int count) throws GLib.Error;
		public virtual void insert_data (int offset, string data) throws GLib.Error;
		public new virtual void replace_data (int offset, int count, string data) throws GLib.Error;
		public virtual string substring_data (int offset, int count) throws GLib.Error;
		/**
		 * Null is an empty string.
		 */
		public abstract string data { owned get; set; }
		public virtual int length { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomChildNode : GLib.Object {
		public abstract void remove ();
	}
	/**
	 * DOM4 comment node
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomComment : GXml.DomCharacterData {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomCustomEvent : GLib.Object, GXml.DomEvent {
		public abstract void init_custom_event (string type, bool bubbles, bool cancelable, GLib.Value detail);
		public abstract GLib.Value detail { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomDocument : GLib.Object, GXml.DomNode, GXml.DomParentNode, GXml.DomNonElementParentNode {
		public abstract GXml.DomNode adopt_node (GXml.DomNode node) throws GLib.Error;
		public abstract GXml.DomComment create_comment (string data) throws GLib.Error;
		public abstract GXml.DomDocumentFragment create_document_fragment ();
		public abstract GXml.DomElement create_element (string local_name) throws GLib.Error;
		public abstract GXml.DomElement create_element_ns (string? @namespace, string qualified_name) throws GLib.Error;
		/**
		 * No implemented jet. This can lead to API changes in future versions.
		 */
		public abstract GXml.DomEvent create_event (string @interface) throws GLib.Error;
		/**
		 * Creates a {@link DomNodeIterator}.
		 *
		 * Consider to connect to {@link DomNodeIterator.accept_node} in order to
		 * filter the nodes you iterate on.
		 *
		 * See at {@link DomNodeFilter} for the constant value of @what_to_show
		 */
		public abstract GXml.DomNodeIterator create_node_iterator (GXml.DomNode root, int whatToShow = (int) 0xFFFFFFFF);
		public abstract GXml.DomProcessingInstruction create_processing_instruction (string target, string data) throws GLib.Error;
		/**
		 * No implemented jet. This can lead to API changes in future versions.
		 */
		public abstract GXml.DomRange create_range ();
		/**
		 * Creates an {@link GLib.InputStream} to write a string representation
		 * in XML of {@link GXml.Document}
		 */
		public virtual GLib.InputStream create_stream () throws GLib.Error;
		/**
		 * Creates an {@link GLib.InputStream} to write a string representation
		 * in XML of {@link GXml.Document}
		 */
		public virtual async GLib.InputStream create_stream_async (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract GXml.DomText create_text_node (string data) throws GLib.Error;
		/**
		 * Creates a {@link DomTreeWalker}.
		 *
		 * Consider to connect to {@link DomTreeWalker.accept_node} in order to
		 * filter the nodes you iterate on.
		 *
		 * See at {@link DomNodeFilter} for the constant value of @what_to_show
		 */
		public abstract GXml.DomTreeWalker create_tree_walker (GXml.DomNode root, int what_to_show = (int) 0xFFFFFFFF);
		public abstract GXml.DomHTMLCollection get_elements_by_class_name (string classNames);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name (string local_name);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name_ns (string? @namespace, string local_name);
		/**
		 * Returns a default XML {@link Parser} to use with this object.
		 */
		public abstract GXml.Parser get_xml_parser ();
		public abstract GXml.DomNode import_node (GXml.DomNode node, bool deep = false) throws GLib.Error;
		/**
		 * Reads a file contents and parse it to document.
		 */
		public virtual void read_from_file (GLib.File file, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Reads a file contents and parse it to document.
		 */
		public virtual async void read_from_file_async (GLib.File file, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Reads a string and parse it to document.
		 */
		public virtual void read_from_stream (GLib.InputStream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Reads a string and parse it to document.
		 */
		public virtual async void read_from_stream_async (GLib.InputStream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Reads a string and parse it to document.
		 */
		public virtual void read_from_string (string str, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Reads a string and parse it to document.
		 */
		public virtual async void read_from_string_async (string str, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Set a default XML {@link Parser} to use with this object.
		 */
		public abstract void set_xml_parser (GXml.Parser parser);
		/**
		 * Writes a dump XML representation of document to a file.
		 */
		public virtual void write_file (GLib.File file, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Writes asynchronically a dump XML representation of document to a file.
		 */
		public virtual async void write_file_async (GLib.File file, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Writes a dump XML representation of document to a stream.
		 */
		public virtual void write_stream (GLib.OutputStream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Writes a dump XML representation of document to a stream.
		 */
		public virtual async void write_stream_async (GLib.OutputStream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Serialize {@link GXml.Document} to a string.
		 */
		public virtual string write_string (GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Serialize {@link GXml.Document} to a string.
		 */
		public virtual async string write_string_async (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract string character_set { get; }
		public abstract string compat_mode { get; }
		public abstract string content_type { get; }
		public abstract GXml.DomDocumentType? doctype { owned get; }
		public abstract GXml.DomElement? document_element { owned get; }
		public abstract string document_uri { get; }
		public abstract GXml.DomImplementation implementation { get; }
		public abstract string origin { get; }
		public abstract string url { get; }
	}
	/**
	 * Not implemented yet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomDocumentFragment : GLib.Object, GXml.DomNode, GXml.DomParentNode, GXml.DomNonElementParentNode {
	}
	/**
	 * Not implemented yet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomDocumentType : GLib.Object, GXml.DomNode, GXml.DomChildNode {
		public abstract string name { get; }
		public abstract string public_id { get; }
		public abstract string system_id { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomElement : GLib.Object, GXml.DomNode, GXml.DomChildNode, GXml.DomNonDocumentTypeChildNode, GXml.DomParentNode {
		/**
		 * Creates an {@link GLib.InputStream} to write a string representation
		 * in XML of {@link GXml.Element} using node's {@link GXml.Document}
		 */
		public virtual GLib.InputStream create_stream () throws GLib.Error;
		/**
		 * Creates an {@link GLib.InputStream} to write a string representation
		 * in XML of {@link GXml.Element} using node's {@link GXml.Document}
		 */
		public virtual async GLib.InputStream create_stream_async (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract string? get_attribute (string name);
		public abstract string? get_attribute_ns (string? @namespace, string local_name);
		public abstract GXml.DomHTMLCollection get_elements_by_class_name (string class_names);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name (string local_name);
		public abstract GXml.DomHTMLCollection get_elements_by_tag_name_ns (string? @namespace, string local_name);
		public abstract bool has_attribute (string name);
		public abstract bool has_attribute_ns (string? @namespace, string local_name);
		public virtual bool matches (string selectors) throws GLib.Error;
		/**
		 * Parses an XML file, deserializing it over {@link GXml.Element}.
		 */
		public virtual void read_from_file (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Parses asinchronically an XML file, deserializing it over {@link GXml.Element}.
		 */
		public virtual async void read_from_file_async (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Parses an XML over a {@link GLib.InputStream}, deserializing it over {@link GXml.Element}.
		 */
		public virtual void read_from_stream (GLib.InputStream istream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Parses asynchronically an XML over a {@link GLib.InputStream}, deserializing it over {@link GXml.Element}.
		 */
		public virtual async void read_from_stream_async (GLib.InputStream istream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Parses an XML string, deserializing it over {@link GXml.Element}.
		 */
		public virtual void read_from_string (string str, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Parses an XML string, deserializing it over {@link GXml.Element}.
		 */
		public virtual async void read_from_string_async (string str, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Parsing a URI file.
		 */
		public virtual void read_from_uri (string uri) throws GLib.Error;
		/**
		 * Parsing asinchronically a URI file.
		 */
		public virtual async void read_from_uri_async (string uri, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract void remove_attribute (string name);
		public abstract void remove_attribute_ns (string? @namespace, string local_name);
		public abstract void set_attribute (string name, string value) throws GLib.Error;
		/**
		 * Set an attribute value to this element. If it doesn't exists yet, it is added
		 * to the list of attributes, unless it is an namespace redefinition.
		 *
		 * To set a namespace declaration [[http://www.w3.org/2000/xmlns]] namespace and xmlns
		 * as prefix. For default namespaces, use xmlns as name without prefix. Namespace
		 * URI will be the one provided as value.
		 *
		 * @param name a prefixed attribute name or xmlns for default namespace declaration
		 * @param value a value for the attribute or URI for namespace declaration
		 */
		public abstract void set_attribute_ns (string? @namespace, string name, string value) throws GLib.Error;
		/**
		 * Uses element's {@link GXml.Document} to write an XML to a file, serializing it.
		 */
		public virtual void write_file (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Uses element's {@link GXml.Document} to write asynchronically an XML to a file, serializing it.
		 */
		public virtual async void write_file_async (GLib.File f, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Uses element's {@link GXml.Document} to write an XML to a stream, serializing it.
		 */
		public virtual void write_stream (GLib.OutputStream stream) throws GLib.Error;
		/**
		 * Uses element's {@link GXml.Document} to write an XML to a stream, serializing it.
		 */
		public virtual async void write_stream_async (GLib.OutputStream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Serialize {@link GXml.Element} to a string.
		 */
		public virtual string write_string (GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Serialize asinchronically {@link GXml.Element} to a string.
		 */
		public virtual async string write_string_async (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract GXml.DomNamedNodeMap attributes { owned get; }
		public abstract GXml.DomTokenList class_list { owned get; }
		public abstract string? class_name { owned get; set; }
		public abstract string? id { owned get; set; }
		public abstract string local_name { owned get; }
		/**
		 * Returns default namespace's uri defined in node or first found.
		 */
		public abstract string? namespace_uri { owned get; }
		/**
		 * Returns default namespace's prefix defined in node or first found.
		 */
		public abstract string? prefix { owned get; }
		public abstract string tag_name { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomEvent : GLib.Object {
		[Flags]
		public enum Flags {
			STOP_PROPAGATION_FLAG,
			STOP_IMMEDIATE_PROPAGATION_FLAG,
			CANCELED_FLAG,
			INITIALIZED_FLAG,
			DISPATCH_FLAG
		}
		public enum Phase {
			NONE,
			CAPTURING_PHASE,
			AT_TARGET,
			BUBBLING_PHASE
		}
		public abstract void init_event (string type, bool bubbles, bool cancelable);
		public abstract void prevent_default ();
		public abstract void stop_immediate_propagation ();
		public abstract void stop_propagation ();
		public abstract bool bubbles { get; }
		public abstract bool cancelable { get; }
		public abstract GXml.DomEventTarget? current_target { get; }
		public abstract bool default_prevented { get; }
		public abstract string etype { get; }
		public abstract GXml.DomEvent.Phase event_phase { get; }
		public abstract GXml.DomEventTarget? event_target { get; }
		public abstract bool is_trusted { get; }
		public abstract GXml.DomTimeStamp time_stamp { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomEventListener : GLib.Object {
		public abstract void handle_event (GXml.DomEvent event);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomEventTarget : GLib.Object {
		public abstract void add_event_listener (string type, GXml.DomEventListener? callback, bool capture = false);
		public abstract bool dispatch_event (GXml.DomEvent event) throws GLib.Error;
		public abstract void remove_event_listener (string type, GXml.DomEventListener? callback, bool capture = false);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomHTMLCollection : GLib.Object, Gee.BidirList<GXml.DomElement> {
		public new abstract GXml.DomElement? get_element (int index);
		public virtual GXml.DomElement? item (int index);
		public virtual GXml.DomElement? named_item (string name);
		public new virtual GXml.DomElement[] to_array ();
		public virtual int length { get; }
	}
	/**
	 * Interface for HTML handling implementation
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomHtmlDocument : GLib.Object, GXml.DomDocument {
		/**
		 * This method reads HTML documents using default parser
		 */
		public abstract void read_from_string (string str) throws GLib.Error;
		/**
		 * This method reads HTML documents using default a very tolerant parser
		 */
		public abstract void read_from_string_tolerant (string str) throws GLib.Error;
		/**
		 * This method dump to HTML string.
		 */
		public abstract string to_html () throws GLib.Error;
	}
	/**
	 * Not implemented yet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomImplementation : GLib.Object {
		public abstract GXml.DomXMLDocument create_document (string? nspace, string? qualified_name, GXml.DomDocumentType? doctype = null) throws GLib.Error;
		public abstract GXml.DomDocumentType create_document_type (string qualified_name, string public_id, string system_id) throws GLib.Error;
		public abstract GXml.DomDocument create_html_document (string title);
		public virtual bool has_feature ();
	}
	/**
	 * Implementers should use constructor with one argument {@link GXml.DomMutationCallback}
	 * to use internally.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomMutationObserver : GLib.Object {
		public abstract void disconnect ();
		public abstract void observe (GXml.Node target, GXml.DomMutationObserverInit options);
		public abstract Gee.List<GXml.DomMutationRecord> take_records ();
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomMutationRecord : GLib.Object {
		public abstract GXml.DomNodeList added_nodes { owned get; set; }
		public abstract string? attribute_name { get; }
		public abstract string? attribute_namespace { get; }
		public abstract string mtype { get; }
		public abstract GXml.DomNode? next_sibling { owned get; }
		public abstract string? old_value { get; }
		public abstract GXml.DomNode? previous_sibling { owned get; }
		public abstract GXml.DomNodeList removed_nodes { owned get; set; }
		public abstract GXml.DomNode target { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNamedNodeMap : GLib.Object, Gee.Map<string,GXml.DomNode> {
		public abstract GXml.DomNode? get_named_item (string name);
		public abstract GXml.DomNode? get_named_item_ns (string namespace_uri, string local_name) throws GLib.Error;
		public abstract GXml.DomNode? item (int index);
		public abstract GXml.DomNode? remove_named_item (string name) throws GLib.Error;
		public abstract GXml.DomNode? remove_named_item_ns (string namespace_uri, string localName) throws GLib.Error;
		public abstract GXml.DomNode? set_named_item (GXml.DomNode node) throws GLib.Error;
		public abstract GXml.DomNode? set_named_item_ns (GXml.DomNode node) throws GLib.Error;
		public abstract int length { get; }
	}
	/**
	 * Base interface for all DOM4 implementations
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNode : GLib.Object, GXml.DomEventTarget {
		[Flags]
		public enum DocumentPosition {
			NONE,
			DISCONNECTED,
			PRECEDING,
			FOLLOWING,
			CONTAINS,
			CONTAINED_BY,
			IMPLEMENTATION_SPECIFIC
		}
		public enum NodeType {
			INVALID,
			ELEMENT_NODE,
			ATTRIBUTE_NODE,
			TEXT_NODE,
			CDATA_SECTION_NODE,
			ENTITY_REFERENCE_NODE,
			ENTITY_NODE,
			PROCESSING_INSTRUCTION_NODE,
			COMMENT_NODE,
			DOCUMENT_NODE,
			DOCUMENT_TYPE_NODE,
			DOCUMENT_FRAGMENT_NODE,
			NOTATION_NODE
		}
		public abstract GXml.DomNode append_child (GXml.DomNode node) throws GLib.Error;
		public abstract GXml.DomNode.DocumentPosition compare_document_position (GXml.DomNode other);
		public abstract bool contains (GXml.DomNode? other);
		/**
		 * Copy a {@link GXml.DomNode} relaying on {@link GXml.DomDocument} to other {@link GXml.DomNode}.
		 *
		 * {@link node} could belongs from different {@link GXml.DomDocument}, while source is a node
		 * belonging to given document.
		 *
		 * Only {@link GXml.DomElement} objects are supported. For attributes, use
		 * {@link GXml.DomElement.set_attribute} method, passing source's name and value as arguments.
		 *
		 * @param doc a {@link GXml.DomDocument} owning destiny node
		 * @param node a {@link GXml.DomElement} to copy nodes to
		 * @param source a {@link GXml.DomElement} to copy nodes from, it could be holded by different {@link GXml.DomDocument}
		 */
		public static bool copy (GXml.DomDocument doc, GXml.DomNode node, GXml.DomNode source, bool deep) throws GLib.Error;
		public abstract bool has_child_nodes ();
		public abstract GXml.DomNode insert_before (GXml.DomNode node, GXml.DomNode? child) throws GLib.Error;
		public abstract bool is_default_namespace (string? nspace);
		public abstract bool is_equal_node (GXml.DomNode? node);
		public abstract string? lookup_namespace_uri (string? prefix);
		public abstract string? lookup_prefix (string? nspace);
		public abstract void normalize ();
		public abstract GXml.DomNode remove_child (GXml.DomNode child) throws GLib.Error;
		public abstract GXml.DomNode replace_child (GXml.DomNode node, GXml.DomNode child) throws GLib.Error;
		public abstract string? base_uri { get; }
		public abstract GXml.DomNodeList child_nodes { owned get; }
		public abstract GXml.DomNode? first_child { owned get; }
		public abstract GXml.DomNode? last_child { owned get; }
		public abstract GXml.DomNode? next_sibling { owned get; }
		public abstract string node_name { owned get; }
		public abstract GXml.DomNode.NodeType node_type { get; }
		public abstract string? node_value { owned get; set; }
		public abstract GXml.DomDocument? owner_document { get; set construct; }
		public abstract GXml.DomElement? parent_element { owned get; }
		public abstract GXml.DomNode? parent_node { owned get; }
		public abstract GXml.DomNode? previous_sibling { owned get; }
		public abstract string? text_content { owned get; set; }
	}
	/**
	 * Document's node iterator.
	 *
	 * If you want to filter while you go though the tree
	 * set a handler for the {@link accept_node} signal
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNodeIterator : GLib.Object {
		public abstract void detach ();
		public abstract GXml.DomNode? next_node ();
		public abstract GXml.DomNode? previous_node ();
		public abstract bool pointer_before_reference_node { get; }
		public abstract GXml.DomNode reference_node { get; }
		public abstract GXml.DomNode root { get; }
		/**
		 * This is a value of {@link DomNodeFilter} constant SHOW.
		 */
		public abstract int what_to_show { get; }
		public signal GXml.DomNodeFilter.Filter accept_node (GXml.DomNode node);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNodeList : GLib.Object, Gee.BidirList<GXml.DomNode> {
		public abstract GXml.DomNode? item (int index);
		public abstract int length { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNonDocumentTypeChildNode : GLib.Object {
		public abstract GXml.DomElement? next_element_sibling { owned get; }
		public abstract GXml.DomElement? previous_element_sibling { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomNonElementParentNode : GLib.Object {
		public abstract GXml.DomElement? get_element_by_id (string element_id) throws GLib.Error;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomParentNode : GLib.Object {
		/**
		 * Search all child {@link GXml.Element} with a given property's name and with
		 * value contained in text.
		 */
		public virtual GXml.DomElementList get_elements_by_property_value (string property, string value);
		/**
		 * Select first matched {@link GXml.DomElement} if exists.
		 * @param selectors valid CSS Level 3 selectors.
		 * @return first matched {@link GXml.DomElement}, or null if nodes aren't found.
		 */
		public virtual GXml.DomElement? query_selector (string selectors) throws GLib.Error;
		/**
		 * Select all {@link GXml.DomElement} child and descendents that match CSS Level 3 selectors.
		 * @param selectors valid CSS Level 3 selectors.
		 * @return a {@link GXml.DomNodeList} with all matched nodes, or throw an Error if selectors are invalid. 
		 */
		public abstract GXml.DomNodeList query_selector_all (string selectors) throws GLib.Error;
		public abstract int child_element_count { get; }
		public abstract GXml.DomHTMLCollection children { owned get; }
		public abstract GXml.DomElement? first_element_child { owned get; }
		public abstract GXml.DomElement? last_element_child { owned get; }
	}
	/**
	 * DOM4 Processing Instruction node
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomProcessingInstruction : GXml.DomCharacterData {
		public abstract string target { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomRange : GLib.Object {
		public enum BoundaryPoints {
			START_TO_START,
			START_TO_END,
			END_TO_END,
			END_TO_START
		}
		public abstract GXml.DomDocumentFragment? clone_contents () throws GLib.Error;
		public abstract GXml.DomRange clone_range ();
		public abstract void collapse (bool to_start = false) throws GLib.Error;
		public abstract int compare_boundary_points (GXml.DomRange.BoundaryPoints how, GXml.DomRange sourceRange) throws GLib.Error;
		public abstract short compare_point (GXml.DomNode node, int offset);
		public abstract void delete_contents () throws GLib.Error;
		public abstract void detach ();
		public abstract GXml.DomDocumentFragment? extract_contents () throws GLib.Error;
		public abstract void insert_node (GXml.DomNode node);
		public abstract bool intersects_node (GXml.DomNode node);
		public abstract bool is_point_in_range (GXml.DomNode node, int offset);
		public abstract void select_node (GXml.DomNode node) throws GLib.Error;
		public abstract void select_node_contents (GXml.DomNode node) throws GLib.Error;
		public abstract void set_end (GXml.DomNode node, int offset) throws GLib.Error;
		public abstract void set_end_after (GXml.DomNode node) throws GLib.Error;
		public abstract void set_end_before (GXml.DomNode node) throws GLib.Error;
		public abstract void set_start (GXml.DomNode node, int offset) throws GLib.Error;
		public abstract void set_start_after (GXml.DomNode node) throws GLib.Error;
		public abstract void set_start_before (GXml.DomNode node) throws GLib.Error;
		public abstract void surround_contents (GXml.DomNode newParent);
		public abstract string to_string ();
		public abstract bool collapsed { get; }
		public abstract GXml.DomNode common_ancestor_container { get; }
		public abstract GXml.DomNode end_container { get; }
		public abstract int end_offset { get; }
		public abstract GXml.DomNode start_container { get; }
		public abstract int start_offset { get; }
	}
	/**
	 * No implemented jet. This can lead to API changes in future versions.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomSettableTokenList : GLib.Object, GXml.DomTokenList {
		public abstract string value { owned get; set; }
	}
	/**
	 * DOM4 text node
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomText : GXml.DomCharacterData {
		public virtual GXml.DomText split_text (int offset) throws GLib.Error;
		public virtual string whole_text { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomTokenList : GLib.Object, Gee.BidirList<string> {
		public abstract void add (string[] tokens) throws GLib.Error;
		public abstract bool contains (string token) throws GLib.Error;
		public abstract string? item (int index);
		public abstract void remove (string[] tokens);
		public abstract string to_string ();
		/**
		 * If auto is true, adds token if not present and removing if it is, @force value
		 * is taken in account. If auto is false, then @force is considered; if true adds
		 * token, if false removes it.
		 */
		public abstract bool toggle (string token, bool force = false, bool auto = true) throws GLib.Error;
		public abstract int length { get; }
	}
	/**
	 * Document tree walker.
	 *
	 * If you want to filter while you go though the tree
	 * set a handler for the {@link accept_node} signal
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomTreeWalker : GLib.Object {
		public abstract GXml.DomNode? first_child ();
		public abstract GXml.DomNode? last_child ();
		public abstract GXml.DomNode? next_node ();
		public abstract GXml.DomNode? next_sibling ();
		public abstract GXml.DomNode? parent_node ();
		public abstract GXml.DomNode? previous_node ();
		public abstract GXml.DomNode? previous_sibling ();
		public abstract GXml.DomNode current_node { get; }
		public abstract GXml.DomNode root { get; }
		public abstract int what_to_show { get; }
		public signal GXml.DomNodeFilter.Filter accept_node (GXml.DomNode node);
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface DomXMLDocument : GLib.Object, GXml.DomDocument {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdAnnotation : GLib.Object {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdAttribute : GLib.Object {
		public const string SCHEMA_NODE_NAME;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdAttributeGroup : GLib.Object {
		public const string SCHEMA_NODE_NAME;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdBaseAttribute : GLib.Object {
		public abstract GXml.IXsdAnnotation anotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdBaseContent : GLib.Object {
		public abstract GXml.IXsdAnnotation anotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdBaseType : GLib.Object {
		public abstract GXml.IXsdAnnotation anotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdComplexContent : GLib.Object, GXml.IXsdBaseContent {
		public const string SCHEMA_NODE_NAME;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdComplexType : GLib.Object, GXml.DomElement, GXml.IXsdBaseType {
		public const string SCHEMA_NODE_NAME;
		/**
		 * attribute name = abstract
		 */
		public abstract bool @abstract { get; set; }
		/**
		 * (#all | List of (extension | restriction))
		 */
		public abstract string block { get; set; }
		/**
		 * A {@link IXsdComplexType} or {@link IXsdSimpleType}
		 */
		public abstract GXml.IXsdBaseContent content_type { get; set; }
		/**
		 * defaultAttributesApply
		 */
		public abstract bool default_attributes_apply { get; set; }
		/**
		 * (#all | List of (extension | restriction))
		 */
		public abstract string final { get; set; }
		/**
		 * List of {@link IXsdAttributeGroup} definitions
		 */
		public abstract GXml.IXsdListAttributesGroup group_attributes { get; }
		public abstract bool mixed { get; set; }
		public abstract string name { get; set; }
		/**
		 * List of {@link IXsdAttribute} definitions
		 */
		public abstract GXml.IXsdListAttributes type_attributes { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdElement : GLib.Object, GXml.DomElement {
		public const string SCHEMA_NODE_NAME;
		/**
		 * attribute name = abstract
		 */
		public abstract bool @abstract { get; set; }
		public abstract GXml.IXsdAnnotation anotation { get; set; }
		/**
		 * (#all | List of (extension | restriction | substitution))
		 */
		public abstract string block { get; set; }
		public abstract GXml.IXsdComplexType complex_type { get; set; }
		public abstract string @default { get; set; }
		/**
		 * (#all | List of (extension | restriction))
		 */
		public abstract string final { get; set; }
		public abstract string fixed { get; set; }
		/**
		 * (qualified | unqualified)
		 */
		public abstract string form { get; set; }
		public abstract string? id { get; set; }
		/**
		 * (nonNegativeInteger | unbounded)  : 1
		 */
		public abstract string maxOccurs { get; set; }
		/**
		 * nonNegativeInteger : 1
		 */
		public abstract string minOccurs { get; set; }
		public abstract string name { get; set; }
		public abstract bool nillable { get; set; }
		/**
		 * attribute name = 'type'
		 */
		public abstract string object_type { get; set; }
		public abstract string @ref { get; set; }
		public abstract GXml.IXsdSimpleType simple_type { get; set; }
		/**
		 * substitutionGroup
		 */
		public abstract GXml.DomTokenList substitution_group { get; set; }
		/**
		 * targetNamespace
		 */
		public abstract string target_namespace { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdExtension : GLib.Object, GXml.DomElement {
		public const string SCHEMA_NODE_NAME;
		public abstract string @base { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdList : GLib.Object, GXml.Collection {
		public abstract void append (GXml.DomElement element);
		public abstract GXml.DomElement? get_item (int index);
		public abstract int index_of (GXml.DomElement element);
		public abstract void remove (int index);
		public abstract GXml.DomElement element { get; set construct; }
		public abstract GLib.Type items_name { get; set construct; }
		public abstract GLib.Type items_type { get; set construct; }
		public abstract int length { get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdListAttributes : GLib.Object, GXml.IXsdList {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdListAttributesGroup : GLib.Object, GXml.IXsdList {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdListComplexTypes : GLib.Object, GXml.IXsdList {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdListElements : GLib.Object, GXml.IXsdList {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdListSimpleTypes : GLib.Object, GXml.IXsdList {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdListTypeRestrictionEnumerations : GLib.Object, GXml.IXsdList {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdListTypeRestrictionWhiteSpaces : GLib.Object, GXml.IXsdList {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdOpenContent : GLib.Object, GXml.IXsdBaseContent {
	}
	/**
	 * Reference interfaces for XSD support.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdSchema : GLib.Object, GXml.DomElement {
		public const string SCHEMA_NAMESPACE_PREFIX;
		public const string SCHEMA_NAMESPACE_URI;
		public const string SCHEMA_NODE_NAME;
		public abstract GXml.IXsdListComplexTypes complex_type_definitions { get; set; }
		public abstract GXml.IXsdListElements element_definitions { get; set; }
		public abstract GXml.IXsdListSimpleTypes simple_type_definitions { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdSimpleContent : GLib.Object, GXml.IXsdBaseContent {
		public const string SCHEMA_NODE_NAME;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdSimpleType : GLib.Object, GXml.DomElement, GXml.IXsdBaseType {
		public const string SCHEMA_NODE_NAME;
		public abstract GXml.IXsdAnnotation annotation { get; set; }
		/**
		 * (#all | List of (list | union | restriction | extension))
		 */
		public abstract string final { get; set; }
		public abstract string id { get; set; }
		public abstract GXml.IXsdTypeList list { get; set; }
		public abstract string name { get; set; }
		public abstract GXml.IXsdTypeRestriction restriction { get; set; }
		public abstract GXml.IXsdTypeUnion union { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeDef : GLib.Object {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeList : GLib.Object, GXml.IXsdTypeDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestriction : GLib.Object, GXml.IXsdTypeDef {
		public const string SCHEMA_NODE_NAME;
		public abstract string @base { get; set; }
		public abstract GXml.IXsdListTypeRestrictionEnumerations enumerations { get; set; }
		public abstract string id { get; set; }
		public abstract GXml.IXsdSimpleType simple_type { get; set; }
		public abstract GXml.IXsdListTypeRestrictionWhiteSpaces white_spaces { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionAssertion : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionDef : GLib.Object {
		public abstract GXml.IXsdAnnotation annotation { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionEnumeration : GLib.Object, GXml.IXsdTypeRestrictionDef {
		public const string SCHEMA_NODE_NAME;
		public abstract string id { get; set; }
		public abstract string value { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionExplicitTimezone : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionFractionDigits : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionLength : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionMaxExclusive : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionMaxInclusive : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionMaxLength : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionMinExclusive : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionMinInclusive : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionMinLength : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionPattern : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionTotalDigits : GLib.Object, GXml.IXsdTypeRestrictionDef {
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeRestrictionWhiteSpace : GLib.Object, GXml.IXsdTypeRestrictionDef {
		public const string SCHEMA_NODE_NAME;
		public abstract bool fixed { get; set; }
		public abstract string id { get; set; }
		/**
		 * (collapse | preserve | replace)
		 */
		public abstract string value { get; set; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface IXsdTypeUnion : GLib.Object, GXml.IXsdTypeDef {
	}
	/**
	 * {@link Gee.Iterable} and {@link Gee.Traversable} implementation of {@link GXml.Collection}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface List : GLib.Object, GXml.Collection, Gee.Traversable<GXml.DomElement>, Gee.Iterable<GXml.DomElement> {
	}
	/**
	 * {@link Gee.Iterable} and {@link Gee.Traversable} implementation of {@link GXml.Collection}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Map : GLib.Object, GXml.Collection, Gee.Traversable<GXml.DomElement>, Gee.Iterable<GXml.DomElement> {
		/**
		 * Returns true if @key is used in collection.
		 */
		public abstract bool has_key (string key);
		/**
		 * Returns an {@link DomElement} in the collection using a string key.
		 */
		public abstract GXml.DomElement? item (string key);
		/**
		 * An attribute's name in items to be added and used to retrieve elements
		 * as key.
		 */
		public abstract string attribute_key { get; set construct; }
		/**
		 * Returns list of keys used in collection.
		 */
		public abstract Gee.Set<string> keys_set { owned get; }
	}
	/**
	 * Interface to be implemented by {@link GXml.Collection} derived classes
	 * in order to provide a string to be used in {@link GXml.HashMap} as key.
	 *
	 * If {@link GXml.HashMap} has set its {@link GXml.HashMap.attribute_key}
	 * its value has precedence over this method.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface MappeableElement : GLib.Object, GXml.DomElement {
		public abstract string get_map_key ();
	}
	/**
	 * Interface to be implemented by {@link GXml.Collection} derived classes
	 * in order to provide a strings to be used in {@link GXml.HashPairedMap} as keys.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface MappeableElementPairKey : GLib.Object, GXml.DomElement {
		public abstract string get_map_primary_key ();
		public abstract string get_map_secondary_key ();
	}
	/**
	 * Interface to be implemented by {@link GXml.Collection} derived classes
	 * in order to provide a string to be used in {@link GXml.HashThreeMap} as key.
	 *
	 * If {@link GXml.HashMap} has set its {@link GXml.HashMap.attribute_key}
	 * its value has precedence over this method.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface MappeableElementThreeKey : GLib.Object, GXml.DomElement {
		/**
		 * Returns primary key of collection.
		 */
		public abstract string get_map_pkey ();
		/**
		 * Returns secondary key of collection.
		 */
		public abstract string get_map_skey ();
		/**
		 * Returns third key of collection.
		 */
		public abstract string get_map_tkey ();
	}
	/**
	 * A GXml Object Model represents a {@link DomElement}. It has attributes
	 * and children. All object's properties are handled as attributes if they are
	 * basic types like integers, strings, enums and others; {@link Property}
	 * objects are handled as attributes too. If object's attribute is a {@link GLib.Object}
	 * it is handled as node's child, but only if it is a {@link GXml.Element} object,
	 * other wise it is ignored when this object is used as {@link DomNode} in XML
	 * documents.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Object : GLib.Object, GXml.DomNode, GXml.DomElement {
		/**
		 * Utility method to remove all instances of a property being child elements
		 * of object. Is useful if you have a {@link GXml.Element} property, it should be
		 * just one child of this type and you want to overwrite it.
		 *
		 * In this example you have defined an element MyClass to be child of
		 * MyParentClass, but it should have just one element, once you set child_elements
		 * it calls {@link clean_property_elements} using property's canonicals name.
		 *
		 * {{{
		 *  public class MyClass : GXml.Element {
		 *    public string name { get; set; }
		 *  }
		 *  public class MyParentClass : GXml.Element {
		 *    private Myclass _child_elements = null;
		 *    public MyClass child_elements {
		 *      get { return _child_elements; }
		 *      set {
		 *        try {
		 *          clean_property_elements ("child-elements");
		 *          _child_elements = value;
		 *          append_child (_child_elements);
		 *        } catch (GLib.Error e) {
		 *          warning (e.message);
		 *        }
		 *      }
		 *    }
		 *  }
		 * }}}
		 *
		 * @param name property name to search value type, use canonical names.
		 *
		 * @throws DomError if property is not a {@link GXml.Element}.
		 */
		public virtual void clean_property_elements (string name) throws GLib.Error;
		/**
		 * From a given property name of type {@link GXml.Element}, search all
		 * child nodes with node's local name equal to property.
		 */
		public virtual GXml.DomElementList find_elements (string name);
		/**
		 * Returns a {@link GXml.Object} or a {@link Collection} property's
		 * {@link GLib.ParamSpec} based on given name. This method is
		 * case insensitive.
		 *
		 * This method will check if nick's name is equal than given name
		 * in order to avoid use canonical names like "your-name" if your
		 * property is your_name; so you can use nick to "YourName" to find
		 * and instantiate it.
		 */
		public virtual GLib.ParamSpec? find_object_property_name (string pname);
		/**
		 * Search for a property of type {@link GXml.Property}
		 * and returns it as object
		 */
		public virtual GXml.Property? find_property (string name);
		/**
		 * Returns property's {@link GLib.ParamSpec} based on given nick, without '::'
		 * This function is case insensitive.
		 *
		 * By default any property to be serialized, should set its nick with a prefix
		 * '::', while this method requires to avoid '::' for property's name to find.
		 * '::' will not be present on serialization output, so you can use any convention
		 * for your attribute's name, like using camel case.
		 */
		public virtual GLib.ParamSpec? find_property_name (string nick);
		/**
		 * Search for properties in objects, it should be
		 * an {@link GLib.Object}'s property. If found a
		 * property with given name its value is returned
		 * as string representation.
		 *
		 * If property is a {@link GXml.Property}
		 * returned value is a string representation according
		 * with object implementation.
		 *
		 * If given property name is not found, then {@link DomElement.get_attribute}
		 * is called.
		 *
		 * By default all {@link GLib.Object} are children of
		 * this object, see {@link get_child}
		 */
		public virtual string? get_attribute (string name);
		/**
		 * Search a {@link GLib.Object} property with given name
		 * and returns it, if it is a {@link DomElement}. If not found,
		 * {@link DomElement.get_elements_by_tag_name} is called, returning
		 * first node found. Tag name to use, is the given name parameter.
		 *
		 * @param name a name of this object's property of type {@link DomElement} or
		 * first {@link DomNode} with that name in child nodes.
		 *
		 */
		public virtual GXml.DomElement? get_child (string name);
		/**
		 * Returns a list with all properties' nick with "::" prefix. Nick name,
		 * with "::" prefix will be used on serialization to an attribute's name.
		 */
		public virtual GLib.List<GLib.ParamSpec> get_properties_list ();
		/**
		 * Returns a list of names for all {@link DomElement}
		 * present as object's properties.
		 */
		public virtual GLib.List<GLib.ParamSpec> get_property_element_list ();
		/**
		 * Returns an string representation of an Object's property.
		 */
		public virtual string? get_property_string (GLib.ParamSpec prop);
		/**
		 * Search for a property and set it to null if possible returning true,
		 * if value can't be removed or located, returns false without change.
		 */
		public virtual bool remove_attribute (string name);
		/**
		 * Search for a {@link GLib.Object} property with
		 * given name, if found, given string representation
		 * is used as value to property, using any required
		 * transformation from string.
		 *
		 * By default all {@link GLib.Object} are children of
		 * this object.
		 */
		public virtual bool set_attribute (string name, string val);
		/**
		 * Convenient method to set an instance of given property's
		 * name and initialize according to have same {@link DomNode.owner_document}
		 * and set its {@link DomNode.parent_node} to this appending it as a child.
		 * If property is a {@link Collection} it is initialize to use
		 * this as its {@link Collection.element}.
		 *
		 * Instance is set to object's property.
		 *
		 * Property should be a {@link GXml.Element} or {@link Collection}
		 *
		 * While an object could be created and set to a Object's property, it
		 * is not correctly initialized by default. This method helps in the process.
		 *
		 * If Object's property has been set, this method overwrite it.
		 *
		 * {{{
		 * class NodeA : GXml.Object {
		 *   construct { try { initialize ("NodeA"); } catch { warning ("Can't initialize); }
		 * }
		 * class NodeB : GXml.Object {
		 *   public NodeA node { get; set; }
		 * }
		 *
		 * var nb = new NodeB ();
		 * nb.create_instance_property ("node");
		 * assert (nb.node != null);
		 * }}}
		 *
		 * Property's name can be canonical or its nick name, see {@link find_object_property_name}
		 *
		 * Returns: true if property has been set and initialized, false otherwise.
		 */
		public virtual bool set_instance_property (string name);
	}
	/**
	 * {@link Gee.Iterable} and {@link Gee.Traversable} implementation of {@link GXml.Collection}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface PairedMap : GLib.Object, GXml.Collection, Gee.Traversable<GXml.DomElement>, Gee.Iterable<GXml.DomElement> {
		/**
		 * Returns true if @key is used in collection as primary key.
		 */
		public abstract bool has_primary_key (string key);
		/**
		 * Returns true if @key is used in collection as secondary key
		 * with @pkey as primary.
		 */
		public abstract bool has_secondary_key (string pkey, string key);
		/**
		 * Returns an {@link DomElement} in the collection using given string keys.
		 */
		public abstract GXml.DomElement? item (string primary_key, string secondary_key);
		/**
		 * Returns list of secondary keys used in collection with @pkey as primary key.
		 */
		public abstract Gee.Set<string> secondary_keys_set (string pkey);
		/**
		 * An attribute's name in items to be added and used to retrieve elements
		 * as primary key.
		 */
		public abstract string attribute_primary_key { get; set construct; }
		/**
		 * An attribute's name in items to be added and used to retrieve elements
		 * as secondary key.
		 */
		public abstract string attribute_secondary_key { get; set construct; }
		/**
		 * Returns list of primary keys used in collection.
		 */
		public abstract Gee.Set<string> primary_keys_set { owned get; }
	}
	/**
	 * XML parser engine for {@link DomDocument} implementations.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Parser : GLib.Object {
		/**
		 * Creates a new {@link DomElement} and append it as a child of parent: for current
		 * read node, only if parent: have a property as {@link Collection} type and current
		 * node have same local name as collection {@link Collection.items_name}
		 *
		 * Returns: true if element is set to a new object, it is set as a child of parent:
		 * and has been added to a parent:'s collection property.
		 */
		public virtual bool add_element_collection (GXml.DomNode parent, out GXml.DomNode element) throws GLib.Error;
		/**
		 * Creates a new {@link DomElement} and append it as a child of parent.
		 */
		public abstract GXml.DomElement? create_element (GXml.DomNode parent) throws GLib.Error;
		/**
		 * Creates an {@link GLib.InputStream} to write a string representation
		 * in XML
		 */
		public abstract GLib.InputStream create_stream () throws GLib.Error;
		/**
		 * Creates asyncronically an {@link GLib.InputStream} to write a string representation
		 * in XML
		 */
		public abstract async GLib.InputStream create_stream_async () throws GLib.Error;
		/**
		 * Check if current node found by parser, is a {@link DomDocument}
		 */
		public abstract bool current_is_document ();
		/**
		 * Check if current node found by parser, is a {@link DomElement}
		 */
		public abstract bool current_is_element ();
		/**
		 * Check if current node has children.
		 */
		public abstract bool current_is_empty_element ();
		/**
		 * Returns current node's local name, found by parser.
		 */
		public abstract string current_node_name ();
		/**
		 * Use parser to go to next parsed node.
		 */
		public abstract bool move_next_node () throws GLib.Error;
		/**
		 * Reads current found element
		 */
		public virtual bool read_child_element (GXml.DomNode parent) throws GLib.Error;
		/**
		 * Creates a new {@link DomNode} and append it to
		 * parent: depending on current node's type found by parser.
		 *
		 * If current found node is a {@link DomElement}, it is not parsed.
		 * If you want to parse it use {@link read_element} method.
		 *
		 * Returns: true if node has been created and appended to parent.
		 */
		public abstract bool read_child_node (GXml.DomNode parent) throws GLib.Error;
		/**
		 * Iterates in all child nodes and append them to node.
		 */
		public virtual void read_child_nodes (GXml.DomNode parent) throws GLib.Error;
		/**
		 * Iterates in all child nodes and append them to node.
		 */
		public virtual async void read_child_nodes_async (GXml.DomNode parent) throws GLib.Error;
		/**
		 * Read all children node feed by stream.
		 */
		public abstract void read_child_nodes_stream (GLib.InputStream istream) throws GLib.Error;
		/**
		 * Read children nodes from string
		 */
		public virtual void read_child_nodes_string (string str) throws GLib.Error;
		/**
		 * Reads an element's attributes, setting its values and taking care about their
		 * namespaces.
		 */
		public abstract void read_element (GXml.DomElement element) throws GLib.Error;
		/**
		 * Creates a new {@link DomElement} and append it as a child of parent: for current
		 * read node, only if parent: have a property as {@link DomElement} type and current
		 * node have same local name as property element.
		 *
		 * Returns: true if element is set to a new object and it is set as a child of parent:
		 * as a property.
		 */
		public virtual bool read_element_property (GXml.DomNode parent, out GXml.DomNode element) throws GLib.Error;
		/**
		 * Reads a {@link node} from a {@link GLib.File}
		 */
		public virtual void read_file (GLib.File file) throws GLib.Error;
		/**
		 * Reads a {@link GXml.DomDocument} from a {@link GLib.File}
		 */
		public virtual async void read_file_async (GLib.File file) throws GLib.Error;
		/**
		 * Read a {@link GXml.DomDocument} from a {@link GLib.InputStream}
		 */
		public abstract void read_stream (GLib.InputStream stream) throws GLib.Error;
		/**
		 * Read a {@link GXml.DomDocument} from a {@link GLib.InputStream}
		 */
		public abstract async void read_stream_async (GLib.InputStream stream) throws GLib.Error;
		/**
		 * Reads a {@link node} from a string
		 */
		public abstract void read_string (string str) throws GLib.Error;
		/**
		 * Reads synchronically {@link node} a from a string
		 */
		public abstract async void read_string_async (string str) throws GLib.Error;
		/**
		 * Reads all child nodes as string
		 */
		public abstract string read_unparsed () throws GLib.Error;
		/**
		 * Writes a {@link GXml.DomDocument} to a {@link GLib.File}
		 */
		public virtual void write_file (GLib.File file) throws GLib.Error;
		/**
		 * Writes a {@link GXml.DomDocument} to a {@link GLib.File}
		 */
		public virtual async void write_file_async (GLib.File file) throws GLib.Error;
		/**
		 * Writes a {@link GXml.DomDocument} to a {@link GLib.OutputStream}
		 */
		public abstract void write_stream (GLib.OutputStream stream) throws GLib.Error;
		/**
		 * Writes asynchronically a {@link node} to a {@link GLib.OutputStream}
		 */
		public abstract async void write_stream_async (GLib.OutputStream stream) throws GLib.Error;
		/**
		 * Writes a {@link node} to a string
		 */
		public abstract string write_string () throws GLib.Error;
		/**
		 * Writes asynchronically {@link node} to a string
		 */
		public abstract async string write_string_async () throws GLib.Error;
		/**
		 * Controls if, when writing to a file, a backup should
		 * be created.
		 */
		public abstract bool backup { get; set; }
		/**
		 * Controls if, when writing, indentation should be used.
		 */
		public abstract GLib.Cancellable? cancellable { get; set; }
		/**
		 * Controls if, when writing, indentation should be used.
		 */
		public abstract bool indent { get; set; }
		/**
		 * A {@link GXml.DomDocument} to read to or write from
		 */
		public abstract GXml.DomNode node { get; }
		/**
		 * A collection of child types of found {@link GXml.CollectionParent}
		 * objects, used to instantiate the correct class based on the
		 * node's name.
		 *
		 * The map use the {@link GLib.Type} of the object implementing
		 * {@link GXml.CollectionParent} as the key, to get a {@link GLib.HashTable}
		 * holding a set of instantiable child classes, with the key as the
		 * lowercase of the node's local name to get the {@link GLib.Type}
		 * of the instantiable class to create and add to the collection.
		 */
		public abstract GLib.HashTable<GLib.Type,GLib.HashTable<string,GLib.Type>> types { get; }
	}
	/**
	 * An interface for {@link GXml.Object}'s properties translated to
	 * {@link DomElement} attributes. If object is instantiated it is
	 * written, if not is just ignored.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface Property : GLib.Object {
		/**
		 * Takes a string and check if it is a valid value for property
		 */
		public abstract bool validate_value (string? val);
		/**
		 * Attribute's value in the parent {@link DomElement} using a string.
		 *
		 * Implementation should take care to validate value before to set or
		 * parse from XML document.
		 */
		public abstract string? value { owned get; set; }
	}
	/**
	 * {@link Gee.Iterable} and {@link Gee.Traversable} implementation of {@link GXml.Collection}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface ThreeMap : GLib.Object, GXml.Collection, Gee.Traversable<GXml.DomElement>, Gee.Iterable<GXml.DomElement> {
		/**
		 * Returns true if @key is used in collection as primary key.
		 */
		public abstract bool has_primary_key (string key);
		/**
		 * Returns true if @key is used in collection as secondary key
		 * with @pkey as primary.
		 */
		public abstract bool has_secondary_key (string pkey, string key);
		/**
		 * Returns true if @key is used in collection as third key with secondary key
		 * and pkey as primary.
		 */
		public abstract bool has_third_key (string pkey, string skey, string key);
		/**
		 * Returns an {@link DomElement} in the collection using given string keys.
		 */
		public abstract GXml.DomElement? item (string primary_key, string secondary_key, string third_key);
		/**
		 * Returns list of secondary keys used in collection with @pkey as primary key.
		 */
		public abstract Gee.Set<string> secondary_keys_set (string pkey);
		/**
		 * Returns list of third keys used in collection with pkey as primary key
		 * and skey as secondary key.
		 */
		public abstract Gee.Set<string> third_keys_set (string pkey, string skey);
		/**
		 * An attribute's name in items to be added and used to retrieve elements
		 * as primary key.
		 */
		public abstract string attribute_primary_key { get; set construct; }
		/**
		 * An attribute's name in items to be added and used to retrieve elements
		 * as secondary key.
		 */
		public abstract string attribute_secondary_key { get; set construct; }
		/**
		 * An attribute's name in items to be added and used to retrieve elements
		 * as third key.
		 */
		public abstract string attribute_third_key { get; set construct; }
		/**
		 * Returns list of primary keys used in collection.
		 */
		public abstract Gee.Set<string> primary_keys_set { owned get; }
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface XPathContext : GLib.Object {
		/**
		 * Evaluate XPath expression.
		 *
		 * This method evaluates provided expression, registers provided namespaces
		 * in resolver and returns an {@link GXml.XPathObject}.
		 *
		 * Resolver is a map where its key is the namespace's prefix and
		 * its value is the namespace's URI
		 *
		 * Throw {@link GXml.XPathError} if one of provided namespaces is invalid.
		 */
		public abstract GXml.XPathObject evaluate (string expression, Gee.Map<string,string>? resolver = null) throws GXml.XPathObjectError;
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public interface XPathObject : GLib.Object {
		/**
		 *
		 */
		public abstract bool boolean_value { get; }
		/**
		 *
		 */
		public abstract GXml.DomHTMLCollection nodeset { get; }
		/**
		 *
		 */
		public abstract double number_value { get; }
		/**
		 *
		 */
		public abstract GXml.XPathObjectType object_type { get; }
		/**
		 *
		 */
		public abstract string string_value { get; }
	}
	/**
	 * Enumeration of identifiers, to combine selectors 
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum CssCombiner {
		NULL,
		NONE,
		INSIDE,
		AND,
		PARENT,
		AFTER,
		PRECEDED
	}
	/**
	 * Enumeration of types for {@link GXml.CssSelector}
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum CssSelectorType {
		CLASS,
		ID,
		ALL,
		ELEMENT,
		ATTRIBUTE,
		ATTRIBUTE_EQUAL,
		ATTRIBUTE_CONTAINS,
		ATTRIBUTE_SUBSTRING,
		ATTRIBUTE_STARTS_WITH,
		ATTRIBUTE_STARTS_WITH_WORD,
		ATTRIBUTE_ENDS_WITH,
		PSEUDO_CLASS
	}
	/**
	 * DOM1 Enumerates possible NodeTypes.
	 *
	 * For more, see: [[http://www.w3.org/TR/DOM-Level-1/level-one-core.html#ID-1950641247]]
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum NodeType {
		INVALID,
		ELEMENT,
		ATTRIBUTE,
		TEXT,
		CDATA_SECTION,
		ENTITY_REFERENCE,
		ENTITY,
		PROCESSING_INSTRUCTION,
		COMMENT,
		DOCUMENT,
		DOCUMENT_TYPE,
		DOCUMENT_FRAGMENT,
		NOTATION
	}
	/**
	 * Object type codes for  {@link XPathObject} objects
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public enum XPathObjectType {
		UNDEFINED,
		NODESET,
		BOOLEAN,
		NUMBER,
		STRING,
		POINT,
		RANGE,
		LOCATIONSET,
		USERS,
		XSLT_TREE
	}
	/**
	 * Error throwed during parsing 
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain CssSelectorError {
		NULL,
		EOF,
		NOT,
		PSEUDO,
		ATTRIBUTE,
		IDENTIFIER,
		COMBINER
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain DomDocumentError {
		FILE_NOT_FOUND_ERROR,
		INVALID_DOCUMENT_ERROR
	}
	/**
	 * DOM4 error codes.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain DomError {
		INDEX_SIZE_ERROR,
		DOMSTRING_SIZE_ERROR,
		HIERARCHY_REQUEST_ERROR,
		WRONG_DOCUMENT_ERROR,
		INVALID_CHARACTER_ERROR,
		NO_DATA_ALLOWED_ERROR,
		NO_MODIFICATION_ALLOWED_ERROR,
		NOT_FOUND_ERROR,
		NOT_SUPPORTED_ERROR,
		INUSE_ATTRIBUTE_ERROR,
		INVALID_STATE_ERROR,
		SYNTAX_ERROR,
		INVALID_MODIFICATION_ERROR,
		NAMESPACE_ERROR,
		INVALID_ACCESS_ERROR,
		VALIDATION_ERROR,
		TYPE_MISMATCH_ERROR,
		SECURITY_ERROR,
		NETWORK_ERROR,
		ABORT_ERROR,
		URL_MISMATCH_ERROR,
		QUOTA_EXCEEDED_ERROR,
		TIME_OUT_ERROR,
		INVALID_NODE_TYPE_ERROR,
		DATA_CLONE_ERROR
	}
	/**
	 * Errors when de/serializing enumerations.
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain EnumerationError {
		/**
		 * Given value is invalid in enumeration, when transform to string.
		 */
		INVALID_VALUE,
		/**
		 * Given text to transform to an enumeration's value.
		 */
		INVALID_TEXT
	}
	/**
	 * Auxiliary error codes for parsing/writing libxml2 powered classes
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain Error {
		NOT_SUPPORTED,
		PARSER,
		WRITER
	}
	/**
	 * XSD schema Error codes for {@link IXsdSchema} objects
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain IXsdSchemaError {
		INVALIDATION_ERROR
	}
	/**
	 * Parser Error codes for {@link DomNode} parsing objects
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain ParserError {
		INVALID_DATA_ERROR,
		INVALID_FILE_ERROR,
		INVALID_STREAM_ERROR
	}
	/**
	 * Parser Error codes for {@link XPathObject} objects
	 */
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain XPathError {
		EXPRESSION_OK,
		NUMBER_ERROR,
		UNFINISHED_LITERAL_ERROR,
		START_LITERAL_ERROR,
		VARIABLE_REF_ERROR,
		UNDEF_VARIABLE_ERROR,
		INVALID_PREDICATE_ERROR,
		EXPR_ERROR,
		UNCLOSED_ERROR,
		UNKNOWN_FUNC_ERROR,
		INVALID_OPERAND,
		INVALID_TYPE,
		INVALID_ARITY,
		INVALID_CTXT_SIZE,
		INVALID_CTXT_POSITION,
		MEMORY_ERROR,
		XPTR_SYNTAX_ERROR,
		XPTR_RESOURCE_ERROR,
		XPTR_SUB_RESOURCE_ERROR,
		UNDEF_PREFIX_ERROR,
		ENCODING_ERROR,
		INVALID_CHAR_ERROR,
		INVALID_CTXT
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public errordomain XPathObjectError {
		INVALID_NAMESPACE_ERROR
	}
	[CCode (cheader_filename = "gxml/gxml.h")]
	public delegate void DomMutationCallback (Gee.List<GXml.DomMutationRecord> mutations, GXml.DomMutationObserver observer);
}
