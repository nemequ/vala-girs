/* vsgi-0.3.vapi generated by valac 0.34.2, do not modify. */

/**
 * VSGI is an set of abstraction and implementations used to build generic web
 * application in Vala.
 *
 * It is minimalist and relies on libsoup-2.4, a good and stable HTTP library.
 */
[CCode (gir_namespace = "VSGI", gir_version = "0.3")]
namespace VSGI {
	/**
	 * CGI implementation of VSGI.
	 *
	 * This implementation is sufficiently general to implement other CGI-like
	 * protocol such as FastCGI and SCGI.
	 */
	namespace CGI {
		/**
		 * CGI request providing consistent environment behaviours.
		 */
		[CCode (cheader_filename = "vsgi.h")]
		[Version (experimental = true)]
		public class Request : VSGI.Request {
			/**
			 * Create a request from the provided environment variables.
			 *
			 * Although not part of CGI/1.1 specification, the 'REQUEST_URI' and
			 * 'HTTPS' environment variables are reckognized.
			 *
			 * {@inheritDoc}
			 *
			 * @param environment environment variables
			 */
			[Version (experimental = true)]
			public Request (VSGI.Connection connection, string[] environment);
			/**
			 * CGI environment variables encoded in 'NAME=VALUE'.
			 */
			[Version (experimental = true)]
			public string[] environment { get; construct; }
			public override string gateway_interface { owned get; }
			public override Soup.HTTPVersion http_version { get; }
			public override string method { owned get; }
			public override GLib.HashTable<string,string>? query { get; }
			public override Soup.URI uri { get; }
		}
		/**
		 * CGI response producing expected headers format.
		 */
		[CCode (cheader_filename = "vsgi.h")]
		[Version (experimental = true)]
		public class Response : VSGI.Response {
			[Version (experimental = true)]
			public Response (VSGI.CGI.Request request);
			protected override bool write_headers (Soup.MessageHeaders headers, out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
			protected override async bool write_headers_async (Soup.MessageHeaders headers, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null, out size_t bytes_written) throws GLib.Error;
			protected override bool write_status_line (Soup.HTTPVersion http_version, uint status, string reason_phrase, out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
			protected override async bool write_status_line_async (Soup.HTTPVersion http_version, uint status, string reason_phrase, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null, out size_t bytes_written) throws GLib.Error;
			/**
			 * On the first attempt to access the response body stream, the status
			 * line and headers will be written synchronously in the response
			 * stream. 'write_head_async' have to be used explicitly to perform a
			 * non-blocking operation.
			 */
			public override GLib.OutputStream body { get; }
		}
	}
	/**
	 * Cookie-related utilities.
	 */
	[CCode (gir_namespace = "VSGI", gir_version = "0.3")]
	namespace CookieUtils {
		/**
		 * Sign the provided cookie name and value in-place using HMAC.
		 *
		 * The returned value will be 'HMAC(checksum_type, name + HMAC(checksum_type, value)) + value'
		 * suitable for a cookie value which can the be verified with {@link VSGI.CookieUtils.verify}.
		 *
		 * {{{
		 * CookieUtils.sign (cookie, ChecksumType.SHA512, "super-secret".data);
		 * }}}
		 *
		 * @param cookie        cookie to sign
		 * @param checksum_type hash algorithm used to compute the HMAC
		 * @param key           secret used to sign the cookie name and value
		 */
		[CCode (cheader_filename = "vsgi.h")]
		[Version (since = "0.3")]
		public static void sign (Soup.Cookie cookie, GLib.ChecksumType checksum_type, uint8[] key);
		/**
		 * Verify a signed cookie from {@link VSGI.CookieUtils.sign}.
		 *
		 * The signature is verified in constant time, more specifically a number
		 * of comparisons equal to length of the checksum.
		 *
		 * @param cookie        cookie which signature will be verified
		 * @param checksum_type hash algorithm used to compute the HMAC
		 * @param key           secret used to sign the cookie's value
		 * @param value         cookie's value extracted from its signature if the
		 *                      verification succeeds, null otherwise
		 * @return              true if the cookie is signed by the secret
		 */
		[CCode (cheader_filename = "vsgi.h")]
		[Version (since = "0.3")]
		public static bool verify (Soup.Cookie cookie, GLib.ChecksumType checksum_type, uint8[] key, out string? value);
	}
	/**
	 * Mock implementation of VSGI used for testing purposes.
	 */
	namespace Mock {
		/**
		 * Stubbed connection with in-memory streams.
		 *
		 * The typical use case is to create a {@link VSGI.Mock.Request} with a
		 * stubbed connection so that the produced and consumed messages can be
		 * easily inspected.
		 */
		[CCode (cheader_filename = "vsgi.h")]
		[Version (experimental = true)]
		public class Connection : VSGI.Connection {
			[Version (experimental = true)]
			public Connection (VSGI.Mock.Server server);
			[Version (experimental = true)]
			public GLib.MemoryInputStream get_memory_input_stream ();
			[Version (experimental = true)]
			public GLib.MemoryOutputStream get_memory_output_stream ();
			public override GLib.InputStream input_stream { get; }
			public override GLib.OutputStream output_stream { get; }
		}
		/**
		 * Test implementation of Request used to stub a request.
		 */
		[CCode (cheader_filename = "vsgi.h")]
		[Version (experimental = true)]
		public class Request : VSGI.Request {
			[Version (experimental = true)]
			public Request (VSGI.Mock.Connection connection, string method, Soup.URI uri, GLib.HashTable<string,string>? query = null);
			[Version (experimental = true)]
			public Request.with_method (string method, Soup.URI uri, GLib.HashTable<string,string>? query = null);
			[Version (experimental = true)]
			public Request.with_query (GLib.HashTable<string,string>? query);
			[Version (experimental = true)]
			public Request.with_uri (Soup.URI uri, GLib.HashTable<string,string>? query = null);
			public override string gateway_interface { owned get; }
			public override Soup.HTTPVersion http_version { get; }
			public override string method { owned get; }
			public override GLib.HashTable<string,string>? query { get; }
			public override Soup.URI uri { get; }
		}
		/**
		 * Test implementation of VSGI.Response to stub a response.
		 */
		[CCode (cheader_filename = "vsgi.h")]
		[Version (experimental = true)]
		public class Response : VSGI.Response {
			[Version (experimental = true)]
			public Response (VSGI.Mock.Request req);
			[Version (experimental = true)]
			public Response.with_status (VSGI.Mock.Request req, uint status);
			protected override bool write_headers (Soup.MessageHeaders headers, out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
			protected override bool write_status_line (Soup.HTTPVersion http_version, uint status, string reason_phrase, out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		}
		[CCode (cheader_filename = "vsgi.h")]
		[Version (experimental = true)]
		public class Server : VSGI.Server {
			public Server ();
			public override void listen (GLib.SocketAddress? address = null) throws GLib.Error;
			public override void listen_socket (GLib.Socket socket) throws GLib.Error;
			public override void stop ();
			public override GLib.SList<Soup.URI> uris { owned get; }
		}
	}
	/**
	 * Cushion around {@link VSGI.Server}.
	 *
	 * It automatically parses the CLI arguments into {@link VSGI.Server.listen}
	 * calls, produces pretty logs, run a {@link GLib.MainLoop} and gracefully
	 * shutdown if a 'SIGTERM' signal is caught.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public class Application : GLib.Application {
		public Application (VSGI.Server server);
		public override int command_line (GLib.ApplicationCommandLine command_line);
		public VSGI.Server server { get; construct; }
	}
	/**
	 * Hold the necessary state to challenge and emit authentication headers.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public abstract class Authentication : GLib.Object {
		public Authentication ();
		/**
		 * Check and extract the fields from an 'Authorization' header.
		 *
		 * @param authorization_header 'Authorization' header value
		 * @param authorization        extracted {@link VSGI.Authorization} object
		 *                             containing the fields from the header
		 *
		 * @return 'true' on success, otherwise 'false' and 'authorization' is set
		 *         to 'null'
		 */
		public abstract bool parse_authorization_header (string authorization_header, out VSGI.Authorization? authorization);
		/**
		 * Produce a 'WWW-Authenticate' (or 'Proxy-Authenticate') header for this.
		 */
		public abstract string to_authenticate_header ();
		/**
		 * Indicate the expected charset to use by the user agent to encode username
		 * and password.
		 *
		 * If not specified, 'UTF-8' is assumed.
		 */
		public string? charset { get; construct; }
		public string realm { get; set construct; }
	}
	/**
	 * Hold the state of an 'Authorization' header and provide means to challenge
	 * it against a password.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public abstract class Authorization : GLib.Object {
		public Authorization ();
		/**
		 * Challenge the credentials against a provided password.
		 *
		 * @return 'true' if the password corresponds, 'false' otherwise
		 */
		public abstract bool challenge_with_password (string password);
		/**
		 * Produce a 'Authorization' header for this.
		 *
		 * @return an 'Authorization' header value
		 */
		public abstract string to_authorization_header ();
		public string username { get; construct; }
	}
	/**
	 * Parse and generate basic authentication headers according to RFC 7617.
	 *
	 * [[https://tools.ietf.org/html/rfc7617]]
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public class BasicAuthentication : VSGI.Authentication {
		public BasicAuthentication (string realm, string? charset = null);
		public override bool parse_authorization_header (string header, out VSGI.Authorization? authorization);
		public override string to_authenticate_header ();
	}
	/**
	 * Hold the state of a basic 'Authorization' header.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public class BasicAuthorization : VSGI.Authorization {
		public BasicAuthorization (string username, string password);
		public override bool challenge_with_password (string password);
		public override string to_authorization_header ();
		public string password { get; construct; }
	}
	/**
	 * Bounded input stream that provide a end-of-file behaviour when a a certain
	 * number of bytes has been read from the base stream.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public class BoundedInputStream : GLib.FilterInputStream {
		/**
		 * {@inheritDoc}
		 *
		 * @param content_length number of bytes that can be read from the base
		 *                       stream
		 */
		public BoundedInputStream (GLib.InputStream base_stream, int64 content_length);
		/**
		 * {@inheritDoc}
		 */
		public override bool close (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * {@inheritDoc}
		 *
		 * Ensures that the read buffer is smaller than the remaining bytes to
		 * read from the base stream. If no more data is available, it produces
		 * an artificial EOF.
		 */
		public override ssize_t read (uint8[] buffer, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * The {@link int64} type is used to remain consistent with
		 * {@link Soup.MessageHeaders.get_content_length}
		 */
		public int64 content_length { get; construct; }
	}
	/**
	 * Connection available from {@link VSGI.Request} holding raw streams.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public abstract class Connection : GLib.IOStream {
		public Connection ();
		/**
		 * Server which initiated this connection.
		 */
		public VSGI.Server server { get; construct; }
	}
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public abstract class Handler : GLib.Object {
		public Handler ();
		/**
		 * Process a pair of {@link VSGI.Request} and {@link VSGI.Response}.
		 *
		 * It is passed to a {@link VSGI.Server} in order to receive request to
		 * process.
		 *
		 * @throws Error unrecoverable error condition can be raised and will be
		 *               handled by the implementation
		 *
		 * @param req a resource being requested
		 * @param res the response to that request
		 *
		 * @return 'true' if the request has been or will eventually be handled,
		 *         otherwise 'false'
		 */
		public abstract bool handle (VSGI.Request req, VSGI.Response res) throws GLib.Error;
	}
	/**
	 * Load custom {@link VSGI.Handler} implementations.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public class HandlerModule : GLib.TypeModule {
		public HandlerModule (string? directory, string name);
		public override bool load ();
		public override void unload ();
		/**
		 * The directory from which the shared library will be searched, or 'null'
		 * to search in standard locations.
		 */
		public string? directory { get; construct; }
		/**
		 * Once loaded, this contain the type of the {@link VSGI.Handler} provided
		 * by this.
		 */
		public GLib.Type handler_type { get; private set; }
		/**
		 * The name of the server implementation.
		 */
		public string name { get; construct; }
		/**
		 * Path from which the module is loaded.
		 */
		public string path { get; construct; }
	}
	/**
	 * Request representing a request of a resource.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.1")]
	public abstract class Request : GLib.Object {
		/**
		 * Placeholder for the request body.
		 */
		[Version (experimental = true, since = "0.3")]
		protected GLib.InputStream? _body;
		[Version (experimental = true, since = "0.1")]
		public const string CONNECT;
		[Version (experimental = true, since = "0.1")]
		public const string DELETE;
		[Version (experimental = true, since = "0.1")]
		public const string GET;
		[Version (experimental = true, since = "0.1")]
		public const string HEAD;
		/**
		 * List of all supported HTTP methods.
		 */
		[Version (experimental = true, since = "0.1")]
		public const string[] METHODS;
		/**
		 * HTTP/1.1 standard methods.
		 *
		 * [[http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html]]
		 */
		[Version (experimental = true, since = "0.1")]
		public const string OPTIONS;
		/**
		 * PATCH method defined in RFC5789.
		 *
		 * [[http://tools.ietf.org/html/rfc5789]]
		 *
		 * This is a proposed standard, it is not part of the current HTTP/1.1
		 * protocol.
		 */
		[Version (experimental = true, since = "0.1")]
		public const string PATCH;
		[Version (experimental = true, since = "0.1")]
		public const string POST;
		[Version (experimental = true, since = "0.1")]
		public const string PUT;
		[Version (experimental = true, since = "0.1")]
		public const string TRACE;
		public Request ();
		/**
		 * Apply a converter to the request body.
		 *
		 * If the payload is chunked, (eg. 'Transfer-Encoding: chunked') and the
		 * new content length is undetermined, it will remain chunked.
		 *
		 * @param content_length resulting value for the 'Content-Length' header
		 *                       or '-1' if the length is undetermined
		 */
		[Version (since = "0.3")]
		public void convert (GLib.Converter converter, int64 content_length = -1);
		/**
		 * Flatten the request body in a buffer.
		 *
		 * This function consumes the body stream. Any subsequent calls will
		 * yield an empty buffer.
		 *
		 * If the 'Content-Length' header is set, a fixed-size buffer is used
		 * instead of dynamically resizing the buffer to fit the stream content.
		 *
		 * @return buffer containing the stream data
		 */
		[Version (since = "0.2")]
		public virtual uint8[] flatten (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * Buffer the body stream asynchronously.
		 *
		 * @return buffer containing the stream data
		 */
		[Version (since = "0.2")]
		public virtual async uint8[] flatten_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * Flatten the request body as a {@link GLib.Bytes}.
		 */
		[Version (since = "0.2")]
		public GLib.Bytes flatten_bytes (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.2")]
		public async GLib.Bytes flatten_bytes_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * Flatten the request body as a 'UTF-8' string.
		 *
		 * The payload is assumed to be encoded according to 'UTF-8'. If it is
		 * not the case, use {@link VSGI.Request.flatten} directly instead.
		 */
		[Version (since = "0.2")]
		public string flatten_utf8 (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.2")]
		public async string flatten_utf8_async (int io_priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		/**
		 * Lookup a cookie using its name.
		 *
		 * The last occurence is returned using a case-sensitive match.
		 *
		 * @param name name of the cookie to lookup
		 * @return the cookie if found, otherwise 'null'
		 */
		[Version (since = "0.3")]
		public Soup.Cookie? lookup_cookie (string name);
		/**
		 * Lookup a key in the request query.
		 *
		 * If the query itself is 'null' or the key is not available
		 *
		 * @param key key to lookup
		 */
		[Version (since = "0.3")]
		public string? lookup_query (string key);
		/**
		 * Lookup a signed cookie using its name.
		 *
		 * The returned cookie has its value signed, the 'value' parameter can
		 * be used to obtain its original value.
		 *
		 * @see CookieUtils.verify
		 *
		 * @return the signed cookie if found, otherwise 'null'
		 */
		[Version (since = "0.3")]
		public Soup.Cookie? lookup_signed_cookie (string name, GLib.ChecksumType checksum_type, uint8[] key, out string? value);
		/**
		 * Request body.
		 *
		 * The provided stream is filtered by the implementation according to
		 * the 'Transfer-Encoding' header value.
		 *
		 * The default implementation returns the connection stream unmodified.
		 */
		[Version (since = "0.2")]
		public GLib.InputStream body { get; }
		/**
		 * Connection containing raw streams.
		 */
		[Version (since = "0.2")]
		public VSGI.Connection connection { get; construct; }
		/**
		 * Request cookies extracted from the 'Cookie' header.
		 */
		[Version (since = "0.3")]
		public GLib.SList<Soup.Cookie> cookies { owned get; }
		/**
		 * Identifier for the gateway (eg. CGI/1.1).
		 *
		 * It is composed of an identifier and a version number separated by a
		 * slash '/'.
		 */
		[Version (since = "0.3")]
		public abstract string gateway_interface { owned get; }
		/**
		 * Request headers.
		 */
		public Soup.MessageHeaders headers { get; protected set construct; }
		/**
		 * Request HTTP version.
		 */
		[Version (since = "0.3")]
		public abstract Soup.HTTPVersion http_version { get; }
		/**
		 * Request HTTP method
		 *
		 * Should be one of OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT
		 * or PATCH.
		 *
		 * Constants for every standard HTTP methods are providen as constants in
		 * this class.
		 */
		public abstract string method { owned get; }
		/**
		 * HTTP query parsed if encoded according to percent-encoding,
		 * otherwise it must be interpreted from {@link VSGI.Request.uri}
		 *
		 * It is 'null' if the query hasn't been set, which is different than an
		 * empty query (eg. '/path/?' instead of '/path/')
		 */
		public abstract GLib.HashTable<string,string>? query { get; }
		/**
		 * Request URI.
		 *
		 * The URI, protocol and HTTP query and other request information is
		 * made available through this property.
		 */
		public abstract Soup.URI uri { get; }
	}
	/**
	 * Response representing a request resource.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.1")]
	public abstract class Response : GLib.Object {
		/**
		 * Placeholder for the response body.
		 */
		[Version (experimental = true, since = "0.3")]
		protected GLib.OutputStream? _body;
		public Response ();
		/**
		 * Append a buffer into the response body, writting the head beforehand
		 * and flushing data immediatly.
		 *
		 * Unless the 'Transport-Encoding' header is explicitly set to 'chunked',
		 * the response encoding is marked with {@link Soup.Encoding.EOF}.
		 */
		[Version (since = "0.3")]
		public bool append (uint8[] buffer, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public async bool append_async (uint8[] buffer, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public bool append_bytes (GLib.Bytes buffer, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public async bool append_bytes_async (GLib.Bytes buffer, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public bool append_utf8 (string buffer, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public async bool append_utf8_async (string buffer, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Apply a converter to the response body.
		 *
		 * If the payload is chunked, (eg. 'Transfer-Encoding: chunked') and the
		 * new content length is undetermined, it will remain chunked.
		 *
		 * @param converter      converter to stack on the response body
		 * @param content_length resulting value for the 'Content-Length' header
		 *                       or '-1' if the length is undetermined
		 */
		[Version (since = "0.3")]
		public void convert (GLib.Converter converter, int64 content_length = -1);
		/**
		 * Write the head before disposing references to other objects.
		 */
		public override void dispose ();
		/**
		 * End the response properly, writting the head if missing.
		 */
		[Version (since = "0.3")]
		public bool end (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.3")]
		public async bool end_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Expand a buffer into the response body.
		 *
		 * If the content length can be determine reliably (eg. no
		 * 'Content-Encoding' applied), it will be set as well.
		 *
		 * This function accept empty buffers, which result in an explicit
		 * 'Content-Length: 0' header and an empty payload.
		 */
		[Version (since = "0.3")]
		public virtual bool expand (uint8[] buffer, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.3")]
		public virtual async bool expand_async (uint8[] buffer, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Expand a {@link GLib.Bytes} buffer into the response body.
		 */
		[Version (since = "0.3")]
		public bool expand_bytes (GLib.Bytes bytes, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.3")]
		public async bool expand_bytes_async (GLib.Bytes bytes, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Expand the content of a file into the response body.
		 */
		[Version (since = "0.3")]
		public virtual bool expand_file (GLib.File file, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public virtual async bool expand_file_async (GLib.File file, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public virtual bool expand_stream (GLib.InputStream @in, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Version (since = "0.3")]
		public virtual async bool expand_stream_async (GLib.InputStream @in, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Expand a UTF-8 string into the response body.
		 *
		 * If not set already, the 'charset' parameter of the 'Content-Type'
		 * header will be set to 'UTF-8'. The media type will default to
		 * 'application/octet-stream' if not set already. Use {@link VSGI.Response.expand}
		 * to write data with arbitrairy charset.
		 */
		[Version (since = "0.3")]
		public bool expand_utf8 (string body, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.3")]
		public async bool expand_utf8_async (string body, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null) throws GLib.Error;
		/**
		 * Split the body stream such that anything written to it are written
		 * both in the base stream and the tee stream.
		 */
		[Version (since = "0.3")]
		public void tee (GLib.OutputStream tee_stream);
		/**
		 * Write status line and headers into the connection stream, emitting
		 * 'wrote-status-line' and 'wrote-headers' signals in the process.
		 *
		 * This is invoked automatically when accessing the response body for
		 * the first time and when the response is disposed.
		 *
		 * Once the 'wrote-status-line' has been emmitted, its handler is free
		 * to modify the response headers accordingly.
		 *
		 * Once the 'wrote-headers' has been emmited, its handler may still
		 * apply converter on the body.
		 *
		 * {@link GLib.Once} is used to ensure that this is called only once:
		 * additionnal calls will be simply ignored and 'true' will be returned.
		 *
		 * Even if the write process fails or is cancelled, the head will be
		 * marked as written since further calls cannot save the response.
		 *
		 * Note that even if the head has been written into the connection
		 * stream, it has not been flushed. This is designed to avoid the number
		 * of I/O operations necessary to send the response.
		 *
		 * @param bytes_written number of bytes written in the stream see
		 *                      {@link GLib.OutputStream.write_all}
		 * @return wether the head was effectively written
		 */
		[Version (since = "0.2")]
		public bool write_head (out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.3")]
		public async bool write_head_async (int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null, out size_t bytes_written) throws GLib.Error;
		/**
		 * Send headers to the client.
		 */
		[Version (since = "0.3")]
		protected abstract bool write_headers (Soup.MessageHeaders headers, out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.3")]
		protected virtual async bool write_headers_async (Soup.MessageHeaders headers, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null, out size_t bytes_written) throws GLib.Error;
		/**
		 * Send the status line to the client.
		 */
		[Version (since = "0.3")]
		protected abstract bool write_status_line (Soup.HTTPVersion http_version, uint status, string reason_phrase, out size_t bytes_written, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		[Version (since = "0.3")]
		protected virtual async bool write_status_line_async (Soup.HTTPVersion http_version, uint status, string reason_phrase, int priority = GLib.Priority.DEFAULT, GLib.Cancellable? cancellable = null, out size_t bytes_written) throws GLib.Error;
		/**
		 * Response body.
		 *
		 * The provided stream is safe for transfer encoding and will filter
		 * the stream properly if it's chunked.
		 *
		 * Typically, this would involve appling chunked encoding, buffering,
		 * transparent compression and other kind of filters required by the
		 * implementation.
		 *
		 * For CGI-ish protocols, the server will generally deal with transfer
		 * encoding automatically, so the default implementation is to simply
		 * return the base_stream.
		 */
		[Version (since = "0.2")]
		public virtual GLib.OutputStream body { get; }
		/**
		 * Response cookies extracted from the 'Set-Cookie' header.
		 */
		[Version (since = "0.3")]
		public GLib.SList<Soup.Cookie> cookies { owned get; }
		/**
		 * Tells if the head has been written in the connection
		 * {@link GLib.OutputStream}.
		 *
		 * This property can only be set internally.
		 */
		[Version (since = "0.2")]
		public bool head_written { get; }
		/**
		 * Response headers.
		 */
		public Soup.MessageHeaders headers { get; protected set construct; }
		/**
		 * Response status message.
		 */
		[Version (since = "0.3")]
		public virtual string? reason_phrase { owned get; set; }
		/**
		 * Request to which this response is responding.
		 */
		public VSGI.Request request { get; construct; }
		/**
		 * Response status.
		 */
		public virtual uint status { get; set; }
		/**
		 * Emitted when the headers has been written.
		 */
		[Version (since = "0.3")]
		public signal void wrote_headers (Soup.MessageHeaders headers);
		/**
		 * Emitted when the status line has been written.
		 */
		[Version (since = "0.3")]
		public signal void wrote_status_line (uint status, string reason_phrase);
	}
	/**
	 * Server that feeds a {@link VSGI.Handler} with incoming requests.
	 *
	 * Once you have initialized a Server instance, start it by calling
	 * {@link GLib.Application.run} with the command-line arguments or a set of
	 * predefined arguments.
	 *
	 * The server should be implemented by overriding the
	 * {@link GLib.Application.command_line} signal.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.1")]
	public abstract class Server : GLib.Object {
		public Server ();
		/**
		 * Dispatch the request to the application callback.
		 *
		 * The application must call {@link Response.write_head} at some point.
		 *
		 * Once dispatched, the {@link Response.head_written} property is
		 * expected to be true unless its reference still held somewhere else
		 * and the return value is 'true'.
		 *
		 * @return true if the request and response were dispatched
		 */
		[Version (since = "0.3")]
		protected bool dispatch (VSGI.Request req, VSGI.Response res) throws GLib.Error;
		/**
		 * Dispatch the request asynchronously.
		 *
		 * Note that this is equivalent to calling {@link VSGI.Server.dispatch}
		 * for the moment, but an eventual release with support of asynchronous
		 * delegates would literally yield from the application callback.
		 */
		[Version (since = "0.3")]
		protected async bool dispatch_async (VSGI.Request req, VSGI.Response res) throws GLib.Error;
		/**
		 * Fork the execution.
		 *
		 * This is typically called after {@link VSGI.Server.listen} such that
		 * workers can share listening interfaces and descriptors.
		 *
		 * The default implementation wraps {@link Posix.fork} and check its
		 * return value. To disable forking, simply override this and return
		 * '0'.
		 *
		 * Marked as experimental because we might change this for a more
		 * sophisticated model based in {@link GLib.Subprocess} in the future.
		 *
		 * @throws GLib.SpawnError.FORK if the {@link Posix.fork} call fails
		 *
		 * @return the process pid if this is the parent process,
		 *         otherwise '0'
		 */
		[Version (experimental = true, since = "0.3")]
		public virtual GLib.Pid fork () throws GLib.Error;
		/**
		 * Prepare the server for listening on the provided socket address.
		 *
		 * Once the {@link GLib.MainLoop} is started, the server should start
		 * accepting incoming connections.
		 *
		 * @param address a {@link GLib.SocketAddress} or 'null' to listen on
		 *                the default interface
		 *
		 * @throws GLib.IOError.NOT_SUPPORTED if the server does not support
		 *                                    listening on the provided address
		 */
		[Version (since = "0.3")]
		public abstract void listen (GLib.SocketAddress? address = null) throws GLib.Error;
		/**
		 * Prepare the server for listening on the provided socket.
		 *
		 * Once the {@link GLib.MainLoop} is started, the server should start
		 * accepting incoming connections.
		 *
		 * @throws GLib.IOError.NOT_SUPPORTED if the server does not support
		 *                                    listening on the provided address
		 */
		[Version (since = "0.3")]
		public abstract void listen_socket (GLib.Socket socket) throws GLib.Error;
		/**
		 * Instantiate a new {@link VSGI.Server} with varidic arguments.
		 */
		[Version (since = "0.3")]
		public static new VSGI.Server? @new (string name, ...);
		/**
		 * Instantiate a new {@link VSGI.Server} instance.
		 *
		 * If the 'VSGI_SERVER_PATH' environment variable is set, it will used
		 * instead of the default system path.
		 *
		 * For a more fine-grained control, use {@link VSGI.ServerModule}.
		 *
		 * @param name name of the server implementation to load
		 * @param list arguments to pass to {@link GLib.Object.new_valist}
		 *
		 * @return the server instance of loaded successfully, otherwise 'null'
		 *         and a critical will be emitted
		 */
		[Version (since = "0.3")]
		public static new VSGI.Server? new_valist (string name, va_list list);
		/**
		 * Create a new {@link VSGI.Application} that cushion the execution of
		 * this server.
		 */
		[Version (since = "0.3")]
		public int run (string[] args = new string[0] { });
		/**
		 * Stop accepting new connections.
		 */
		[Version (since = "0.3")]
		public abstract void stop ();
		/**
		 * Handler processing incoming connections.
		 */
		[Version (since = "0.3")]
		public VSGI.Handler handler { get; set construct; }
		/**
		 * URIs this server is listening on.
		 */
		[Version (since = "0.3")]
		public abstract GLib.SList<Soup.URI> uris { owned get; }
	}
	/**
	 * Load custom {@link VSGI.Server} implementations.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public class ServerModule : GLib.TypeModule {
		public ServerModule (string? directory, string name);
		public override bool load ();
		public override void unload ();
		/**
		 * The directory from which the shared library will be searched, or 'null'
		 * to search in standard locations.
		 */
		public string? directory { get; construct; }
		/**
		 * The name of the server implementation.
		 */
		public string name { get; construct; }
		/**
		 * Path from which the module is loaded.
		 */
		public string path { get; construct; }
		/**
		 * Once loaded, this contain the type of the {@link VSGI.Server} provided
		 * by this.
		 */
		public GLib.Type server_type { get; private set; }
	}
	/**
	 * Base for implementing a server upon {@link GLib.SocketService}.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public abstract class SocketServer : VSGI.Server {
		public SocketServer ();
		/**
		 * Dispatch an incoming socket connection.
		 */
		protected abstract bool incoming (GLib.SocketConnection connection);
		public override void listen (GLib.SocketAddress? address = null) throws GLib.Error;
		public override void listen_socket (GLib.Socket socket) throws GLib.Error;
		public override void stop ();
		[Description (blurb = "Listen queue depth used in the listen() call")]
		public int backlog { get; construct; }
		/**
		 * Scheme used for generated listening {@link Soup.URI}.
		 */
		protected abstract string scheme { get; }
		public override GLib.SList<Soup.URI> uris { owned get; }
	}
	/**
	 * Pipe data into a base and a tee streams, similarly to the UNIX 'tee' utility.
	 *
	 * The base stream is always priviledged: it is always written and closed first.
	 * Also, The best is done to replicate the written data into the tee stream,
	 * erroring only if everything has been attempted. The tee operations are not
	 * cancellable.
	 */
	[CCode (cheader_filename = "vsgi.h")]
	[Version (since = "0.3")]
	public class TeeOutputStream : GLib.FilterOutputStream {
		public TeeOutputStream (GLib.OutputStream base_stream, GLib.OutputStream tee_stream);
		public override bool close (GLib.Cancellable? cancellable = null) throws GLib.IOError;
		public override ssize_t write (uint8[] buffer, GLib.Cancellable? cancellable = null) throws GLib.IOError;
		public GLib.OutputStream tee_stream { get; construct; }
	}
	[CCode (cheader_filename = "vsgi.h", has_target = false)]
	[Version (since = "0.3")]
	public delegate GLib.Type HandlerInitFunc (GLib.TypeModule type_module);
	[CCode (cheader_filename = "vsgi.h", has_target = false)]
	[Version (since = "0.3")]
	public delegate GLib.Type ServerInitFunc (GLib.TypeModule module);
}
