/* gee.vapi generated by valac, do not modify. */

namespace Vala {
	/**
	 * Arrays of arbitrary elements which grow automatically as elements are added.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public class ArrayList<G> : Vala.List<G> {
		public ArrayList (GLib.EqualFunc equal_func = GLib.direct_equal);
		public override bool add (G item);
		public override void clear ();
		public override bool contains (G item);
		public override G @get (int index);
		public override GLib.Type get_element_type ();
		public override int index_of (G item);
		public override void insert (int index, G item);
		public override Vala.Iterator<G> iterator ();
		public override bool remove (G item);
		public override void remove_at (int index);
		public override void @set (int index, G item);
		public GLib.EqualFunc equal_func { set; }
		public override int size { get; }
	}
	/**
	 * Serves as the base interface for implementing collection classes. Defines
	 * size, iteration, and modification methods.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Collection<G> : Vala.Iterable<G> {
		public Collection ();
		/**
		 * Adds an item to this collection. Must not be called on read-only
		 * collections.
		 *
		 * @param item the item to add to the collection
		 *
		 * @return     true if the collection has been changed, false otherwise
		 */
		public abstract bool add (G item);
		/**
		 * Removes all items from this collection. Must not be called on
		 * read-only collections.
		 */
		public abstract void clear ();
		/**
		 * Determines whether this collection contains the specified item.
		 *
		 * @param item the item to locate in the collection
		 *
		 * @return     true if item is found, false otherwise
		 */
		public abstract bool contains (G item);
		/**
		 * Removes the first occurrence of an item from this collection. Must not
		 * be called on read-only collections.
		 *
		 * @param item the item to remove from the collection
		 *
		 * @return     true if the collection has been changed, false otherwise
		 */
		public abstract bool remove (G item);
		/**
		 * The number of items in this collection.
		 */
		public abstract int size { get; }
	}
	/**
	 * Hashtable implementation of the Map interface.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public class HashMap<K,V> : Vala.Map<K,V> {
		public HashMap (GLib.HashFunc key_hash_func = GLib.direct_hash, GLib.EqualFunc key_equal_func = GLib.direct_equal, GLib.EqualFunc value_equal_func = GLib.direct_equal);
		public override void clear ();
		public override bool contains (K key);
		public override V @get (K key);
		public override Vala.Set<K> get_keys ();
		public override Vala.Collection<V> get_values ();
		public override Vala.MapIterator<K,V> map_iterator ();
		public override bool remove (K key);
		public override void @set (K key, V value);
		public GLib.EqualFunc key_equal_func { set; }
		public GLib.HashFunc key_hash_func { set; }
		public override int size { get; }
		public GLib.EqualFunc value_equal_func { set; }
	}
	/**
	 * Hashtable implementation of the Set interface.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public class HashSet<G> : Vala.Set<G> {
		public HashSet (GLib.HashFunc hash_func = GLib.direct_hash, GLib.EqualFunc equal_func = GLib.direct_equal);
		public override bool add (G key);
		public override void clear ();
		public override bool contains (G key);
		public override GLib.Type get_element_type ();
		public override Vala.Iterator<G> iterator ();
		public override bool remove (G key);
		public GLib.EqualFunc equal_func { set; }
		public GLib.HashFunc hash_func { set; }
		public override int size { get; }
	}
	/**
	 * Implemented by classes that support a simple iteration over instances of the
	 * collection.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Iterable<G> {
		public Iterable ();
		public abstract GLib.Type get_element_type ();
		/**
		 * Returns a Iterator that can be used for simple iteration over a
		 * collection.
		 *
		 * @return a Iterator that can be used for simple iteration over a
		 *         collection
		 */
		public abstract Vala.Iterator<G> iterator ();
	}
	/**
	 * Implemented by classes that support a simple iteration over instances of the
	 * collection.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Iterator<G> {
		public Iterator ();
		/**
		 * Returns the current element in the iteration.
		 *
		 * @return the current element in the iteration
		 */
		public abstract G @get ();
		/**
		 * Advances to the next element in the iteration.
		 *
		 * @return true if the iterator has a next element
		 */
		public abstract bool next ();
	}
	/**
	 * Represents a collection of items in a well-defined order.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public abstract class List<G> : Vala.Collection<G> {
		public List ();
		/**
		 * Returns the item at the specified index in this list.
		 *
		 * @param index zero-based index of the item to be returned
		 *
		 * @return      the item at the specified index in the list
		 */
		public abstract G @get (int index);
		/**
		 * Returns the index of the first occurrence of the specified item in
		 * this list.
		 *
		 * @return the index of the first occurrence of the specified item, or
		 *         -1 if the item could not be found
		 */
		public abstract int index_of (G item);
		/**
		 * Inserts an item into this list at the specified position.
		 *
		 * @param index zero-based index at which item is inserted
		 * @param item  item to insert into the list
		 */
		public abstract void insert (int index, G item);
		/**
		 * Removes the item at the specified index of this list.
		 *
		 * @param index zero-based index of the item to be removed
		 */
		public abstract void remove_at (int index);
		/**
		 * Sets the item at the specified index in this list.
		 *
		 * @param index zero-based index of the item to be set
		 */
		public abstract void @set (int index, G item);
	}
	/**
	 * A map is a generic collection of key/value pairs.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Map<K,V> {
		public Map ();
		/**
		 * Removes all items from this collection. Must not be called on
		 * read-only collections.
		 */
		public abstract void clear ();
		/**
		 * Determines whether this map contains the specified key.
		 *
		 * @param key the key to locate in the map
		 *
		 * @return    true if key is found, false otherwise
		 */
		public abstract bool contains (K key);
		/**
		 * Returns the value of the specified key in this map.
		 *
		 * @param key the key whose value is to be retrieved
		 *
		 * @return    the value associated with the key, or null if the key
		 *            couldn't be found
		 */
		public abstract V @get (K key);
		/**
		 * Returns the keys of this map as a read-only set.
		 *
		 * @return the keys of the map
		 */
		public abstract Vala.Set<K> get_keys ();
		/**
		 * Returns the values of this map as a read-only collection.
		 *
		 * @return the values of the map
		 */
		public abstract Vala.Collection<V> get_values ();
		/**
		 * Returns a Iterator that can be used for simple iteration over a
		 * map.
		 *
		 * @return a Iterator that can be used for simple iteration over a
		 *         map
		 */
		public abstract Vala.MapIterator<K,V> map_iterator ();
		/**
		 * Removes the specified key from this map.
		 *
		 * @param key the key to remove from the map
		 *
		 * @return    true if the map has been changed, false otherwise
		 */
		public abstract bool remove (K key);
		/**
		 * Inserts a new key and value into this map.
		 *
		 * @param key   the key to insert
		 * @param value the value to associate with the key
		 */
		public abstract void @set (K key, V value);
		/**
		 * The number of items in this map.
		 */
		public abstract int size { get; }
	}
	/**
	 * An iterator over a map.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public abstract class MapIterator<K,V> {
		public MapIterator ();
		/**
		 * Returns the current key in the iteration.
		 *
		 * @return the current key in the iteration
		 */
		public abstract K get_key ();
		/**
		 * Returns the current value in the iteration.
		 *
		 * @return the current value in the iteration
		 */
		public abstract V get_value ();
		/**
		 * Advances to the next element in the iteration.
		 *
		 * @return true if the iterator has a next element
		 */
		public abstract bool next ();
	}
	/**
	 * A set is a collection without duplicates.
	 */
	[CCode (cheader_filename = "valagee.h")]
	public abstract class Set<G> : Vala.Collection<G> {
		public Set ();
	}
}
/* ccode.vapi generated by valac, do not modify. */

namespace Vala {
	/**
	 * Represents an assignment expression in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeAssignment : Vala.CCodeExpression {
		public CCodeAssignment (Vala.CCodeExpression l, Vala.CCodeExpression r, Vala.CCodeAssignmentOperator op = CCodeAssignmentOperator.SIMPLE);
		public override void write (Vala.CCodeWriter writer);
		public override void write_inner (Vala.CCodeWriter writer);
		/**
		 * Left hand side of the assignment.
		 */
		public Vala.CCodeExpression left { get; set; }
		/**
		 * Assignment operator.
		 */
		public Vala.CCodeAssignmentOperator operator { get; set; }
		/**
		 * Right hand side of the assignment.
		 */
		public Vala.CCodeExpression right { get; set; }
	}
	/**
	 * Represents an expression with two operands in C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeBinaryExpression : Vala.CCodeExpression {
		public CCodeBinaryExpression (Vala.CCodeBinaryOperator op, Vala.CCodeExpression l, Vala.CCodeExpression r);
		public override void write (Vala.CCodeWriter writer);
		public override void write_inner (Vala.CCodeWriter writer);
		/**
		 * The left operand.
		 */
		public Vala.CCodeExpression left { get; set; }
		/**
		 * The binary operator.
		 */
		public Vala.CCodeBinaryOperator operator { get; set; }
		/**
		 * The right operand.
		 */
		public Vala.CCodeExpression right { get; set; }
	}
	/**
	 * Represents a C code block.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeBlock : Vala.CCodeStatement {
		public CCodeBlock ();
		/**
		 * Append the specified statement to the list of statements.
		 */
		public void add_statement (Vala.CCodeNode statement);
		/**
		 * Prepend the specified statement to the list of statements.
		 */
		public void prepend_statement (Vala.CCodeNode statement);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * Specifies whether a newline at the end of the block should be
		 * suppressed.
		 */
		public bool suppress_newline { get; set; }
	}
	/**
	 * Represents a break statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeBreakStatement : Vala.CCodeStatement {
		public CCodeBreakStatement ();
		public override void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a case block in a switch statement in C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeCaseStatement : Vala.CCodeStatement {
		public CCodeCaseStatement (Vala.CCodeExpression expression);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The case expression.
		 */
		public Vala.CCodeExpression expression { get; set; }
	}
	/**
	 * Represents a type cast in the generated C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeCastExpression : Vala.CCodeExpression {
		public CCodeCastExpression (Vala.CCodeExpression expr, string type);
		public override void write (Vala.CCodeWriter writer);
		public override void write_inner (Vala.CCodeWriter writer);
		/**
		 * The expression to be cast.
		 */
		public Vala.CCodeExpression inner { get; set; }
		/**
		 * The target type.
		 */
		public string type_name { get; set; }
	}
	/**
	 * Represents a comma separated expression list in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeCommaExpression : Vala.CCodeExpression {
		public CCodeCommaExpression ();
		/**
		 * Appends the specified expression to the expression list.
		 *
		 * @param expr a C code expression
		 */
		public void append_expression (Vala.CCodeExpression expr);
		public Vala.List<Vala.CCodeExpression> get_inner ();
		public void set_expression (int index, Vala.CCodeExpression expr);
		public override void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a comment in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeComment : Vala.CCodeNode {
		public CCodeComment (string _text);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The text content of the comment.
		 */
		public string text { get; set; }
	}
	/**
	 * Represents a conditional expression in C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeConditionalExpression : Vala.CCodeExpression {
		public CCodeConditionalExpression (Vala.CCodeExpression cond, Vala.CCodeExpression true_expr, Vala.CCodeExpression false_expr);
		public override void write (Vala.CCodeWriter writer);
		public override void write_inner (Vala.CCodeWriter writer);
		/**
		 * The condition.
		 */
		public Vala.CCodeExpression condition { get; set; }
		/**
		 * The expression to be evaluated if the condition doesn't hold.
		 */
		public Vala.CCodeExpression false_expression { get; set; }
		/**
		 * The expression to be evaluated if the condition holds.
		 */
		public Vala.CCodeExpression true_expression { get; set; }
	}
	/**
	 * A constant C expression.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeConstant : Vala.CCodeExpression {
		public CCodeConstant (global::string _name);
		public CCodeConstant.string (global::string _name);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The name of this constant.
		 */
		public global::string name { get; set; }
	}
	/**
	 * Represents a continue statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeContinueStatement : Vala.CCodeStatement {
		public CCodeContinueStatement ();
		public override void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a local variable declaration in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeDeclaration : Vala.CCodeStatement {
		public CCodeDeclaration (string type_name);
		/**
		 * Adds the specified declarator to this declaration.
		 *
		 * @param decl a declarator
		 */
		public void add_declarator (Vala.CCodeDeclarator decl);
		public override void write (Vala.CCodeWriter writer);
		public override void write_declaration (Vala.CCodeWriter writer);
		/**
		 * The declaration modifier.
		 */
		public Vala.CCodeModifiers modifiers { get; set; }
		/**
		 * The type of the local variable.
		 */
		public string type_name { get; set; }
	}
	/**
	 * Represents a variable or function pointer declarator in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public abstract class CCodeDeclarator : Vala.CCodeNode {
		public CCodeDeclarator ();
		/**
		 * Writes initialization statements for this declarator with the
		 * specified C code writer if necessary.
		 *
		 * @param writer a C code writer
		 */
		public virtual void write_initialization (Vala.CCodeWriter writer);
	}
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeDeclaratorSuffix {
		public bool array;
		public Vala.CCodeExpression? array_length;
		public bool deprecated;
		public CCodeDeclaratorSuffix ();
		public CCodeDeclaratorSuffix.with_array (Vala.CCodeExpression? array_length = null);
		public void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a do iteration statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeDoStatement : Vala.CCodeStatement {
		public CCodeDoStatement (Vala.CCodeStatement stmt, Vala.CCodeExpression cond);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The loop body.
		 */
		public Vala.CCodeStatement body { get; set; }
		/**
		 * The loop condition.
		 */
		public Vala.CCodeExpression condition { get; set; }
	}
	/**
	 * Represents an access to an array member in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeElementAccess : Vala.CCodeExpression {
		public CCodeElementAccess (Vala.CCodeExpression cont, Vala.CCodeExpression i);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * Expression representing the container on which we want to access.
		 */
		public Vala.CCodeExpression container { get; set; }
		/**
		 * Expression representing the index we want to access inside the
		 * container.
		 */
		public Vala.CCodeExpression index { get; set; }
	}
	/**
	 * Represents an empty statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeEmptyStatement : Vala.CCodeStatement {
		public CCodeEmptyStatement ();
		public override void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents an enum in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeEnum : Vala.CCodeNode {
		public CCodeEnum (string? name = null);
		/**
		 * Adds the specified value to this enum.
		 *
		 * @param value optional numerical value
		 */
		public void add_value (Vala.CCodeEnumValue value);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * Whether the enum is deprecated.
		 */
		public bool deprecated { get; set; }
		/**
		 * The name of this enum.
		 */
		public string name { get; set; }
	}
	/**
	 * Represents an enum value in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeEnumValue : Vala.CCodeNode {
		public CCodeEnumValue (string name, Vala.CCodeExpression? value = null);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * Whether this enum value is deprecated.
		 */
		public bool deprecated { get; set; }
		/**
		 * The name of this enum value.
		 */
		public string name { get; set; }
		/**
		 * The numerical representation of this enum value.
		 */
		public Vala.CCodeExpression? value { get; set; }
	}
	/**
	 * Represents an expression node in the C code tree.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public abstract class CCodeExpression : Vala.CCodeNode {
		public CCodeExpression ();
		public virtual void write_inner (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a C code statement that evaluates a given expression.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeExpressionStatement : Vala.CCodeStatement {
		public CCodeExpressionStatement (Vala.CCodeExpression expr);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The expression to evaluate.
		 */
		public Vala.CCodeExpression expression { get; set; }
	}
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeFile {
		public CCodeFile ();
		public void add_comment (Vala.CCodeComment comment);
		public void add_constant_declaration (Vala.CCodeNode node);
		public bool add_declaration (string name);
		public void add_function (Vala.CCodeFunction func);
		public void add_function_declaration (Vala.CCodeFunction func);
		public void add_include (string filename, bool local = false);
		public void add_type_declaration (Vala.CCodeNode node);
		public void add_type_definition (Vala.CCodeNode node);
		public void add_type_member_declaration (Vala.CCodeNode node);
		public void add_type_member_definition (Vala.CCodeNode node);
		public Vala.List<string> get_symbols ();
		public bool store (string filename, string? source_filename, bool write_version, bool line_directives, string? begin_decls = null, string? end_decls = null);
		public bool is_header { get; set; }
	}
	/**
	 * Represents a for iteration statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeForStatement : Vala.CCodeStatement {
		public CCodeForStatement (Vala.CCodeExpression? condition, Vala.CCodeStatement? body = null);
		/**
		 * Appends the specified expression to the list of initializers.
		 *
		 * @param expr an initializer expression
		 */
		public void add_initializer (Vala.CCodeExpression expr);
		/**
		 * Appends the specified expression to the iterator.
		 *
		 * @param expr an iterator expression
		 */
		public void add_iterator (Vala.CCodeExpression expr);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The loop body.
		 */
		public Vala.CCodeStatement body { get; set; }
		/**
		 * The loop condition.
		 */
		public Vala.CCodeExpression? condition { get; set; }
	}
	/**
	 * Represents a container for C code nodes.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeFragment : Vala.CCodeNode {
		public CCodeFragment ();
		/**
		 * Appends the specified code node to this code fragment.
		 *
		 * @param node a C code node
		 */
		public void append (Vala.CCodeNode node);
		/**
		 * Returns a copy of the list of children.
		 *
		 * @return children list
		 */
		public Vala.List<Vala.CCodeNode> get_children ();
		public override void write (Vala.CCodeWriter writer);
		public override void write_combined (Vala.CCodeWriter writer);
		public override void write_declaration (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a function declaration in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeFunction : Vala.CCodeNode {
		public CCodeFunction (string name, string return_type = "void");
		public void add_assignment (Vala.CCodeExpression left, Vala.CCodeExpression right);
		public void add_break ();
		public void add_case (Vala.CCodeExpression expression);
		public void add_continue ();
		public void add_declaration (string type_name, Vala.CCodeDeclarator declarator, Vala.CCodeModifiers modifiers = 0);
		public void add_default ();
		public void add_else ();
		public void add_expression (Vala.CCodeExpression expression);
		public void add_goto (string target);
		public void add_label (string label);
		/**
		 * Appends the specified parameter to the list of function parameters.
		 *
		 * @param param a formal parameter
		 */
		public void add_parameter (Vala.CCodeParameter param);
		public void add_return (Vala.CCodeExpression? expression = null);
		public void add_statement (Vala.CCodeNode stmt);
		public void close ();
		/**
		 * Returns a copy of this function.
		 *
		 * @return copied function
		 */
		public Vala.CCodeFunction copy ();
		public void else_if (Vala.CCodeExpression condition);
		public Vala.CCodeParameter get_parameter (int position);
		public int get_parameter_count ();
		public void insert_parameter (int position, Vala.CCodeParameter param);
		public void open_block ();
		public void open_for (Vala.CCodeExpression? initializer, Vala.CCodeExpression condition, Vala.CCodeExpression? iterator);
		public void open_if (Vala.CCodeExpression condition);
		public void open_switch (Vala.CCodeExpression expression);
		public void open_while (Vala.CCodeExpression condition);
		public override void write (Vala.CCodeWriter writer);
		public string attributes { get; set; }
		/**
		 * The function body.
		 */
		public Vala.CCodeBlock block { get; set; }
		/**
		 * The current line directive.
		 */
		public Vala.CCodeLineDirective current_line { get; set; }
		public bool is_declaration { get; set; }
		/**
		 * The function modifiers.
		 */
		public Vala.CCodeModifiers modifiers { get; set; }
		/**
		 * The name of this function.
		 */
		public string name { get; set; }
		/**
		 * The function return type.
		 */
		public string return_type { get; set; }
	}
	/**
	 * Represents a function call in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeFunctionCall : Vala.CCodeExpression {
		public CCodeFunctionCall (Vala.CCodeExpression? call = null);
		/**
		 * Appends the specified expression to the list of arguments.
		 *
		 * @param expr a C code expression
		 */
		public void add_argument (Vala.CCodeExpression expr);
		/**
		 * Returns a copy of the list of arguments.
		 *
		 * @return list of arguments
		 */
		public Vala.List<Vala.CCodeExpression> get_arguments ();
		public void insert_argument (int index, Vala.CCodeExpression expr);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The function to be called.
		 */
		public Vala.CCodeExpression? call { get; set; }
	}
	/**
	 * Represents a function pointer declarator in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeFunctionDeclarator : Vala.CCodeDeclarator {
		public CCodeFunctionDeclarator (string name);
		/**
		 * Appends the specified parameter to the list of function parameters.
		 *
		 * @param param a formal parameter
		 */
		public void add_parameter (Vala.CCodeParameter param);
		public override void write (Vala.CCodeWriter writer);
		public override void write_declaration (Vala.CCodeWriter writer);
		/**
		 * The declarator name.
		 */
		public string name { get; set; }
	}
	/**
	 * Represents a goto statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeGotoStatement : Vala.CCodeStatement {
		public CCodeGotoStatement (string name);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The name of the target label.
		 */
		public string name { get; set; }
	}
	/**
	 * Represents a identifier in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeIdentifier : Vala.CCodeExpression {
		public CCodeIdentifier (string _name);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The name of this identifier.
		 */
		public string name { get; set; }
	}
	/**
	 * Represents a section that should be processed on condition.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeIfSection : Vala.CCodeFragment {
		public CCodeIfSection (string expr);
		public override void write (Vala.CCodeWriter writer);
		public override void write_declaration (Vala.CCodeWriter writer);
		/**
		 * The expression
		 */
		public string expression { get; set; }
	}
	/**
	 * Represents an if selection statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeIfStatement : Vala.CCodeStatement {
		public CCodeIfStatement (Vala.CCodeExpression cond, Vala.CCodeStatement true_stmt, Vala.CCodeStatement? false_stmt = null);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The boolean condition to evaluate.
		 */
		public Vala.CCodeExpression condition { get; set; }
		/**
		 * Specifies whether this if statement is part of an else if statement.
		 * This only affects the output formatting.
		 */
		public bool else_if { get; set; }
		/**
		 * The optional statement to be evaluated if the condition doesn't hold.
		 */
		public Vala.CCodeStatement? false_statement { get; set; }
		/**
		 * The statement to be evaluated if the condition holds.
		 */
		public Vala.CCodeStatement true_statement { get; set; }
	}
	/**
	 * Represents an include preprocessor directive in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeIncludeDirective : Vala.CCodeNode {
		public CCodeIncludeDirective (string _filename, bool _local = false);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The file to be included.
		 */
		public string filename { get; set; }
		/**
		 * Specifies whether the specified file should be searched in the local
		 * directory.
		 */
		public bool local { get; set; }
	}
	/**
	 * Represents a struct or array initializer list in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeInitializerList : Vala.CCodeExpression {
		public CCodeInitializerList ();
		/**
		 * Appends the specified expression to this initializer list.
		 *
		 * @param expr an expression
		 */
		public void append (Vala.CCodeExpression expr);
		public override void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents an invalid expression.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeInvalidExpression : Vala.CCodeExpression {
		public CCodeInvalidExpression ();
		public override void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a label declaration in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeLabel : Vala.CCodeStatement {
		public CCodeLabel (string name);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The name of this label.
		 */
		public string name { get; set; }
	}
	/**
	 * Represents a line directive in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeLineDirective : Vala.CCodeNode {
		public CCodeLineDirective (string _filename, int _line);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The name of the source file to be presumed.
		 */
		public string filename { get; set; }
		/**
		 * The line number in the source file to be presumed.
		 */
		public int line_number { get; set; }
	}
	/**
	 * Represents a preprocessor macro replacement definition in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeMacroReplacement : Vala.CCodeNode {
		public CCodeMacroReplacement (string name, string replacement);
		public CCodeMacroReplacement.with_expression (string name, Vala.CCodeExpression replacement_expression);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The name of this macro.
		 */
		public string name { get; set; }
		/**
		 * The replacement of this macro.
		 */
		public string replacement { get; set; }
		/**
		 * The replacement expression of this macro.
		 */
		public Vala.CCodeExpression replacement_expression { get; set; }
	}
	/**
	 * Represents an access to a struct member in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeMemberAccess : Vala.CCodeExpression {
		public CCodeMemberAccess (Vala.CCodeExpression container, string member, bool pointer = false);
		public CCodeMemberAccess.pointer (Vala.CCodeExpression container, string member);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The parent of the member.
		 */
		public Vala.CCodeExpression inner { get; set; }
		/**
		 * Specifies whether the member access happens by pointer dereferencing.
		 */
		public bool is_pointer { get; set; }
		/**
		 * The name of the member.
		 */
		public string member_name { get; set; }
	}
	/**
	 * Represents a line break in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeNewline : Vala.CCodeNode {
		public CCodeNewline ();
		public override void write (Vala.CCodeWriter writer);
	}
	/**
	 * Represents a node in the C code tree.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public abstract class CCodeNode {
		public CCodeNode ();
		/**
		 * Writes this code node and all children with the specified C code
		 * writer.
		 *
		 * @param writer a C code writer
		 */
		public abstract void write (Vala.CCodeWriter writer);
		/**
		 * Writes declaration and implementation combined for this code node and
		 * all children with the specified C code writer.
		 *
		 * @param writer a C code writer
		 */
		public virtual void write_combined (Vala.CCodeWriter writer);
		/**
		 * Writes declaration for this code node with the specified C code
		 * writer if necessary.
		 *
		 * @param writer a C code writer
		 */
		public virtual void write_declaration (Vala.CCodeWriter writer);
		/**
		 * The source file name and line number to be presumed for this code
		 * node.
		 */
		public Vala.CCodeLineDirective line { get; set; }
	}
	/**
	 * Represents a section that should only to processed once.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeOnceSection : Vala.CCodeFragment {
		public CCodeOnceSection (string def);
		public override void write (Vala.CCodeWriter writer);
		public override void write_declaration (Vala.CCodeWriter writer);
		/**
		 * The name of the guarding define.
		 */
		public string define { get; set; }
	}
	/**
	 * Represents a formal parameter in a C method signature.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeParameter : Vala.CCodeNode {
		public CCodeParameter (string n, string type);
		public CCodeParameter.with_ellipsis ();
		public override void write (Vala.CCodeWriter writer);
		/**
		 * Specifies whether the function accepts an indefinite number of
		 * arguments.
		 */
		public bool ellipsis { get; set; }
		/**
		 * The parameter name.
		 */
		public string name { get; set; }
		/**
		 * The parameter type.
		 */
		public string type_name { get; set; }
	}
	/**
	 * Represents a parenthesized expression in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeParenthesizedExpression : Vala.CCodeExpression {
		public CCodeParenthesizedExpression (Vala.CCodeExpression expr);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The expression in the parenthesis.
		 */
		public Vala.CCodeExpression inner { get; set; }
	}
	/**
	 * Represents a return statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeReturnStatement : Vala.CCodeStatement {
		public CCodeReturnStatement (Vala.CCodeExpression? expr = null);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The optional expression to return.
		 */
		public Vala.CCodeExpression? return_expression { get; set; }
	}
	/**
	 * Represents a statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public abstract class CCodeStatement : Vala.CCodeNode {
		public CCodeStatement ();
	}
	/**
	 * Represents a struct declaration in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeStruct : Vala.CCodeNode {
		public CCodeStruct (string name);
		/**
		 * Adds the specified declaration as member to this struct.
		 *
		 * @param decl a variable declaration
		 */
		public void add_declaration (Vala.CCodeDeclaration decl);
		/**
		 * Adds a variable with the specified type and name to this struct.
		 *
		 * @param type_name field type
		 * @param name      member name
		 */
		public void add_field (string type_name, string name, Vala.CCodeDeclaratorSuffix? declarator_suffix = null);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * Whether the struct is deprecated.
		 */
		public bool deprecated { get; set; }
		public bool is_empty { get; }
		/**
		 * The struct name.
		 */
		public string name { get; set; }
	}
	/**
	 * Represents a switch selection statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeSwitchStatement : Vala.CCodeBlock {
		public CCodeSwitchStatement (Vala.CCodeExpression expression);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The switch expression.
		 */
		public Vala.CCodeExpression expression { get; set; }
	}
	/**
	 * Represents a typedef in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeTypeDefinition : Vala.CCodeNode {
		public CCodeTypeDefinition (string type, Vala.CCodeDeclarator decl);
		public override void write (Vala.CCodeWriter writer);
		public override void write_declaration (Vala.CCodeWriter writer);
		/**
		 * The type declarator.
		 */
		public Vala.CCodeDeclarator declarator { get; set; }
		/**
		 * Whether the type is deprecated.
		 */
		public bool deprecated { get; set; }
		/**
		 * The type name.
		 */
		public string type_name { get; set; }
	}
	/**
	 * Represents an expression with one operand in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeUnaryExpression : Vala.CCodeExpression {
		public CCodeUnaryExpression (Vala.CCodeUnaryOperator op, Vala.CCodeExpression expr);
		public override void write (Vala.CCodeWriter writer);
		public override void write_inner (Vala.CCodeWriter writer);
		/**
		 * The operand.
		 */
		public Vala.CCodeExpression inner { get; set; }
		/**
		 * The unary operator.
		 */
		public Vala.CCodeUnaryOperator operator { get; set; }
	}
	/**
	 * Represents a variable declarator in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeVariableDeclarator : Vala.CCodeDeclarator {
		public CCodeVariableDeclarator (string name, Vala.CCodeExpression? initializer = null, Vala.CCodeDeclaratorSuffix? declarator_suffix = null);
		public override void write (Vala.CCodeWriter writer);
		public override void write_declaration (Vala.CCodeWriter writer);
		public override void write_initialization (Vala.CCodeWriter writer);
		public CCodeVariableDeclarator.zero (string name, Vala.CCodeExpression? initializer, Vala.CCodeDeclaratorSuffix? declarator_suffix = null);
		/**
		 * The optional declarator suffix.
		 */
		public Vala.CCodeDeclaratorSuffix? declarator_suffix { get; set; }
		/**
		 * Initializer only used to zero memory, safe to initialize as part
		 * of declaration at beginning of block instead of separate assignment.
		 */
		public bool init0 { get; set; }
		/**
		 * The optional initializer expression.
		 */
		public Vala.CCodeExpression? initializer { get; set; }
		/**
		 * The variable name.
		 */
		public string name { get; set; }
	}
	/**
	 * Represents a while iteration statement in the C code.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeWhileStatement : Vala.CCodeStatement {
		public CCodeWhileStatement (Vala.CCodeExpression cond, Vala.CCodeStatement? stmt = null);
		public override void write (Vala.CCodeWriter writer);
		/**
		 * The loop body.
		 */
		public Vala.CCodeStatement body { get; set; }
		/**
		 * The loop condition.
		 */
		public Vala.CCodeExpression condition { get; set; }
	}
	/**
	 * Represents a writer to write C source files.
	 */
	[CCode (cheader_filename = "valaccode.h")]
	public class CCodeWriter {
		public CCodeWriter (string filename, string? source_filename = null);
		/**
		 * Closes the file.
		 */
		public void close ();
		/**
		 * Opens the file.
		 *
		 * @return true if the file has been opened successfully,
		 *         false otherwise
		 */
		public bool open (bool write_version);
		/**
		 * Opens a new block, increasing the indent level.
		 */
		public void write_begin_block ();
		/**
		 * Writes the specified text as comment.
		 *
		 * @param text the comment text
		 */
		public void write_comment (string text);
		/**
		 * Closes the current block, decreasing the indent level.
		 */
		public void write_end_block ();
		/**
		 * Writes tabs according to the current indent level.
		 */
		public void write_indent (Vala.CCodeLineDirective? line = null);
		/**
		 * Writes a newline.
		 */
		public void write_newline ();
		/**
		 * Writes the specified string.
		 *
		 * @param s a string
		 */
		public void write_string (string s);
		/**
		 * Specifies whether the output stream is at the beginning of a line.
		 */
		public bool bol { get; }
		/**
		 * Specifies the file to be written.
		 */
		public string filename { get; set; }
		/**
		 * Specifies whether to emit line directives.
		 */
		public bool line_directives { get; set; }
	}
	[CCode (cheader_filename = "valaccode.h")]
	public enum CCodeAssignmentOperator {
		SIMPLE,
		BITWISE_OR,
		BITWISE_AND,
		BITWISE_XOR,
		ADD,
		SUB,
		MUL,
		DIV,
		PERCENT,
		SHIFT_LEFT,
		SHIFT_RIGHT
	}
	[CCode (cheader_filename = "valaccode.h")]
	public enum CCodeBinaryOperator {
		PLUS,
		MINUS,
		MUL,
		DIV,
		MOD,
		SHIFT_LEFT,
		SHIFT_RIGHT,
		LESS_THAN,
		GREATER_THAN,
		LESS_THAN_OR_EQUAL,
		GREATER_THAN_OR_EQUAL,
		EQUALITY,
		INEQUALITY,
		BITWISE_AND,
		BITWISE_OR,
		BITWISE_XOR,
		AND,
		OR
	}
	[CCode (cheader_filename = "valaccode.h")]
	[Flags]
	public enum CCodeModifiers {
		NONE,
		STATIC,
		REGISTER,
		EXTERN,
		INLINE,
		VOLATILE,
		DEPRECATED,
		THREAD_LOCAL,
		INTERNAL
	}
	[CCode (cheader_filename = "valaccode.h")]
	public enum CCodeUnaryOperator {
		PLUS,
		MINUS,
		LOGICAL_NEGATION,
		BITWISE_COMPLEMENT,
		POINTER_INDIRECTION,
		ADDRESS_OF,
		PREFIX_INCREMENT,
		PREFIX_DECREMENT,
		POSTFIX_INCREMENT,
		POSTFIX_DECREMENT
	}
}
/* vala.vapi generated by valac, do not modify. */

namespace Vala {
	namespace Genie {
		/**
		 * Code visitor parsing all Genie source files.
		 */
		[CCode (cheader_filename = "vala.h")]
		public class Parser : Vala.CodeVisitor {
			public Parser ();
			/**
			 * Parses all .gs source files in the specified code context and
			 * builds a code tree.
			 *
			 * @param context a code context
			 */
			public void parse (Vala.CodeContext context);
			public void parse_file (Vala.SourceFile source_file);
			public override void visit_source_file (Vala.SourceFile source_file);
		}
		/**
		 * Lexical scanner for Genie source files.
		 */
		[CCode (cheader_filename = "vala.h")]
		public class Scanner {
			public Scanner (Vala.SourceFile source_file);
			public static Vala.Genie.TokenType get_identifier_or_keyword (char* begin, int len);
			public void parse_file_comments ();
			/**
			 * Clears and returns the content of the comment stack.
			 *
			 * @return saved comment
			 */
			public Vala.Comment? pop_comment ();
			public Vala.Genie.TokenType read_regex_token (out Vala.SourceLocation token_begin, out Vala.SourceLocation token_end);
			public Vala.Genie.TokenType read_template_token (out Vala.SourceLocation token_begin, out Vala.SourceLocation token_end);
			public Vala.Genie.TokenType read_token (out Vala.SourceLocation token_begin, out Vala.SourceLocation token_end);
			public void seek (Vala.SourceLocation location);
			public int indent_spaces { get; set; }
			public Vala.SourceFile source_file { get; private set; }
		}
		[CCode (cheader_filename = "vala.h")]
		public enum TokenType {
			NONE,
			ABSTRACT,
			ARRAY,
			AS,
			ASSERT,
			ASSIGN,
			ASSIGN_ADD,
			ASSIGN_BITWISE_AND,
			ASSIGN_BITWISE_OR,
			ASSIGN_BITWISE_XOR,
			ASSIGN_DIV,
			ASSIGN_MUL,
			ASSIGN_PERCENT,
			ASSIGN_SHIFT_LEFT,
			ASSIGN_SUB,
			ASYNC,
			BITWISE_AND,
			BITWISE_OR,
			BREAK,
			CARRET,
			CASE,
			CHARACTER_LITERAL,
			CLASS,
			CLOSE_BRACE,
			CLOSE_BRACKET,
			CLOSE_PARENS,
			CLOSE_REGEX_LITERAL,
			CLOSE_TEMPLATE,
			COLON,
			COMMA,
			CONST,
			CONSTRUCT,
			CONTINUE,
			DEDENT,
			DEF,
			DEFAULT,
			DELEGATE,
			DELETE,
			DICT,
			DIV,
			DO,
			DOT,
			DOWNTO,
			DYNAMIC,
			ELLIPSIS,
			ELSE,
			ENUM,
			ENSURES,
			ERRORDOMAIN,
			EOF,
			EOL,
			EVENT,
			EXCEPT,
			EXTERN,
			FALSE,
			FINAL,
			FINALLY,
			FOR,
			GET,
			HASH,
			IDENTIFIER,
			IF,
			IMPLEMENTS,
			IN,
			INDENT,
			INIT,
			INLINE,
			INTEGER_LITERAL,
			INTERFACE,
			INTERNAL,
			INTERR,
			IS,
			ISA,
			LAMBDA,
			LIST,
			LOCK,
			MINUS,
			NAMESPACE,
			NEW,
			NULL,
			OF,
			OUT,
			OP_AND,
			OP_DEC,
			OP_EQ,
			OP_GE,
			OP_GT,
			OP_INC,
			OP_LE,
			OP_LT,
			OP_NE,
			OP_NEG,
			OP_OR,
			OP_PTR,
			OP_SHIFT_LEFT,
			OPEN_BRACE,
			OPEN_BRACKET,
			OPEN_PARENS,
			OPEN_REGEX_LITERAL,
			OPEN_TEMPLATE,
			OVERRIDE,
			OWNED,
			PARAMS,
			PASS,
			PERCENT,
			PLUS,
			PRINT,
			PRIVATE,
			PROP,
			PROTECTED,
			PUBLIC,
			RAISE,
			RAISES,
			READONLY,
			REAL_LITERAL,
			REF,
			REGEX_LITERAL,
			REQUIRES,
			RETURN,
			SEALED,
			SEMICOLON,
			SET,
			SIZEOF,
			STAR,
			STATIC,
			STRING_LITERAL,
			STRUCT,
			SUPER,
			TEMPLATE_STRING_LITERAL,
			THIS,
			TILDE,
			TO,
			TRUE,
			TRY,
			TYPEOF,
			UNOWNED,
			USES,
			VAR,
			VERBATIM_STRING_LITERAL,
			VIRTUAL,
			VOID,
			VOLATILE,
			WEAK,
			WHEN,
			WHILE,
			WRITEONLY,
			YIELD;
			public unowned string to_string ();
		}
	}
	/**
	 * Represents an address-of expression in the source code, e.g. `&foo`.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class AddressofExpression : Vala.Expression {
		/**
		 * Creates a new address-of expression.
		 *
		 * @param inner variable whose address is to be computed
		 * @return      newly created address-of expression
		 */
		public AddressofExpression (Vala.Expression inner, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The variable whose address is to be computed.
		 */
		public Vala.Expression inner { get; set; }
	}
	/**
	 * Represents an array creation expression e.g. {{{ new int[] {1,2,3} }}}.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ArrayCreationExpression : Vala.Expression {
		public ArrayCreationExpression (Vala.DataType element_type, int rank, Vala.InitializerList? initializer_list, Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Add a size expression.
		 */
		public void append_size (Vala.Expression size);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Get the sizes for all dimensions ascending from left to right.
		 */
		public Vala.List<Vala.Expression> get_sizes ();
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * The type of the elements of the array.
		 */
		public Vala.DataType element_type { get; set; }
		/**
		 * The root array initializer list.
		 */
		public Vala.InitializerList? initializer_list { get; set; }
		/**
		 * The rank of the array.
		 */
		public int rank { get; set; }
	}
	/**
	 * Represents the Array.length field.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ArrayLengthField : Vala.Field {
		/**
		 * Creates a new array length field.
		 *
		 * @return newly created field
		 */
		public ArrayLengthField (Vala.SourceReference source_reference);
	}
	/**
	 * Represents the Array.move method.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ArrayMoveMethod : Vala.Method {
		/**
		 * Creates a new array move method.
		 *
		 * @return newly created method
		 */
		public ArrayMoveMethod (Vala.SourceReference source_reference);
	}
	/**
	 * Represents the Array.resize method.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ArrayResizeMethod : Vala.Method {
		/**
		 * Creates a new array resize method.
		 *
		 * @return newly created method
		 */
		public ArrayResizeMethod (Vala.SourceReference source_reference);
	}
	/**
	 * An array type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ArrayType : Vala.ReferenceType {
		public ArrayType (Vala.DataType element_type, int rank, Vala.SourceReference? source_reference);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override bool compatible (Vala.DataType target_type);
		public override Vala.DataType copy ();
		public override Vala.DataType get_actual_type (Vala.DataType? derived_instance_type, Vala.MemberAccess? method_access, Vala.CodeNode node_reference);
		public override Vala.Symbol? get_member (string member_name);
		public override Vala.DataType? infer_type_argument (Vala.TypeParameter type_param, Vala.DataType value_type);
		public override bool is_accessible (Vala.Symbol sym);
		public override bool is_array ();
		public override bool is_disposable ();
		public override bool is_reference_type_or_type_parameter ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		public override string to_qualified_string (Vala.Scope? scope);
		/**
		 * The element type.
		 */
		public Vala.DataType element_type { get; set; }
		public bool fixed_length { get; set; }
		public bool inline_allocated { get; set; }
		public bool invalid_syntax { get; set; }
		/**
		 * The length of this fixed-length array.
		 */
		public Vala.Expression? length { get; set; }
		/**
		 * The rank of this array.
		 */
		public int rank { get; set; }
	}
	/**
	 * Represents an assignment expression in the source code.
	 *
	 * Supports =, |=, &=, ^=, +=, -=, *=, /=, %=, <<=, >>=.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Assignment : Vala.Expression {
		/**
		 * Creates a new assignment.
		 *
		 * @param left             left hand side
		 * @param operator         assignment operator
		 * @param right            right hand side
		 * @param source_reference reference to source code
		 * @return                 newly created assignment
		 */
		public Assignment (Vala.Expression left, Vala.Expression right, Vala.AssignmentOperator operator = AssignmentOperator.SIMPLE, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * Left hand side of the assignment.
		 */
		public Vala.Expression left { get; set; }
		/**
		 * Assignment operator.
		 */
		public Vala.AssignmentOperator operator { get; set; }
		/**
		 * Right hand side of the assignment.
		 */
		public Vala.Expression right { get; set; }
	}
	/**
	 * Represents an attribute specified in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Attribute : Vala.CodeNode {
		/**
		 * Contains all specified attribute arguments.
		 */
		public Vala.Map<string,string> args;
		/**
		 * Creates a new attribute.
		 *
		 * @param name             attribute type name
		 * @param source_reference reference to source code
		 * @return                 newly created attribute
		 */
		public Attribute (string name, Vala.SourceReference? source_reference = null);
		/**
		 * Adds an attribute argument.
		 *
		 * @param key    argument name
		 * @param value  argument value
		 */
		public void add_argument (string key, string value);
		/**
		 * Returns the boolean value of the specified named argument.
		 *
		 * @param name argument name
		 * @return     boolean value
		 */
		public bool get_bool (string name, bool default_value = false);
		/**
		 * Returns the double value of the specified named argument.
		 *
		 * @param name argument name
		 * @return     double value
		 */
		public double get_double (string name, double default_value = 0);
		/**
		 * Returns the integer value of the specified named argument.
		 *
		 * @param name argument name
		 * @return     integer value
		 */
		public int get_integer (string name, int default_value = 0);
		/**
		 * Returns the string value of the specified named argument.
		 *
		 * @param name argument name
		 * @return     string value
		 */
		public string? get_string (string name, string? default_value = null);
		/**
		 * Returns whether this attribute has the specified named argument.
		 *
		 * @param name argument name
		 * @return     true if the argument has been found, false otherwise
		 */
		public bool has_argument (string name);
		/**
		 * The name of the attribute type.
		 */
		public string name { get; set; }
	}
	[CCode (cheader_filename = "vala.h")]
	public class AttributeCache {
		public AttributeCache ();
	}
	/**
	 * Represents an access to base class members in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class BaseAccess : Vala.Expression {
		/**
		 * Creates a new base access expression.
		 *
		 * @param source reference to source code
		 * @return       newly created base access expression
		 */
		public BaseAccess (Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_pure ();
		public override string to_string ();
	}
	/**
	 * Represents a basic block, i.e. a straight-line piece of code without any
	 * jumps or jump targets.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class BasicBlock {
		public BasicBlock ();
		public void add_child (Vala.BasicBlock block);
		public void add_dominator_frontier (Vala.BasicBlock block);
		public void add_node (Vala.CodeNode node);
		public void add_phi_function (Vala.PhiFunction phi);
		public void connect (Vala.BasicBlock target);
		public BasicBlock.entry ();
		public BasicBlock.exit ();
		public Vala.List<Vala.BasicBlock> get_children ();
		public Vala.Set<Vala.BasicBlock> get_dominator_frontier ();
		public Vala.List<Vala.CodeNode> get_nodes ();
		public Vala.Set<Vala.PhiFunction> get_phi_functions ();
		public Vala.List<weak Vala.BasicBlock> get_predecessors ();
		public Vala.List<weak Vala.BasicBlock> get_successors ();
		public Vala.BasicBlock parent { get; private set; }
		public int postorder_number { get; set; }
		public bool postorder_visited { get; set; }
	}
	/**
	 * Represents an expression with two operands in the source code.
	 *
	 * Supports +, -, *, /, %, <<, >>, <, >, <=, >=, ==, !=, &, |, ^, &&, ||, ??.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class BinaryExpression : Vala.Expression {
		public bool chained;
		/**
		 * Creates a new binary expression.
		 *
		 * @param op      binary operator
		 * @param _left   left operand
		 * @param _right  right operand
		 * @param source  reference to source code
		 * @return        newly created binary expression
		 */
		public BinaryExpression (Vala.BinaryOperator op, Vala.Expression _left, Vala.Expression _right, Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public string get_operator_string ();
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_constant ();
		public override bool is_non_null ();
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override string to_string ();
		/**
		 * The left operand.
		 */
		public Vala.Expression left { get; set; }
		/**
		 * The binary operator.
		 */
		public Vala.BinaryOperator operator { get; set; }
		/**
		 * The right operand.
		 */
		public Vala.Expression right { get; set; }
	}
	/**
	 * Represents a source code block.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Block : Vala.Symbol, Vala.Statement {
		/**
		 * Creates a new block.
		 *
		 * @param source_reference  reference to source code
		 */
		public Block (Vala.SourceReference? source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public void add_local_constant (Vala.Constant constant);
		/**
		 * Add a local variable to this block.
		 *
		 * @param local a variable declarator
		 */
		public void add_local_variable (Vala.LocalVariable local);
		/**
		 * Append a statement to this block.
		 *
		 * @param stmt a statement
		 */
		public void add_statement (Vala.Statement stmt);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns a copy of the list of local variables.
		 *
		 * @return variable declarator list
		 */
		public Vala.List<Vala.LocalVariable> get_local_variables ();
		/**
		 * Returns a copy of the list of statements.
		 *
		 * @return statement list
		 */
		public Vala.List<Vala.Statement> get_statements ();
		public void insert_before (Vala.Statement stmt, Vala.Statement new_stmt);
		public void insert_statement (int index, Vala.Statement stmt);
		public void remove_local_variable (Vala.LocalVariable local);
		public void replace_statement (Vala.Statement old_stmt, Vala.Statement new_stmt);
		public bool captured { get; set; }
		/**
		 * Specifies whether this block contains a jump statement. This
		 * information can be used to remove unreachable block cleanup code.
		 */
		public bool contains_jump_statement { get; set; }
	}
	/**
	 * Represents a literal boolean, i.e. true or false.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class BooleanLiteral : Vala.Literal {
		/**
		 * Creates a new boolean literal.
		 *
		 * @param b      boolean value
		 * @param source reference to source code
		 * @return       newly created boolean literal
		 */
		public BooleanLiteral (bool b, Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_pure ();
		public override string to_string ();
		/**
		 * The literal value.
		 */
		public bool value { get; set; }
	}
	/**
	 * A boolean type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class BooleanType : Vala.ValueType {
		public BooleanType (Vala.Struct type_symbol);
		public override Vala.DataType copy ();
	}
	/**
	 * Represents a break statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class BreakStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new break statement.
		 *
		 * @param source reference to source code
		 * @return       newly created break statement
		 */
		public BreakStatement (Vala.SourceReference? source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void emit (Vala.CodeGenerator codegen);
	}
	/**
	 * Represents a type cast in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class CastExpression : Vala.Expression {
		/**
		 * Creates a new cast expression.
		 *
		 * @param inner           expression to be cast
		 * @param type_reference  target type
		 * @return                newly created cast expression
		 */
		public CastExpression (Vala.Expression inner, Vala.DataType type_reference, Vala.SourceReference source_reference, bool is_silent_cast);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_constant ();
		public override bool is_pure ();
		public CastExpression.non_null (Vala.Expression inner, Vala.SourceReference source_reference);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * The expression to be cast.
		 */
		public Vala.Expression inner { get; set; }
		public bool is_non_null_cast { get; set; }
		/**
		 * Checked casts return NULL instead of raising an error.
		 */
		public bool is_silent_cast { get; set; }
		/**
		 * The target type.
		 */
		public Vala.DataType type_reference { get; set; }
	}
	/**
	 * Represents a catch clause in a try statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class CatchClause : Vala.CodeNode {
		/**
		 * Creates a new catch
		 *
		 * @param error_type       error type
		 * @param variable_name    error variable name
		 * @param body             error handler body
		 * @param source_reference reference to source code
		 * @return                 newly created catch clause
		 */
		public CatchClause (Vala.DataType? error_type, string? variable_name, Vala.Block body, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Specifies the error handler body.
		 */
		public Vala.Block body { get; set; }
		/**
		 * Specifies the label used for this catch clause in the C code.
		 */
		public string? clabel_name { get; set; }
		/**
		 * Specifies the error type.
		 */
		public Vala.DataType? error_type { get; set; }
		/**
		 * Specifies the declarator for the generated error variable.
		 */
		public Vala.LocalVariable error_variable { get; set; }
		/**
		 * Specifies the error variable name.
		 */
		public string? variable_name { get; set; }
	}
	/**
	 * Represents a single literal character.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class CharacterLiteral : Vala.Literal {
		/**
		 * Creates a new character literal.
		 *
		 * @param c      character
		 * @param source reference to source code
		 * @return       newly created character literal
		 */
		public CharacterLiteral (string c, Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns the unicode character value this character literal
		 * represents.
		 *
		 * @return unicode character value
		 */
		public unichar get_char ();
		public override bool is_pure ();
		public override string to_string ();
		/**
		 * The literal value.
		 */
		public string value { get; set; }
	}
	/**
	 * Represents a class declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Class : Vala.ObjectTypeSymbol {
		/**
		 * Creates a new class.
		 *
		 * @param name             type name
		 * @param source_reference reference to source code
		 * @param comment          class documentation
		 * @return                 newly created class
		 */
		public Class (string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Adds the specified class or interface to the list of base types of
		 * this class.
		 *
		 * @param type a class or interface reference
		 */
		public void add_base_type (Vala.DataType type);
		/**
		 * Adds the specified class as an inner class.
		 *
		 * @param cl a class
		 */
		public override void add_class (Vala.Class cl);
		/**
		 * Adds the specified constant as a member to this class.
		 *
		 * @param c a constant
		 */
		public override void add_constant (Vala.Constant c);
		public override void add_constructor (Vala.Constructor c);
		/**
		 * Adds the specified delegate as an inner delegate.
		 *
		 * @param d a delegate
		 */
		public override void add_delegate (Vala.Delegate d);
		public override void add_destructor (Vala.Destructor d);
		/**
		 * Adds the specified enum as an inner enum.
		 *
		 * @param en an enum
		 */
		public override void add_enum (Vala.Enum en);
		/**
		 * Adds the specified field as a member to this class.
		 *
		 * @param f a field
		 */
		public override void add_field (Vala.Field f);
		/**
		 * Adds the specified method as a member to this class.
		 *
		 * @param m a method
		 */
		public override void add_method (Vala.Method m);
		/**
		 * Adds the specified property as a member to this class.
		 *
		 * @param prop a property
		 */
		public override void add_property (Vala.Property prop);
		/**
		 * Adds the specified signal as a member to this class.
		 *
		 * @param sig a signal
		 */
		public override void add_signal (Vala.Signal sig);
		/**
		 * Adds the specified struct as an inner struct.
		 *
		 * @param st a struct
		 */
		public override void add_struct (Vala.Struct st);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns a copy of the base type list.
		 *
		 * @return list of base types
		 */
		public Vala.List<Vala.DataType> get_base_types ();
		/**
		 * Returns a copy of the list of classes.
		 *
		 * @return list of classes
		 */
		public Vala.List<Vala.Class> get_classes ();
		/**
		 * Returns a copy of the list of constants.
		 *
		 * @return list of constants
		 */
		public Vala.List<Vala.Constant> get_constants ();
		/**
		 * Returns a copy of the list of delegates.
		 *
		 * @return list of delegates
		 */
		public Vala.List<Vala.Delegate> get_delegates ();
		/**
		 * Returns a copy of the list of enums.
		 *
		 * @return list of enums
		 */
		public Vala.List<Vala.Enum> get_enums ();
		/**
		 * Returns a copy of the list of fields.
		 *
		 * @return list of fields
		 */
		public Vala.List<Vala.Field> get_fields ();
		/**
		 * Returns a copy of the list of methods.
		 *
		 * @return list of methods
		 */
		public override Vala.List<Vala.Method> get_methods ();
		/**
		 * Returns a copy of the list of properties.
		 *
		 * @return list of properties
		 */
		public override Vala.List<Vala.Property> get_properties ();
		/**
		 * Returns a copy of the list of signals.
		 *
		 * @return list of signals
		 */
		public override Vala.List<Vala.Signal> get_signals ();
		/**
		 * Returns a copy of the list of structs.
		 *
		 * @return list of structs
		 */
		public Vala.List<Vala.Struct> get_structs ();
		public bool is_fundamental ();
		public override bool is_reference_type ();
		public override bool is_subtype_of (Vala.TypeSymbol t);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Specifies the base class.
		 */
		public Vala.Class base_class { get; set; }
		/**
		 * Specifies the class constructor.
		 */
		public Vala.Constructor class_constructor { get; set; }
		/**
		 * Specifies the class destructor.
		 */
		public Vala.Destructor? class_destructor { get; set; }
		/**
		 * Specifies the instance constructor.
		 */
		public Vala.Constructor constructor { get; set; }
		/**
		 * Specifies the default construction method.
		 */
		public Vala.CreationMethod default_construction_method { get; set; }
		/**
		 * Specifies the instance destructor.
		 */
		public Vala.Destructor? destructor { get; set; }
		/**
		 * Specifies whether this class has class fields.
		 */
		public bool has_class_private_fields { get; private set; }
		/**
		 * Specifies whether this class has private fields.
		 */
		public bool has_private_fields { get; set; }
		/**
		 * Specifies whether this class is abstract. Abstract classes may not be
		 * instantiated.
		 */
		public bool is_abstract { get; set; }
		/**
		 * Instances of compact classes are fast to create and have a
		 * compact memory layout. Compact classes don't support runtime
		 * type information or virtual methods.
		 */
		public bool is_compact { get; set; }
		/**
		 * Specifies whether this class denotes an error base.
		 */
		public bool is_error_base { get; }
		/**
		 * Instances of immutable classes are immutable after construction.
		 */
		public bool is_immutable { get; set; }
		/**
		 * Specifies the static class constructor.
		 */
		public Vala.Constructor static_constructor { get; set; }
		/**
		 * Specifies the class destructor.
		 */
		public Vala.Destructor? static_destructor { get; set; }
	}
	/**
	 * A class type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ClassType : Vala.ReferenceType {
		public ClassType (Vala.Class class_symbol);
		public override Vala.DataType copy ();
		/**
		 * The referred class.
		 */
		public Vala.Class class_symbol { get; set; }
	}
	/**
	 * The root of the code tree.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class CodeContext {
		/**
		 * List of directories where to find .gir files.
		 */
		public string[] gir_directories;
		public string[] gresources;
		/**
		 * List of directories where to find .metadata files for .gir files.
		 */
		public string[] metadata_directories;
		/**
		 * List of directories where to find .vapi files.
		 */
		public string[] vapi_directories;
		public CodeContext ();
		/**
		 * Visits the complete code tree file by file.
		 * It is possible to add new source files while visiting the tree.
		 *
		 * @param visitor the visitor to be called when traversing
		 */
		public void accept (Vala.CodeVisitor visitor);
		/**
		 * Adds the specified file to the list of C source files.
		 *
		 * @param file a C source file
		 */
		public void add_c_source_file (string file);
		public void add_define (string define);
		/**
		 * Pull the specified package into the context.
		 * The method is tolerant if the package has been already loaded.
		 *
		 * @param pkg a package name
		 * @return false if the package could not be loaded
		 *
		 */
		public bool add_external_package (string pkg);
		/**
		 * Adds the specified package to the list of used packages.
		 *
		 * @param pkg a package name
		 */
		public void add_package (string pkg);
		/**
		 * Read the given filename and pull in packages.
		 * The method is tolerant if the file does not exist.
		 *
		 * @param filename a filename
		 * @return false if an error occurs while reading the file or if a package could not be added
		 */
		public bool add_packages_from_file (string filename);
		/**
		 * Adds the specified file to the list of source files.
		 *
		 * @param file a source file
		 */
		public void add_source_file (Vala.SourceFile file);
		/**
		 * Add the specified source file to the context. Only .vala, .vapi, .gs,
		 * and .c extensions are supported.
		 *
		 * @param filename a filename
		 * @param is_source true to force adding the file as .vala or .gs
		 * @param cmdline true if the file came from the command line.
		 * @return false if the file is not recognized or the file does not exist
		 */
		public bool add_source_filename (string filename, bool is_source = false, bool cmdline = false);
		/**
		 * Resolve and analyze.
		 */
		public void check ();
		/**
		 * Return the topmost context from the context stack.
		 */
		public static Vala.CodeContext @get ();
		/**
		 * Returns a copy of the list of C source files.
		 *
		 * @return list of C source files
		 */
		public Vala.List<string> get_c_source_files ();
		public string? get_gir_path (string gir);
		public string? get_metadata_path (string gir_filename);
		/**
		 * Returns a copy of the list of used packages.
		 *
		 * @return list of used packages
		 */
		public Vala.List<string> get_packages ();
		/**
		 * Returns a copy of the list of source files.
		 *
		 * @return list of source files
		 */
		public Vala.List<Vala.SourceFile> get_source_files ();
		public string? get_vapi_path (string pkg);
		/**
		 * Returns whether the specified package is being used.
		 *
		 * @param pkg a package name
		 * @return    true if the specified package is being used
		 */
		public bool has_package (string pkg);
		public bool is_defined (string define);
		/**
		 * Remove the topmost context from the context stack.
		 */
		public static void pop ();
		/**
		 * Push the specified context to the context stack.
		 */
		public static void push (Vala.CodeContext context);
		public static string realpath (string name);
		/**
		 * Returns true if the target version of glib is greater than or 
		 * equal to the specified version.
		 */
		public bool require_glib_version (int major, int minor);
		public void write_dependencies (string filename);
		public Vala.SemanticAnalyzer analyzer { get; private set; }
		/**
		 * Enable run-time checks for programming errors.
		 */
		public bool assert { get; set; }
		/**
		 * Base source directory.
		 */
		public string basedir { get; set; }
		/**
		 * Output C code, don't compile to object code.
		 */
		public bool ccode_only { get; set; }
		/**
		 * Enable additional run-time checks such as type checks.
		 */
		public bool checking { get; set; }
		/**
		 * The selected code generator.
		 */
		public Vala.CodeGenerator codegen { get; set; }
		/**
		 * Compile but do not link.
		 */
		public bool compile_only { get; set; }
		/**
		 * Produce debug information.
		 */
		public bool debug { get; set; }
		/**
		 * Do not warn when using deprecated features.
		 */
		public bool deprecated { get; set; }
		/**
		 * Code output directory.
		 */
		public string directory { get; set; }
		public Vala.Method? entry_point { get; set; }
		public string entry_point_name { get; set; }
		/**
		 * Do not warn when using experimental features.
		 */
		public bool experimental { get; set; }
		/**
		 * Enable experimental enhancements for non-null types.
		 */
		public bool experimental_non_null { get; set; }
		public Vala.FlowAnalyzer flow_analyzer { get; private set; }
		/**
		 * Enable GObject creation tracing.
		 */
		public bool gobject_tracing { get; set; }
		/**
		 * Output C header file.
		 */
		public string? header_filename { get; set; }
		/**
		 * Hide the symbols marked as internal
		 */
		public bool hide_internal { get; set; }
		/**
		 * Base directory used for header_filename in the VAPIs.
		 */
		public string? includedir { get; set; }
		/**
		 * Output internal C header file.
		 */
		public string? internal_header_filename { get; set; }
		/**
		 * Enable memory profiler.
		 */
		public bool mem_profiler { get; set; }
		/**
		 * Specifies the optional module initialization method.
		 */
		public Vala.Method module_init_method { get; set; }
		public bool nostdpkg { get; set; }
		/**
		 * Optimization level.
		 */
		public int optlevel { get; set; }
		/**
		 * Output filename.
		 */
		public string output { get; set; }
		public Vala.Profile profile { get; set; }
		public Vala.Report report { get; set; }
		public Vala.SymbolResolver resolver { get; private set; }
		/**
		 * The root namespace of the symbol tree.
		 */
		public Vala.Namespace root { get; }
		public bool run_output { get; set; }
		public bool save_csources { get; }
		/**
		 * Keep temporary files produced by the compiler.
		 */
		public bool save_temps { get; set; }
		/**
		 * Do not check whether used symbols exist in local packages.
		 */
		public bool since_check { get; set; }
		/**
		 * Output symbols file.
		 */
		public string? symbols_filename { get; set; }
		/**
		 * Target major version number of glib for code generation.
		 */
		public int target_glib_major { get; set; }
		/**
		 * Target minor version number of glib for code generation.
		 */
		public int target_glib_minor { get; set; }
		/**
		 * Enable multithreading support.
		 */
		public bool thread { get; set; }
		public bool use_fast_vapi { get; set; }
		public bool use_header { get; set; }
		/**
		 * Mark attributes used by the compiler and report unused at the end.
		 */
		public Vala.UsedAttr used_attr { get; set; }
		/**
		 * Include comments in generated vapi.
		 */
		public bool vapi_comments { get; set; }
		public bool verbose_mode { get; set; }
		public bool version_header { get; set; }
	}
	/**
	 * Abstract code visitor generating code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class CodeGenerator : Vala.CodeVisitor {
		public CodeGenerator ();
		public abstract Vala.LocalVariable create_local (Vala.DataType type);
		/**
		 * Generate and emit C code for the specified code context.
		 *
		 * @param context a code context
		 */
		public virtual void emit (Vala.CodeContext context);
		public abstract Vala.TargetValue load_field (Vala.Field field, Vala.TargetValue? instance);
		public abstract Vala.TargetValue load_local (Vala.LocalVariable local);
		public abstract Vala.TargetValue load_parameter (Vala.Parameter param);
		public abstract void store_field (Vala.Field field, Vala.TargetValue? instance, Vala.TargetValue value);
		public abstract void store_local (Vala.LocalVariable local, Vala.TargetValue value, bool initializer);
		public abstract void store_parameter (Vala.Parameter param, Vala.TargetValue value, bool capturing_parameter = false);
	}
	/**
	 * Represents a part of the parsed source code.
	 *
	 * Code nodes get created by the parser and are used throughout the whole
	 * compilation process.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class CodeNode {
		/**
		 * Contains all attributes that have been specified for this code node.
		 */
		public GLib.List<Vala.Attribute> attributes;
		public CodeNode ();
		/**
		 * Visits this code node with the specified CodeVisitor.
		 *
		 * @param visitor the visitor to be called while traversing
		 */
		public virtual void accept (Vala.CodeVisitor visitor);
		/**
		 * Visits all children of this code node with the specified CodeVisitor.
		 *
		 * @param visitor the visitor to be called while traversing
		 */
		public virtual void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Adds an error type to the exceptions that can be thrown by this node
		 * or a child node 
		 */
		public void add_error_type (Vala.DataType error_type);
		/**
		 * Adds a collection of error types to the exceptions that can be thrown by this node
		 * or a child node 
		 */
		public void add_error_types (Vala.List<Vala.DataType> error_types);
		public virtual bool check (Vala.CodeContext context);
		public virtual void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns the specified attribute.
		 *
		 * @param name attribute name
		 * @return     attribute
		 */
		public Vala.Attribute? get_attribute (string name);
		/**
		 * Returns the bool value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @return          bool value
		 */
		public bool get_attribute_bool (string attribute, string argument, bool default_value = false);
		/**
		 * Returns the attribute cache at the specified index.
		 *
		 * @param index attribute cache index
		 * @return      attribute cache
		 */
		public Vala.AttributeCache? get_attribute_cache (int index);
		/**
		 * Returns a new cache index for accessing the attributes cache of code nodes
		 *
		 * @return a new cache index
		 */
		public static int get_attribute_cache_index ();
		/**
		 * Returns the double value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @return          double value
		 */
		public double get_attribute_double (string attribute, string argument, double default_value = 0);
		/**
		 * Returns the integer value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @return          integer value
		 */
		public int get_attribute_integer (string attribute, string argument, int default_value = 0);
		/**
		 * Returns the string value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @return          string value
		 */
		public string? get_attribute_string (string attribute, string argument, string? default_value = null);
		public virtual void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		/**
		 * Specifies the exceptions that can be thrown by this node or a child node
		 */
		public Vala.List<Vala.DataType> get_error_types ();
		public static string get_temp_name ();
		public virtual void get_used_variables (Vala.Collection<Vala.Variable> collection);
		/**
		 * Returns true if the specified attribute argument is set.
		 *
		 * @param  attribute attribute name
		 * @param  argument  argument name
		 * @return           true if the attribute has the given argument
		 */
		public bool has_attribute_argument (string attribute, string argument);
		/**
		 * Remove the specified named attribute argument
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 */
		public void remove_attribute_argument (string attribute, string argument);
		public virtual void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public virtual void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Sets the specified named attribute to this code node.
		 *
		 * @param name  attribute name
		 * @param value true to add the attribute, false to remove it
		 */
		public void set_attribute (string name, bool value, Vala.SourceReference? source_reference = null);
		/**
		 * Sets the boolean value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @param value     bool value
		 */
		public void set_attribute_bool (string attribute, string argument, bool value, Vala.SourceReference? source_reference = null);
		/**
		 * Sets the specified attribute cache to this code node.
		 *
		 * @param index attribute cache index
		 * @param cache attribute cache
		 */
		public void set_attribute_cache (int index, Vala.AttributeCache cache);
		/**
		 * Sets the integer value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @param value     double value
		 */
		public void set_attribute_double (string attribute, string argument, double value, Vala.SourceReference? source_reference = null);
		/**
		 * Sets the integer value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @param value     integer value
		 */
		public void set_attribute_integer (string attribute, string argument, int value, Vala.SourceReference? source_reference = null);
		/**
		 * Sets the string value of the specified attribute argument.
		 *
		 * @param attribute attribute name
		 * @param argument  argument name
		 * @param value     string value
		 */
		public void set_attribute_string (string attribute, string argument, string? value, Vala.SourceReference? source_reference = null);
		/**
		 * Returns a string that represents this code node.
		 *
		 * @return a string representation
		 */
		public virtual string to_string ();
		public bool checked { get; set; }
		/**
		 * Specifies whether a fatal error has been detected in this code node.
		 */
		public bool error { get; set; }
		/**
		 * Parent of this code node.
		 */
		public Vala.CodeNode? parent_node { get; set; }
		/**
		 * References the location in the source file where this code node has
		 * been written.
		 */
		public Vala.SourceReference? source_reference { get; set; }
		/**
		 * Specifies that this node or a child node may throw an exception.
		 */
		public bool tree_can_fail { get; }
		public string type_name { get; }
		public bool unreachable { get; set; }
	}
	/**
	 * Abstract code node visitor for traversing source code tree.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class CodeVisitor {
		public CodeVisitor ();
		/**
		 * Visit operation called for address-of expressions.
		 *
		 * @param expr an address-of expression
		 */
		public virtual void visit_addressof_expression (Vala.AddressofExpression expr);
		/**
		 * Visit operations called for array creation expresions.
		 *
		 * @param expr an array creation expression
		 */
		public virtual void visit_array_creation_expression (Vala.ArrayCreationExpression expr);
		/**
		 * Visit operation called for assignments.
		 *
		 * @param a an assignment
		 */
		public virtual void visit_assignment (Vala.Assignment a);
		/**
		 * Visit operation called for base access expressions.
		 *
		 * @param expr a base access expression
		 */
		public virtual void visit_base_access (Vala.BaseAccess expr);
		/**
		 * Visit operation called for binary expressions.
		 *
		 * @param expr a binary expression
		 */
		public virtual void visit_binary_expression (Vala.BinaryExpression expr);
		/**
		 * Visit operation called for blocks.
		 *
		 * @param b a block
		 */
		public virtual void visit_block (Vala.Block b);
		/**
		 * Visit operation called for boolean literals.
		 *
		 * @param lit a boolean literal
		 */
		public virtual void visit_boolean_literal (Vala.BooleanLiteral lit);
		/**
		 * Visit operation called for break statements.
		 *
		 * @param stmt a break statement
		 */
		public virtual void visit_break_statement (Vala.BreakStatement stmt);
		/**
		 * Visit operation called for call expressions.
		 *
		 * @param expr a call expression
		 */
		public virtual void visit_cast_expression (Vala.CastExpression expr);
		/**
		 * Visit operation called for catch clauses.
		 *
		 * @param clause a catch cluase
		 */
		public virtual void visit_catch_clause (Vala.CatchClause clause);
		/**
		 * Visit operation called for character literals.
		 *
		 * @param lit a character literal
		 */
		public virtual void visit_character_literal (Vala.CharacterLiteral lit);
		/**
		 * Visit operation called for classes.
		 *
		 * @param cl a class
		 */
		public virtual void visit_class (Vala.Class cl);
		/**
		 * Visit operation called for conditional expressions.
		 *
		 * @param expr a conditional expression
		 */
		public virtual void visit_conditional_expression (Vala.ConditionalExpression expr);
		/**
		 * Visit operation called for constants.
		 *
		 * @param c a constant
		 */
		public virtual void visit_constant (Vala.Constant c);
		/**
		 * Visit operation called for constructors.
		 *
		 * @param c a constructor
		 */
		public virtual void visit_constructor (Vala.Constructor c);
		/**
		 * Visit operation called for continue statements.
		 *
		 * @param stmt a continue statement
		 */
		public virtual void visit_continue_statement (Vala.ContinueStatement stmt);
		/**
		 * Visit operation called for creation methods.
		 *
		 * @param m a method
		 */
		public virtual void visit_creation_method (Vala.CreationMethod m);
		/**
		 * Visit operation called for type references.
		 *
		 * @param type a type reference
		 */
		public virtual void visit_data_type (Vala.DataType type);
		/**
		 * Visit operation called for declaration statements.
		 *
		 * @param stmt a declaration statement
		 */
		public virtual void visit_declaration_statement (Vala.DeclarationStatement stmt);
		/**
		 * Visit operation called for delegates.
		 *
		 * @param d a delegate
		 */
		public virtual void visit_delegate (Vala.Delegate d);
		/**
		 * Visit operation called for delete statements.
		 *
		 * @param stmt a delete statement
		 */
		public virtual void visit_delete_statement (Vala.DeleteStatement stmt);
		/**
		 * Visit operation called for destructors.
		 *
		 * @param d a destructor
		 */
		public virtual void visit_destructor (Vala.Destructor d);
		/**
		 * Visit operation called for do statements.
		 *
		 * @param stmt a do statement
		 */
		public virtual void visit_do_statement (Vala.DoStatement stmt);
		/**
		 * Visit operation called for element access expressions.
		 *
		 * @param expr an element access expression
		 */
		public virtual void visit_element_access (Vala.ElementAccess expr);
		/**
		 * Visit operation called for empty statements.
		 *
		 * @param stmt an empty statement
		 */
		public virtual void visit_empty_statement (Vala.EmptyStatement stmt);
		/**
		 * Visit operation called at end of full expressions.
		 *
		 * @param expr a full expression
		 */
		public virtual void visit_end_full_expression (Vala.Expression expr);
		/**
		 * Visit operation called for enums.
		 *
		 * @param en an enum
		 */
		public virtual void visit_enum (Vala.Enum en);
		/**
		 * Visit operation called for enum values.
		 *
		 * @param ev an enum value
		 */
		public virtual void visit_enum_value (Vala.EnumValue ev);
		/**
		 * Visit operation called for error codes.
		 *
		 * @param ecode an error code
		 */
		public virtual void visit_error_code (Vala.ErrorCode ecode);
		/**
		 * Visit operation called for error domains.
		 *
		 * @param edomain an error domain
		 */
		public virtual void visit_error_domain (Vala.ErrorDomain edomain);
		/**
		 * Visit operations called for expresions.
		 *
		 * @param expr an expression
		 */
		public virtual void visit_expression (Vala.Expression expr);
		/**
		 * Visit operation called for expression statements.
		 *
		 * @param stmt an expression statement
		 */
		public virtual void visit_expression_statement (Vala.ExpressionStatement stmt);
		/**
		 * Visit operation called for fields.
		 *
		 * @param f a field
		 */
		public virtual void visit_field (Vala.Field f);
		/**
		 * Visit operation called for for statements.
		 *
		 * @param stmt a for statement
		 */
		public virtual void visit_for_statement (Vala.ForStatement stmt);
		/**
		 * Visit operation called for foreach statements.
		 *
		 * @param stmt a foreach statement
		 */
		public virtual void visit_foreach_statement (Vala.ForeachStatement stmt);
		/**
		 * Visit operation called for formal parameters.
		 *
		 * @param p a formal parameter
		 */
		public virtual void visit_formal_parameter (Vala.Parameter p);
		/**
		 * Visit operation called for if statements.
		 *
		 * @param stmt an if statement
		 */
		public virtual void visit_if_statement (Vala.IfStatement stmt);
		/**
		 * Visit operation called for initializer lists
		 *
		 * @param list an initializer list
		 */
		public virtual void visit_initializer_list (Vala.InitializerList list);
		/**
		 * Visit operation called for integer literals.
		 *
		 * @param lit an integer literal
		 */
		public virtual void visit_integer_literal (Vala.IntegerLiteral lit);
		/**
		 * Visit operation called for interfaces.
		 *
		 * @param iface an interface
		 */
		public virtual void visit_interface (Vala.Interface iface);
		/**
		 * Visit operation called for lambda expressions.
		 *
		 * @param expr a lambda expression
		 */
		public virtual void visit_lambda_expression (Vala.LambdaExpression expr);
		/**
		 * Visit operation called for local variables.
		 *
		 * @param local a local variable
		 */
		public virtual void visit_local_variable (Vala.LocalVariable local);
		/**
		 * Visit operation called for lock statements before the body has been visited.
		 *
		 * @param stmt a lock statement
		 */
		public virtual void visit_lock_statement (Vala.LockStatement stmt);
		/**
		 * Visit operation called for loops.
		 *
		 * @param stmt a loop
		 */
		public virtual void visit_loop (Vala.Loop stmt);
		/**
		 * Visit operation called for member access expressions.
		 *
		 * @param expr a member access expression
		 */
		public virtual void visit_member_access (Vala.MemberAccess expr);
		/**
		 * Visit operation called for methods.
		 *
		 * @param m a method
		 */
		public virtual void visit_method (Vala.Method m);
		/**
		 * Visit operation called for invocation expressions.
		 *
		 * @param expr an invocation expression
		 */
		public virtual void visit_method_call (Vala.MethodCall expr);
		/**
		 * Visit operation called for named arguments.
		 *
		 * @param expr a named argument
		 */
		public virtual void visit_named_argument (Vala.NamedArgument expr);
		/**
		 * Visit operation called for namespaces.
		 *
		 * @param ns a namespace
		 */
		public virtual void visit_namespace (Vala.Namespace ns);
		/**
		 * Visit operation called for null literals.
		 *
		 * @param lit a null literal
		 */
		public virtual void visit_null_literal (Vala.NullLiteral lit);
		/**
		 * Visit operation called for object creation expressions.
		 *
		 * @param expr an object creation expression
		 */
		public virtual void visit_object_creation_expression (Vala.ObjectCreationExpression expr);
		/**
		 * Visit operation called for pointer indirections.
		 *
		 * @param expr a pointer indirection
		 */
		public virtual void visit_pointer_indirection (Vala.PointerIndirection expr);
		/**
		 * Visit operation called for postfix expressions.
		 *
		 * @param expr a postfix expression
		 */
		public virtual void visit_postfix_expression (Vala.PostfixExpression expr);
		/**
		 * Visit operation called for properties.
		 *
		 * @param prop a property
		 */
		public virtual void visit_property (Vala.Property prop);
		/**
		 * Visit operation called for property accessors.
		 *
		 * @param acc a property accessor
		 */
		public virtual void visit_property_accessor (Vala.PropertyAccessor acc);
		/**
		 * Visit operation called for real literals.
		 *
		 * @param lit a real literal
		 */
		public virtual void visit_real_literal (Vala.RealLiteral lit);
		/**
		 * Visit operation called for reference transfer expressions.
		 *
		 * @param expr a reference transfer expression
		 */
		public virtual void visit_reference_transfer_expression (Vala.ReferenceTransferExpression expr);
		/**
		 * Visit operation called for regex literals.
		 *
		 * @param lit a regex literal
		 */
		public virtual void visit_regex_literal (Vala.RegexLiteral lit);
		/**
		 * Visit operation called for return statements.
		 *
		 * @param stmt a return statement
		 */
		public virtual void visit_return_statement (Vala.ReturnStatement stmt);
		/**
		 * Visit operation called for signals.
		 *
		 * @param sig a signal
		 */
		public virtual void visit_signal (Vala.Signal sig);
		/**
		 * Visit operation called for sizeof expressions.
		 *
		 * @param expr a sizeof expression
		 */
		public virtual void visit_sizeof_expression (Vala.SizeofExpression expr);
		/**
		 * Visit operation called for array slice expressions.
		 *
		 * @param expr an array slice expression
		 */
		public virtual void visit_slice_expression (Vala.SliceExpression expr);
		/**
		 * Visit operation called for source files.
		 *
		 * @param source_file a source file
		 */
		public virtual void visit_source_file (Vala.SourceFile source_file);
		/**
		 * Visit operation called for string literals.
		 *
		 * @param lit a string literal
		 */
		public virtual void visit_string_literal (Vala.StringLiteral lit);
		/**
		 * Visit operation called for structs.
		 *
		 * @param st a struct
		 */
		public virtual void visit_struct (Vala.Struct st);
		/**
		 * Visit operation called for switch label.
		 *
		 * @param label a switch label
		 */
		public virtual void visit_switch_label (Vala.SwitchLabel label);
		/**
		 * Visit operation called for switch sections.
		 *
		 * @param section a switch section
		 */
		public virtual void visit_switch_section (Vala.SwitchSection section);
		/**
		 * Visit operation called for switch statements.
		 *
		 * @param stmt a switch statement
		 */
		public virtual void visit_switch_statement (Vala.SwitchStatement stmt);
		/**
		 * Visit operation called for string templates.
		 *
		 * @param tmpl a string template
		 */
		public virtual void visit_template (Vala.Template tmpl);
		/**
		 * Visit operation called for throw statements.
		 *
		 * @param stmt a throw statement
		 */
		public virtual void visit_throw_statement (Vala.ThrowStatement stmt);
		/**
		 * Visit operation called for try statements.
		 *
		 * @param stmt a try statement
		 */
		public virtual void visit_try_statement (Vala.TryStatement stmt);
		/**
		 * Visit operation called for tuples.
		 *
		 * @param tuple a tuple
		 */
		public virtual void visit_tuple (Vala.Tuple tuple);
		/**
		 * Visit operation called for type checks.
		 *
		 * @param expr a type check expression
		 */
		public virtual void visit_type_check (Vala.TypeCheck expr);
		/**
		 * Visit operation called for type parameters.
		 *
		 * @param p a type parameter
		 */
		public virtual void visit_type_parameter (Vala.TypeParameter p);
		/**
		 * Visit operation called for typeof expressions.
		 *
		 * @param expr a typeof expression
		 */
		public virtual void visit_typeof_expression (Vala.TypeofExpression expr);
		/**
		 * Visit operation called for unary expressions.
		 *
		 * @param expr an unary expression
		 */
		public virtual void visit_unary_expression (Vala.UnaryExpression expr);
		/**
		 * Visit operation called for unlock statements.
		 *
		 * @param stmt an unlock statement
		 */
		public virtual void visit_unlock_statement (Vala.UnlockStatement stmt);
		/**
		 * Visit operation called for using directives.
		 *
		 * @param ns a using directive
		 */
		public virtual void visit_using_directive (Vala.UsingDirective ns);
		/**
		 * Visit operation called for while statements.
		 *
		 * @param stmt an while statement
		 */
		public virtual void visit_while_statement (Vala.WhileStatement stmt);
		/**
		 * Visit operation called for yield statement.
		 *
		 * @param y a yield statement
		 */
		public virtual void visit_yield_statement (Vala.YieldStatement y);
	}
	/**
	 * Code visitor generating Vala API file for the public interface.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class CodeWriter : Vala.CodeVisitor {
		public CodeWriter (Vala.CodeWriterType type = CodeWriterType.EXTERNAL);
		/**
		 * Allows overriding of a specific cheader in the output
		 * @param original orignal cheader to override
		 * @param replacement cheader to replace original with
		 */
		public void set_cheader_override (string original, string replacement);
		public override void visit_addressof_expression (Vala.AddressofExpression expr);
		public override void visit_array_creation_expression (Vala.ArrayCreationExpression expr);
		public override void visit_assignment (Vala.Assignment a);
		public override void visit_base_access (Vala.BaseAccess expr);
		public override void visit_binary_expression (Vala.BinaryExpression expr);
		public override void visit_block (Vala.Block b);
		public override void visit_boolean_literal (Vala.BooleanLiteral lit);
		public override void visit_break_statement (Vala.BreakStatement stmt);
		public override void visit_cast_expression (Vala.CastExpression expr);
		public override void visit_catch_clause (Vala.CatchClause clause);
		public override void visit_character_literal (Vala.CharacterLiteral lit);
		public override void visit_class (Vala.Class cl);
		public override void visit_conditional_expression (Vala.ConditionalExpression expr);
		public override void visit_constant (Vala.Constant c);
		public override void visit_constructor (Vala.Constructor c);
		public override void visit_continue_statement (Vala.ContinueStatement stmt);
		public override void visit_creation_method (Vala.CreationMethod m);
		public override void visit_declaration_statement (Vala.DeclarationStatement stmt);
		public override void visit_delegate (Vala.Delegate cb);
		public override void visit_delete_statement (Vala.DeleteStatement stmt);
		public override void visit_do_statement (Vala.DoStatement stmt);
		public override void visit_element_access (Vala.ElementAccess expr);
		public override void visit_empty_statement (Vala.EmptyStatement stmt);
		public override void visit_enum (Vala.Enum en);
		public override void visit_error_domain (Vala.ErrorDomain edomain);
		public override void visit_expression_statement (Vala.ExpressionStatement stmt);
		public override void visit_field (Vala.Field f);
		public override void visit_for_statement (Vala.ForStatement stmt);
		public override void visit_foreach_statement (Vala.ForeachStatement stmt);
		public override void visit_if_statement (Vala.IfStatement stmt);
		public override void visit_initializer_list (Vala.InitializerList list);
		public override void visit_integer_literal (Vala.IntegerLiteral lit);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_lambda_expression (Vala.LambdaExpression expr);
		public override void visit_local_variable (Vala.LocalVariable local);
		public override void visit_lock_statement (Vala.LockStatement stmt);
		public override void visit_loop (Vala.Loop stmt);
		public override void visit_member_access (Vala.MemberAccess expr);
		public override void visit_method (Vala.Method m);
		public override void visit_method_call (Vala.MethodCall expr);
		public override void visit_namespace (Vala.Namespace ns);
		public override void visit_null_literal (Vala.NullLiteral lit);
		public override void visit_object_creation_expression (Vala.ObjectCreationExpression expr);
		public override void visit_pointer_indirection (Vala.PointerIndirection expr);
		public override void visit_postfix_expression (Vala.PostfixExpression expr);
		public override void visit_property (Vala.Property prop);
		public override void visit_real_literal (Vala.RealLiteral lit);
		public override void visit_reference_transfer_expression (Vala.ReferenceTransferExpression expr);
		public override void visit_return_statement (Vala.ReturnStatement stmt);
		public override void visit_signal (Vala.Signal sig);
		public override void visit_sizeof_expression (Vala.SizeofExpression expr);
		public override void visit_slice_expression (Vala.SliceExpression expr);
		public override void visit_string_literal (Vala.StringLiteral lit);
		public override void visit_struct (Vala.Struct st);
		public override void visit_switch_label (Vala.SwitchLabel label);
		public override void visit_switch_section (Vala.SwitchSection section);
		public override void visit_switch_statement (Vala.SwitchStatement stmt);
		public override void visit_throw_statement (Vala.ThrowStatement stmt);
		public override void visit_try_statement (Vala.TryStatement stmt);
		public override void visit_type_check (Vala.TypeCheck expr);
		public override void visit_typeof_expression (Vala.TypeofExpression expr);
		public override void visit_unary_expression (Vala.UnaryExpression expr);
		public override void visit_using_directive (Vala.UsingDirective ns);
		public override void visit_while_statement (Vala.WhileStatement stmt);
		public override void visit_yield_statement (Vala.YieldStatement y);
		/**
		 * Writes the public interface of the specified code context into the
		 * specified file.
		 *
		 * @param context  a code context
		 * @param filename a relative or absolute filename
		 */
		public void write_file (Vala.CodeContext context, string filename);
	}
	/**
	 * A documentation comment used by valadoc
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Comment {
		public Comment (string comment, Vala.SourceReference _source_reference);
		/**
		 * The text describing the referenced source code.
		 */
		public string content { get; set; }
		/**
		 * References the location in the source file where this code node has
		 * been written.
		 */
		public Vala.SourceReference source_reference { get; set; }
	}
	/**
	 * Represents a conditional expression in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ConditionalExpression : Vala.Expression {
		/**
		 * Creates a new conditional expression.
		 *
		 * @param cond       a condition
		 * @param true_expr  expression to be evaluated if condition is true
		 * @param false_expr expression to be evaluated if condition is false
		 * @return           newly created conditional expression
		 */
		public ConditionalExpression (Vala.Expression cond, Vala.Expression true_expr, Vala.Expression false_expr, Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override bool is_pure ();
		/**
		 * The condition.
		 */
		public Vala.Expression condition { get; set; }
		/**
		 * The expression to be evaluated if the condition doesn't hold.
		 */
		public Vala.Expression false_expression { get; set; }
		/**
		 * The expression to be evaluated if the condition holds.
		 */
		public Vala.Expression true_expression { get; set; }
	}
	/**
	 * Represents a type member with a constant value.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Constant : Vala.Symbol, Vala.Lockable {
		/**
		 * Creates a new constant.
		 *
		 * @param name             constant name
		 * @param type_reference   constant type
		 * @param value            constant value
		 * @param source_reference reference to source code
		 * @return                 newly created constant
		 */
		public Constant (string name, Vala.DataType? type_reference, Vala.Expression? value, Vala.SourceReference? source_reference, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * The data type of this constant.
		 */
		public Vala.DataType type_reference { get; set; }
		/**
		 * The value of this constant.
		 */
		public Vala.Expression? value { get; set; }
	}
	/**
	 * Represents a class or instance constructor.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Constructor : Vala.Subroutine {
		/**
		 * Creates a new constructor.
		 *
		 * @param source reference to source code
		 * @return       newly created constructor
		 */
		public Constructor (Vala.SourceReference? source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Specifies whether this is an instance or a class constructor.
		 */
		public Vala.MemberBinding binding { get; set; }
		public override bool has_result { get; }
		/**
		 * Specifies the generated `this` parameter for instance methods.
		 */
		public Vala.Parameter this_parameter { get; set; }
	}
	/**
	 * Represents a continue statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ContinueStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new continue statement.
		 *
		 * @param source reference to source code
		 * @return       newly created continue statement
		 */
		public ContinueStatement (Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void emit (Vala.CodeGenerator codegen);
	}
	/**
	 * Represents a type creation method.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class CreationMethod : Vala.Method {
		/**
		 * Creates a new method.
		 *
		 * @param name             method name
		 * @param source_reference reference to source code
		 * @return                 newly created method
		 */
		public CreationMethod (string? class_name, string? name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Specifies whether this constructor chains up to a base
		 * constructor or a different constructor of the same class.
		 */
		public bool chain_up { get; set; }
		/**
		 * Specifies the name of the type this creation method belongs to.
		 */
		public string class_name { get; set; }
	}
	/**
	 * A reference to a data type. This is used to specify static types of
	 * expressions.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class DataType : Vala.CodeNode {
		public DataType ();
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified type as generic type argument.
		 *
		 * @param arg a type reference
		 */
		public void add_type_argument (Vala.DataType arg);
		public virtual bool compatible (Vala.DataType target_type);
		/**
		 * Creates a shallow copy of this type reference.
		 *
		 * @return copy of this type reference
		 */
		public abstract Vala.DataType copy ();
		/**
		 * Checks two type references for equality. May only be used with
		 * resolved type references.
		 *
		 * @param type2 a type reference
		 * @return      true if this type reference is equal to type2, false
		 *              otherwise
		 */
		public virtual bool equals (Vala.DataType type2);
		public virtual Vala.DataType get_actual_type (Vala.DataType? derived_instance_type, Vala.MemberAccess? method_access, Vala.CodeNode node_reference);
		public virtual Vala.Symbol? get_member (string member_name);
		/**
		 * Returns copy of the list of invocation parameters.
		 *
		 * @return parameter list
		 */
		public virtual Vala.List<Vala.Parameter>? get_parameters ();
		public virtual Vala.Symbol? get_pointer_member (string member_name);
		/**
		 * Returns the return type of this invokable.
		 *
		 * @return return type
		 */
		public virtual Vala.DataType? get_return_type ();
		/**
		 * Returns a copy of the list of generic type arguments.
		 *
		 * @return type argument list
		 */
		public Vala.List<Vala.DataType> get_type_arguments ();
		public bool has_type_arguments ();
		/**
		 * Search for the type parameter in this formal type and match it in
		 * value_type.
		 */
		public virtual Vala.DataType? infer_type_argument (Vala.TypeParameter type_param, Vala.DataType value_type);
		public virtual bool is_accessible (Vala.Symbol sym);
		public virtual bool is_array ();
		/**
		 * Returns whether the value needs to be disposed, i.e. whether
		 * allocated memory or other resources need to be released when
		 * the value is no longer needed.
		 */
		public virtual bool is_disposable ();
		/**
		 * Returns whether instances of this type are invokable.
		 *
		 * @return true if invokable, false otherwise
		 */
		public virtual bool is_invokable ();
		public bool is_real_non_null_struct_type ();
		/**
		 * Checks whether this data type references a real struct. A real struct
		 * is a struct which is not a simple (fundamental) type.
		 */
		public virtual bool is_real_struct_type ();
		public virtual bool is_reference_type_or_type_parameter ();
		public bool is_weak ();
		/**
		 * Removes all generic type arguments.
		 */
		public void remove_all_type_arguments ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Checks whether this type reference is at least as strict as the
		 * specified type reference type2.
		 *
		 * @param type2 a type reference
		 * @return      true if this type reference is stricter or equal
		 */
		public virtual bool stricter (Vala.DataType type2);
		public virtual string to_qualified_string (Vala.Scope? scope = null);
		public override string to_string ();
		/**
		 * The referred data type.
		 */
		public Vala.TypeSymbol data_type { get; set; }
		/**
		 * Specifies that the expression transfers a floating reference.
		 */
		public bool floating_reference { get; set; }
		/**
		 * Specifies that the type supports dynamic lookup.
		 */
		public bool is_dynamic { get; set; }
		/**
		 * Specifies that the expression may be null.
		 */
		public bool nullable { get; set; }
		/**
		 * The referred generic type parameter.
		 */
		public Vala.TypeParameter type_parameter { get; set; }
		/**
		 * Specifies that the expression or variable owns the value.
		 */
		public bool value_owned { get; set; }
	}
	/**
	 * Represents a local variable or constant declaration statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class DeclarationStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new declaration statement.
		 *
		 * @param declaration       local variable declaration
		 * @param source_reference  reference to source code
		 * @return                  newly created declaration statement
		 */
		public DeclarationStatement (Vala.Symbol declaration, Vala.SourceReference? source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		/**
		 * The local variable or constant declaration.
		 */
		public Vala.Symbol declaration { get; set; }
	}
	/**
	 * Represents a function callback type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Delegate : Vala.TypeSymbol {
		/**
		 * Creates a new delegate.
		 *
		 * @param name              delegate type name
		 * @param return_type       return type
		 * @param source_reference  reference to source code
		 * @return                  newly created delegate
		 */
		public Delegate (string? name, Vala.DataType return_type, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends paramater to this callback function.
		 *
		 * @param param a formal parameter
		 */
		public void add_parameter (Vala.Parameter param);
		/**
		 * Appends the specified parameter to the list of type parameters.
		 *
		 * @param p a type parameter
		 */
		public void add_type_parameter (Vala.TypeParameter p);
		public override bool check (Vala.CodeContext context);
		/**
		 * Return copy of parameter list.
		 *
		 * @return parameter list
		 */
		public Vala.List<Vala.Parameter> get_parameters ();
		public string get_prototype_string (string name);
		public override int get_type_parameter_index (string name);
		public Vala.List<Vala.TypeParameter> get_type_parameters ();
		public override bool is_reference_type ();
		/**
		 * Checks whether the arguments and return type of the specified method
		 * matches this callback.
		 *
		 * @param m a method
		 * @return  true if the specified method is compatible to this callback
		 */
		public bool matches_method (Vala.Method m, Vala.DataType dt);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Specifies whether callback supports calling instance methods.
		 * The reference to the object instance will be appended to the end of
		 * the argument list in the generated C code.
		 */
		public bool has_target { get; set; }
		/**
		 * The return type of this callback.
		 */
		public Vala.DataType return_type { get; set; }
		public Vala.DataType? sender_type { get; set; }
	}
	/**
	 * The type of an instance of a delegate.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class DelegateType : Vala.DataType {
		public DelegateType (Vala.Delegate delegate_symbol);
		public override bool check (Vala.CodeContext context);
		public override Vala.DataType copy ();
		public override Vala.List<Vala.Parameter>? get_parameters ();
		public override Vala.DataType? get_return_type ();
		public override bool is_accessible (Vala.Symbol sym);
		public override bool is_disposable ();
		public override bool is_invokable ();
		public override string to_qualified_string (Vala.Scope? scope);
		public Vala.Delegate delegate_symbol { get; set; }
		public bool is_called_once { get; set; }
	}
	/**
	 * Represents a delete statement e.g. "delete a".
	 */
	[CCode (cheader_filename = "vala.h")]
	public class DeleteStatement : Vala.CodeNode, Vala.Statement {
		public DeleteStatement (Vala.Expression expression, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Expression representing the instance to be freed.
		 */
		public Vala.Expression expression { get; set; }
	}
	/**
	 * Represents a class or instance destructor.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Destructor : Vala.Subroutine {
		/**
		 * Creates a new destructor.
		 *
		 * @param source_reference reference to source code
		 * @return                 newly created destructor
		 */
		public Destructor (Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Specifies whether this is an instance or a class destructor.
		 */
		public Vala.MemberBinding binding { get; set; }
		public override bool has_result { get; }
		/**
		 * Specifies the generated `this` parameter for instance methods.
		 */
		public Vala.Parameter this_parameter { get; set; }
	}
	/**
	 * Represents a do iteration statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class DoStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new do statement.
		 *
		 * @param body              loop body
		 * @param condition         loop condition
		 * @param source_reference  reference to source code
		 * @return                  newly created do statement
		 */
		public DoStatement (Vala.Block body, Vala.Expression condition, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Specifies the loop body.
		 */
		public Vala.Block body { get; set; }
		/**
		 * Specifies the loop condition.
		 */
		public Vala.Expression condition { get; set; }
	}
	/**
	 * Represents a late bound method.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class DynamicMethod : Vala.Method {
		public DynamicMethod (Vala.DataType dynamic_type, string name, Vala.DataType return_type, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override bool check (Vala.CodeContext context);
		public Vala.DataType dynamic_type { get; set; }
		public Vala.MethodCall invocation { get; set; }
	}
	/**
	 * Represents a late bound property.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class DynamicProperty : Vala.Property {
		public DynamicProperty (Vala.DataType dynamic_type, string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override bool check (Vala.CodeContext context);
		public Vala.DataType dynamic_type { get; set; }
	}
	/**
	 * Represents a late bound signal.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class DynamicSignal : Vala.Signal {
		public DynamicSignal (Vala.DataType dynamic_type, string name, Vala.DataType return_type, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override bool check (Vala.CodeContext context);
		public Vala.DataType dynamic_type { get; set; }
		public Vala.Expression handler { get; set; }
	}
	/**
	 * Represents an array access expression e.g. "a[1,2]".
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ElementAccess : Vala.Expression {
		public ElementAccess (Vala.Expression container, Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public void append_index (Vala.Expression index);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public Vala.List<Vala.Expression> get_indices ();
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * Expression representing the container on which we want to access.
		 */
		public Vala.Expression container { get; set; }
	}
	/**
	 * An empty statement.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class EmptyStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new empty statement.
		 *
		 * @param source reference to source code
		 * @return       newly created empty statement
		 */
		public EmptyStatement (Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void emit (Vala.CodeGenerator codegen);
	}
	/**
	 * Represents an enum declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Enum : Vala.TypeSymbol {
		/**
		 * Creates a new enum.
		 *
		 * @param name             type name
		 * @param source_reference reference to source code
		 * @return                 newly created enum
		 */
		public Enum (string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Adds the specified constant as a member to this enum.
		 *
		 * @param c a constant
		 */
		public override void add_constant (Vala.Constant c);
		/**
		 * Adds the specified method as a member to this enum.
		 *
		 * @param m a method
		 */
		public override void add_method (Vala.Method m);
		/**
		 * Appends the specified enum value to the list of values.
		 *
		 * @param value an enum value
		 */
		public void add_value (Vala.EnumValue value);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns a copy of the list of constants.
		 *
		 * @return list of constants
		 */
		public Vala.List<Vala.Constant> get_constants ();
		/**
		 * Returns a copy of the list of methods.
		 *
		 * @return list of methods
		 */
		public Vala.List<Vala.Method> get_methods ();
		/**
		 * Returns a copy of the list of enum values.
		 *
		 * @return list of enum values
		 */
		public Vala.List<Vala.EnumValue> get_values ();
		public override bool is_reference_type ();
		public void remove_all_values ();
		/**
		 * Specifies whether this is a flags enum.
		 */
		public bool is_flags { get; }
	}
	/**
	 * Represents an enum member in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class EnumValue : Vala.Constant {
		/**
		 * Creates a new enum value with the specified numerical representation.
		 *
		 * @param name  enum value name
		 * @param value numerical representation
		 * @return      newly created enum value
		 */
		public EnumValue (string name, Vala.Expression? value, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
	}
	/**
	 * An enum value type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class EnumValueType : Vala.ValueType {
		public EnumValueType (Vala.Enum type_symbol);
		public override Vala.DataType copy ();
		public override Vala.Symbol? get_member (string member_name);
		public Vala.Method get_to_string_method ();
	}
	/**
	 * Represents an enum member in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ErrorCode : Vala.TypeSymbol {
		/**
		 * Creates a new enum value.
		 *
		 * @param name enum value name
		 * @return     newly created enum value
		 */
		public ErrorCode (string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Creates a new enum value with the specified numerical representation.
		 *
		 * @param name  enum value name
		 * @param value numerical representation
		 * @return      newly created enum value
		 */
		public ErrorCode.with_value (string name, Vala.Expression value, Vala.SourceReference? source_reference = null);
		/**
		 * Specifies the numerical representation of this enum value.
		 */
		public Vala.Expression value { get; set; }
	}
	/**
	 * Represents an error domain declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ErrorDomain : Vala.TypeSymbol {
		/**
		 * Creates a new error domain.
		 *
		 * @param name             type name
		 * @param source_reference reference to source code
		 * @return                 newly created error domain
		 */
		public ErrorDomain (string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified code to the list of error codes.
		 *
		 * @param ecode an error code
		 */
		public void add_code (Vala.ErrorCode ecode);
		/**
		 * Adds the specified method as a member to this error domain.
		 *
		 * @param m a method
		 */
		public override void add_method (Vala.Method m);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns a copy of the list of error codes.
		 *
		 * @return list of error codes
		 */
		public Vala.List<Vala.ErrorCode> get_codes ();
		/**
		 * Returns a copy of the list of methods.
		 *
		 * @return list of methods
		 */
		public Vala.List<Vala.Method> get_methods ();
		public override bool is_reference_type ();
	}
	/**
	 * A class type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ErrorType : Vala.ReferenceType {
		public ErrorType (Vala.ErrorDomain? error_domain, Vala.ErrorCode? error_code, Vala.SourceReference? source_reference = null);
		public override bool check (Vala.CodeContext context);
		public override bool compatible (Vala.DataType target_type);
		public override Vala.DataType copy ();
		public override bool equals (Vala.DataType type2);
		public override Vala.Symbol? get_member (string member_name);
		public override bool is_reference_type_or_type_parameter ();
		public override string to_qualified_string (Vala.Scope? scope);
		public bool dynamic_error { get; set; }
		/**
		 * The error code or null for generic error.
		 */
		public Vala.ErrorCode? error_code { get; set; }
		/**
		 * The error domain or null for generic error.
		 */
		public Vala.ErrorDomain? error_domain { get; set; }
	}
	/**
	 * Base class for all code nodes that might be used as an expression.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class Expression : Vala.CodeNode {
		public Expression ();
		public void insert_statement (Vala.Block block, Vala.Statement stmt);
		/**
		 * Returns whether this expression is constant, i.e. whether this
		 * expression only consists of literals and other constants.
		 */
		public virtual bool is_constant ();
		/**
		 * Returns whether this expression is guaranteed to be non-null.
		 */
		public virtual bool is_non_null ();
		/**
		 * Returns whether this expression is pure, i.e. whether this expression
		 * is free of side-effects.
		 */
		public abstract bool is_pure ();
		public Vala.DataType? formal_target_type { get; set; }
		public Vala.DataType? formal_value_type { get; set; }
		/**
		 * Specifies that this expression is used as lvalue, i.e. the
		 * left hand side of an assignment.
		 */
		public bool lvalue { get; set; }
		public Vala.Statement? parent_statement { get; }
		/**
		 * The symbol this expression refers to.
		 */
		public Vala.Symbol symbol_reference { get; set; }
		public Vala.DataType target_type { get; set; }
		public Vala.TargetValue? target_value { get; set; }
		/**
		 * The static type of the value of this expression.
		 * 
		 * The semantic analyzer computes this value.
		 */
		public Vala.DataType value_type { get; set; }
	}
	/**
	 * A code statement that evaluates a given expression. The value computed by the
	 * expression, if any, is discarded.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ExpressionStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new expression statement.
		 *
		 * @param expression        expression to evaluate
		 * @param source_reference  reference to source code
		 * @return                  newly created expression statement
		 */
		public ExpressionStatement (Vala.Expression expression, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * Specifies the expression to evaluate.
		 */
		public Vala.Expression expression { get; set; }
	}
	/**
	 * Represents a type or namespace field.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Field : Vala.Variable, Vala.Lockable {
		/**
		 * Creates a new field.
		 *
		 * @param name              field name
		 * @param variable_type     field type
		 * @param initializer       initializer expression
		 * @param source_reference  reference to source code
		 * @return                  newly created field
		 */
		public Field (string name, Vala.DataType variable_type, Vala.Expression? initializer, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public string? get_ctype ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		public void set_ctype (string ctype);
		/**
		 * Specifies whether this field may only be accessed with an instance of
		 * the contained type.
		 */
		public Vala.MemberBinding binding { get; set; }
		/**
		 * Specifies whether the field is volatile. Volatile fields are
		 * necessary to allow multi-threaded access.
		 */
		public bool is_volatile { get; set; }
	}
	/**
	 * A reference to an instance field without a specific instance.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class FieldPrototype : Vala.DataType {
		public FieldPrototype (Vala.Field field_symbol);
		public override Vala.DataType copy ();
		public override string to_qualified_string (Vala.Scope? scope);
		public Vala.Field field_symbol { get; set; }
	}
	/**
	 * A floating-point type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class FloatingType : Vala.ValueType {
		public FloatingType (Vala.Struct type_symbol);
		public override Vala.DataType copy ();
	}
	/**
	 * Code visitor building the control flow graph.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class FlowAnalyzer : Vala.CodeVisitor {
		public FlowAnalyzer ();
		/**
		 * Build control flow graph in the specified context.
		 *
		 * @param context a code context
		 */
		public void analyze (Vala.CodeContext context);
		public override void visit_block (Vala.Block b);
		public override void visit_break_statement (Vala.BreakStatement stmt);
		public override void visit_class (Vala.Class cl);
		public override void visit_continue_statement (Vala.ContinueStatement stmt);
		public override void visit_creation_method (Vala.CreationMethod m);
		public override void visit_declaration_statement (Vala.DeclarationStatement stmt);
		public override void visit_enum (Vala.Enum en);
		public override void visit_error_domain (Vala.ErrorDomain ed);
		public override void visit_expression (Vala.Expression expr);
		public override void visit_expression_statement (Vala.ExpressionStatement stmt);
		public override void visit_field (Vala.Field f);
		public override void visit_foreach_statement (Vala.ForeachStatement stmt);
		public override void visit_if_statement (Vala.IfStatement stmt);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_lambda_expression (Vala.LambdaExpression le);
		public override void visit_local_variable (Vala.LocalVariable local);
		public override void visit_lock_statement (Vala.LockStatement stmt);
		public override void visit_loop (Vala.Loop stmt);
		public override void visit_method (Vala.Method m);
		public override void visit_property (Vala.Property prop);
		public override void visit_property_accessor (Vala.PropertyAccessor acc);
		public override void visit_return_statement (Vala.ReturnStatement stmt);
		public override void visit_signal (Vala.Signal sig);
		public override void visit_source_file (Vala.SourceFile source_file);
		public override void visit_struct (Vala.Struct st);
		public override void visit_switch_statement (Vala.SwitchStatement stmt);
		public override void visit_throw_statement (Vala.ThrowStatement stmt);
		public override void visit_try_statement (Vala.TryStatement stmt);
		public override void visit_unlock_statement (Vala.UnlockStatement stmt);
		public override void visit_yield_statement (Vala.YieldStatement stmt);
	}
	/**
	 * Represents a for iteration statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ForStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new for statement.
		 *
		 * @param condition        loop condition
		 * @param body             loop body
		 * @param source_reference reference to source code
		 * @return                 newly created for statement
		 */
		public ForStatement (Vala.Expression? condition, Vala.Block body, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified expression to the list of initializers.
		 *
		 * @param init an initializer expression
		 */
		public void add_initializer (Vala.Expression init);
		/**
		 * Appends the specified expression to the iterator.
		 *
		 * @param iter an iterator expression
		 */
		public void add_iterator (Vala.Expression iter);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns a copy of the list of initializers.
		 *
		 * @return initializer list
		 */
		public Vala.List<Vala.Expression> get_initializer ();
		/**
		 * Returns a copy of the iterator.
		 *
		 * @return iterator
		 */
		public Vala.List<Vala.Expression> get_iterator ();
		/**
		 * Specifies the loop body.
		 */
		public Vala.Block body { get; set; }
		/**
		 * Specifies the loop condition.
		 */
		public Vala.Expression? condition { get; set; }
	}
	/**
	 * Represents a foreach statement in the source code. Foreach statements iterate
	 * over the elements of a collection.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ForeachStatement : Vala.Block {
		/**
		 * Creates a new foreach statement.
		 *
		 * @param type_reference    element type
		 * @param variable_name     element variable name
		 * @param collection        container
		 * @param body              loop body
		 * @param source_reference  reference to source code
		 * @return                  newly created foreach statement
		 */
		public ForeachStatement (Vala.DataType? type_reference, string variable_name, Vala.Expression collection, Vala.Block body, Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Specifies the loop body.
		 */
		public Vala.Block body { get; set; }
		/**
		 * Specifies the container.
		 */
		public Vala.Expression collection { get; set; }
		/**
		 * Specifies the declarator for the generated collection variable.
		 */
		public Vala.LocalVariable collection_variable { get; set; }
		/**
		 * Specifies the declarator for the generated element variable.
		 */
		public Vala.LocalVariable element_variable { get; set; }
		/**
		 * Specifies the declarator for the generated iterator variable.
		 */
		public Vala.LocalVariable iterator_variable { get; set; }
		/**
		 * Specifies the element type.
		 */
		public Vala.DataType? type_reference { get; set; }
		public bool use_iterator { get; private set; }
		/**
		 * Specifies the element variable name.
		 */
		public string variable_name { get; set; }
	}
	/**
	 * The type of a generic type parameter.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class GenericType : Vala.DataType {
		public GenericType (Vala.TypeParameter type_parameter);
		public override Vala.DataType copy ();
		public override Vala.Symbol? get_member (string member_name);
		public override Vala.DataType? infer_type_argument (Vala.TypeParameter type_param, Vala.DataType value_type);
		public override string to_qualified_string (Vala.Scope? scope = null);
	}
	/**
	 * A documentation comment used by valadoc
	 */
	[CCode (cheader_filename = "vala.h")]
	public class GirComment : Vala.Comment {
		public GirComment (string? comment, Vala.SourceReference _source_reference);
		public Vala.Comment? get_content_for_parameter (string name);
		public Vala.MapIterator<string,Vala.Comment> parameter_iterator ();
		public Vala.Comment? return_content { get; set; }
	}
	/**
	 * Code visitor parsing all GIR source files.
	 *
	 * Pipeline:
	 * 1) Parse metadata
	 * 2) Parse GIR with metadata, track unresolved GIR symbols, create Vala symbols
	 * 3) Reconciliate the tree by mapping tracked symbols
	 * 4) Process the tree
	 */
	[CCode (cheader_filename = "vala.h")]
	public class GirParser : Vala.CodeVisitor {
		public GirParser ();
		/**
		 * Parses all .gir source files in the specified code
		 * context and builds a code tree.
		 *
		 * @param context a code context
		 */
		public void parse (Vala.CodeContext context);
		public void parse_file (Vala.SourceFile source_file);
		public override void visit_source_file (Vala.SourceFile source_file);
	}
	/**
	 * Represents an if selection statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class IfStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new if statement.
		 *
		 * @param cond       a boolean condition
		 * @param true_stmt  statement to be evaluated if condition is true
		 * @param false_stmt statement to be evaluated if condition is false
		 * @return           newly created if statement
		 */
		public IfStatement (Vala.Expression cond, Vala.Block true_stmt, Vala.Block? false_stmt, Vala.SourceReference? source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The boolean condition to evaluate.
		 */
		public Vala.Expression condition { get; set; }
		/**
		 * The optional statement to be evaluated if the condition doesn't hold.
		 */
		public Vala.Block? false_statement { get; set; }
		/**
		 * The statement to be evaluated if the condition holds.
		 */
		public Vala.Block true_statement { get; set; }
	}
	/**
	 * Represents an array or struct initializer list in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class InitializerList : Vala.Expression {
		/**
		 * Creates a new initializer 
		 *
		 * @param source_reference reference to source code
		 * @return                 newly created initializer list
		 */
		public InitializerList (Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified expression to this initializer 
		 *
		 * @param expr an expression
		 */
		public void append (Vala.Expression expr);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns a copy of the expression 
		 *
		 * @return expression list
		 */
		public Vala.List<Vala.Expression> get_initializers ();
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_constant ();
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * Returns the initializer count in this initializer 
		 */
		public int size { get; }
	}
	/**
	 * Represents an integer literal in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class IntegerLiteral : Vala.Literal {
		/**
		 * Creates a new integer literal.
		 *
		 * @param i      literal value
		 * @param source reference to source code
		 * @return       newly created integer literal
		 */
		public IntegerLiteral (string i, Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_pure ();
		public override string to_string ();
		public string type_suffix { get; set; }
		/**
		 * The literal value.
		 */
		public string value { get; set; }
	}
	/**
	 * An integer type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class IntegerType : Vala.ValueType {
		public IntegerType (Vala.Struct type_symbol, string? literal_value = null, string? literal_type_name = null);
		public override bool compatible (Vala.DataType target_type);
		public override Vala.DataType copy ();
	}
	/**
	 * Represents a class declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Interface : Vala.ObjectTypeSymbol {
		/**
		 * Creates a new interface.
		 *
		 * @param name              type name
		 * @param source_reference  reference to source code
		 * @return                  newly created interface
		 */
		public Interface (string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Adds the specified class as an inner class.
		 *
		 * @param cl a class
		 */
		public override void add_class (Vala.Class cl);
		/**
		 * Adds the specified constant as a member to this interface.
		 *
		 * @param c a constant
		 */
		public override void add_constant (Vala.Constant c);
		/**
		 * Adds the specified delegate as an inner delegate.
		 *
		 * @param d a delegate
		 */
		public override void add_delegate (Vala.Delegate d);
		/**
		 * Adds the specified enum as an inner enum.
		 *
		 * @param en an enum
		 */
		public override void add_enum (Vala.Enum en);
		/**
		 * Adds the specified field as a member to this interface. The field
		 * must be private and static.
		 *
		 * @param f a field
		 */
		public override void add_field (Vala.Field f);
		/**
		 * Adds the specified method as a member to this interface.
		 *
		 * @param m a method
		 */
		public override void add_method (Vala.Method m);
		/**
		 * Adds the specified interface or class to the list of prerequisites of
		 * this interface.
		 *
		 * @param type an interface or class reference
		 */
		public void add_prerequisite (Vala.DataType type);
		/**
		 * Adds the specified property as a member to this interface.
		 *
		 * @param prop a property
		 */
		public override void add_property (Vala.Property prop);
		/**
		 * Adds the specified signal as a member to this interface.
		 *
		 * @param sig a signal
		 */
		public override void add_signal (Vala.Signal sig);
		/**
		 * Adds the specified struct as an inner struct.
		 *
		 * @param st a struct
		 */
		public override void add_struct (Vala.Struct st);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns a copy of the list of classes.
		 *
		 * @return list of classes
		 */
		public Vala.List<Vala.Class> get_classes ();
		/**
		 * Returns a copy of the list of constants.
		 *
		 * @return list of constants
		 */
		public Vala.List<Vala.Constant> get_constants ();
		/**
		 * Returns a copy of the list of delegates.
		 *
		 * @return list of delegates
		 */
		public Vala.List<Vala.Delegate> get_delegates ();
		/**
		 * Returns a copy of the list of enums.
		 *
		 * @return list of enums
		 */
		public Vala.List<Vala.Enum> get_enums ();
		/**
		 * Returns a copy of the list of fields.
		 *
		 * @return list of fields
		 */
		public Vala.List<Vala.Field> get_fields ();
		/**
		 * Returns a copy of the list of methods.
		 *
		 * @return list of methods
		 */
		public override Vala.List<Vala.Method> get_methods ();
		/**
		 * Returns a copy of the base type list.
		 *
		 * @return list of base types
		 */
		public Vala.List<Vala.DataType> get_prerequisites ();
		/**
		 * Returns a copy of the list of properties.
		 *
		 * @return list of properties
		 */
		public override Vala.List<Vala.Property> get_properties ();
		/**
		 * Returns a copy of the list of signals.
		 *
		 * @return list of signals
		 */
		public override Vala.List<Vala.Signal> get_signals ();
		/**
		 * Returns a copy of the list of structs.
		 *
		 * @return list of structs
		 */
		public Vala.List<Vala.Struct> get_structs ();
		public virtual Vala.List<Vala.Symbol> get_virtuals ();
		public override bool is_reference_type ();
		public override bool is_subtype_of (Vala.TypeSymbol t);
		/**
		 * Prepends the specified interface or class to the list of
		 * prerequisites of this interface.
		 *
		 * @param type an interface or class reference
		 */
		public void prepend_prerequisite (Vala.DataType type);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
	}
	/**
	 * An interface type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class InterfaceType : Vala.ReferenceType {
		public InterfaceType (Vala.Interface interface_symbol);
		public override Vala.DataType copy ();
		/**
		 * The referred interface.
		 */
		public Vala.Interface interface_symbol { get; set; }
	}
	/**
	 * An invalid reference to a data type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class InvalidType : Vala.DataType {
		public InvalidType ();
		public override Vala.DataType copy ();
	}
	/**
	 * Represents a lambda expression in the source code. Lambda expressions are
	 * anonymous methods with implicitly typed parameters.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class LambdaExpression : Vala.Expression {
		/**
		 * Creates a new lambda expression.
		 *
		 * @param expression_body  expression body
		 * @param source_reference reference to source code
		 * @return                 newly created lambda expression
		 */
		public LambdaExpression (Vala.Expression expression_body, Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends implicitly typed parameter.
		 *
		 * @param param parameter name
		 */
		public void add_parameter (Vala.Parameter param);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns copy of parameter list.
		 *
		 * @return parameter list
		 */
		public Vala.List<Vala.Parameter> get_parameters ();
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		/**
		 * Creates a new lambda expression with statement body.
		 *
		 * @param statement_body   statement body
		 * @param source_reference reference to source code
		 * @return                 newly created lambda expression
		 */
		public LambdaExpression.with_statement_body (Vala.Block statement_body, Vala.SourceReference source_reference);
		/**
		 * The expression body of this lambda expression. Only one of
		 * expression_body or statement_body may be set.
		 */
		public Vala.Expression expression_body { get; set; }
		/**
		 * The generated method.
		 */
		public Vala.Method method { get; set; }
		/**
		 * The statement body of this lambda expression. Only one of
		 * expression_body or statement_body may be set.
		 */
		public Vala.Block statement_body { get; set; }
	}
	/**
	 * Base class for all literals in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class Literal : Vala.Expression {
		public Literal ();
		public override bool is_constant ();
		public override bool is_pure ();
	}
	/**
	 * Represents a local variable declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class LocalVariable : Vala.Variable {
		/**
		 * Creates a new local variable.
		 *
		 * @param name              name of the variable
		 * @param initializer       optional initializer expression
		 * @param source_reference  reference to source code
		 * @return                  newly created variable declarator
		 */
		public LocalVariable (Vala.DataType? variable_type, string name, Vala.Expression? initializer = null, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		public bool captured { get; set; }
		public bool is_result { get; set; }
		public bool no_init { get; set; }
	}
	/**
	 * Represents a lock statement e.g. {{{ lock (a); }}} or {{{ lock (a) { f(a); } }}}.
	 *
	 * If the statement is empty, the mutex remains locked until a corresponding UnlockStatement
	 * occurs. Otherwise it's translated into a try/finally statement which unlocks the mutex
	 * after the block is finished.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class LockStatement : Vala.CodeNode, Vala.Statement {
		public LockStatement (Vala.Expression resource, Vala.Block? body, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * The statement during its execution the resource is locked.
		 */
		public Vala.Block? body { get; set; }
		/**
		 * Expression representing the resource to be locked.
		 */
		public Vala.Expression resource { get; set; }
	}
	/**
	 * Represents an endless loop.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Loop : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new loop.
		 *
		 * @param body             loop body
		 * @param source_reference reference to source code
		 * @return                 newly created while statement
		 */
		public Loop (Vala.Block body, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Specifies the loop body.
		 */
		public Vala.Block body { get; set; }
	}
	/**
	 * Simple reader for a subset of XML.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class MarkupReader : GLib.Object {
		public MarkupReader (string filename);
		public string? get_attribute (string attr);
		public Vala.Map<string,string> get_attributes ();
		public Vala.MarkupTokenType read_token (out Vala.SourceLocation token_begin, out Vala.SourceLocation token_end);
		public string content { get; private set; }
		public string filename { get; private set; }
		public string name { get; private set; }
	}
	/**
	 * Represents an access to a type member in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class MemberAccess : Vala.Expression {
		/**
		 * Creates a new member access expression.
		 *
		 * @param inner            parent of the member
		 * @param member_name      member name
		 * @param source_reference reference to source code
		 * @return                 newly created member access expression
		 */
		public MemberAccess (Vala.Expression? inner, string member_name, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified type as generic type argument.
		 *
		 * @param arg a type reference
		 */
		public void add_type_argument (Vala.DataType arg);
		public override bool check (Vala.CodeContext context);
		public void check_lvalue_access ();
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		/**
		 * Returns a copy of the list of generic type arguments.
		 *
		 * @return type argument list
		 */
		public Vala.List<Vala.DataType> get_type_arguments ();
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_constant ();
		public override bool is_non_null ();
		public override bool is_pure ();
		public MemberAccess.pointer (Vala.Expression inner, string member_name, Vala.SourceReference? source_reference = null);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		public MemberAccess.simple (string member_name, Vala.SourceReference? source_reference = null);
		public override string to_string ();
		/**
		 * Specifies whether the member is used for object creation.
		 */
		public bool creation_member { get; set; }
		/**
		 * The parent of the member.
		 */
		public Vala.Expression? inner { get; set; }
		/**
		 * The name of the member.
		 */
		public string member_name { get; set; }
		/**
		 * Pointer member access.
		 */
		public bool pointer_member_access { get; set; }
		/**
		 * Represents access to an instance member without an actual instance,
		 * e.g. `MyClass.an_instance_method`.
		 */
		public bool prototype_access { get; set; }
		/**
		 * Qualified access to global symbol.
		 */
		public bool qualified { get; set; }
	}
	/**
	 * Represents a member initializer, i.e. an element of an object initializer, in
	 * the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class MemberInitializer : Vala.CodeNode {
		/**
		 * Creates a new member initializer.
		 *
		 * @param name             member name
		 * @param initializer      initializer expression
		 * @param source_reference reference to source code
		 * @return                 newly created member initializer
		 */
		public MemberInitializer (string name, Vala.Expression initializer, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * Initializer expression.
		 */
		public Vala.Expression initializer { get; set; }
		/**
		 * Member name.
		 */
		public string name { get; set; }
		/**
		 * The symbol this expression refers to.
		 */
		public Vala.Symbol symbol_reference { get; set; }
	}
	/**
	 * Represents a type or namespace method.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Method : Vala.Subroutine {
		/**
		 * Creates a new method.
		 *
		 * @param name              method name
		 * @param return_type       method return type
		 * @param source_reference  reference to source code
		 * @return                  newly created method
		 */
		public Method (string? name, Vala.DataType return_type, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public void add_captured_variable (Vala.LocalVariable local);
		/**
		 * Appends parameter to this method.
		 *
		 * @param param a formal parameter
		 */
		public void add_parameter (Vala.Parameter param);
		/**
		 * Adds a postcondition to this method.
		 *
		 * @param postcondition a boolean postcondition expression
		 */
		public void add_postcondition (Vala.Expression postcondition);
		/**
		 * Adds a precondition to this method.
		 *
		 * @param precondition a boolean precondition expression
		 */
		public void add_precondition (Vala.Expression precondition);
		/**
		 * Appends the specified parameter to the list of type parameters.
		 *
		 * @param p a type parameter
		 */
		public void add_type_parameter (Vala.TypeParameter p);
		public override bool check (Vala.CodeContext context);
		/**
		 * Remove all parameters from this method.
		 */
		public void clear_parameters ();
		/**
		 * Checks whether the parameters and return type of this method are
		 * compatible with the specified method
		 *
		 * @param base_method a method
		 * @param invalid_match error string about which check failed
		 * @return true if the specified method is compatible to this method
		 */
		public bool compatible (Vala.Method base_method, out string? invalid_match);
		public Vala.List<Vala.Parameter> get_async_begin_parameters ();
		public Vala.List<Vala.Parameter> get_async_end_parameters ();
		public Vala.Method get_callback_method ();
		public void get_captured_variables (Vala.Collection<Vala.LocalVariable> variables);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public Vala.List<Vala.Parameter> get_parameters ();
		/**
		 * Returns a copy of the list of postconditions of this method.
		 *
		 * @return list of postconditions
		 */
		public Vala.List<Vala.Expression> get_postconditions ();
		/**
		 * Returns a copy of the list of preconditions of this method.
		 *
		 * @return list of preconditions
		 */
		public Vala.List<Vala.Expression> get_preconditions ();
		public int get_required_arguments ();
		public int get_type_parameter_index (string name);
		/**
		 * Returns a copy of the type parameter list.
		 *
		 * @return list of type parameters
		 */
		public Vala.List<Vala.TypeParameter> get_type_parameters ();
		public bool is_variadic ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Specifies the abstract interface method this method implements.
		 */
		public Vala.Method base_interface_method { get; }
		/**
		 * Specifies the explicit interface containing the method this method implements.
		 */
		public Vala.DataType base_interface_type { get; set; }
		/**
		 * Specifies the virtual or abstract method this method overrides.
		 * Reference must be weak as virtual and abstract methods set 
		 * base_method to themselves.
		 */
		public Vala.Method base_method { get; }
		/**
		 * Specifies whether this method may only be called with an instance of
		 * the contained type.
		 */
		public Vala.MemberBinding binding { get; set; }
		public bool closure { get; set; }
		public bool coroutine { get; set; }
		public bool entry_point { get; private set; }
		/**
		 * Specifies whether a construct function with a GType parameter is
		 * available. This is only applicable to creation methods.
		 */
		public bool has_construct_function { get; set; }
		public override bool has_result { get; }
		/**
		 * Specifies whether this method is abstract. Abstract methods have no
		 * body, may only be specified within abstract classes, and must be
		 * overriden by derived non-abstract classes.
		 */
		public bool is_abstract { get; set; }
		public bool is_async_callback { get; set; }
		/**
		 * Specifies whether this method should be inlined.
		 */
		public bool is_inline { get; set; }
		/**
		 * Specifies whether this method is virtual. Virtual methods may be
		 * overridden by derived classes.
		 */
		public bool is_virtual { get; set; }
		/**
		 * Specifies whether this method overrides a virtual or abstract method
		 * of a base type.
		 */
		public bool overrides { get; set; }
		/**
		 * Specifies whether this method expects printf-style format arguments.
		 */
		public bool printf_format { get; set; }
		/**
		 * The return type of this method.
		 */
		public Vala.DataType return_type { get; set; }
		public bool returns_floating_reference { get; set; }
		public bool returns_modified_pointer { get; set; }
		/**
		 * Specifies whether this method expects scanf-style format arguments.
		 */
		public bool scanf_format { get; set; }
		public Vala.Signal signal_reference { get; set; }
		/**
		 * Specifies the generated `this` parameter for instance methods.
		 */
		public Vala.Parameter this_parameter { get; set; }
		public int yield_count { get; set; }
	}
	/**
	 * Represents an invocation expression in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class MethodCall : Vala.Expression {
		public Vala.Expression _call;
		/**
		 * Creates a new invocation expression.
		 *
		 * @param call             method to call
		 * @param source_reference reference to source code
		 * @return                 newly created invocation expression
		 */
		public MethodCall (Vala.Expression call, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified expression to the list of arguments.
		 *
		 * @param arg an argument
		 */
		public void add_argument (Vala.Expression arg);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns a copy of the argument list.
		 *
		 * @return argument list
		 */
		public Vala.List<Vala.Expression> get_argument_list ();
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_constant ();
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The method to call.
		 */
		public Vala.Expression call { get; set; }
		public bool is_assert { get; private set; }
		/**
		 * Whether this chain up uses the constructv function with va_list.
		 */
		public bool is_constructv_chainup { get; private set; }
		public bool is_yield_expression { get; set; }
	}
	/**
	 * The type of a method referencea.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class MethodType : Vala.DataType {
		public MethodType (Vala.Method method_symbol);
		public override bool compatible (Vala.DataType target_type);
		public override Vala.DataType copy ();
		public override Vala.Symbol? get_member (string member_name);
		public override Vala.List<Vala.Parameter>? get_parameters ();
		public override Vala.DataType? get_return_type ();
		public override bool is_invokable ();
		public string to_prototype_string (bool with_type_parameters = false);
		public override string to_qualified_string (Vala.Scope? scope);
		public Vala.Method method_symbol { get; set; }
	}
	[CCode (cheader_filename = "vala.h")]
	public class NamedArgument : Vala.Expression {
		public NamedArgument (string name, Vala.Expression inner, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public Vala.Expression inner { get; set; }
		public string name { get; set; }
	}
	/**
	 * Represents a namespace declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Namespace : Vala.Symbol {
		/**
		 * Creates a new namespace.
		 *
		 * @param name             namespace name
		 * @param source_reference reference to source code
		 * @return                 newly created namespace
		 */
		public Namespace (string? name, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Adds the specified class to this namespace.
		 *
		 * @param cl a class
		 */
		public override void add_class (Vala.Class cl);
		public void add_comment (Vala.Comment comment);
		/**
		 * Adds the specified constant to this namespace.
		 *
		 * @param constant a constant
		 */
		public override void add_constant (Vala.Constant constant);
		/**
		 * Adds the specified delegate to this namespace.
		 *
		 * @param d a delegate
		 */
		public override void add_delegate (Vala.Delegate d);
		/**
		 * Adds the specified enum to this namespace.
		 *
		 * @param en an enum
		 */
		public override void add_enum (Vala.Enum en);
		/**
		 * Adds the specified error domain to this namespace.
		 *
		 * @param edomain an error domain
		 */
		public override void add_error_domain (Vala.ErrorDomain edomain);
		/**
		 * Adds the specified field to this namespace.
		 *
		 * @param f a field
		 */
		public override void add_field (Vala.Field f);
		/**
		 * Adds the specified interface to this namespace.
		 *
		 * @param iface an interface
		 */
		public override void add_interface (Vala.Interface iface);
		/**
		 * Adds the specified method to this namespace.
		 *
		 * @param m a method
		 */
		public override void add_method (Vala.Method m);
		/**
		 * Adds the specified namespace to this source file.
		 *
		 * @param ns a namespace
		 */
		public override void add_namespace (Vala.Namespace ns);
		/**
		 * Adds the specified struct to this namespace.
		 *
		 * @param st a struct
		 */
		public override void add_struct (Vala.Struct st);
		/**
		 * Adds a new using directive with the specified namespace.
		 *
		 * @param ns reference to namespace
		 */
		public void add_using_directive (Vala.UsingDirective ns);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns a copy of the list of classes.
		 *
		 * @return class list
		 */
		public Vala.List<Vala.Class> get_classes ();
		/**
		 * Returns a copy of the list of namespaces.
		 *
		 * @return comment list
		 */
		public Vala.List<Vala.Comment> get_comments ();
		/**
		 * Returns a copy of the list of constants.
		 *
		 * @return constant list
		 */
		public Vala.List<Vala.Constant> get_constants ();
		/**
		 * Returns a copy of the list of delegates.
		 *
		 * @return delegate list
		 */
		public Vala.List<Vala.Delegate> get_delegates ();
		/**
		 * Returns a copy of the list of enums.
		 *
		 * @return enum list
		 */
		public Vala.List<Vala.Enum> get_enums ();
		/**
		 * Returns a copy of the list of error domains.
		 *
		 * @return error domain list
		 */
		public Vala.List<Vala.ErrorDomain> get_error_domains ();
		/**
		 * Returns a copy of the list of fields.
		 *
		 * @return field list
		 */
		public Vala.List<Vala.Field> get_fields ();
		/**
		 * Returns a copy of the list of interfaces.
		 *
		 * @return interface list
		 */
		public Vala.List<Vala.Interface> get_interfaces ();
		/**
		 * Returns a copy of the list of methods.
		 *
		 * @return method list
		 */
		public Vala.List<Vala.Method> get_methods ();
		/**
		 * Returns a copy of the list of namespaces.
		 *
		 * @return namespace list
		 */
		public Vala.List<Vala.Namespace> get_namespaces ();
		/**
		 * Returns a copy of the list of structs.
		 *
		 * @return struct list
		 */
		public Vala.List<Vala.Struct> get_structs ();
		/**
		 * Removes the specified struct from this namespace.
		 *
		 * @param st a struct
		 */
		public void remove_struct (Vala.Struct st);
	}
	/**
	 * Represents a literal `null` in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class NullLiteral : Vala.Literal {
		/**
		 * Creates a new null literal.
		 *
		 * @param source reference to source code
		 * @return       newly created null literal
		 */
		public NullLiteral (Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_pure ();
		public override string to_string ();
	}
	/**
	 * The type of the null literal.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class NullType : Vala.ReferenceType {
		public NullType (Vala.SourceReference? source_reference);
		public override bool compatible (Vala.DataType target_type);
		public override Vala.DataType copy ();
		public override bool is_disposable ();
		public override string to_qualified_string (Vala.Scope? scope = null);
	}
	/**
	 * Represents an object creation expression in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ObjectCreationExpression : Vala.Expression {
		/**
		 * Creates a new object creation expression.
		 *
		 * @param member_name      object type to create
		 * @param source_reference reference to source code
		 * @return                 newly created object creation expression
		 */
		public ObjectCreationExpression (Vala.MemberAccess member_name, Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified expression to the list of arguments.
		 *
		 * @param arg an argument
		 */
		public void add_argument (Vala.Expression arg);
		/**
		 * Appends the specified member initializer to the object initializer.
		 *
		 * @param init a member initializer
		 */
		public void add_member_initializer (Vala.MemberInitializer init);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns a copy of the argument list.
		 *
		 * @return argument list
		 */
		public Vala.List<Vala.Expression> get_argument_list ();
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		/**
		 * Returns the object initializer.
		 *
		 * @return member initializer list
		 */
		public Vala.List<Vala.MemberInitializer> get_object_initializer ();
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		public bool is_yield_expression { get; set; }
		/**
		 * The construction method to use or the data type to be created
		 * with the default construction method.
		 */
		public Vala.MemberAccess member_name { get; set; }
		public bool struct_creation { get; set; }
		/**
		 * The object type to create.
		 */
		public Vala.DataType type_reference { get; set; }
	}
	/**
	 * A class type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ObjectType : Vala.ReferenceType {
		public ObjectType (Vala.ObjectTypeSymbol type_symbol);
		public override bool check (Vala.CodeContext context);
		public override Vala.DataType copy ();
		public override Vala.List<Vala.Parameter>? get_parameters ();
		public override Vala.DataType? get_return_type ();
		public override bool is_invokable ();
		public override bool stricter (Vala.DataType target_type);
		/**
		 * The referred class or interface.
		 */
		public Vala.ObjectTypeSymbol type_symbol { get; set; }
	}
	/**
	 * Represents a runtime data type for objects and interfaces. This data type may
	 * be defined in Vala source code or imported from an external library with a 
	 * Vala API file.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class ObjectTypeSymbol : Vala.TypeSymbol {
		public ObjectTypeSymbol (string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		/**
		 * Adds the specified method as a hidden member to this class,
		 * primarily used for default signal handlers.
		 *
		 * The hidden methods are not part of the `methods` collection.
		 *
		 * There may also be other use cases, eg, convert array.resize() to
		 * this type of method?
		 *
		 * @param m a method
		 */
		public void add_hidden_method (Vala.Method m);
		/**
		 * Appends the specified parameter to the list of type parameters.
		 *
		 * @param p a type parameter
		 */
		public void add_type_parameter (Vala.TypeParameter p);
		public abstract Vala.List<Vala.Method> get_methods ();
		public abstract Vala.List<Vala.Property> get_properties ();
		public abstract Vala.List<Vala.Signal> get_signals ();
		public Vala.ObjectType get_this_type ();
		public override int get_type_parameter_index (string name);
		/**
		 * Returns a copy of the type parameter list.
		 *
		 * @return list of type parameters
		 */
		public Vala.List<Vala.TypeParameter> get_type_parameters ();
	}
	/**
	 * Represents a formal parameter in method and callback signatures.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Parameter : Vala.Variable {
		/**
		 * Creates a new formal parameter.
		 *
		 * @param name              parameter name
		 * @param variable_type     parameter type
		 * @param source_reference  reference to source code
		 * @return                  newly created formal parameter
		 */
		public Parameter (string name, Vala.DataType? variable_type, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public Vala.Parameter copy ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Creates a new ellipsis parameter representing an indefinite number of
		 * parameters.
		 */
		public Parameter.with_ellipsis (Vala.SourceReference? source_reference = null);
		/**
		 * The base parameter of this parameter relative to the base method.
		 */
		public Vala.Parameter base_parameter { get; set; }
		public bool captured { get; set; }
		public Vala.ParameterDirection direction { get; set; }
		/**
		 * Specifies whether the methods accepts an indefinite number of
		 * parameters.
		 */
		public bool ellipsis { get; set; }
		/**
		 * Specifies whether the methods accepts an indefinite number of
		 * parameters.
		 */
		public bool params_array { get; set; }
	}
	/**
	 * Code visitor parsing all Vala source files.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Parser : Vala.CodeVisitor {
		public Parser ();
		/**
		 * Parses all .vala and .vapi source files in the specified code
		 * context and builds a code tree.
		 *
		 * @param context a code context
		 */
		public void parse (Vala.CodeContext context);
		public void parse_file (Vala.SourceFile source_file);
		public override void visit_source_file (Vala.SourceFile source_file);
	}
	[CCode (cheader_filename = "vala.h")]
	public class PhiFunction {
		public PhiFunction (Vala.Variable variable, int num_of_ops);
		public Vala.List<Vala.Variable?> operands { get; private set; }
		public Vala.Variable original_variable { get; private set; }
	}
	/**
	 * Represents a pointer indirection in the source code, e.g. `*pointer`.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class PointerIndirection : Vala.Expression {
		/**
		 * Creates a new pointer indirection.
		 *
		 * @param inner pointer to be dereferenced
		 * @return      newly created pointer indirection
		 */
		public PointerIndirection (Vala.Expression inner, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The pointer to dereference.
		 */
		public Vala.Expression inner { get; set; }
	}
	/**
	 * A pointer type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class PointerType : Vala.DataType {
		public PointerType (Vala.DataType base_type, Vala.SourceReference? source_reference = null);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override bool compatible (Vala.DataType target_type);
		public override Vala.DataType copy ();
		public override Vala.DataType get_actual_type (Vala.DataType? derived_instance_type, Vala.MemberAccess? method_access, Vala.CodeNode node_reference);
		public override Vala.Symbol? get_member (string member_name);
		public override Vala.Symbol? get_pointer_member (string member_name);
		public override Vala.DataType? infer_type_argument (Vala.TypeParameter type_param, Vala.DataType value_type);
		public override bool is_accessible (Vala.Symbol sym);
		public override bool is_disposable ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		public override string to_qualified_string (Vala.Scope? scope);
		/**
		 * The base type the pointer is referring to.
		 */
		public Vala.DataType base_type { get; set; }
	}
	/**
	 * Represents a postfix increment or decrement expression.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class PostfixExpression : Vala.Expression {
		/**
		 * Creates a new postfix expression.
		 *
		 * @param _inner  operand expression
		 * @param inc     true for increment, false for decrement
		 * @param source  reference to source code
		 * @return newly  created postfix expression
		 */
		public PostfixExpression (Vala.Expression _inner, bool inc, Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		/**
		 * Specifies whether value should be incremented or decremented.
		 */
		public bool increment { get; set; }
		/**
		 * The operand, must be a variable or a property.
		 */
		public Vala.Expression inner { get; set; }
	}
	/**
	 * Represents a property declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Property : Vala.Symbol, Vala.Lockable {
		/**
		 * Creates a new property.
		 *
		 * @param name              property name
		 * @param property_type     property type
		 * @param get_accessor      get accessor
		 * @param set_accessor      set/construct accessor
		 * @param source_reference  reference to source code
		 * @return                  newly created property
		 */
		public Property (string name, Vala.DataType? property_type, Vala.PropertyAccessor? get_accessor, Vala.PropertyAccessor? set_accessor, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Checks whether the accessors of this property are compatible
		 * with the specified base property.
		 *
		 * @param base_property a property
		 * @param invalid_match error string about which check failed
		 * @return true if the specified property is compatible to this property
		 */
		public bool compatible (Vala.Property base_property, out string? invalid_match);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Specifies the abstract interface property this property implements.
		 */
		public Vala.Property base_interface_property { get; }
		/**
		 * Specifies the virtual or abstract property this property overrides.
		 * Reference must be weak as virtual properties set base_property to
		 * themselves.
		 */
		public Vala.Property base_property { get; }
		/**
		 * Specifies whether this field may only be accessed with an instance of
		 * the contained type.
		 */
		public Vala.MemberBinding binding { get; set; }
		/**
		 * Reference the the Field that holds this property
		 */
		public Vala.Field field { get; set; }
		/**
		 * The get accessor of this property if available.
		 */
		public Vala.PropertyAccessor? get_accessor { get; set; }
		/**
		 * Specifies the default value of this property.
		 */
		public Vala.Expression initializer { get; set; }
		/**
		 * Specifies whether automatic accessor code generation should be
		 * disabled.
		 */
		public bool interface_only { get; set; }
		/**
		 * Specifies whether this property is abstract. Abstract properties have
		 * no accessor bodies, may only be specified within abstract classes and
		 * interfaces, and must be overriden by derived non-abstract classes.
		 */
		public bool is_abstract { get; set; }
		/**
		 * Specifies whether this property is virtual. Virtual properties may be
		 * overridden by derived classes.
		 */
		public bool is_virtual { get; set; }
		/**
		 * Specifies whether this property overrides a virtual or abstract
		 * property of a base type.
		 */
		public bool overrides { get; set; }
		/**
		 * The property type.
		 */
		public Vala.DataType? property_type { get; set; }
		/**
		 * The set/construct accessor of this property if available.
		 */
		public Vala.PropertyAccessor? set_accessor { get; set; }
		/**
		 * Represents the generated `this` parameter in this property.
		 */
		public Vala.Parameter this_parameter { get; set; }
	}
	/**
	 * Represents a get or set accessor of a property in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class PropertyAccessor : Vala.Subroutine {
		/**
		 * Creates a new property accessor.
		 *
		 * @param readable           true if get accessor, false otherwise
		 * @param writable           true if set accessor, false otherwise
		 * @param construction       true if construct accessor, false otherwise
		 * @param body               accessor body
		 * @param source_reference   reference to source code
		 * @return                   newly created property accessor
		 */
		public PropertyAccessor (bool readable, bool writable, bool construction, Vala.DataType? value_type, Vala.Block? body, Vala.SourceReference? source_reference, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Get the method representing this property accessor
		 * @return   null if the accessor is neither readable nor writable
		 */
		public Vala.Method? get_method ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * True if the body was automatically generated
		 */
		public bool automatic_body { get; set; }
		/**
		 * Specifies whether this accessor may be used to construct the
		 * property.
		 */
		public bool construction { get; set; }
		public override bool has_result { get; }
		/**
		 * The corresponding property.
		 */
		public Vala.Property prop { get; }
		/**
		 * Specifies whether this accessor may be used to get the property.
		 */
		public bool readable { get; set; }
		/**
		 * Represents the generated value parameter in a set accessor.
		 */
		public Vala.Parameter value_parameter { get; set; }
		/**
		 * The property type.
		 */
		public Vala.DataType? value_type { get; set; }
		/**
		 * Specifies whether this accessor may be used to set the property.
		 */
		public bool writable { get; set; }
	}
	/**
	 * Represents a real literal in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class RealLiteral : Vala.Literal {
		/**
		 * Creates a new real literal.
		 *
		 * @param r      literal value
		 * @param source reference to source code
		 * @return       newly created real literal
		 */
		public RealLiteral (string r, Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns the type name of the value this literal represents.
		 *
		 * @return the name of literal type
		 */
		public string get_type_name ();
		public override bool is_pure ();
		public override string to_string ();
		/**
		 * The literal value.
		 */
		public string value { get; set; }
	}
	/**
	 * Represents a reference transfer expression in the source code, e.g. `#foo`.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ReferenceTransferExpression : Vala.Expression {
		/**
		 * Creates a new reference transfer expression.
		 *
		 * @param inner variable whose reference is to be transferred
		 * @return      newly created reference transfer expression
		 */
		public ReferenceTransferExpression (Vala.Expression inner, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The variable whose reference is to be transferred.
		 */
		public Vala.Expression inner { get; set; }
	}
	/**
	 * A reference type, i.e. a class, interface, or array type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class ReferenceType : Vala.DataType {
		public ReferenceType ();
	}
	/**
	 * Represents a regular expression literal in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class RegexLiteral : Vala.Literal {
		/**
		 * Creates a new regular expression literal.
		 *
		 * @param value             the literal value
		 * @param source_reference  reference to source code
		 * @return                  newly created string literal
		 */
		public RegexLiteral (string value, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_non_null ();
		public override bool is_pure ();
		public override string to_string ();
		/**
		 * The literal value.
		 */
		public string value { get; set; }
	}
	/**
	 * Namespace to centralize reporting warnings and errors.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Report : GLib.Object {
		protected int errors;
		protected int warnings;
		public Report ();
		/**
		 * Reports the specified message as deprecation warning.
		 *
		 * @param source  reference to source code
		 * @param message warning message
		 */
		public virtual void depr (Vala.SourceReference? source, string message);
		public static void deprecated (Vala.SourceReference? source, string message);
		/**
		 * Reports the specified message as error.
		 *
		 * @param source  reference to source code
		 * @param message error message
		 */
		public virtual void err (Vala.SourceReference? source, string message);
		public static void error (Vala.SourceReference? source, string message);
		public static void experimental (Vala.SourceReference? source, string message);
		/**
		 * Returns the total number of errors reported.
		 */
		public int get_errors ();
		/**
		 * Returns the total number of warnings reported.
		 */
		public int get_warnings ();
		/**
		 * Reports the specified message as note.
		 *
		 * @param source  reference to source code
		 * @param message note message
		 */
		public virtual void note (Vala.SourceReference? source, string message);
		public static void notice (Vala.SourceReference? source, string message);
		/**
		 * Set all colors by string
		 *
		 * {{{
		 *   "error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"
		 * }}}
		 */
		public bool set_colors (string str);
		/**
		 * Set the error verbosity.
		 */
		public void set_verbose_errors (bool verbose);
		/**
		 * Reports the specified message as warning.
		 *
		 * @param source  reference to source code
		 * @param message warning message
		 */
		public virtual void warn (Vala.SourceReference? source, string message);
		public static void warning (Vala.SourceReference? source, string message);
		public bool enable_warnings { get; set; }
	}
	/**
	 * Represents a return statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ReturnStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new return statement.
		 *
		 * @param return_expression the return expression
		 * @param source_reference  reference to source code
		 * @return                  newly created return statement
		 */
		public ReturnStatement (Vala.Expression? return_expression = null, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The optional expression to return.
		 */
		public Vala.Expression? return_expression { get; set; }
	}
	/**
	 * Lexical scanner for Vala source files.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Scanner {
		public Scanner (Vala.SourceFile source_file);
		public static Vala.TokenType get_identifier_or_keyword (char* begin, int len);
		public void parse_file_comments ();
		/**
		 * Clears and returns the content of the comment stack.
		 *
		 * @return saved comment
		 */
		public Vala.Comment? pop_comment ();
		public Vala.TokenType read_regex_token (out Vala.SourceLocation token_begin, out Vala.SourceLocation token_end);
		public Vala.TokenType read_template_token (out Vala.SourceLocation token_begin, out Vala.SourceLocation token_end);
		public Vala.TokenType read_token (out Vala.SourceLocation token_begin, out Vala.SourceLocation token_end);
		public void seek (Vala.SourceLocation location);
		public Vala.SourceFile source_file { get; private set; }
	}
	/**
	 * Represents a part of the symbol tree.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Scope {
		/**
		 * Creates a new scope.
		 *
		 * @return newly created scope
		 */
		public Scope (Vala.Symbol? owner = null);
		/**
		 * Adds the specified symbol with the specified name to the symbol table
		 * of this scope.
		 *
		 * @param name name for the specified symbol
		 * @param sym  a symbol
		 */
		public void add (string? name, Vala.Symbol sym);
		public Vala.Map<string,Vala.Symbol> get_symbol_table ();
		/**
		 * Returns whether the specified scope is an ancestor of this scope.
		 *
		 * @param scope a scope or null for the root scope
		 * @return      true if this scope is a subscope of the specified
		 *              scope, false otherwise
		 */
		public bool is_subscope_of (Vala.Scope? scope);
		/**
		 * Returns the symbol stored in the symbol table with the specified
		 * name.
		 *
		 * @param name name of the symbol to be returned
		 * @return     found symbol or null
		 */
		public Vala.Symbol? lookup (string name);
		public void remove (string name);
		/**
		 * The symbol that owns this scope.
		 */
		public Vala.Symbol owner { get; set; }
		/**
		 * The parent of this scope.
		 */
		public Vala.Scope parent_scope { get; set; }
	}
	/**
	 * Code visitor analyzing and checking code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SemanticAnalyzer : Vala.CodeVisitor {
		public Vala.DataType bool_type;
		public Vala.DataType double_type;
		public Vala.DataType error_type;
		public Vala.DataType garray_type;
		public Vala.Class gerror_type;
		public Vala.DataType glist_type;
		public Vala.DataType gslist_type;
		public Vala.Class gsource_type;
		public Vala.StructValueType gvalue_type;
		public Vala.DataType gvaluearray_type;
		public Vala.ObjectType gvariant_type;
		public Vala.Block insert_block;
		public Vala.DataType int8_type;
		public Vala.DataType int_type;
		public Vala.DataType list_type;
		public Vala.DataType long_type;
		public int next_lambda_id;
		public Vala.Class object_type;
		public Vala.DataType regex_type;
		public Vala.List<Vala.CodeNode> replaced_nodes;
		public Vala.Symbol root_symbol;
		public Vala.DataType short_type;
		public Vala.DataType size_t_type;
		public Vala.DataType ssize_t_type;
		public Vala.DataType string_type;
		public Vala.DataType tuple_type;
		public Vala.DataType type_type;
		public Vala.DataType uchar_type;
		public Vala.DataType uint_type;
		public Vala.DataType ulong_type;
		public Vala.DataType unichar_type;
		public Vala.DataType ushort_type;
		public Vala.DataType va_list_type;
		public Vala.DataType void_type;
		public SemanticAnalyzer ();
		/**
		 * Analyze and check code in the specified context.
		 *
		 * @param context a code context
		 */
		public void analyze (Vala.CodeContext context);
		public bool check_arguments (Vala.Expression expr, Vala.DataType mtype, Vala.List<Vala.Parameter> @params, Vala.List<Vala.Expression> args);
		public bool check_print_format (string format, Vala.Iterator<Vala.Expression> arg_it, Vala.SourceReference source_reference);
		public bool check_variadic_arguments (Vala.Iterator<Vala.Expression>? arg_it, int i, Vala.SourceReference source_reference);
		public static Vala.Expression create_temp_access (Vala.LocalVariable local, Vala.DataType? target_type);
		public Vala.Method? find_current_method ();
		public Vala.Method? find_parent_method (Vala.Symbol sym);
		public Vala.Symbol? find_parent_method_or_property_accessor (Vala.Symbol sym);
		public static Vala.DataType? get_actual_type (Vala.DataType? derived_instance_type, Vala.MemberAccess? method_access, Vala.GenericType generic_type, Vala.CodeNode node_reference);
		public Vala.DataType? get_arithmetic_result_type (Vala.DataType left_type, Vala.DataType right_type);
		public static Vala.DataType get_data_type_for_symbol (Vala.TypeSymbol sym);
		public Vala.DataType? get_value_type_for_symbol (Vala.Symbol sym, bool lvalue);
		public bool is_in_constructor ();
		public bool is_in_destructor ();
		public bool is_in_instance_method ();
		public bool is_type_accessible (Vala.Symbol sym, Vala.DataType type);
		public static Vala.Symbol? symbol_lookup_inherited (Vala.Symbol sym, string name);
		public void visit_member_initializer (Vala.MemberInitializer init, Vala.DataType type);
		public override void visit_source_file (Vala.SourceFile file);
		public Vala.CodeContext context { get; set; }
		public Vala.Method? current_async_method { get; }
		public Vala.Class? current_class { get; }
		public Vala.Method? current_method { get; }
		public Vala.Symbol? current_method_or_property_accessor { get; }
		public Vala.PropertyAccessor? current_property_accessor { get; }
		public Vala.DataType? current_return_type { get; }
		public Vala.SourceFile current_source_file { get; set; }
		public Vala.Struct? current_struct { get; }
		public Vala.Symbol current_symbol { get; set; }
		public Vala.TypeSymbol? current_type_symbol { get; }
	}
	/**
	 * Represents an object signal. Signals enable objects to provide notifications.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Signal : Vala.Symbol, Vala.Lockable {
		/**
		 * Creates a new signal.
		 *
		 * @param name              signal name
		 * @param return_type       signal return type
		 * @param source_reference  reference to source code
		 * @return                  newly created signal
		 */
		public Signal (string name, Vala.DataType return_type, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends parameter to signal handler.
		 *
		 * @param param a formal parameter
		 */
		public void add_parameter (Vala.Parameter param);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns generated delegate to be used for signal handlers.
		 *
		 * @return delegate
		 */
		public Vala.Delegate get_delegate (Vala.DataType sender_type, Vala.CodeNode node_reference);
		public Vala.List<Vala.Parameter> get_parameters ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		public Vala.Block body { get; set; }
		/**
		 * Refers to the default signal handler, which is an anonymous
		 * function in the scope.
		 * */
		public Vala.Method default_handler { get; private set; }
		/**
		 * Specifies whether this signal has virtual method handler.
		 */
		public bool is_virtual { get; set; }
		/**
		 * The return type of handlers of this signal.
		 */
		public Vala.DataType return_type { get; set; }
	}
	/**
	 * The type of a signal referencea.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SignalType : Vala.DataType {
		public SignalType (Vala.Signal signal_symbol);
		public override bool compatible (Vala.DataType target_type);
		public override Vala.DataType copy ();
		public Vala.DelegateType get_handler_type ();
		public override Vala.Symbol? get_member (string member_name);
		public override Vala.List<Vala.Parameter>? get_parameters ();
		public override Vala.DataType? get_return_type ();
		public override bool is_accessible (Vala.Symbol sym);
		public override bool is_invokable ();
		public override string to_qualified_string (Vala.Scope? scope);
		public Vala.Signal signal_symbol { get; set; }
	}
	/**
	 * Represents a sizeof expression in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SizeofExpression : Vala.Expression {
		/**
		 * Creates a new sizeof expression.
		 *
		 * @param type   a data type
		 * @param source reference to source code
		 * @return       newly created sizeof expression
		 */
		public SizeofExpression (Vala.DataType type, Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_constant ();
		public override bool is_pure ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * The type whose size to be retrieved.
		 */
		public Vala.DataType type_reference { get; set; }
	}
	/**
	 * Represents an array slice expression e.g "a[1:5]".
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SliceExpression : Vala.Expression {
		public SliceExpression (Vala.Expression container, Vala.Expression start, Vala.Expression stop, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public Vala.Expression container { get; set; }
		public Vala.Expression start { get; private set; }
		public Vala.Expression stop { get; private set; }
	}
	/**
	 * Represents a Vala source or VAPI package file.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SourceFile {
		/**
		 * Creates a new source file.
		 *
		 * @param filename source file name
		 * @return         newly created source file
		 */
		public SourceFile (Vala.CodeContext context, Vala.SourceFileType type, string filename, string? content = null, bool cmdline = false);
		public void accept (Vala.CodeVisitor visitor);
		public void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Adds a header comment to this source file.
		 */
		public void add_comment (Vala.Comment comment);
		/**
		 * Adds the specified code node to this source file.
		 *
		 * @param node a code node
		 */
		public void add_node (Vala.CodeNode node);
		/**
		 * Adds a new using directive with the specified namespace.
		 *
		 * @param ns reference to namespace
		 */
		public void add_using_directive (Vala.UsingDirective ns);
		public bool check (Vala.CodeContext context);
		/**
		 * Returns the filename to use when including the generated C header
		 * file.
		 *
		 * @return C header filename to include
		 */
		public string get_cinclude_filename ();
		/**
		 * Returns a copy of the list of header comments.
		 *
		 * @return list of comments
		 */
		public Vala.List<Vala.Comment> get_comments ();
		/**
		 * Returns the filename to use when generating C source files.
		 *
		 * @return generated C source filename
		 */
		public string get_csource_filename ();
		public char* get_mapped_contents ();
		public size_t get_mapped_length ();
		/**
		 * Returns a copy of the list of code nodes.
		 *
		 * @return code node list
		 */
		public Vala.List<Vala.CodeNode> get_nodes ();
		public string get_relative_filename ();
		/**
		 * Returns the requested line from this file, loading it if needed.
		 *
		 * @param lineno 1-based line number
		 * @return       the specified source line
		 */
		public string? get_source_line (int lineno);
		public void remove_node (Vala.CodeNode node);
		public string? content { get; set; }
		/**
		 * The context this source file belongs to.
		 */
		public Vala.CodeContext context { get; set; }
		public Vala.List<Vala.UsingDirective> current_using_directives { get; set; }
		/**
		 * Specifies whether this file is a VAPI package file.
		 */
		public Vala.SourceFileType file_type { get; set; }
		/**
		 * The name of this source file.
		 */
		public string filename { get; set; }
		/**
		 * Specifies whether this file came from the command line directly.
		 */
		public bool from_commandline { get; set; }
		/**
		 *  GIR Namespace for this source file, if it's a VAPI package
		 */
		public string gir_namespace { get; set; }
		/**
		 *  GIR Namespace version for this source file, if it's a VAPI package
		 */
		public string gir_version { get; set; }
		/**
		 * The installed package version or null
		 */
		public string? installed_version { get; set; }
		public string? package_name { get; set; }
		public string? relative_filename { set; }
		/**
		 * If the file has been used (ie: if anything in the file has
		 * been emitted into C code as a definition or declaration).
		 */
		public bool used { get; set; }
	}
	/**
	 * Represents a reference to a location in a source file.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SourceReference {
		/**
		 * Creates a new source reference.
		 *
		 * @param _file        a source file
		 * @param begin        the begin of the referenced source code
		 * @param end          the end of the referenced source code
		 * @return             newly created source reference
		 */
		public SourceReference (Vala.SourceFile _file, Vala.SourceLocation begin, Vala.SourceLocation end);
		/**
		 * Returns a string representation of this source reference.
		 *
		 * @return human-readable string
		 */
		public string to_string ();
		/**
		 * The begin of the referenced source code.
		 */
		public Vala.SourceLocation begin { get; set; }
		/**
		 * The end of the referenced source code.
		 */
		public Vala.SourceLocation end { get; set; }
		/**
		 * The source file to be referenced.
		 */
		public Vala.SourceFile file { get; set; }
		public Vala.List<Vala.UsingDirective> using_directives { get; private set; }
	}
	[CCode (cheader_filename = "vala.h")]
	public class StatementList : Vala.CodeNode, Vala.Statement {
		public StatementList (Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public void add (Vala.Statement stmt);
		public override void emit (Vala.CodeGenerator codegen);
		public Vala.Statement @get (int index);
		public void insert (int index, Vala.Statement stmt);
		public void @set (int index, Vala.Statement stmt);
		public int length { get; }
	}
	/**
	 * Represents a string literal in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class StringLiteral : Vala.Literal {
		/**
		 * Creates a new string literal.
		 *
		 * @param value             the literal value
		 * @param source_reference  reference to source code
		 * @return                  newly created string literal
		 */
		public StringLiteral (string value, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Evaluates the literal string value.
		 *
		 * @return the unescaped string
		 */
		public string? eval ();
		public override bool is_non_null ();
		public override bool is_pure ();
		public override string to_string ();
		public bool translate { get; set; }
		/**
		 * The literal value.
		 */
		public string value { get; set; }
	}
	/**
	 * Represents a struct declaration in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Struct : Vala.TypeSymbol {
		/**
		 * Creates a new struct.
		 *
		 * @param name             type name
		 * @param source_reference reference to source code
		 * @return                 newly created struct
		 */
		public Struct (string name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Adds the specified constant as a member to this struct.
		 *
		 * @param c a constant
		 */
		public override void add_constant (Vala.Constant c);
		/**
		 * Adds the specified field as a member to this struct.
		 *
		 * @param f a field
		 */
		public override void add_field (Vala.Field f);
		/**
		 * Adds the specified method as a member to this struct.
		 *
		 * @param m a method
		 */
		public override void add_method (Vala.Method m);
		/**
		 * Adds the specified property as a member to this struct.
		 *
		 * @param prop a property
		 */
		public override void add_property (Vala.Property prop);
		/**
		 * Appends the specified parameter to the list of type parameters.
		 *
		 * @param p a type parameter
		 */
		public void add_type_parameter (Vala.TypeParameter p);
		public override bool check (Vala.CodeContext context);
		/**
		 * Returns a copy of the list of constants.
		 *
		 * @return list of constants
		 */
		public Vala.List<Vala.Constant> get_constants ();
		/**
		 * Returns a copy of the list of fields.
		 *
		 * @return list of fields
		 */
		public Vala.List<Vala.Field> get_fields ();
		/**
		 * Returns a copy of the list of methods.
		 *
		 * @return list of methods
		 */
		public Vala.List<Vala.Method> get_methods ();
		/**
		 * Returns a copy of the list of properties.
		 *
		 * @return list of properties
		 */
		public Vala.List<Vala.Property> get_properties ();
		/**
		 * Returns the rank of this integer or floating point type.
		 *
		 * @return the rank if this is an integer or floating point type
		 */
		public int get_rank ();
		public override int get_type_parameter_index (string name);
		/**
		 * Returns a copy of the type parameter list.
		 *
		 * @return list of type parameters
		 */
		public Vala.List<Vala.TypeParameter> get_type_parameters ();
		/**
		 * Returns whether this is a boolean type.
		 *
		 * @return true if this is a boolean type, false otherwise
		 */
		public bool is_boolean_type ();
		public bool is_decimal_floating_type ();
		public bool is_disposable ();
		/**
		 * Returns whether this is a floating point type.
		 *
		 * @return true if this is a floating point type, false otherwise
		 */
		public bool is_floating_type ();
		/**
		 * Returns whether this is an integer type.
		 *
		 * @return true if this is an integer type, false otherwise
		 */
		public bool is_integer_type ();
		/**
		 * Returns whether this struct is a simple type, i.e. whether
		 * instances are passed by value.
		 */
		public bool is_simple_type ();
		public override bool is_subtype_of (Vala.TypeSymbol t);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * Sets the rank of this integer or floating point type.
		 */
		public void set_rank (int rank);
		/**
		 * Marks this struct as simple type, i.e. instances will be passed by
		 * value.
		 */
		public void set_simple_type (bool simple_type);
		/**
		 * Specifies the base Struct.
		 */
		public Vala.Struct? base_struct { get; }
		/**
		 * Specifies the base type.
		 */
		public Vala.DataType? base_type { get; set; }
		/**
		 * Specifies the default construction method.
		 */
		public Vala.Method default_construction_method { get; set; }
		/**
		 * Specifies if 'const' should be emitted for input parameters
		 * of this type.
		 */
		public bool is_immutable { get; set; }
		public bool signed { get; set; }
		public int width { get; set; }
	}
	/**
	 * A struct value type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class StructValueType : Vala.ValueType {
		public StructValueType (Vala.Struct type_symbol);
		public override Vala.DataType copy ();
		public override Vala.List<Vala.Parameter>? get_parameters ();
		public override Vala.DataType? get_return_type ();
		public override bool is_invokable ();
	}
	[CCode (cheader_filename = "vala.h")]
	public abstract class Subroutine : Vala.Symbol {
		protected Subroutine (string? name, Vala.SourceReference? source_reference, Vala.Comment? comment = null);
		public Vala.Block body { get; set; }
		public Vala.BasicBlock entry_block { get; set; }
		public Vala.BasicBlock exit_block { get; set; }
		public abstract bool has_result { get; }
		/**
		 * Specifies the generated `result` variable for postconditions.
		 */
		public Vala.LocalVariable result_var { get; set; }
		public Vala.BasicBlock return_block { get; set; }
	}
	/**
	 * Represents a switch label in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SwitchLabel : Vala.CodeNode {
		/**
		 * Creates a new switch case label.
		 *
		 * @param expr   label expression
		 * @param source reference to source code
		 * @return       newly created switch case label
		 */
		public SwitchLabel (Vala.Expression expr, Vala.SourceReference? source = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Creates a new switch default label.
		 *
		 * @param source reference to source code
		 * @return       newly created switch default label
		 */
		public SwitchLabel.with_default (Vala.SourceReference? source = null);
		/**
		 * Specifies the label expression.
		 */
		public Vala.Expression expression { get; set; }
		public Vala.SwitchSection section { get; set; }
	}
	/**
	 * Represents a switch section in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SwitchSection : Vala.Block {
		/**
		 * Creates a new switch section.
		 *
		 * @param source_reference reference to source code
		 * @return                 newly created switch section
		 */
		public SwitchSection (Vala.SourceReference? source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified label to the list of switch labels.
		 *
		 * @param label a switch label
		 */
		public void add_label (Vala.SwitchLabel label);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns a copy of the list of switch labels.
		 *
		 * @return switch label list
		 */
		public Vala.List<Vala.SwitchLabel> get_labels ();
		public bool has_default_label ();
	}
	/**
	 * Represents a switch selection statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SwitchStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new switch statement.
		 *
		 * @param expression       switch expression
		 * @param source_reference reference to source code
		 * @return                 newly created switch statement
		 */
		public SwitchStatement (Vala.Expression expression, Vala.SourceReference? source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified section to the list of switch sections.
		 *
		 * @param section a switch section
		 */
		public void add_section (Vala.SwitchSection section);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns a copy of the list of switch sections.
		 *
		 * @return section list
		 */
		public Vala.List<Vala.SwitchSection> get_sections ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * Specifies the switch expression.
		 */
		public Vala.Expression expression { get; set; }
	}
	/**
	 * Represents a node in the symbol tree.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class Symbol : Vala.CodeNode {
		public Symbol (string? name, Vala.SourceReference? source_reference, Vala.Comment? comment = null);
		public virtual void add_class (Vala.Class cl);
		public virtual void add_constant (Vala.Constant constant);
		public virtual void add_constructor (Vala.Constructor c);
		public virtual void add_delegate (Vala.Delegate d);
		public virtual void add_destructor (Vala.Destructor d);
		public virtual void add_enum (Vala.Enum en);
		public virtual void add_error_domain (Vala.ErrorDomain edomain);
		public virtual void add_field (Vala.Field f);
		public virtual void add_interface (Vala.Interface iface);
		public virtual void add_method (Vala.Method m);
		public virtual void add_namespace (Vala.Namespace ns);
		public virtual void add_property (Vala.Property prop);
		public virtual void add_signal (Vala.Signal sig);
		public virtual void add_struct (Vala.Struct st);
		/**
		 * Converts a string from CamelCase to lower_case.
		 *
		 * @param camel_case a string in camel case
		 * @return           the specified string converted to lower case
		 */
		public static string camel_case_to_lower_case (string camel_case);
		/**
		 * Returns the fully expanded name of this symbol for use in
		 * human-readable messages.
		 *
		 * @return full name
		 */
		public string get_full_name ();
		public Vala.Symbol? get_hidden_member ();
		public Vala.Scope? get_top_accessible_scope (bool is_internal = false);
		public bool is_accessible (Vala.Symbol sym);
		public virtual bool is_class_member ();
		public virtual bool is_instance_member ();
		/**
		 * Check if this symbol is just internal API (and therefore doesn't need 
		 * to be listed in header files for instance) by traversing parent symbols
		 * and checking their accessibility.
		 */
		public bool is_internal_symbol ();
		public bool is_private_symbol ();
		/**
		 * Converts a string from lower_case to CamelCase.
		 *
		 * @param lower_case a string in lower case
		 * @return           the specified string converted to camel case
		 */
		public static string lower_case_to_camel_case (string lower_case);
		/**
		 * Specifies the accessibility of this symbol. Public accessibility
		 * doesn't limit access. Default accessibility limits access to this
		 * program or library. Private accessibility limits access to instances
		 * of the contained type.
		 */
		public Vala.SymbolAccessibility access { get; set; }
		/**
		 * Specifies whether this symbol is active.
		 *
		 * Symbols may become inactive when they only apply to a part of a
		 * scope. This is used for local variables not declared at the beginning
		 * of the block to determine which variables need to be freed before
		 * jump statements.
		 */
		public bool active { get; set; }
		public Vala.Comment? comment { get; set; }
		/**
		 * Specifies whether the implementation is external, for example in
		 * a separate C source file or in an external library.
		 */
		public bool external { get; set; }
		/**
		 * Specifies whether the implementation is in an external library.
		 */
		public bool external_package { get; }
		/**
		 * Specifies whether the implementation came from the commandline.
		 */
		public bool from_commandline { get; }
		/**
		 * Specifies whether this method explicitly hides a member of a base
		 * type.
		 */
		public bool hides { get; set; }
		/**
		 * The symbol name.
		 */
		public string? name { get; set; }
		/**
		 * The scope this symbol is a part of
		 */
		public Vala.Scope owner { get; set; }
		/**
		 * The parent of this symbol.
		 */
		public Vala.Symbol? parent_symbol { get; }
		/**
		 * The scope this symbol opens.
		 */
		public Vala.Scope scope { get; }
		/**
		 * Gets the SourceFileType of the source file that this symbol
		 * came from, or SourceFileType.NONE.
		 */
		public Vala.SourceFileType source_type { get; }
		/**
		 * Specifies whether this symbol has been accessed.
		 */
		public bool used { get; set; }
		/**
		 * The associated [Version] attribute
		 */
		public Vala.VersionAttribute version { get; }
	}
	/**
	 * Code visitor resolving symbol names.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class SymbolResolver : Vala.CodeVisitor {
		public SymbolResolver ();
		/**
		 * Resolve symbol names in the specified code context.
		 *
		 * @param context a code context
		 */
		public void resolve (Vala.CodeContext context);
		public override void visit_addressof_expression (Vala.AddressofExpression expr);
		public override void visit_array_creation_expression (Vala.ArrayCreationExpression e);
		public override void visit_assignment (Vala.Assignment a);
		public override void visit_binary_expression (Vala.BinaryExpression expr);
		public override void visit_block (Vala.Block b);
		public override void visit_cast_expression (Vala.CastExpression expr);
		public override void visit_catch_clause (Vala.CatchClause clause);
		public override void visit_class (Vala.Class cl);
		public override void visit_conditional_expression (Vala.ConditionalExpression expr);
		public override void visit_constant (Vala.Constant c);
		public override void visit_constructor (Vala.Constructor c);
		public override void visit_creation_method (Vala.CreationMethod m);
		public override void visit_data_type (Vala.DataType data_type);
		public override void visit_declaration_statement (Vala.DeclarationStatement stmt);
		public override void visit_delegate (Vala.Delegate cb);
		public override void visit_delete_statement (Vala.DeleteStatement stmt);
		public override void visit_destructor (Vala.Destructor d);
		public override void visit_do_statement (Vala.DoStatement stmt);
		public override void visit_element_access (Vala.ElementAccess expr);
		public override void visit_enum (Vala.Enum en);
		public override void visit_error_domain (Vala.ErrorDomain ed);
		public override void visit_expression_statement (Vala.ExpressionStatement stmt);
		public override void visit_field (Vala.Field f);
		public override void visit_for_statement (Vala.ForStatement stmt);
		public override void visit_foreach_statement (Vala.ForeachStatement stmt);
		public override void visit_formal_parameter (Vala.Parameter p);
		public override void visit_if_statement (Vala.IfStatement stmt);
		public override void visit_initializer_list (Vala.InitializerList list);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_lambda_expression (Vala.LambdaExpression l);
		public override void visit_local_variable (Vala.LocalVariable local);
		public override void visit_loop (Vala.Loop stmt);
		public override void visit_member_access (Vala.MemberAccess expr);
		public override void visit_method (Vala.Method m);
		public override void visit_method_call (Vala.MethodCall expr);
		public override void visit_named_argument (Vala.NamedArgument expr);
		public override void visit_namespace (Vala.Namespace ns);
		public override void visit_object_creation_expression (Vala.ObjectCreationExpression expr);
		public override void visit_postfix_expression (Vala.PostfixExpression expr);
		public override void visit_property (Vala.Property prop);
		public override void visit_property_accessor (Vala.PropertyAccessor acc);
		public override void visit_reference_transfer_expression (Vala.ReferenceTransferExpression expr);
		public override void visit_return_statement (Vala.ReturnStatement stmt);
		public override void visit_signal (Vala.Signal sig);
		public override void visit_sizeof_expression (Vala.SizeofExpression expr);
		public override void visit_slice_expression (Vala.SliceExpression expr);
		public override void visit_struct (Vala.Struct st);
		public override void visit_switch_label (Vala.SwitchLabel label);
		public override void visit_switch_section (Vala.SwitchSection section);
		public override void visit_switch_statement (Vala.SwitchStatement stmt);
		public override void visit_template (Vala.Template tmpl);
		public override void visit_throw_statement (Vala.ThrowStatement stmt);
		public override void visit_try_statement (Vala.TryStatement stmt);
		public override void visit_tuple (Vala.Tuple tuple);
		public override void visit_type_check (Vala.TypeCheck expr);
		public override void visit_typeof_expression (Vala.TypeofExpression expr);
		public override void visit_unary_expression (Vala.UnaryExpression expr);
		public override void visit_using_directive (Vala.UsingDirective ns);
		public override void visit_while_statement (Vala.WhileStatement stmt);
		public override void visit_yield_statement (Vala.YieldStatement stmt);
	}
	[CCode (cheader_filename = "vala.h")]
	public abstract class TargetValue {
		protected TargetValue (Vala.DataType? value_type);
		public Vala.DataType? actual_value_type { get; set; }
		public Vala.DataType? value_type { get; set; }
	}
	[CCode (cheader_filename = "vala.h")]
	public class Template : Vala.Expression {
		public Template (Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public void add_expression (Vala.Expression expr);
		public override bool check (Vala.CodeContext context);
		public Vala.List<Vala.Expression> get_expressions ();
		public override bool is_pure ();
	}
	/**
	 * Represents a throw statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class ThrowStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new throw statement.
		 *
		 * @param error_expression the error expression
		 * @param source_reference reference to source code
		 * @return                 newly created throw statement
		 */
		public ThrowStatement (Vala.Expression error_expression, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The error expression to throw.
		 */
		public Vala.Expression error_expression { get; set; }
	}
	/**
	 * Represents a try statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class TryStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new try statement.
		 *
		 * @param body             body of the try statement
		 * @param finally_body     body of the optional finally clause
		 * @param source_reference reference to source code
		 * @return                 newly created try statement
		 */
		public TryStatement (Vala.Block body, Vala.Block? finally_body, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		/**
		 * Appends the specified clause to the list of catch clauses.
		 *
		 * @param clause a catch clause
		 */
		public void add_catch_clause (Vala.CatchClause clause);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Returns a copy of the list of catch clauses.
		 *
		 * @return list of catch clauses
		 */
		public Vala.List<Vala.CatchClause> get_catch_clauses ();
		public bool after_try_block_reachable { get; set; }
		/**
		 * Specifies the body of the try statement.
		 */
		public Vala.Block body { get; set; }
		/**
		 * Specifies the body of the optional finally clause.
		 */
		public Vala.Block? finally_body { get; set; }
	}
	/**
	 * Represents a fixed-length sequence of expressions in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class Tuple : Vala.Expression {
		public Tuple (Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public void add_expression (Vala.Expression expr);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public Vala.List<Vala.Expression> get_expressions ();
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
	}
	/**
	 * Represents a type check (`is`) expression in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class TypeCheck : Vala.Expression {
		/**
		 * Creates a new type check expression.
		 *
		 * @param expr   an expression
		 * @param type   a data type
		 * @param source reference to source code
		 * @return       newly created type check expression
		 */
		public TypeCheck (Vala.Expression expr, Vala.DataType type, Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * The expression to be checked.
		 */
		public Vala.Expression expression { get; set; }
		/**
		 * The type to be matched against.
		 */
		public Vala.DataType type_reference { get; set; }
	}
	/**
	 * Represents a generic type parameter in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class TypeParameter : Vala.Symbol {
		/**
		 * Creates a new generic type parameter.
		 *
		 * @param name              parameter name
		 * @param source_reference  reference to source code
		 * @return                  newly created generic type parameter
		 */
		public TypeParameter (string name, Vala.SourceReference source_reference);
		public override void accept (Vala.CodeVisitor visitor);
		/**
		 * Checks two type parameters for equality.
		 *
		 * @param param2 a type parameter
		 * @return      true if this type parameter is equal to param2, false
		 *              otherwise
		 */
		public bool equals (Vala.TypeParameter param2);
	}
	/**
	 * Represents a runtime data type. This data type may be defined in Vala source
	 * code or imported from an external library with a Vala API file.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class TypeSymbol : Vala.Symbol {
		public TypeSymbol (string? name, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		/**
		 * Return the index of the specified type parameter name.
		 */
		public virtual int get_type_parameter_index (string name);
		/**
		 * Checks whether this data type has value or reference type semantics.
		 *
		 * @return true if this data type has reference type semantics
		 */
		public virtual bool is_reference_type ();
		/**
		 * Checks whether this data type is equal to or a subtype of the
		 * specified data type.
		 *
		 * @param t a data type
		 * @return  true if t is a supertype of this data type, false otherwise
		 */
		public virtual bool is_subtype_of (Vala.TypeSymbol t);
	}
	/**
	 * Represents a typeof expression in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class TypeofExpression : Vala.Expression {
		/**
		 * Creates a new typeof expression.
		 *
		 * @param type   a data type
		 * @param source reference to source code
		 * @return       newly created typeof expression
		 */
		public TypeofExpression (Vala.DataType type, Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override bool is_pure ();
		public override void replace_type (Vala.DataType old_type, Vala.DataType new_type);
		/**
		 * The type to be retrieved.
		 */
		public Vala.DataType type_reference { get; set; }
	}
	/**
	 * Represents an expression with one operand in the source code.
	 *
	 * Supports +, -, !, ~, ref, out.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class UnaryExpression : Vala.Expression {
		/**
		 * Creates a new unary expression.
		 *
		 * @param op     unary operator
		 * @param _inner operand
		 * @param source reference to source code
		 * @return       newly created binary expression
		 */
		public UnaryExpression (Vala.UnaryOperator op, Vala.Expression _inner, Vala.SourceReference source);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void get_defined_variables (Vala.Collection<Vala.Variable> collection);
		public override void get_used_variables (Vala.Collection<Vala.Variable> collection);
		public override bool is_constant ();
		public override bool is_pure ();
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		public override string to_string ();
		/**
		 * The operand.
		 */
		public Vala.Expression inner { get; set; }
		/**
		 * The unary operator.
		 */
		public Vala.UnaryOperator operator { get; set; }
	}
	/**
	 * Represents an unlock statement e.g. {{{ unlock (a); }}}.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class UnlockStatement : Vala.CodeNode, Vala.Statement {
		public UnlockStatement (Vala.Expression resource, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		/**
		 * Expression representing the resource to be unlocked.
		 */
		public Vala.Expression resource { get; set; }
	}
	/**
	 * An unresolved reference to a symbol.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class UnresolvedSymbol : Vala.Symbol {
		public UnresolvedSymbol (Vala.UnresolvedSymbol? inner, string name, Vala.SourceReference? source_reference = null);
		public Vala.UnresolvedSymbol copy ();
		public static Vala.UnresolvedSymbol? new_from_expression (Vala.Expression expr);
		public override string to_string ();
		/**
		 * The parent of the symbol or null.
		 */
		public Vala.UnresolvedSymbol? inner { get; set; }
		/**
		 * Qualified access to global symbol.
		 */
		public bool qualified { get; set; }
	}
	/**
	 * An unresolved reference to a data type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class UnresolvedType : Vala.DataType {
		public UnresolvedType ();
		public override Vala.DataType copy ();
		/**
		 * Creates a new type reference.
		 *
		 * @param symbol    unresolved type symbol
		 * @param source    reference to source code
		 * @return          newly created type reference
		 */
		public UnresolvedType.from_symbol (Vala.UnresolvedSymbol symbol, Vala.SourceReference? source = null);
		public override bool is_disposable ();
		/**
		 * Creates a new type reference from a code expression.
		 *
		 * @param expr   member access expression
		 * @return       newly created type reference
		 */
		public static Vala.UnresolvedType? new_from_expression (Vala.Expression expr);
		public override string to_qualified_string (Vala.Scope? scope);
		/**
		 * The unresolved reference to a type symbol.
		 */
		public Vala.UnresolvedSymbol unresolved_symbol { get; set; }
	}
	/**
	 * Code visitor to warn about unused attributes
	 */
	[CCode (cheader_filename = "vala.h")]
	public class UsedAttr : Vala.CodeVisitor {
		public Vala.Map<string,Vala.Set<string>> marked;
		public UsedAttr ();
		/**
		 * Traverse the code tree and warn about unused attributes.
		 *
		 * @param context a code context
		 */
		public void check_unused (Vala.CodeContext context);
		/**
		 * Mark the attribute or attribute argument as used by the compiler
		 */
		public void mark (string attribute, string? argument);
		public override void visit_class (Vala.Class cl);
		public override void visit_constant (Vala.Constant c);
		public override void visit_creation_method (Vala.CreationMethod m);
		public override void visit_delegate (Vala.Delegate cb);
		public override void visit_enum (Vala.Enum en);
		public override void visit_error_domain (Vala.ErrorDomain ed);
		public override void visit_field (Vala.Field f);
		public override void visit_formal_parameter (Vala.Parameter p);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_method (Vala.Method m);
		public override void visit_namespace (Vala.Namespace ns);
		public override void visit_property (Vala.Property prop);
		public override void visit_signal (Vala.Signal sig);
		public override void visit_struct (Vala.Struct st);
	}
	/**
	 * A reference to a namespace symbol.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class UsingDirective : Vala.CodeNode {
		/**
		 * Creates a new using directive.
		 *
		 * @param namespace_symbol namespace symbol
		 * @return                 newly created using directive
		 */
		public UsingDirective (Vala.Symbol namespace_symbol, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		/**
		 * The symbol of the namespace this using directive is referring to.
		 */
		public Vala.Symbol namespace_symbol { get; set; }
	}
	/**
	 * A value type, i.e. a struct or an enum type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public abstract class ValueType : Vala.DataType {
		public ValueType (Vala.TypeSymbol type_symbol);
		public override bool check (Vala.CodeContext context);
		public override bool is_disposable ();
		/**
		 * The referred struct or enum.
		 */
		public Vala.TypeSymbol type_symbol { get; set; }
	}
	[CCode (cheader_filename = "vala.h")]
	public class Variable : Vala.Symbol {
		public Variable (Vala.DataType? variable_type, string? name, Vala.Expression? initializer = null, Vala.SourceReference? source_reference = null, Vala.Comment? comment = null);
		/**
		 * The optional initializer expression.
		 */
		public Vala.Expression? initializer { get; set; }
		public bool single_assignment { get; set; }
		/**
		 * The variable type.
		 */
		public Vala.DataType? variable_type { get; set; }
	}
	/**
	 * Represents a [Version] attribute
	 */
	[CCode (cheader_filename = "vala.h")]
	public class VersionAttribute {
		/**
		 * Constructs a new VersionAttribute.
		 *
		 * @param symbol the owner
		 * @return a new VersionAttribute
		 * @see Vala.Symbol
		 */
		public VersionAttribute (Vala.Symbol symbol);
		/**
		 * Check to see if the symbol is experimental, deprecated or not available
		 * and emit a warning if it is.
		 */
		public bool check (Vala.SourceReference? source_ref = null);
		/**
		 * A simple version comparison function.
		 *
		 * @param v1str a version number
		 * @param v2str a version number
		 * @return an integer less than, equal to, or greater than zero, if v1str is <, == or > than v2str
		 * @see GLib.CompareFunc
		 */
		public static int cmp_versions (string v1str, string v2str);
		/**
		 * Specifies whether this symbol has been deprecated.
		 */
		public bool deprecated { get; set; }
		/**
		 * Specifies what version this symbol has been deprecated since.
		 */
		public string? deprecated_since { owned get; set; }
		/**
		 * Specifies whether this symbol is experimental.
		 */
		public bool experimental { get; set; }
		/**
		 * Specifies until which version this symbol is experimental.
		 */
		public string? experimental_until { owned get; set; }
		/**
		 * Specifies the replacement if this symbol has been deprecated.
		 */
		public string? replacement { owned get; set; }
		/**
		 * The minimum version for {@link Vala.VersionAttribute.symbol}
		 */
		public string? since { owned get; set; }
	}
	/**
	 * The void type.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class VoidType : Vala.DataType {
		public VoidType (Vala.SourceReference? source_reference = null);
		public override Vala.DataType copy ();
		public override bool stricter (Vala.DataType type2);
		public override string to_qualified_string (Vala.Scope? scope);
	}
	/**
	 * Represents a while iteration statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class WhileStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new while statement.
		 *
		 * @param condition         loop condition
		 * @param body              loop body
		 * @param source_reference  reference to source code
		 * @return                  newly created while statement
		 */
		public WhileStatement (Vala.Expression condition, Vala.Block body, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		/**
		 * Specifies the loop body.
		 */
		public Vala.Block body { get; set; }
		/**
		 * Specifies the loop condition.
		 */
		public Vala.Expression condition { get; set; }
	}
	/**
	 * Represents a yield statement in the source code.
	 */
	[CCode (cheader_filename = "vala.h")]
	public class YieldStatement : Vala.CodeNode, Vala.Statement {
		/**
		 * Creates a new yield statement.
		 *
		 * @param yield_expression the yield expression
		 * @param source_reference reference to source code
		 * @return                 newly created yield statement
		 */
		public YieldStatement (Vala.Expression? yield_expression, Vala.SourceReference? source_reference = null);
		public override void accept (Vala.CodeVisitor visitor);
		public override void accept_children (Vala.CodeVisitor visitor);
		public override bool check (Vala.CodeContext context);
		public override void emit (Vala.CodeGenerator codegen);
		public override void replace_expression (Vala.Expression old_node, Vala.Expression new_node);
		/**
		 * The expression to yield or the method call to yield to.
		 */
		public Vala.Expression? yield_expression { get; set; }
	}
	/**
	 * Represents a lockable object.
	 */
	[CCode (cheader_filename = "vala.h")]
	public interface Lockable {
		/**
		 * Indicates a specific lockable object beeing actually locked somewhere.
		 */
		public abstract bool get_lock_used ();
		/**
		 * Set this lockable object as beeing locked somewhere.
		 */
		public abstract void set_lock_used (bool used);
	}
	/**
	 * Interface for all statement types.
	 */
	[CCode (cheader_filename = "vala.h")]
	public interface Statement : Vala.CodeNode {
	}
	/**
	 * Represents a position in a source file.
	 */
	[CCode (cheader_filename = "vala.h")]
	public struct SourceLocation {
		public char* pos;
		public int line;
		public int column;
		public SourceLocation (char* _pos, int _line, int _column);
	}
	[CCode (cheader_filename = "vala.h")]
	public enum AssignmentOperator {
		NONE,
		SIMPLE,
		BITWISE_OR,
		BITWISE_AND,
		BITWISE_XOR,
		ADD,
		SUB,
		MUL,
		DIV,
		PERCENT,
		SHIFT_LEFT,
		SHIFT_RIGHT
	}
	[CCode (cheader_filename = "vala.h")]
	public enum BinaryOperator {
		NONE,
		PLUS,
		MINUS,
		MUL,
		DIV,
		MOD,
		SHIFT_LEFT,
		SHIFT_RIGHT,
		LESS_THAN,
		GREATER_THAN,
		LESS_THAN_OR_EQUAL,
		GREATER_THAN_OR_EQUAL,
		EQUALITY,
		INEQUALITY,
		BITWISE_AND,
		BITWISE_OR,
		BITWISE_XOR,
		AND,
		OR,
		IN,
		COALESCE
	}
	[CCode (cheader_filename = "vala.h")]
	public enum CodeWriterType {
		EXTERNAL,
		INTERNAL,
		FAST,
		DUMP
	}
	[CCode (cheader_filename = "vala.h")]
	public enum MarkupTokenType {
		NONE,
		START_ELEMENT,
		END_ELEMENT,
		TEXT,
		EOF;
		public unowned string to_string ();
	}
	[CCode (cheader_filename = "vala.h")]
	public enum MemberBinding {
		INSTANCE,
		CLASS,
		STATIC
	}
	[CCode (cheader_filename = "vala.h")]
	public enum ParameterDirection {
		IN,
		OUT,
		REF
	}
	[CCode (cheader_filename = "vala.h")]
	public enum Profile {
		GOBJECT
	}
	[CCode (cheader_filename = "vala.h")]
	public enum SourceFileType {
		NONE,
		SOURCE,
		PACKAGE,
		FAST
	}
	[CCode (cheader_filename = "vala.h")]
	public enum SymbolAccessibility {
		PRIVATE,
		INTERNAL,
		PROTECTED,
		PUBLIC
	}
	[CCode (cheader_filename = "vala.h")]
	public enum TokenType {
		NONE,
		ABSTRACT,
		AS,
		ASSIGN,
		ASSIGN_ADD,
		ASSIGN_BITWISE_AND,
		ASSIGN_BITWISE_OR,
		ASSIGN_BITWISE_XOR,
		ASSIGN_DIV,
		ASSIGN_MUL,
		ASSIGN_PERCENT,
		ASSIGN_SHIFT_LEFT,
		ASSIGN_SUB,
		ASYNC,
		BASE,
		BITWISE_AND,
		BITWISE_OR,
		BREAK,
		CARRET,
		CASE,
		CATCH,
		CHARACTER_LITERAL,
		CLASS,
		CLOSE_BRACE,
		CLOSE_BRACKET,
		CLOSE_PARENS,
		CLOSE_REGEX_LITERAL,
		CLOSE_TEMPLATE,
		COLON,
		COMMA,
		CONST,
		CONSTRUCT,
		CONTINUE,
		DEFAULT,
		DELEGATE,
		DELETE,
		DIV,
		DO,
		DOUBLE_COLON,
		DOT,
		DYNAMIC,
		ELLIPSIS,
		ELSE,
		ENUM,
		ENSURES,
		ERRORDOMAIN,
		EOF,
		EXTERN,
		FALSE,
		FINALLY,
		FOR,
		FOREACH,
		GET,
		HASH,
		IDENTIFIER,
		IF,
		IN,
		INLINE,
		INTEGER_LITERAL,
		INTERFACE,
		INTERNAL,
		INTERR,
		IS,
		LAMBDA,
		LOCK,
		MINUS,
		NAMESPACE,
		NEW,
		NULL,
		OUT,
		OP_AND,
		OP_COALESCING,
		OP_DEC,
		OP_EQ,
		OP_GE,
		OP_GT,
		OP_INC,
		OP_LE,
		OP_LT,
		OP_NE,
		OP_NEG,
		OP_OR,
		OP_PTR,
		OP_SHIFT_LEFT,
		OPEN_BRACE,
		OPEN_BRACKET,
		OPEN_PARENS,
		OPEN_REGEX_LITERAL,
		OPEN_TEMPLATE,
		OVERRIDE,
		OWNED,
		PARAMS,
		PERCENT,
		PLUS,
		PRIVATE,
		PROTECTED,
		PUBLIC,
		REAL_LITERAL,
		REF,
		REGEX_LITERAL,
		REQUIRES,
		RETURN,
		SEALED,
		SEMICOLON,
		SET,
		SIGNAL,
		SIZEOF,
		STAR,
		STATIC,
		STRING_LITERAL,
		STRUCT,
		SWITCH,
		TEMPLATE_STRING_LITERAL,
		THIS,
		THROW,
		THROWS,
		TILDE,
		TRUE,
		TRY,
		TYPEOF,
		UNOWNED,
		USING,
		VAR,
		VERBATIM_STRING_LITERAL,
		VIRTUAL,
		VOID,
		VOLATILE,
		WEAK,
		WHILE,
		YIELD;
		public unowned string to_string ();
	}
	[CCode (cheader_filename = "vala.h")]
	public enum UnaryOperator {
		NONE,
		PLUS,
		MINUS,
		LOGICAL_NEGATION,
		BITWISE_COMPLEMENT,
		INCREMENT,
		DECREMENT,
		REF,
		OUT
	}
	[CCode (cheader_filename = "vala.h")]
	public errordomain ParseError {
		FAILED,
		SYNTAX
	}
}
/* codegen.vapi generated by valac, do not modify. */

namespace Vala {
	[CCode (cheader_filename = "valacodegen.h")]
	public class CCodeArrayModule : Vala.CCodeMethodCallModule {
		public CCodeArrayModule ();
		public override string? append_struct_array_free (Vala.Struct st);
		public override void append_vala_array_free ();
		public override void append_vala_array_length ();
		public override void append_vala_array_move ();
		public override Vala.TargetValue? copy_value (Vala.TargetValue value, Vala.CodeNode node);
		public override Vala.CCodeExpression destroy_value (Vala.TargetValue value, bool is_macro_definition = false);
		public override Vala.CCodeParameter generate_parameter (Vala.Parameter param, Vala.CCodeFile decl_space, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.Map<int,Vala.CCodeExpression>? carg_map);
		public override Vala.CCodeExpression get_array_length_cexpression (Vala.Expression array_expr, int dim = -1);
		public override string get_array_length_cname (string array_cname, int dim);
		public override Vala.CCodeExpression get_array_length_cvalue (Vala.TargetValue value, int dim = -1);
		public override string get_array_size_cname (string array_cname);
		public override Vala.CCodeExpression? get_dup_func_expression (Vala.DataType type, Vala.SourceReference? source_reference, bool is_chainup);
		public override string get_parameter_array_length_cname (Vala.Parameter param, int dim);
		public override void visit_array_creation_expression (Vala.ArrayCreationExpression expr);
		public override void visit_assignment (Vala.Assignment assignment);
		public override void visit_element_access (Vala.ElementAccess expr);
		public override void visit_slice_expression (Vala.SliceExpression expr);
	}
	/**
	 * The link between an assignment and generated code.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class CCodeAssignmentModule : Vala.CCodeMemberAccessModule {
		public CCodeAssignmentModule ();
		public override void store_field (Vala.Field field, Vala.TargetValue? instance, Vala.TargetValue value);
		public override void store_local (Vala.LocalVariable local, Vala.TargetValue value, bool initializer);
		public override void store_parameter (Vala.Parameter param, Vala.TargetValue _value, bool capturing_parameter = false);
		public override void store_value (Vala.TargetValue lvalue, Vala.TargetValue value);
		public override void visit_assignment (Vala.Assignment assignment);
	}
	/**
	 * Cache for the CCode attribute
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class CCodeAttribute : Vala.AttributeCache {
		public CCodeAttribute (Vala.CodeNode node);
		public bool array_length { get; }
		public string? array_length_expr { get; private set; }
		public string? array_length_name { get; private set; }
		public string? array_length_type { get; private set; }
		public bool array_null_terminated { get; }
		public string const_name { get; }
		public string copy_function { get; }
		public string ctype { get; }
		public string default_value { get; }
		public bool delegate_target { get; private set; }
		public string delegate_target_name { get; }
		public string destroy_function { get; }
		public string finish_name { get; }
		public string finish_real_name { get; }
		public string finish_vfunc_name { get; }
		public string free_function { get; }
		public bool free_function_address_of { get; }
		public string get_value_function { get; }
		public string header_filenames { get; }
		public string lower_case_prefix { get; }
		public string lower_case_suffix { get; }
		public string marshaller_type_name { get; }
		public string name { get; }
		public string param_spec_function { get; }
		public double pos { get; }
		public string prefix { get; }
		public string real_name { get; }
		public string ref_function { get; }
		public bool ref_function_void { get; }
		public string ref_sink_function { get; }
		public string sentinel { get; private set; }
		public string set_value_function { get; }
		public string take_value_function { get; }
		public string type_id { get; }
		public string type_name { get; }
		public string unref_function { get; }
		public string vfunc_name { get; }
	}
	/**
	 * Code visitor generating C Code.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public abstract class CCodeBaseModule : Vala.CodeGenerator {
		public class EmitContext {
			public Vala.CCodeFunction ccode;
			public Vala.ArrayList<Vala.CCodeFunction> ccode_stack;
			public Vala.Map<Vala.LocalVariable,int> closure_variable_clash_map;
			public Vala.Map<string,int> closure_variable_count_map;
			public Vala.CatchClause current_catch;
			public bool current_method_inner_error;
			public bool current_method_return;
			public Vala.Symbol? current_symbol;
			public Vala.TryStatement current_try;
			public int next_temp_var_id;
			public Vala.ArrayList<Vala.Symbol> symbol_stack;
			public Vala.ArrayList<Vala.TargetValue> temp_ref_values;
			public Vala.Map<string,string> variable_name_map;
			public EmitContext (Vala.Symbol? symbol = null);
			public void pop_symbol ();
			public void push_symbol (Vala.Symbol symbol);
		}
		public Vala.CCodeBaseModule.EmitContext base_finalize_context;
		public Vala.CCodeBaseModule.EmitContext base_init_context;
		public Vala.DataType bool_type;
		public static int ccode_attribute_cache_index;
		public Vala.CCodeFile cfile;
		public Vala.DataType char_type;
		public Vala.CCodeBaseModule.EmitContext class_finalize_context;
		public Vala.CCodeBaseModule.EmitContext class_init_context;
		public Vala.CCodeStruct closure_struct;
		public Vala.CCodeLineDirective? current_line;
		public Vala.TypeSymbol dbus_proxy_type;
		public Vala.DataType double_type;
		public Vala.CCodeBaseModule.EmitContext emit_context;
		public Vala.DataType float_type;
		public Vala.TypeSymbol garray_type;
		public Vala.TypeSymbol gbytearray_type;
		public Vala.Struct gcond_type;
		public Vala.DataType gdestroynotify_type;
		public Vala.ErrorType gerror_type;
		public Vala.Class glist_type;
		public Vala.Struct gmutex_type;
		public Vala.Class gnode_type;
		public Vala.TypeSymbol gobject_type;
		public Vala.TypeSymbol gptrarray_type;
		public Vala.DataType gquark_type;
		public Vala.Class gqueue_type;
		public Vala.Struct grecmutex_type;
		public Vala.Struct grwlock_type;
		public Vala.Class gslist_type;
		public Vala.Class gsource_type;
		public Vala.TypeSymbol gstringbuilder_type;
		public Vala.TypeSymbol gthreadpool_type;
		public Vala.Class gtk_widget_type;
		public Vala.TypeSymbol gtype_type;
		public Vala.Struct gvalue_type;
		public Vala.Class gvaluearray_type;
		public bool gvaluecollector_h_needed;
		public Vala.Class gvariant_type;
		public Vala.CCodeFile header_file;
		public bool in_plugin;
		public Vala.CCodeBaseModule.EmitContext instance_finalize_context;
		public Vala.CCodeBaseModule.EmitContext instance_init_context;
		public Vala.DataType int16_type;
		public Vala.DataType int32_type;
		public Vala.DataType int64_type;
		public Vala.DataType int8_type;
		public Vala.DataType int_type;
		public Vala.CCodeFile internal_header_file;
		public Vala.DataType long_type;
		public string module_init_param_name;
		public Vala.Struct mutex_type;
		public int next_coroutine_state;
		public int next_regex_id;
		public Vala.CCodeStruct param_spec_struct;
		public Vala.Set<string> predefined_marshal_set;
		public Vala.CCodeEnum prop_enum;
		public Vala.DataType regex_type;
		public bool requires_array_free;
		public bool requires_array_length;
		public bool requires_array_move;
		public bool requires_assert;
		public bool requires_clear_mutex;
		public Vala.Symbol root_symbol;
		public Vala.DataType short_type;
		public Vala.DataType string_type;
		public Vala.TypeSymbol type_module_type;
		public Vala.DataType uchar_type;
		public Vala.DataType uint16_type;
		public Vala.DataType uint32_type;
		public Vala.DataType uint64_type;
		public Vala.DataType uint8_type;
		public Vala.DataType uint_type;
		public Vala.DataType ulong_type;
		public Vala.DataType? unichar_type;
		public Vala.Set<string> user_marshal_set;
		public Vala.DataType ushort_type;
		public Vala.DataType void_type;
		public Vala.Set<string> wrappers;
		public CCodeBaseModule ();
		public bool add_generated_external_symbol (Vala.Symbol external_symbol);
		public void add_generic_type_arguments (Vala.Map<int,Vala.CCodeExpression> arg_map, Vala.List<Vala.DataType> type_args, Vala.CodeNode expr, bool is_chainup = false, Vala.List<Vala.TypeParameter>? type_parameters = null);
		public virtual void add_simple_check (Vala.CodeNode node, bool always_fails = false);
		public bool add_symbol_declaration (Vala.CCodeFile decl_space, Vala.Symbol sym, string name);
		public bool add_wrapper (string wrapper_name);
		public void append_array_length (Vala.Expression expr, Vala.CCodeExpression size);
		public void append_local_free (Vala.Symbol sym, bool stop_at_loop = false, Vala.CodeNode? stop_at = null);
		protected virtual void append_scope_free (Vala.Symbol sym, Vala.CodeNode? stop_at = null);
		public virtual string? append_struct_array_free (Vala.Struct st);
		public virtual void append_vala_array_free ();
		public virtual void append_vala_array_length ();
		public virtual void append_vala_array_move ();
		public void append_vala_clear_mutex (string typename, string funcprefix);
		public void check_type (Vala.DataType type);
		public Vala.CCodeExpression convert_from_generic_pointer (Vala.CCodeExpression cexpr, Vala.DataType actual_type);
		public Vala.CCodeExpression convert_to_generic_pointer (Vala.CCodeExpression cexpr, Vala.DataType actual_type);
		public virtual Vala.TargetValue? copy_value (Vala.TargetValue value, Vala.CodeNode node);
		public override Vala.LocalVariable create_local (Vala.DataType type);
		public void create_postcondition_statement (Vala.Expression postcondition);
		/**
		 * Create a temporary variable and return lvalue access to it
		 */
		public Vala.TargetValue create_temp_value (Vala.DataType type, bool init, Vala.CodeNode node_reference, bool? value_owned = null);
		public virtual void create_type_check_statement (Vala.CodeNode method_node, Vala.DataType ret_type, Vala.TypeSymbol t, bool non_null, string var_name);
		public Vala.CCodeExpression? default_value_for_type (Vala.DataType type, bool initializer_expression);
		public virtual Vala.CCodeExpression? deserialize_expression (Vala.DataType type, Vala.CCodeExpression variant_expr, Vala.CCodeExpression? expr, Vala.CCodeExpression? error_expr = null, out bool may_fail = null);
		public Vala.CCodeExpression destroy_field (Vala.Field field, Vala.TargetValue? instance);
		public Vala.CCodeExpression destroy_local (Vala.LocalVariable local);
		public Vala.CCodeExpression destroy_parameter (Vala.Parameter param);
		public virtual Vala.CCodeExpression destroy_value (Vala.TargetValue value, bool is_macro_definition = false);
		public override void emit (Vala.CodeContext context);
		public void emit_temp_var (Vala.LocalVariable local);
		public virtual void generate_class_declaration (Vala.Class cl, Vala.CCodeFile decl_space);
		public virtual void generate_class_struct_declaration (Vala.Class cl, Vala.CCodeFile decl_space);
		public void generate_constant_declaration (Vala.Constant c, Vala.CCodeFile decl_space, bool definition = false);
		public virtual void generate_cparameters (Vala.Method m, Vala.CCodeFile decl_space, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.CCodeFunction func, Vala.CCodeFunctionDeclarator? vdeclarator = null, Vala.Map<int,Vala.CCodeExpression>? carg_map = null, Vala.CCodeFunctionCall? vcall = null, int direction = 3);
		public virtual void generate_delegate_declaration (Vala.Delegate d, Vala.CCodeFile decl_space);
		protected string generate_dup_func_wrapper (Vala.DataType type);
		public virtual void generate_dynamic_method_wrapper (Vala.DynamicMethod method);
		public virtual bool generate_enum_declaration (Vala.Enum en, Vala.CCodeFile decl_space);
		public virtual void generate_error_domain_declaration (Vala.ErrorDomain edomain, Vala.CCodeFile decl_space);
		public void generate_field_declaration (Vala.Field f, Vala.CCodeFile decl_space);
		protected string generate_free_func_wrapper (Vala.DataType type);
		protected string generate_free_function_address_of_wrapper (Vala.DataType type);
		public Vala.CCodeFunctionCall generate_instance_cast (Vala.CCodeExpression expr, Vala.TypeSymbol type);
		public virtual void generate_interface_declaration (Vala.Interface iface, Vala.CCodeFile decl_space);
		public virtual void generate_method_declaration (Vala.Method m, Vala.CCodeFile decl_space);
		public void generate_property_accessor_declaration (Vala.PropertyAccessor acc, Vala.CCodeFile decl_space);
		public virtual string generate_ready_function (Vala.Method m);
		public virtual void generate_struct_declaration (Vala.Struct st, Vala.CCodeFile decl_space);
		public void generate_type_declaration (Vala.DataType type, Vala.CCodeFile decl_space);
		public Vala.CCodeExpression get_array_length_cexpr (Vala.TargetValue value);
		public virtual Vala.CCodeExpression get_array_length_cexpression (Vala.Expression array_expr, int dim = -1);
		public virtual string get_array_length_cname (string array_cname, int dim);
		public virtual Vala.CCodeExpression get_array_length_cvalue (Vala.TargetValue value, int dim = -1);
		public Vala.List<Vala.CCodeExpression>? get_array_lengths (Vala.Expression expr);
		public bool get_array_null_terminated (Vala.TargetValue value);
		public virtual string get_array_size_cname (string array_cname);
		public Vala.CCodeExpression? get_array_size_cvalue (Vala.TargetValue value);
		public int get_block_id (Vala.Block b);
		public static bool get_ccode_array_length (Vala.CodeNode node);
		public static string? get_ccode_array_length_expr (Vala.CodeNode node);
		public static string? get_ccode_array_length_name (Vala.CodeNode node);
		public static double get_ccode_array_length_pos (Vala.CodeNode node);
		public static string? get_ccode_array_length_type (Vala.CodeNode node);
		public static bool get_ccode_array_null_terminated (Vala.CodeNode node);
		public static Vala.CCodeAttribute get_ccode_attribute (Vala.CodeNode node);
		public static string get_ccode_blurb (Vala.Property prop);
		public static bool get_ccode_concrete_accessor (Vala.Property p);
		public static string get_ccode_const_name (Vala.CodeNode node);
		public static string get_ccode_constructv_name (Vala.CreationMethod m);
		public static string get_ccode_copy_function (Vala.TypeSymbol sym);
		public Vala.CCodeDeclaratorSuffix? get_ccode_declarator_suffix (Vala.DataType type);
		public static string get_ccode_default_value (Vala.TypeSymbol sym);
		public static bool get_ccode_delegate_target (Vala.CodeNode node);
		public static string get_ccode_delegate_target_name (Vala.Variable variable);
		public static double get_ccode_delegate_target_pos (Vala.CodeNode node);
		public static string get_ccode_destroy_function (Vala.TypeSymbol sym);
		public static double get_ccode_destroy_notify_pos (Vala.CodeNode node);
		public static string? get_ccode_dup_function (Vala.TypeSymbol sym);
		public static string get_ccode_finish_name (Vala.Method m);
		public static string get_ccode_finish_real_name (Vala.Method m);
		public static string get_ccode_finish_vfunc_name (Vala.Method m);
		public static string get_ccode_free_function (Vala.TypeSymbol sym);
		public static bool get_ccode_free_function_address_of (Vala.Class cl);
		public static double get_ccode_generic_type_pos (Vala.Method m);
		public static string get_ccode_get_value_function (Vala.CodeNode sym);
		public static bool get_ccode_has_copy_function (Vala.Struct st);
		public static bool get_ccode_has_destroy_function (Vala.Struct st);
		public static bool get_ccode_has_generic_type_parameter (Vala.Method m);
		public static bool get_ccode_has_new_function (Vala.Method m);
		public static bool get_ccode_has_type_id (Vala.TypeSymbol sym);
		public static string get_ccode_header_filenames (Vala.Symbol sym);
		public static double get_ccode_instance_pos (Vala.CodeNode node);
		public static bool get_ccode_is_gboxed (Vala.TypeSymbol sym);
		public static string get_ccode_lower_case_name (Vala.CodeNode node, string? infix = null);
		public static string get_ccode_lower_case_prefix (Vala.Symbol sym);
		public static string get_ccode_lower_case_suffix (Vala.Symbol sym);
		public static string get_ccode_marshaller_type_name (Vala.CodeNode node);
		public static string get_ccode_name (Vala.CodeNode node);
		public static string get_ccode_nick (Vala.Property prop);
		public static bool get_ccode_no_accessor_method (Vala.Property p);
		public static bool get_ccode_notify (Vala.Property prop);
		public static string get_ccode_param_spec_function (Vala.CodeNode sym);
		public static double get_ccode_pos (Vala.Parameter param);
		public static string get_ccode_prefix (Vala.Symbol sym);
		public static string get_ccode_real_name (Vala.Symbol sym);
		public static string get_ccode_ref_function (Vala.TypeSymbol sym);
		public static bool get_ccode_ref_function_void (Vala.Class cl);
		public static string get_ccode_ref_sink_function (Vala.ObjectTypeSymbol sym);
		public static string get_ccode_sentinel (Vala.Method m);
		public static string get_ccode_set_value_function (Vala.CodeNode sym);
		public static bool get_ccode_simple_generics (Vala.Method m);
		public static string get_ccode_take_value_function (Vala.CodeNode sym);
		public static string? get_ccode_type (Vala.CodeNode node);
		public static string get_ccode_type_check_function (Vala.TypeSymbol sym);
		public static string get_ccode_type_id (Vala.CodeNode node);
		public static string get_ccode_type_name (Vala.Interface iface);
		public static string get_ccode_unref_function (Vala.ObjectTypeSymbol sym);
		public static string get_ccode_upper_case_name (Vala.Symbol sym, string? infix = null);
		public static string get_ccode_vfunc_name (Vala.Method m);
		public Vala.CCodeExpression? get_ccodenode (Vala.Expression node);
		public string? get_ctype (Vala.TargetValue value);
		public Vala.CCodeExpression? get_cvalue (Vala.Expression expr);
		public Vala.CCodeExpression? get_cvalue_ (Vala.TargetValue value);
		public static Vala.DataType get_data_type_for_symbol (Vala.TypeSymbol sym);
		public Vala.CCodeExpression? get_delegate_target (Vala.Expression expr);
		public virtual Vala.CCodeExpression get_delegate_target_cexpression (Vala.Expression delegate_expr, out Vala.CCodeExpression delegate_target_destroy_notify);
		public virtual string get_delegate_target_cname (string delegate_cname);
		public virtual Vala.CCodeExpression get_delegate_target_cvalue (Vala.TargetValue value);
		public Vala.CCodeExpression? get_delegate_target_destroy_notify (Vala.Expression expr);
		public virtual string get_delegate_target_destroy_notify_cname (string delegate_cname);
		public virtual Vala.CCodeExpression get_delegate_target_destroy_notify_cvalue (Vala.TargetValue value);
		public Vala.CCodeExpression? get_destroy0_func_expression (Vala.DataType type, bool is_chainup = false);
		public Vala.CCodeExpression? get_destroy_func_expression (Vala.DataType type, bool is_chainup = false);
		public virtual Vala.CCodeExpression? get_dup_func_expression (Vala.DataType type, Vala.SourceReference? source_reference, bool is_chainup = false);
		public virtual string get_dynamic_property_getter_cname (Vala.DynamicProperty node);
		public virtual string get_dynamic_property_setter_cname (Vala.DynamicProperty node);
		public virtual string get_dynamic_signal_cname (Vala.DynamicSignal node);
		public virtual string get_dynamic_signal_connect_after_wrapper_name (Vala.DynamicSignal node);
		public virtual string get_dynamic_signal_connect_wrapper_name (Vala.DynamicSignal node);
		public virtual string get_dynamic_signal_disconnect_wrapper_name (Vala.DynamicSignal node);
		public static Vala.CCodeConstant get_enum_value_canonical_cconstant (Vala.EnumValue ev);
		public abstract Vala.TargetValue get_field_cvalue (Vala.Field field, Vala.TargetValue? instance);
		public virtual Vala.CCodeExpression get_implicit_cast_expression (Vala.CCodeExpression source_cexpr, Vala.DataType? expression_type, Vala.DataType? target_type, Vala.CodeNode? node);
		public Vala.CCodeExpression get_local_cexpression (Vala.LocalVariable local);
		public string get_local_cname (Vala.LocalVariable local);
		public abstract Vala.TargetValue get_local_cvalue (Vala.LocalVariable local);
		public bool get_lvalue (Vala.TargetValue value);
		public bool get_non_null (Vala.TargetValue value);
		public int get_param_pos (double param_pos, bool ellipsis = false);
		public virtual Vala.CCodeFunctionCall get_param_spec (Vala.Property prop);
		public virtual string get_parameter_array_length_cname (Vala.Parameter param, int dim);
		public abstract Vala.TargetValue get_parameter_cvalue (Vala.Parameter param);
		public Vala.CCodeConstant get_property_canonical_cconstant (Vala.Property prop);
		public static string get_quark_name (Vala.ErrorDomain edomain);
		public Vala.CCodeExpression get_result_cexpression (string cname = "result");
		public Vala.CCodeConstant get_signal_canonical_constant (Vala.Signal sig, string? detail = null);
		public virtual Vala.CCodeFunctionCall get_signal_creation (Vala.Signal sig, Vala.TypeSymbol type);
		public bool get_signal_has_emitter (Vala.Signal sig);
		public string get_symbol_lock_name (string symname);
		public Vala.LocalVariable get_temp_variable (Vala.DataType type, bool value_owned = true, Vala.CodeNode? node_reference = null, bool init = true);
		public Vala.CCodeExpression get_this_cexpression ();
		public Vala.DataType? get_this_type ();
		public Vala.CCodeExpression get_type_id_expression (Vala.DataType type, bool is_chainup = false);
		public Vala.CCodeIdentifier get_value_setter_function (Vala.DataType type_reference);
		public Vala.CCodeIdentifier get_value_taker_function (Vala.DataType type_reference);
		public Vala.CCodeExpression get_variable_cexpression (string name);
		public string get_variable_cname (string name);
		public Vala.CCodeExpression? handle_struct_argument (Vala.Parameter? param, Vala.Expression arg, Vala.CCodeExpression? cexpr);
		public bool is_constant_ccode_expression (Vala.CCodeExpression cexpr);
		public virtual bool is_gobject_property (Vala.Property prop);
		public bool is_in_constructor ();
		public bool is_in_coroutine ();
		public bool is_in_destructor ();
		public bool is_lvalue_access_allowed (Vala.DataType type);
		/**
		 * Returns whether the passed cexpr is a pure expression, i.e. an
		 * expression without side-effects.
		 */
		public bool is_pure_ccode_expression (Vala.CCodeExpression cexpr);
		public static bool is_reference_counting (Vala.TypeSymbol sym);
		public bool is_simple_struct_creation (Vala.Variable variable, Vala.Expression expr);
		/**
		 * Load a temporary variable returning unowned or owned rvalue access to it, depending on the ownership of the value type.
		 */
		public Vala.TargetValue load_temp_value (Vala.TargetValue lvalue);
		public abstract Vala.TargetValue load_this_parameter (Vala.TypeSymbol sym);
		public abstract Vala.TargetValue load_variable (Vala.Variable variable, Vala.TargetValue value);
		public virtual bool method_has_wrapper (Vala.Method method);
		public unowned Vala.Block? next_closure_block (Vala.Symbol sym);
		public bool no_implicit_copy (Vala.DataType type);
		public void pop_context ();
		public void pop_function ();
		public void pop_line ();
		public void push_context (Vala.CCodeBaseModule.EmitContext emit_context);
		public void push_function (Vala.CCodeFunction func);
		public void push_line (Vala.SourceReference? source_reference);
		public virtual void register_dbus_info (Vala.CCodeBlock block, Vala.ObjectTypeSymbol bindable);
		public bool requires_copy (Vala.DataType type);
		public bool requires_destroy (Vala.DataType type);
		public void return_default_value (Vala.DataType return_type);
		public void return_out_parameter (Vala.Parameter param);
		public virtual Vala.CCodeExpression? serialize_expression (Vala.DataType type, Vala.CCodeExpression expr);
		public void set_array_size_cvalue (Vala.TargetValue value, Vala.CCodeExpression? cvalue);
		public void set_cvalue (Vala.Expression expr, Vala.CCodeExpression? cvalue);
		public void set_delegate_target (Vala.Expression expr, Vala.CCodeExpression? delegate_target);
		public void set_delegate_target_destroy_notify (Vala.Expression expr, Vala.CCodeExpression? destroy_notify);
		public void store_property (Vala.Property prop, Vala.Expression? instance, Vala.TargetValue value);
		/**
		 * Store a value in a temporary variable and return unowned or owned rvalue access to it, depending on the ownership of the given type.
		 */
		public Vala.TargetValue store_temp_value (Vala.TargetValue initializer, Vala.CodeNode node_reference, bool? value_owned = null);
		public abstract void store_value (Vala.TargetValue lvalue, Vala.TargetValue value);
		public Vala.TargetValue transform_value (Vala.TargetValue value, Vala.DataType? target_type, Vala.CodeNode node);
		public Vala.CCodeExpression? try_cast_value_to_type (Vala.CCodeExpression ccodeexpr, Vala.DataType from, Vala.DataType to, Vala.Expression? expr = null);
		public Vala.TargetValue? try_cast_variant_to_type (Vala.TargetValue value, Vala.DataType to, Vala.CodeNode? node = null);
		public bool variable_accessible_in_finally (Vala.LocalVariable local);
		public override void visit_addressof_expression (Vala.AddressofExpression expr);
		public override void visit_base_access (Vala.BaseAccess expr);
		public override void visit_binary_expression (Vala.BinaryExpression expr);
		public override void visit_block (Vala.Block b);
		public override void visit_boolean_literal (Vala.BooleanLiteral expr);
		public override void visit_cast_expression (Vala.CastExpression expr);
		public override void visit_character_literal (Vala.CharacterLiteral expr);
		public override void visit_class (Vala.Class cl);
		public override void visit_constant (Vala.Constant c);
		public override void visit_declaration_statement (Vala.DeclarationStatement stmt);
		public override void visit_delete_statement (Vala.DeleteStatement stmt);
		public override void visit_destructor (Vala.Destructor d);
		public override void visit_end_full_expression (Vala.Expression expr);
		public override void visit_enum (Vala.Enum en);
		public override void visit_expression (Vala.Expression expr);
		public override void visit_expression_statement (Vala.ExpressionStatement stmt);
		public override void visit_field (Vala.Field f);
		public override void visit_formal_parameter (Vala.Parameter p);
		public override void visit_initializer_list (Vala.InitializerList list);
		public override void visit_integer_literal (Vala.IntegerLiteral expr);
		public override void visit_lambda_expression (Vala.LambdaExpression lambda);
		public override void visit_local_variable (Vala.LocalVariable local);
		public override void visit_lock_statement (Vala.LockStatement stmt);
		public void visit_member (Vala.Symbol m);
		public override void visit_named_argument (Vala.NamedArgument expr);
		public override void visit_null_literal (Vala.NullLiteral expr);
		public override void visit_object_creation_expression (Vala.ObjectCreationExpression expr);
		public override void visit_pointer_indirection (Vala.PointerIndirection expr);
		public override void visit_postfix_expression (Vala.PostfixExpression expr);
		public override void visit_property (Vala.Property prop);
		public override void visit_property_accessor (Vala.PropertyAccessor acc);
		public override void visit_real_literal (Vala.RealLiteral expr);
		public override void visit_reference_transfer_expression (Vala.ReferenceTransferExpression expr);
		public override void visit_regex_literal (Vala.RegexLiteral expr);
		public override void visit_return_statement (Vala.ReturnStatement stmt);
		public override void visit_sizeof_expression (Vala.SizeofExpression expr);
		public override void visit_source_file (Vala.SourceFile source_file);
		public override void visit_string_literal (Vala.StringLiteral expr);
		public override void visit_type_check (Vala.TypeCheck expr);
		public override void visit_typeof_expression (Vala.TypeofExpression expr);
		public override void visit_unary_expression (Vala.UnaryExpression expr);
		public override void visit_unlock_statement (Vala.UnlockStatement stmt);
		public Vala.CCodeFunction ccode { get; }
		public Vala.CodeContext context { get; set; }
		public Vala.CatchClause current_catch { get; set; }
		public Vala.Class? current_class { get; }
		public Vala.Block? current_closure_block { get; }
		public Vala.Constructor? current_constructor { get; }
		public Vala.Destructor? current_destructor { get; }
		public Vala.Method? current_method { get; }
		public bool current_method_inner_error { get; set; }
		public bool current_method_return { get; set; }
		public Vala.PropertyAccessor? current_property_accessor { get; }
		public Vala.DataType? current_return_type { get; }
		public Vala.Symbol current_symbol { get; }
		public Vala.TryStatement current_try { get; set; }
		public Vala.TypeSymbol? current_type_symbol { get; }
		public bool in_creation_method { get; }
		public int next_temp_var_id { get; set; }
		public Vala.ArrayList<Vala.TargetValue> temp_ref_values { get; }
		public Vala.Map<string,string> variable_name_map { get; }
	}
	/**
	 * Interface to the C compiler.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class CCodeCompiler {
		public CCodeCompiler ();
		/**
		 * Compile generated C code to object code and optionally link object
		 * files.
		 *
		 * @param context a code context
		 */
		public void compile (Vala.CodeContext context, string? cc_command, string[] cc_options, string? pkg_config_command = null);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public abstract class CCodeControlFlowModule : Vala.CCodeMethodModule {
		public CCodeControlFlowModule ();
		public override void visit_break_statement (Vala.BreakStatement stmt);
		public override void visit_continue_statement (Vala.ContinueStatement stmt);
		public override void visit_foreach_statement (Vala.ForeachStatement stmt);
		public override void visit_if_statement (Vala.IfStatement stmt);
		public override void visit_loop (Vala.Loop stmt);
		public override void visit_switch_label (Vala.SwitchLabel label);
		public override void visit_switch_statement (Vala.SwitchStatement stmt);
	}
	/**
	 * The link between an assignment and generated code.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class CCodeDelegateModule : Vala.CCodeArrayModule {
		public CCodeDelegateModule ();
		public override void generate_delegate_declaration (Vala.Delegate d, Vala.CCodeFile decl_space);
		public string generate_delegate_wrapper (Vala.Method m, Vala.DelegateType dt, Vala.CodeNode? node);
		public override Vala.CCodeParameter generate_parameter (Vala.Parameter param, Vala.CCodeFile decl_space, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.Map<int,Vala.CCodeExpression>? carg_map);
		public override Vala.CCodeExpression get_delegate_target_cexpression (Vala.Expression delegate_expr, out Vala.CCodeExpression delegate_target_destroy_notify);
		public override string get_delegate_target_cname (string delegate_cname);
		public override Vala.CCodeExpression get_delegate_target_cvalue (Vala.TargetValue value);
		public override string get_delegate_target_destroy_notify_cname (string delegate_cname);
		public override Vala.CCodeExpression get_delegate_target_destroy_notify_cvalue (Vala.TargetValue value);
		public override Vala.CCodeExpression get_implicit_cast_expression (Vala.CCodeExpression source_cexpr, Vala.DataType? expression_type, Vala.DataType? target_type, Vala.CodeNode? node);
		public override void visit_delegate (Vala.Delegate d);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public abstract class CCodeMemberAccessModule : Vala.CCodeControlFlowModule {
		public CCodeMemberAccessModule ();
		public override Vala.TargetValue get_field_cvalue (Vala.Field field, Vala.TargetValue? instance);
		public override Vala.TargetValue get_local_cvalue (Vala.LocalVariable local);
		public override Vala.TargetValue get_parameter_cvalue (Vala.Parameter param);
		public override Vala.TargetValue load_field (Vala.Field field, Vala.TargetValue? instance);
		public override Vala.TargetValue load_local (Vala.LocalVariable local);
		public override Vala.TargetValue load_parameter (Vala.Parameter param);
		public override Vala.TargetValue load_this_parameter (Vala.TypeSymbol sym);
		public override Vala.TargetValue load_variable (Vala.Variable variable, Vala.TargetValue value);
		public override void visit_member_access (Vala.MemberAccess expr);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class CCodeMethodCallModule : Vala.CCodeAssignmentModule {
		public CCodeMethodCallModule ();
		public override void visit_method_call (Vala.MethodCall expr);
	}
	/**
	 * The link between a method and generated code.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public abstract class CCodeMethodModule : Vala.CCodeStructModule {
		public CCodeMethodModule ();
		public void complete_async ();
		public override void generate_cparameters (Vala.Method m, Vala.CCodeFile decl_space, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.CCodeFunction func, Vala.CCodeFunctionDeclarator? vdeclarator = null, Vala.Map<int,Vala.CCodeExpression>? carg_map = null, Vala.CCodeFunctionCall? vcall = null, int direction = 3);
		public override void generate_method_declaration (Vala.Method m, Vala.CCodeFile decl_space);
		public virtual void generate_method_result_declaration (Vala.Method m, Vala.CCodeFile decl_space, Vala.CCodeFunction cfunc, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.Map<int,Vala.CCodeExpression>? carg_map);
		public virtual Vala.CCodeParameter generate_parameter (Vala.Parameter param, Vala.CCodeFile decl_space, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.Map<int,Vala.CCodeExpression>? carg_map);
		public void generate_vfunc (Vala.Method m, Vala.DataType return_type, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.Map<int,Vala.CCodeExpression> carg_map, string suffix = "", int direction = 3);
		public override bool method_has_wrapper (Vala.Method method);
		public override void visit_creation_method (Vala.CreationMethod m);
		/**
		 * This function generates the code the given method. If the method is
		 * a constructor, _construct is generated, unless it's variadic, in which
		 * case _constructv is generated (and _construct is generated together
		 * with _new in visit_creation_method).
		 */
		public override void visit_method (Vala.Method m);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public abstract class CCodeStructModule : Vala.CCodeBaseModule {
		public CCodeStructModule ();
		public override void generate_struct_declaration (Vala.Struct st, Vala.CCodeFile decl_space);
		public override void visit_struct (Vala.Struct st);
	}
	/**
	 * A C type, used only for code generation purposes.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class CType : Vala.DataType {
		public CType (string ctype_name);
		public override Vala.DataType copy ();
		/**
		 * The name of the C type.
		 */
		public string ctype_name { get; set; }
	}
	/**
	 * C function to register a class at runtime.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class ClassRegisterFunction : Vala.TypeRegisterFunction {
		/**
		 * Creates a new C function to register the specified class at runtime.
		 *
		 * @param cl a class
		 * @return   newly created class register function
		 */
		public ClassRegisterFunction (Vala.Class cl, Vala.CodeContext context);
		public override Vala.SymbolAccessibility get_accessibility ();
		public override string get_base_finalize_func_name ();
		public override string get_base_init_func_name ();
		public override string get_class_finalize_func_name ();
		public override string get_class_init_func_name ();
		public override string? get_gtype_value_table_collect_value_function_name ();
		public override string? get_gtype_value_table_copy_function_name ();
		public override string? get_gtype_value_table_free_function_name ();
		public override string? get_gtype_value_table_init_function_name ();
		public override string? get_gtype_value_table_lcopy_value_function_name ();
		public override string? get_gtype_value_table_peek_pointer_function_name ();
		public override string get_instance_init_func_name ();
		public override string get_instance_struct_size ();
		public override string get_parent_type_name ();
		public override Vala.TypeSymbol get_type_declaration ();
		public override string get_type_flags ();
		public override Vala.CCodeFragment get_type_interface_init_declaration ();
		public override void get_type_interface_init_statements (Vala.CCodeBlock block, bool plugin);
		public override string get_type_struct_name ();
		/**
		 * Specifies the class to be registered.
		 */
		public Vala.Class class_reference { get; set; }
	}
	/**
	 * C function to register an enum at runtime.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class EnumRegisterFunction : Vala.TypeRegisterFunction {
		/**
		 * Creates a new C function to register the specified enum at runtime.
		 *
		 * @param en an enum
		 * @return   newly created enum register function
		 */
		public EnumRegisterFunction (Vala.Enum en, Vala.CodeContext context);
		public override Vala.SymbolAccessibility get_accessibility ();
		public override Vala.TypeSymbol get_type_declaration ();
		/**
		 * Specifies the enum to be registered.
		 */
		public Vala.Enum enum_reference { get; set; }
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GAsyncModule : Vala.GtkModule {
		public GAsyncModule ();
		public string generate_async_callback_wrapper ();
		public override void generate_cparameters (Vala.Method m, Vala.CCodeFile decl_space, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.CCodeFunction func, Vala.CCodeFunctionDeclarator? vdeclarator = null, Vala.Map<int,Vala.CCodeExpression>? carg_map = null, Vala.CCodeFunctionCall? vcall = null, int direction = 3);
		public override void generate_method_declaration (Vala.Method m, Vala.CCodeFile decl_space);
		public override string generate_ready_function (Vala.Method m);
		public override void generate_virtual_method_declaration (Vala.Method m, Vala.CCodeFile decl_space, Vala.CCodeStruct type_struct);
		public override void return_with_exception (Vala.CCodeExpression error_expr);
		public override void visit_creation_method (Vala.CreationMethod m);
		public override void visit_method (Vala.Method m);
		public override void visit_return_statement (Vala.ReturnStatement stmt);
		public override void visit_yield_statement (Vala.YieldStatement stmt);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GDBusClientModule : Vala.GDBusModule {
		public GDBusClientModule ();
		public override void generate_dynamic_method_wrapper (Vala.DynamicMethod method);
		public override void generate_interface_declaration (Vala.Interface iface, Vala.CCodeFile decl_space);
		public Vala.CCodeConstant get_dbus_timeout (Vala.Symbol symbol);
		public override void register_dbus_info (Vala.CCodeBlock block, Vala.ObjectTypeSymbol sym);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_method_call (Vala.MethodCall expr);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GDBusModule : Vala.GVariantModule {
		public GDBusModule ();
		public bool dbus_method_uses_file_descriptor (Vala.Method method);
		public static string dbus_result_name (Vala.Method m);
		public static string? get_dbus_name (Vala.TypeSymbol symbol);
		public static string get_dbus_name_for_member (Vala.Symbol symbol);
		protected Vala.CCodeExpression get_interface_info (Vala.ObjectTypeSymbol sym);
		public static bool is_dbus_no_reply (Vala.Method m);
		public static bool is_dbus_visible (Vala.CodeNode node);
		public void receive_dbus_value (Vala.DataType type, Vala.CCodeExpression message_expr, Vala.CCodeExpression iter_expr, Vala.CCodeExpression target_expr, Vala.Symbol? sym, Vala.CCodeExpression? error_expr = null, out bool may_fail = null);
		public void send_dbus_value (Vala.DataType type, Vala.CCodeExpression builder_expr, Vala.CCodeExpression expr, Vala.Symbol? sym);
		public override void visit_class (Vala.Class cl);
		public override void visit_error_domain (Vala.ErrorDomain edomain);
		public override void visit_interface (Vala.Interface iface);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GDBusServerModule : Vala.GDBusClientModule {
		public GDBusServerModule ();
		public override void generate_class_declaration (Vala.Class cl, Vala.CCodeFile decl_space);
		public override void generate_interface_declaration (Vala.Interface iface, Vala.CCodeFile decl_space);
		public override void register_dbus_info (Vala.CCodeBlock block, Vala.ObjectTypeSymbol sym);
		public override void visit_class (Vala.Class cl);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_method_call (Vala.MethodCall expr);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GErrorModule : Vala.CCodeDelegateModule {
		public GErrorModule ();
		public override void add_simple_check (Vala.CodeNode node, bool always_fails = false);
		protected override void append_scope_free (Vala.Symbol sym, Vala.CodeNode? stop_at = null);
		public override void generate_error_domain_declaration (Vala.ErrorDomain edomain, Vala.CCodeFile decl_space);
		public virtual void return_with_exception (Vala.CCodeExpression error_expr);
		public override void visit_catch_clause (Vala.CatchClause clause);
		public override void visit_error_domain (Vala.ErrorDomain edomain);
		public override void visit_throw_statement (Vala.ThrowStatement stmt);
		public override void visit_try_statement (Vala.TryStatement stmt);
	}
	/**
	 * Code visitor generating .gir file for the public interface.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class GIRWriter : Vala.CodeVisitor {
		public GIRWriter ();
		protected virtual string? get_class_comment (Vala.Class c);
		protected virtual string? get_constant_comment (Vala.Constant c);
		protected virtual string? get_delegate_comment (Vala.Delegate cb);
		protected virtual string? get_delegate_return_comment (Vala.Delegate cb);
		protected virtual string? get_enum_comment (Vala.Enum en);
		protected virtual string? get_enum_value_comment (Vala.EnumValue ev);
		protected virtual string? get_error_code_comment (Vala.ErrorCode ecode);
		protected virtual string? get_error_domain_comment (Vala.ErrorDomain edomain);
		protected virtual string? get_field_comment (Vala.Field f);
		protected virtual string? get_interface_comment (Vala.Interface iface);
		protected virtual string? get_method_comment (Vala.Method m);
		protected virtual string? get_method_return_comment (Vala.Method m);
		protected virtual string? get_parameter_comment (Vala.Parameter param);
		protected virtual string? get_property_comment (Vala.Property prop);
		protected virtual string? get_signal_comment (Vala.Signal sig);
		protected virtual string? get_signal_return_comment (Vala.Signal sig);
		protected virtual string? get_struct_comment (Vala.Struct st);
		public override void visit_class (Vala.Class cl);
		public override void visit_constant (Vala.Constant c);
		public override void visit_creation_method (Vala.CreationMethod m);
		public override void visit_delegate (Vala.Delegate cb);
		public override void visit_enum (Vala.Enum en);
		public override void visit_enum_value (Vala.EnumValue ev);
		public override void visit_error_code (Vala.ErrorCode ecode);
		public override void visit_error_domain (Vala.ErrorDomain edomain);
		public override void visit_field (Vala.Field f);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_method (Vala.Method m);
		public override void visit_namespace (Vala.Namespace ns);
		public override void visit_property (Vala.Property prop);
		public override void visit_signal (Vala.Signal sig);
		public override void visit_struct (Vala.Struct st);
		/**
		 * Writes the public interface of the specified code context into the
		 * specified file.
		 *
		 * @param context      a code context
		 * @param gir_filename a relative or absolute filename
		 */
		public void write_file (Vala.CodeContext context, string directory, string gir_filename, string gir_namespace, string gir_version, string package, string? gir_shared_library = null);
		public void write_includes ();
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GLibValue : Vala.TargetValue {
		public Vala.CCodeExpression? array_length_cexpr;
		public Vala.List<Vala.CCodeExpression> array_length_cvalues;
		public bool array_null_terminated;
		public Vala.CCodeExpression? array_size_cvalue;
		public string? ctype;
		public Vala.CCodeExpression cvalue;
		public Vala.CCodeExpression? delegate_target_cvalue;
		public Vala.CCodeExpression? delegate_target_destroy_notify_cvalue;
		public bool lvalue;
		public bool non_null;
		public GLibValue (Vala.DataType? value_type = null, Vala.CCodeExpression? cvalue = null, bool lvalue = false);
		public void append_array_length_cvalue (Vala.CCodeExpression length_cvalue);
		public Vala.GLibValue copy ();
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GObjectModule : Vala.GTypeModule {
		public GObjectModule ();
		public override void generate_class_init (Vala.Class cl);
		public override string get_dynamic_property_getter_cname (Vala.DynamicProperty prop);
		public override string get_dynamic_property_setter_cname (Vala.DynamicProperty prop);
		public override string get_dynamic_signal_cname (Vala.DynamicSignal node);
		public override string get_dynamic_signal_connect_after_wrapper_name (Vala.DynamicSignal sig);
		public override string get_dynamic_signal_connect_wrapper_name (Vala.DynamicSignal sig);
		public override bool is_gobject_property (Vala.Property prop);
		public override void visit_class (Vala.Class cl);
		public override void visit_constructor (Vala.Constructor c);
		public override void visit_method_call (Vala.MethodCall expr);
		public override void visit_property (Vala.Property prop);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GSignalModule : Vala.GObjectModule {
		public GSignalModule ();
		public override Vala.CCodeFunctionCall get_signal_creation (Vala.Signal sig, Vala.TypeSymbol type);
		public override void visit_assignment (Vala.Assignment assignment);
		public override void visit_element_access (Vala.ElementAccess expr);
		public override void visit_member_access (Vala.MemberAccess expr);
		public override void visit_method_call (Vala.MethodCall expr);
		public override void visit_signal (Vala.Signal sig);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GTypeModule : Vala.GErrorModule {
		public GTypeModule ();
		public override void create_type_check_statement (Vala.CodeNode method_node, Vala.DataType ret_type, Vala.TypeSymbol t, bool non_null, string var_name);
		public virtual void end_instance_init (Vala.Class cl);
		public override void generate_class_declaration (Vala.Class cl, Vala.CCodeFile decl_space);
		public virtual void generate_class_init (Vala.Class cl);
		public override void generate_class_struct_declaration (Vala.Class cl, Vala.CCodeFile decl_space);
		public override void generate_interface_declaration (Vala.Interface iface, Vala.CCodeFile decl_space);
		public override Vala.CCodeParameter generate_parameter (Vala.Parameter param, Vala.CCodeFile decl_space, Vala.Map<int,Vala.CCodeParameter> cparam_map, Vala.Map<int,Vala.CCodeExpression>? carg_map);
		public virtual void generate_virtual_method_declaration (Vala.Method m, Vala.CCodeFile decl_space, Vala.CCodeStruct type_struct);
		public override Vala.CCodeFunctionCall get_param_spec (Vala.Property prop);
		public override void visit_class (Vala.Class cl);
		public override void visit_enum (Vala.Enum en);
		public override void visit_interface (Vala.Interface iface);
		public override void visit_method_call (Vala.MethodCall expr);
		public override void visit_property (Vala.Property prop);
		public override void visit_struct (Vala.Struct st);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GVariantModule : Vala.GAsyncModule {
		public GVariantModule ();
		public override Vala.CCodeExpression? deserialize_expression (Vala.DataType type, Vala.CCodeExpression variant_expr, Vala.CCodeExpression? expr, Vala.CCodeExpression? error_expr = null, out bool may_fail = null);
		public override bool generate_enum_declaration (Vala.Enum en, Vala.CCodeFile decl_space);
		public Vala.CCodeFunction generate_enum_from_string_function (Vala.Enum en);
		public Vala.CCodeFunction generate_enum_from_string_function_declaration (Vala.Enum en);
		public Vala.CCodeFunction generate_enum_to_string_function (Vala.Enum en);
		public Vala.CCodeFunction generate_enum_to_string_function_declaration (Vala.Enum en);
		public static string? get_dbus_signature (Vala.Symbol symbol);
		public static string? get_type_signature (Vala.DataType datatype, Vala.Symbol? symbol = null);
		public void read_expression (Vala.DataType type, Vala.CCodeExpression iter_expr, Vala.CCodeExpression target_expr, Vala.Symbol? sym, Vala.CCodeExpression? error_expr = null, out bool may_fail = null);
		public override Vala.CCodeExpression? serialize_expression (Vala.DataType type, Vala.CCodeExpression expr);
		public override void visit_enum (Vala.Enum en);
		public void write_expression (Vala.DataType type, Vala.CCodeExpression builder_expr, Vala.CCodeExpression expr, Vala.Symbol? sym);
	}
	[CCode (cheader_filename = "valacodegen.h")]
	public class GtkModule : Vala.GSignalModule {
		public GtkModule ();
		public override void end_instance_init (Vala.Class cl);
		public override void generate_class_init (Vala.Class cl);
		public override void visit_field (Vala.Field f);
		public override void visit_method (Vala.Method m);
		public override void visit_property (Vala.Property prop);
	}
	/**
	 * C function to register an interface at runtime.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class InterfaceRegisterFunction : Vala.TypeRegisterFunction {
		public InterfaceRegisterFunction (Vala.Interface iface, Vala.CodeContext context);
		public override Vala.SymbolAccessibility get_accessibility ();
		public override string get_base_finalize_func_name ();
		public override string get_base_init_func_name ();
		public override string get_class_finalize_func_name ();
		public override string get_class_init_func_name ();
		public override string get_instance_init_func_name ();
		public override string get_instance_struct_size ();
		public override string get_parent_type_name ();
		public override Vala.TypeSymbol get_type_declaration ();
		public override void get_type_interface_init_statements (Vala.CCodeBlock block, bool plugin);
		public override string get_type_struct_name ();
		/**
		 * Specifies the interface to be registered.
		 */
		public Vala.Interface interface_reference { get; set; }
	}
	/**
	 * C function to register a struct at runtime.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public class StructRegisterFunction : Vala.TypeRegisterFunction {
		/**
		 * Creates a new C function to register the specified struct at runtime.
		 *
		 * @param st a struct
		 * @return   newly created struct register function
		 */
		public StructRegisterFunction (Vala.Struct st, Vala.CodeContext context);
		public override Vala.SymbolAccessibility get_accessibility ();
		public override Vala.TypeSymbol get_type_declaration ();
		/**
		 * Specifies the struct to be registered.
		 */
		public Vala.Struct struct_reference { get; set; }
	}
	/**
	 * C function to register a type at runtime.
	 */
	[CCode (cheader_filename = "valacodegen.h")]
	public abstract class TypeRegisterFunction {
		public TypeRegisterFunction ();
		/**
		 * Returns the accessibility for this type.
		 */
		public abstract Vala.SymbolAccessibility get_accessibility ();
		/**
		 * Returns the name of the base_finalize function in C code.
		 *
		 * @return C function name
		 */
		public virtual string get_base_finalize_func_name ();
		/**
		 * Returns the name of the base_init function in C code.
		 *
		 * @return C function name
		 */
		public virtual string get_base_init_func_name ();
		/**
		 * Returns the name of the class_finalize function in C code.
		 *
		 * @return C function name
		 */
		public virtual string get_class_finalize_func_name ();
		/**
		 * Returns the name of the class_init function in C code.
		 *
		 * @return C function name
		 */
		public virtual string get_class_init_func_name ();
		/**
		 * Returns the declaration for this type register function in C code.
		 *
		 * @return C function declaration fragment
		 */
		public Vala.CCodeFragment get_declaration ();
		/**
		 * Returns the definition for this type register function in C code.
		 *
		 * @return C function definition fragment
		 */
		public Vala.CCodeFragment get_definition ();
		/**
		 * Returns the C-name of the new generated GTypeValueTable collect value function or null when not available.
		 *
		 * @return C function name
		 */
		public virtual string? get_gtype_value_table_collect_value_function_name ();
		/**
		 * Returns the C-name of the new generated GTypeValueTable copy function or null when not available.
		 *
		 * @return C function name
		 */
		public virtual string? get_gtype_value_table_copy_function_name ();
		/**
		 * Returns the C-name of the new generated GTypeValueTable free function or null when not available.
		 *
		 * @return C function name
		 */
		public virtual string? get_gtype_value_table_free_function_name ();
		/**
		 * Returns the C-name of the new generated GTypeValueTable init function or null when not available.
		 *
		 * @return C function name
		 */
		public virtual string? get_gtype_value_table_init_function_name ();
		/**
		 * Returns the C-name of the new generated GTypeValueTable lcopy function or null when not available.
		 *
		 * @return C function name
		 */
		public virtual string? get_gtype_value_table_lcopy_value_function_name ();
		/**
		 * Returns the C-name of the new generated GTypeValueTable peek pointer function or null when not available.
		 *
		 * @return C function name
		 */
		public virtual string? get_gtype_value_table_peek_pointer_function_name ();
		/**
		 * Returns the name of the instance_init function in C code.
		 *
		 * @return C function name
		 */
		public virtual string get_instance_init_func_name ();
		/**
		 * Returns the size of the instance struct in C code.
		 *
		 * @return C instance struct size
		 */
		public virtual string get_instance_struct_size ();
		/**
		 * Returns the name of the parent type in C code.
		 *
		 * @return C function name
		 */
		public virtual string get_parent_type_name ();
		public Vala.CCodeFragment get_source_declaration ();
		/**
		 * Returns the data type to be registered.
		 *
		 * @return type to be registered
		 */
		public abstract Vala.TypeSymbol get_type_declaration ();
		/**
		 * Returns the set of type flags to be applied when registering.
		 *
		 * @return type flags
		 */
		public virtual string get_type_flags ();
		/**
		 * Returns additional C declarations to setup interfaces.
		 *
		 * @return C declarations
		 */
		public virtual Vala.CCodeFragment get_type_interface_init_declaration ();
		/**
		 * Returns additional C initialization statements to setup interfaces.
		 *
		 * @return C statements
		 */
		public virtual void get_type_interface_init_statements (Vala.CCodeBlock block, bool plugin);
		/**
		 * Returns the name of the type struct in C code.
		 *
		 * @return C struct name
		 */
		public virtual string get_type_struct_name ();
		/**
		 * Constructs the C function from the specified type.
		 */
		public void init_from_type (bool plugin, bool declaration_only);
		public Vala.CodeContext context { get; set; }
	}
}
