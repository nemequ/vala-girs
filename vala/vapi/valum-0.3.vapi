/* valum-0.3.vapi generated by valac 0.34.2, do not modify. */

/**
 * Valum is a Web micro-framework written in Vala.
 */
[CCode (gir_namespace = "Valum", gir_version = "0.3")]
namespace Valum {
	/**
	 * Content negociation for various headers.
	 */
	[CCode (gir_namespace = "Valum", gir_version = "0.3")]
	namespace ContentNegotiation {
		/**
		 * Negotiate a 'Accept' header.
		 *
		 * It understands patterns that match all types (eg. '*\/*'), subtypes
		 * (eg. 'text\/*') and compound subtypes (eg. 'application/vnd.api+json')
		 *
		 * For compound subtypes, it checks if the accepted subtypes by the user
		 * agent form a subset of the proposed ones. Note that the '*' subtype is
		 * always considered acceptable.
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback accept (string content_types, owned Valum.ForwardCallback<string> forward = Valum.forward);
		/**
		 * Negotiate a 'Accept-Charset' header.
		 *
		 * It understands the wildcard character '*'.
		 *
		 * On success, set the 'charset' parameter of the 'Content-Type' header. If
		 * no content type is set, it defaults to 'application/octet-stream'.
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback accept_charset (string charsets, owned Valum.ForwardCallback<string> forward = Valum.forward);
		/**
		 * Negotiate a 'Accept-Encoding' header.
		 *
		 * It understands the wildcard '*'.
		 *
		 * This must be applied before any other content negotiation as it might
		 * convert the response to honor the negotiated encoding.
		 *
		 * The 'gzip', 'deflate' and 'identity' encodings are handled. Other
		 * encodings must be handled manually.
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback accept_encoding (string encodings, owned Valum.ForwardCallback<string> forward = Valum.forward);
		/**
		 * Negotiate a 'Accept-Language' header.
		 *
		 * If the user agent have regional preferences (eg. 'Accept: en-GB'),
		 * then any non-regional variation will be considered acceptable.
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback accept_language (string languages, owned Valum.ForwardCallback<string> forward = Valum.forward);
		/**
		 * Negotiate a 'Accept-Range' header.
		 *
		 * This is typically used with the 'bytes' value.
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback accept_ranges (string ranges, owned Valum.ForwardCallback<string> forward = Valum.forward);
		/**
		 * Negotiate a 'TE' header.
		 *
		 * Unlike for {@link Valum.ContentNegotiation.accept_encoding}, the transfer
		 * coding is not applied with a {@link GLib.Converter}, but simply stated in
		 * the response headers. It's up to the VSGI implementation to perform that
		 * work.
		 *
		 * Note that according to HTTP/1.1 specification, the 'chunked' encoding is
		 * always considered acceptable.
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback accept_transfer_encoding (string encodings, owned Valum.ForwardCallback<string> forward = Valum.forward);
		/**
		 * Negotiate a HTTP header against a set of expectations.
		 *
		 * The header is extracted as a quality list and a lookup is performed to
		 * see if the expected value is accepted by the user agent.
		 *
		 * The expectation is selected such that it maximize the product of the
		 * quality and user agent preference. For equal values, user agent
		 * preferences are considered first, then expectations.
		 *
		 * If the header is not provided in the request, it is assumed that the user
		 * agent consider any response as acceptable: the expectation with the
		 * highest quality will be forwarded.
		 *
		 * If more than one expectations is supplied, the 'Vary' header with the
		 * negotiated header name will be appended to the response headers to
		 * indicate that the resource has been generated based on its value.
		 *
		 * @param header_name  header to negotiate
		 * @param expectations expected values, possibly with a qvalue
		 * @param forward      callback forwarding the best expectation
		 *Â @param match        compare the user agent string against an expectation
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback negotiate (string header_name, string expectations, owned Valum.ForwardCallback<string> forward = Valum.forward, GLib.EqualFunc<string> match = (GLib.EqualFunc<string>) Soup.str_case_equal);
	}
	/**
	 * Middleware and utilities to produce server-sent events.
	 */
	[CCode (gir_namespace = "Valum", gir_version = "0.3")]
	namespace ServerSentEvents {
		/**
		 * Create a context for sending SSE messages.
		 *
		 * It replaces the {@link VSGI.Response} by a {@link Valum.ServerSentEvents.SendEventCallback}.
		 *
		 * @param request    request this is responding to
		 * @param send_event send a SSE message
		 * @param context    routing context
		 *
		 * @throws GLib.Error thrown errors are suppressed with {@link GLib.warning}
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public delegate void EventStreamCallback (VSGI.Request request, owned Valum.ServerSentEvents.SendEventCallback send_event, Valum.Context context) throws GLib.Error;
		/**
		 * Send an message over the body stream.
		 *
		 * All string data must be encoded using UTF-8 and multi-line data are
		 * handled properly by writing multiple 'data:' fields.
		 *
		 * @param event event name, or 'null' to omit the field
		 * @param data  event data
		 * @param id    event identifier, or 'null' to omit the field
		 * @param retry retry, or 'null' to omit the field
		 *
		 * @throws Error errors are handled as warnings to avoid breaking the
		 *               `text/event-stream` content
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public delegate void SendEventCallback (string? event, string data, string? id = null, GLib.TimeSpan? retry = null) throws GLib.Error;
		/**
		 * Middleware that create a context for sending Server-Sent Events.
		 *
		 * The {@link VSGI.Response} cannot be manipulated directly, but through a
		 * {@link Valum.ServerSentEvents.SendEventCallback} callback instead.
		 *
		 * The stream is explicitly flushed the ensure that the user agent receives
		 * the message.
		 *
		 * Messages are send directly with the {@link Soup.Encoding.EOF} encoding
		 * as recommended by the W3C.
		 *
		 * The middleware automatically send a keep-alive every 15 seconds to ensure
		 * that unaware clients keep the connection opened.
		 *
		 * @param context context for sending events
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback stream_events (owned Valum.ServerSentEvents.EventStreamCallback context);
	}
	/**
	 * Utilities to serve static resources.
	 */
	[CCode (gir_namespace = "Valum", gir_version = "0.3")]
	namespace Static {
		/**
		 * Flags used to enble or disable options for serving static resources.
		 */
		[CCode (cheader_filename = "valum.h")]
		[Flags]
		[Version (since = "0.3")]
		public enum ServeFlags {
			NONE,
			/**
			 * Produce an 'ETag' header and raise a {@link Valum.Redirection.NOT_MODIFIED}
			 * if the resource has already been transmitted. If not available, it
			 * will fallback on either {@link Valum.Static.ServeFlags.ENABLE_LAST_MODIFIED}
			 * or no caching at all.
			 */
			ENABLE_ETAG,
			/**
			 * Produce a 'Last-Modified' header and raise a {@link Valum.Redirection.NOT_MODIFIED}
			 * if the resource has already been transmitted.
			 *
			 * If {@link Valum.Static.ServeFlags.ENABLE_ETAG} is specified and available,
			 * it will be used instead.
			 */
			ENABLE_LAST_MODIFIED,
			/**
			 * Raise a {@link ClientError.FORBIDDEN} if rights are missing on the
			 * resource rather than calling 'next'.
			 */
			FORBID_ON_MISSING_RIGHTS,
			/**
			 * If supported, generate a 'X-Sendfile' header instead of delivering
			 * the actual resource in the response body.
			 *
			 * The absolute path as provided by {@link GLib.File.get_path} will be
			 * produced in the 'X-Sendfile' header. It must therefore be accessible
			 * for the HTTP server, otherwise it will silently fallback to serve the
			 * resource directly.
			 */
			[Version (experimental = true)]
			X_SENDFILE
		}
		/**
		 * Serve static files relative to a given root.
		 *
		 * The path to relative to the root is expected to be associated to the
		 * 'path' key in the routing context.
		 *
		 * The path can be local or remote given that GVFS can be used.
		 *
		 * The 'ETag' header is obtained from {@link GLib.FileAttribute.ETAG_VALUE}.
		 *
		 * If the file is not found, the request is delegated to the next
		 * middleware.
		 *
		 * If the file is not readable, a '403 Forbidden' is raised.
		 *
		 * @param root        path from which resources are resolved
		 * @param serve_flags flags for serving the resources
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback serve_from_file (GLib.File root, Valum.Static.ServeFlags serve_flags = ServeFlags.NONE, Valum.ForwardCallback<GLib.File> forward = Valum.forward);
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback serve_from_path (string path, Valum.Static.ServeFlags serve_flags = ServeFlags.NONE, owned Valum.ForwardCallback<GLib.File> forward = Valum.forward);
		/**
		 * Serve files from the provided {@link GLib.Resource} bundle.
		 *
		 * The 'ETag' header is obtained from a SHA1 checksum.
		 *
		 * [[http://valadoc.org/#!api=gio-2.0/GLib.Resource]]
		 *
		 * @see Valum.Static.serve_from_file
		 * @see GLib.resources_open_stream
		 * @see GLib.resources_lookup_data
		 *
		 * @param resource    resource bundle to serve
		 * @param prefix      prefix from which resources are resolved in the
		 *                    resource bundle; a valid prefix begin and start with a
		 *                    '/' character
		 * @param serve_flags flags for serving the resources
		 */
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback serve_from_resource (GLib.Resource resource, string prefix = "/", Valum.Static.ServeFlags serve_flags = ServeFlags.NONE, owned Valum.HandlerCallback forward = Valum.forward);
		[CCode (cheader_filename = "valum.h")]
		[Version (since = "0.3")]
		public static Valum.HandlerCallback serve_from_uri (string uri, Valum.Static.ServeFlags serve_flags = ServeFlags.NONE, owned Valum.ForwardCallback<GLib.File> forward = Valum.forward);
	}
	/**
	 * Route supporting the asterisk '*' path.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public class AsteriskRoute : Valum.Route {
		public AsteriskRoute (Valum.Method method, owned Valum.HandlerCallback handler);
		public override bool fire (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context ctx) throws GLib.Error;
		public override bool match (VSGI.Request req, Valum.Context ctx);
		public override string to_url_from_hash (GLib.HashTable<string,string>? @params = null);
	}
	/**
	 * Routing context that stores various states for middleware interaction.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public class Context : GLib.Object {
		/**
		 * Create a new root context.
		 */
		public Context ();
		/**
		 * Test if this context or its parent has a key.
		 *
		 * @param key the key used to test
		 *
		 * @return 'true' if the key is found in the context tree, 'false' otherwise
		 */
		public bool contains (string key);
		/**
		 * Iterate for each keys in the context tree by depth.
		 *
		 * @param func function called on each key in the context tree
		 */
		public void @foreach (owned Valum.ContextForeachFunc func);
		/**
		 * Obtain a key from this context or its parent if it's not found.
		 *
		 * @param key the key used to retreive the value
		 * @return    the value, or 'null' if not found
		 */
		public new unowned GLib.Value? @get (string key);
		/**
		 * Remove all occurences of a key in the context and its parents.
		 *
		 * @return 'true' if the key was removed from the context, otherwise the key
		 *          was not found and 'false' is returned
		 */
		public bool remove (string key);
		/**
		 * Set a key in this context.
		 *
		 * @param key   the key used to retreive the value once assigned
		 * @param value the value, which is then owned by the context
		 */
		public new void @set (string key, owned GLib.Value value);
		/**
		 * Take a {@link GLib.Value} from the context.
		 *
		 * The value is removed from the context and owned by the caller.
		 *
		 * @param key the key used to retreive the value
		 * @return    the value, or 'null' if not found
		 */
		public GLib.Value? take (string key);
		/**
		 * Create a new child context.
		 */
		public Context.with_parent (Valum.Context parent);
		/**
		 * Parent's context from which missing keys are resolved.
		 */
		public Valum.Context? parent { get; construct; }
	}
	/**
	 * Route based on a {@link Valum.MatcherCallback}.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public class MatcherRoute : Valum.Route {
		public MatcherRoute (Valum.Method method, owned Valum.MatcherCallback matcher, owned Valum.HandlerCallback handler);
		public override bool fire (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context ctx) throws GLib.Error;
		public override bool match (VSGI.Request req, Valum.Context ctx);
		public void set_matcher_callback (owned Valum.MatcherCallback callback);
		public override string to_url_from_hash (GLib.HashTable<string,string>? @params = null);
	}
	/**
	 * Route based on exact path matching.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public class PathRoute : Valum.Route {
		public PathRoute (Valum.Method method, string path, owned Valum.HandlerCallback handler);
		public override bool fire (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context ctx) throws GLib.Error;
		public override bool match (VSGI.Request req, Valum.Context ctx);
		public override string to_url_from_hash (GLib.HashTable<string,string>? @params = null);
		/**
		 * The path matched by this route.
		 */
		public string path { get; construct; }
	}
	/**
	 * Route based on {@link GLib.Regex}.
	 *
	 * The providen regular expression pattern will be extracted, scoped,
	 * anchored and optimized. This means you must not anchor the regex yourself
	 * with '^' and '$' characters and providing a pre-optimized {@link  GLib.Regex}
	 * is useless.
	 *
	 * Like for the rules, the regular expression starts matching after the
	 * scopes and the leading '/' character.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public class RegexRoute : Valum.Route {
		public RegexRoute (Valum.Method method, GLib.Regex regex, owned Valum.HandlerCallback handler);
		public override bool fire (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context ctx) throws GLib.Error;
		public override bool match (VSGI.Request req, Valum.Context context);
		public override string to_url_from_hash (GLib.HashTable<string,string>? @params = null);
		public GLib.SList<string> captures { get; owned construct; }
		public GLib.Regex regex { get; construct; }
	}
	/**
	 * Describe a matching and handling process for a pair of {@link VSGI.Request}
	 * and {@link VSGI.Response} objects.
	 *
	 * It holds metadata as well to optimize the routing process.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public abstract class Route : GLib.Object {
		public Route ();
		/**
		 * Apply the handler on the request and response.
		 *
		 * @return the return value of the callback if set, otherwise 'false'
		 */
		public abstract bool fire (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context ctx) throws Valum.Success, Valum.Redirection, Valum.ClientError, Valum.ServerError, GLib.Error;
		/**
		 * Matches the given request and populate its parameters on success.
		 */
		public abstract bool match (VSGI.Request req, Valum.Context ctx);
		/**
		 * Reverse the route into an URL using varidic arguments.
		 *
		 * Arguments alternate between keys and values, all assumed to be
		 * {@link string}.
		 */
		[Version (since = "0.3")]
		public string to_url (...);
		/**
		 * Reverse the route into an URL.
		 *
		 * @param params parameters which are typically extract from the
		 *               {@link VSGI.Request.uri} property
		 *
		 * @return the corresponding URL if supported, otherwise 'null'
		 */
		[Version (since = "0.3")]
		public abstract string to_url_from_hash (GLib.HashTable<string,string>? @params = null);
		/**
		 * Reverse the route into an URL by building from a varidic arguments
		 * list.
		 */
		[Version (since = "0.3")]
		public string to_url_from_valist (va_list list);
		/**
		 * Flag describing allowed HTTP methods.
		 */
		[Version (since = "0.2")]
		public Valum.Method method { get; construct; }
	}
	/**
	 * Dispatches incoming requests to the appropriate registered handler.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public class Router : VSGI.Handler {
		[Version (experimental = true, since = "0.3")]
		public GLib.Sequence<Valum.Route> routes;
		[Version (since = "0.3")]
		public Router ();
		/**
		 * Bind a callback to handle asterisk '*' URI.
		 *
		 * Typically, this is used with {@link Valum.Method.OPTIONS} to provide
		 * general information about the service.
		 */
		[Version (since = "0.3")]
		public void asterisk (Valum.Method method, owned Valum.HandlerCallback cb);
		public new void connect (string rule, owned Valum.HandlerCallback cb, string? name = null);
		public void @delete (string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * Since the {@link Valum.Method.GET} flag is used, 'HEAD' will be
		 * provided as well.
		 */
		public new void @get (string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * Perform the routing of a pair of request and response objects.
		 *
		 * If the request method is {@link VSGI.Request.TRACE}, a
		 * representation of the request will be produced in the response.
		 *
		 * If nothing matches, the one of the following error will be thrown at
		 * the bottom of the routing:
		 *
		 * * a {@link Valum.ClientError.METHOD_NOT_ALLOWED} if alternate methods exist
		 * * a {@link Valum.ClientError.NOT_FOUND} otherwise
		 *
		 * If the request method is {@link VSGI.Request.OPTIONS}, a success
		 * message will be produced with the 'Allow' header set accordingly. No
		 * error will be thrown.
		 */
		public override bool handle (VSGI.Request req, VSGI.Response res) throws GLib.Error;
		public void head (string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * Bind a callback to a given method and a matcher callback.
		 *
		 * The method will be marked as provided with the {@link Valum.Method.PROVIDED}
		 * flag.
		 *
		 * @param method  HTTP method or 'null' for any
		 * @param matcher callback used to match the request
		 * @param cb      callback used to process the pair of request and response.
		 */
		public void matcher (Valum.Method method, owned Valum.MatcherCallback matcher, owned Valum.HandlerCallback cb);
		[Version (since = "0.3")]
		public void once (owned Valum.HandlerCallback cb);
		public void options (string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * [[http://tools.ietf.org/html/rfc5789]]
		 */
		public void patch (string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * Bind a callback to a given method and path.
		 *
		 * While {@link Valum.Router.rule} can be as well used for exact path
		 * matches, this helper is more efficient as it does rely on regex
		 * matching under the hood.
		 *
		 * @param method  flag for allowed HTTP methods
		 * @param path    the path which must be satisfied by the request
		 * @param handler callback applied on the pair of request and response
		 *                objects if the method and path are satisfied
		 */
		[Version (since = "0.3")]
		public void path (Valum.Method method, string path, owned Valum.HandlerCallback handler, string? name = null);
		public void post (string rule, owned Valum.HandlerCallback cb, string? name = null);
		public void put (string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * Bind a callback to a given method and regular expression.
		 *
		 * The providen regular expression pattern will be extracted, scoped,
		 * anchored and optimized. This means you must not anchor the regex yourself
		 * with '^' and '$' characters and providing a pre-optimized {@link GLib.Regex}
		 * is useless.
		 *
		 * The method will be marked as provided with the {@link Valum.Method.PROVIDED}
		 * flag.
		 *
		 * @param method flag for allowed HTTP methods
		 * @param regex  regular expression matching the request path
		 * @param cb     callback used to process the pair of request and response
		 */
		public void regex (Valum.Method method, GLib.Regex regex, owned Valum.HandlerCallback cb);
		/**
		 * Register a type to be understood by {@link Valum.RuleRoute}.
		 *
		 * If a type is already registered with that name, it is replaced with
		 * the new definition.
		 *
		 * @param name             name by which types are identified in the
		 *                         rule pattern
		 * @param pattern          matches instance of the type in a path
		 */
		[Version (experimental = true, since = "0.3")]
		public void register_type (string name, GLib.Regex pattern);
		/**
		 * Append a {@link Route} object on the routing sequence.
		 *
		 * @param route an instance of Route defining the matching process and
		 *              the callback.
		 */
		[Version (since = "0.3")]
		public void route (Valum.Route route, string? name = null);
		/**
		 * Bind a callback to a given method and rule.
		 *
		 * The actual rule is scoped, anchored and compiled down to a
		 * {@link GLib.Regex}.
		 *
		 * The method will be marked as provided with the {@link Valum.Method.PROVIDED}
		 * flag.
		 *
		 * @param method flag for allowed HTTP methods
		 * @param rule   rule matching the request path
		 * @param cb     callback used to process the pair of request and response
		 */
		[Version (since = "0.3")]
		public void rule (Valum.Method method, string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * Add a fragment to the scope stack and nest a router in this new
		 * environment.
		 *
		 * Scoping will only work with rules and regular expressions.
		 *
		 * @param fragment fragment to push on the scopes stack
		 * @param loader   nests a router in the new scoped environment
		 */
		public void scope (string fragment, owned Valum.LoaderCallback loader);
		public void trace (string rule, owned Valum.HandlerCallback cb, string? name = null);
		/**
		 * Reverse an URL for a named {@link Valum.Route} using varidic
		 * arguments.
		 */
		[Version (since = "0.3")]
		public string url_for (string name, ...);
		/**
		 * Reverse an URL for a named {@link Valum.Route}.
		 *
		 * @param name   name of the route
		 * @param params parameters for the {@link Valum.Route.to_url} call
		 *
		 * @return 'null' if the route is not found otherwise the return value
		 *         of {@link Valum.Route.to_url}
		 */
		[Version (since = "0.3")]
		public string url_for_hash (string name, GLib.HashTable<string,string>? @params = null);
		/**
		 * Reverse an URL for a named {@link Valum.Route} using a varidic
		 * arguments list.
		 */
		[Version (since = "0.3")]
		public string url_for_valist (string name, va_list list);
		/**
		 * Mount a handling middleware on the routing queue.
		 */
		[Version (since = "0.3")]
		public void use (owned Valum.HandlerCallback cb);
		/**
		 * Global routing context.
		 */
		[Version (since = "0.3")]
		public Valum.Context context { get; construct; }
	}
	/**
	 * Route based on the rule system.
	 *
	 * The rule pattern is composed of a few elements:
	 *
	 *  * '<' '>' for parameters
	 *  * '(' and ')' for group
	 *  * '?' for optional
	 *  * '*' for wildcard
	 *
	 * The content of a parameters is a name with an optional type such as
	 * '<type:name>'. Types are resolved in a provided mapping and names are
	 * pushed on the routing {@link Valum.Context}.
	 *
	 * A group allow a more fine-grained application for optional parts.
	 *
	 * The optional symbol makes the last character or group optional. If it
	 * contains parameters, they will not be pushed on the context.
	 *
	 * The wildcard stands for the '.*' regular expression, which match pretty
	 * much anything.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public class RuleRoute : Valum.RegexRoute {
		/**
		 * Create a Route for a given callback from a rule.
		 *
		 * @param rule  compiled down ot a regular expression and captures all
		 *              paths if set to 'null'
		 * @param types type mapping to figure out types in rule or 'null' to
		 *              prevent any form of typing
		 */
		public RuleRoute (Valum.Method method, string rule, GLib.HashTable<string,GLib.Regex> types, owned Valum.HandlerCallback handler) throws GLib.RegexError;
		public override bool fire (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context ctx) throws GLib.Error;
		public override string to_url_from_hash (GLib.HashTable<string,string>? @params = null);
		public string rule { get; construct; }
		public GLib.HashTable<string,GLib.Regex> types { get; construct; }
	}
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public enum CacheControlDirective {
		PUBLIC,
		PRIVATE,
		NO_CACHE,
		NO_STORE,
		NO_TRANSFORM,
		MUST_REVALIDATE,
		PROXY_REVALIDATE,
		MAX_AGE,
		S_MAXAGE
	}
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public enum DecodeFlags {
		NONE,
		/**
		 * Forward with the remaining content encodings if they are expected to
		 * be processed later.
		 */
		FORWARD_REMAINING_ENCODINGS
	}
	/**
	 * Represent a set of HTTP methods.
	 *
	 * This is used for {@link Valum.Route} to define what methods are allowed
	 * for a given instance.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Flags]
	[Version (since = "0.3")]
	public enum Method {
		OPTIONS,
		ONLY_GET,
		HEAD,
		GET,
		PUT,
		POST,
		DELETE,
		TRACE,
		CONNECT,
		PATCH,
		/**
		 * HTTP methods considered safe according to RFC 7231.
		 */
		SAFE,
		/**
		 * HTTP methods considered idempotent according to RFC 7231.
		 */
		ITEMPOTENT,
		/**
		 * HTTP methods considered cacheable according to RFC 7231.
		 *
		 * POST is considered cacheable because it completely replaces the
		 * resources. The second call does not change the state of the resource.
		 */
		CACHEABLE,
		/**
		 * Mask for all standard HTTP methods.
		 */
		ALL,
		/**
		 * If this is used, the {@link Valum.Route} object must perform its own
		 * method matching.
		 */
		OTHER,
		/**
		 * Mask for all methods, including non-standard ones.
		 */
		ANY,
		/**
		 * Indicate that the method literally provided by the {@link Valum.Route}
		 * object which declared it.
		 *
		 * This has an impact on introspected routes to build the 'Allow'
		 * header.
		 */
		[Version (experimental = true, since = "0.3")]
		PROVIDED,
		/**
		 * Mask for all meta flags.
		 */
		[Version (experimental = true, since = "0.3")]
		META;
		public static Valum.Method from_string (string method);
	}
	/**
	 * Client errors corresponding to the 4xx HTTP status codes.
	 *
	 * @see   Soup.Status
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public errordomain ClientError {
		BAD_REQUEST,
		UNAUTHORIZED,
		PAYMENT_REQUIRED,
		FORBIDDEN,
		NOT_FOUND,
		/**
		 * The error message is used for the 'Allow' header value.
		 */
		METHOD_NOT_ALLOWED,
		NOT_ACCEPTABLE,
		PROXY_AUTHENTICATION_REQUIRED,
		PROXY_UNAUTHORIZED,
		REQUEST_TIMEOUT,
		CONFLICT,
		GONE,
		LENGTH_REQUIRED,
		PRECONDITION_FAILED,
		REQUEST_ENTITY_TOO_LARGE,
		REQUEST_URI_TOO_LONG,
		UNSUPPORTED_MEDIA_TYPE,
		REQUESTED_RANGE_NOT_SATISFIABLE,
		INVALID_RANGE,
		EXPECTATION_FAILED,
		IM_A_TEAPOT,
		AUTHENTICATION_TIMEOUT,
		MISDIRECTED_REQUEST,
		UNPROCESSABLE_ENTITY,
		LOCKED,
		FAILED_DEPENDENCY,
		/**
		 * The error message is used for the 'Upgrade' header.
		 */
		UPGRADE_REQUIRED,
		PRECONDITION_REQUIRED,
		TOO_MANY_REQUESTS,
		REQUEST_HEADER_FIELDS_TOO_LARGE
	}
	/**
	 * Informational status corresponding to the 1xx HTTP status codes.
	 *
	 * @see   Soup.Status
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public errordomain Informational {
		CONTINUE,
		/**
		 * The error message will be used for the 'Upgrade' header.
		 */
		SWITCHING_PROTOCOLS,
		PROCESSING
	}
	/**
	 * Redirection corresponding to the 3xx HTTP status codes.
	 *
	 * The error message will be used in the 'Location' header.
	 *
	 * @see   Soup.Status
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public errordomain Redirection {
		MULTIPLE_CHOICES,
		MOVED_PERMANENTLY,
		FOUND,
		MOVED_TEMPORARILY,
		SEE_OTHER,
		NOT_MODIFIED,
		USE_PROXY,
		NOT_APPEARING_IN_THIS_PROTOCOL,
		TEMPORARY_REDIRECT,
		PERMANENT_REDIRECT
	}
	/**
	 * Server errors corresponding to the 5xx HTTP status codes.
	 *
	 * @see   Soup.Status
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public errordomain ServerError {
		INTERNAL_SERVER_ERROR,
		NOT_IMPLEMENTED,
		BAD_GATEWAY,
		SERVICE_UNAVAILABLE,
		GATEWAY_TIMEOUT,
		HTTP_VERSION_NOT_SUPPORTED,
		VARIANT_ALSO_NEGOTIATES,
		INSUFFICIENT_STORAGE,
		LOOP_DETECTED,
		NOT_EXTENDED,
		NETWORK_AUTHENTICATION_REQUIRED
	}
	/**
	 * Success corresponding to the 2xx HTTP status codes.
	 *
	 * @see   Soup.Status
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public errordomain Success {
		OK,
		/**
		 * The error message will be used for the 'Location' header which
		 * should point to the newly created resource.
		 */
		CREATED,
		ACCEPTED,
		NON_AUTHORITATIVE,
		NO_CONTENT,
		RESET_CONTENT,
		/**
		 * The error message will be used for the 'Range' header.
		 */
		PARTIAL_CONTENT,
		MULTI_STATUS,
		ALREADY_REPORTED,
		IM_USED
	}
	/**
	 * Perform the authentication against the credentials source.
	 *
	 * This will typically retreive the password for {@link VSGI.Authorization.username}
	 * and call {@link VSGI.Authorization.challenge_with_password}.
	 *
	 * @param auth represent the credentials provided by the user-agent
	 *             which can be challenged
	 *
	 * @return 'true' if the authentication is successful, 'false' otherwise
	 *         even if the provided input is malformed
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public delegate bool AuthCallback (VSGI.Authorization auth);
	/**
	 * Type of function passed to {@link Valum.Context.foreach} to iterate in all
	 * context entries depth-wise.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public delegate void ContextForeachFunc (string key, GLib.Value value, uint depth);
	/**
	 * Define a type of {@link Valum.HandlerCallback} that forward a generic
	 * value.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public delegate bool ForwardCallback<T> (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context context, T value) throws GLib.Error;
	/**
	 * Handle a pair of request and response.
	 *
	 * @throws Error callback are free to raise any error
	 *
	 * @param req     request being handled
	 * @param res     response to send back to the requester
	 * @param next    continuation to keep routing
	 * @param context routing context which parent is the context of the
	 *                preceeding 'next' invocation or initialized by the
	 *                first {@link Valum.MatcherCallback}
	 *
	 * @return 'true' if the request has been or will eventually be handled,
	 *         otherwise 'false'
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public delegate bool HandlerCallback (VSGI.Request req, VSGI.Response res, Valum.NextCallback next, Valum.Context context) throws GLib.Error;
	/**
	 * Loads {@link Route} instances on a provided router.
	 *
	 * This is used for scoping and as a general definition for callback
	 * taking a {@link Router} as parameter like modules.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public delegate void LoaderCallback (Valum.Router router);
	/**
	 * Match the request and populate the {@link Valum.Context}.
	 *
	 * This is expected to be *very* fast and thus, no blocking operation must
	 * be performed. If necessary, it is preferable to use a
	 * {@link Valum.HandlerCallback} and invoke the 'next' continuation when ready.
	 *
	 * @param req     request being matched
	 * @param context context which may be initial or derive from a parent
	 *
	 * @return 'true' if the request is matched, otherwise 'false'
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public delegate bool MatcherCallback (VSGI.Request req, Valum.Context context);
	/**
	 * Continuation passed in a {@link Valum.HandlerCallback} to *keep routing*
	 * both {@link VSGI.Request} and {@link VSGI.Response}.
	 *
	 * Any thrown error will be propagate to the caller found upstream in the
	 * routing.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.1")]
	public delegate bool NextCallback () throws Valum.Informational, Valum.Success, Valum.Redirection, Valum.ClientError, Valum.ServerError, GLib.Error;
	/**
	 * Define a kind of {@link Valum.HandlerCallback} which may only raise
	 * status codes so that other errors have to be explicitly handled.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public delegate bool SafeHandlerCallback (VSGI.Request req, VSGI.Response res, Valum.SafeNextCallback next, Valum.Context ctx) throws Valum.Informational, Valum.Success, Valum.Redirection, Valum.ClientError, Valum.ServerError;
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public delegate bool SafeNextCallback () throws Valum.Informational, Valum.Success, Valum.Redirection, Valum.ClientError, Valum.ServerError;
	/**
	 * Challenge incoming requests against the provided authentication
	 * definition.
	 *
	 * On success, the request is forwarded with the authenticated username.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback authenticate (VSGI.Authentication auth, owned Valum.AuthCallback callback, owned Valum.ForwardCallback<string> forward = Valum.forward);
	/**
	 * Rebase and forward requests which path match the provided basepath.
	 *
	 * If the {@link VSGI.Request.uri} path has the provided prefix, it is
	 * stripped and the resulting request is forwared.
	 *
	 * Typically, a leading slash and no ending slash are used to form the
	 * prefix path (e.g. '/user').
	 *
	 * If 'next' is called while forwarding, the URI path is restored.
	 *
	 * Error which message consist of a 'Location' header are prefixed by
	 * the basepath.
	 *
	 * @param path    path prefix stripped on forwarded requests
	 * @param forward callback used to forward the request
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback basepath (string path, owned Valum.HandlerCallback forward);
	/**
	 * Provide a set of basic behaviours such as status and error handling.
	 *
	 * Raised status code are handled according to the expectations of the HTTP
	 * specification.
	 *
	 * Other errors are treated as '500 Internal Server Error' with a
	 * pre-defined payload.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback basic ();
	/**
	 * Produce a 'Cache-Control' response header.
	 *
	 * @param directive directive for the 'Cache-Control' header
	 * @param max_age   argument for 'max-age' or 's-maxage' directives if
	 *                  specified in the type, otherwise it's used for 'max-age'
	 *                  if greater than zero
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback cache_control (Valum.CacheControlDirective directive, GLib.TimeSpan max_age = 0);
	/**
	 * Decode any applied 'Content-Encoding'.
	 *
	 * Supports 'gzip', 'deflate' and 'identity', otherwise raise a
	 * {@link Valum.ServerError.NOT_IMPLEMENTED}.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback decode (Valum.DecodeFlags flags = DecodeFlags.NONE);
	/**
	 * Extract subdomains from a domain name excluding the top and second level
	 * domain.
	 *
	 * @param domain domain from which subdomains will be extracted
	 * @param skip   number of labels to skip, which defaults to 2 (eg. 'example'
	 *               and 'com')
	 * @return a list of subdomains in their left-to-right order of appearance
	 *         in the domain excluding the two top-most levels
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static string[] extract_subdomains (string domain, uint skip = 2);
	/**
	 * Used as a default value when all that is necessary is to call the 'next'
	 * continuation.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static bool forward (VSGI.Request req, VSGI.Response res, Valum.NextCallback next) throws GLib.Error;
	/**
	 * Forward using a provided handler callback.
	 *
	 * This is basically a hack to pass a {@link Valum.HandlerCallback} where a
	 * {@link Valum.ForwardCallback} is expected, discarding the forwarded
	 * value.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.ForwardCallback<T> forward_with<T> (owned Valum.HandlerCallback handle);
	/**
	 * Perform some operations safely.
	 *
	 * Typically, errors are thrown out of callbacks and handled altogether.
	 * However, some critical sections might not want to have errors leaking, so
	 * this middleware ensure that by providing a context where no errors, but
	 * status can be raised.
	 *
	 * The 'next' continuation is wrapped in such way that if any non-status
	 * error is raised, it will be thrown upstream but not leaked from invoking
	 * it. This is useful because one only want to deal with errors in the direct
	 * scope.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback safely (owned Valum.SafeHandlerCallback forward);
	/**
	 * Produce a handler sequence of 'a' and 'b'.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback sequence (owned Valum.HandlerCallback a, owned Valum.HandlerCallback b);
	/**
	 * Handle any corresponding error thrown by the following handler.
	 *
	 * If {@link Soup.Status.INTERNAL_SERVER_ERROR} is specified, other errors
	 * will be forwarded as well.
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback status (uint status, owned Valum.ForwardCallback<GLib.Error> forward);
	/**
	 * Produce a matching middleware that accepts request which subdomain is
	 * consistent with the expectation.
	 *
	 * If the expected subdomain is 'api', then 'api.example.com' and
	 * '*.api.example.com' will be accepted.
	 *
	 * The joker '*' can be used to fuzzy-match a label.
	 *
	 * @param expected_subdomain expected subdomain pattern
	 * @param forward            invoked if the subdomain matches
	 * @param strict             strictly match the subdomains to have the
	 *                           exactly same amount of labels
	 * @param skip               see {@link Valum.extract_subdomains}
	 */
	[CCode (cheader_filename = "valum.h")]
	[Version (since = "0.3")]
	public static Valum.HandlerCallback subdomain (string expected_subdomain, owned Valum.ForwardCallback<string> forward, bool strict = false, uint skip = 2);
}
