/* folks.vapi generated by valac 0.57.0.169-9de8e, do not modify. */

/**
 * New general types required by Folks.
 *
 * @since 0.3.1
 */
[CCode (gir_namespace = "Folks", gir_version = "0.7")]
namespace Folks {
	/**
	 * Object representing any type of value that can have some vCard-like
	 * parameters associated with it.
	 *
	 * Some contact details, like phone numbers or URLs, can have some
	 * extra details associated with them.
	 * For instance, a phone number expressed in vcard notation as
	 * ``tel;type=work,voice:(111) 555-1234`` would be represented as
	 * a AbstractFieldDetails with value "(111) 555-1234" and with parameters
	 * ``['type': ('work', 'voice')]``.
	 *
	 * The parameter name "type" with values "work", "home", or "other" are common
	 * amongst most vCard attributes (and thus most AbstractFieldDetails-derived
	 * classes). A "type" of "pref" may be used to indicate a preferred
	 * {@link AbstractFieldDetails.value} amongst many. See specific classes for
	 * information on additional parameters and values specific to that class.
	 *
	 * See [[http://www.ietf.org/rfc/rfc2426.txt|RFC2426]] for more details on
	 * pre-defined parameter names and values.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public abstract class AbstractFieldDetails<T> : GLib.Object {
		/**
		 * Parameter name for classifying the type of value this field contains.
		 *
		 * For example, the value could be relevant to the contact's home life, or to
		 * their work life; values of {@link AbstractFieldDetails.PARAM_TYPE_HOME}
		 * and {@link AbstractFieldDetails.PARAM_TYPE_WORK} would be used for the
		 * {@link AbstractFieldDetails.PARAM_TYPE} parameter, respectively, in those
		 * cases.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE;
		/**
		 * Parameter value for home-related field values.
		 *
		 * Value for a parameter with name {@link AbstractFieldDetails.PARAM_TYPE}.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE_HOME;
		/**
		 * Parameter value for miscellaneous field values.
		 *
		 * Value for a parameter with name {@link AbstractFieldDetails.PARAM_TYPE}.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE_OTHER;
		/**
		 * Parameter value for work-related field values.
		 *
		 * Value for a parameter with name {@link AbstractFieldDetails.PARAM_TYPE}.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE_WORK;
		protected AbstractFieldDetails ();
		/**
		 * Add a new value for a parameter.
		 *
		 * If there is already a parameter called ``parameter_name`` then
		 * ``parameter_value`` is added to the existing ones.
		 *
		 * @param parameter_name the name of the parameter
		 * @param parameter_value the value to add
		 *
		 * @since 0.6.0
		 */
		public void add_parameter (string parameter_name, string parameter_value);
		/**
		 * A fairly-strict equality function for {@link AbstractFieldDetails}.
		 *
		 * This function compares:
		 *
		 *  * {@link AbstractFieldDetails.value}s
		 *  * {@link AbstractFieldDetails.parameters}
		 *
		 * And does not compare:
		 *
		 *  * {@link AbstractFieldDetails.id}s
		 *
		 * See the description of {@link AbstractFieldDetails.values_equal} for
		 * details on the value comparison.
		 *
		 * To check equality not including the parameters, see
		 * {@link AbstractFieldDetails.values_equal}.
		 *
		 * @param that another {@link AbstractFieldDetails}
		 *
		 * @return whether the elements are equal
		 *
		 * @see AbstractFieldDetails.parameters_equal
		 * @see AbstractFieldDetails.values_equal
		 * @since 0.6.0
		 */
		public virtual bool equal (Folks.AbstractFieldDetails<T> that);
		/**
		 * Same as {@link AbstractFieldDetails.equal}, but static, so we can use
		 * libgee 0.8 without an API break.
		 *
		 * See [[https://bugzilla.gnome.org/show_bug.cgi?id=673918|673918]]
		 * This can and should be removed next time we break the API.
		 * Note: This uses Gee.EqualDataFunc signature, to avoid having to cast.
		 *
		 * @param left one {@link AbstractFieldDetails} to compare
		 * @param right another {@link AbstractFieldDetails} to compare
		 *
		 * @return whether the elemants are equal
		 *
		 * @since 0.9.0
		 */
		public static bool equal_static (Folks.AbstractFieldDetails left, Folks.AbstractFieldDetails right);
		/**
		 * Extend the existing parameters.
		 *
		 * Merge the parameters from ``additional`` into the existing ones.
		 *
		 * @param additional the parameters to add
		 *
		 * @since 0.6.0
		 */
		public void extend_parameters (Gee.MultiMap<string,string> additional);
		/**
		 * Get the values for a parameter
		 *
		 * @param parameter_name the parameter name
		 * @return a collection of values for ``parameter_name`` or ``null`` (i.e. no
		 * collection) if there are no such parameters.
		 *
		 * @since 0.6.0
		 */
		public Gee.Collection<string>? get_parameter_values (string parameter_name);
		/**
		 * A hash function for the {@link AbstractFieldDetails}.
		 *
		 * This defaults to a string hash of the
		 * {@link AbstractFieldDetails.value} if the generic type is string;
		 * otherwise, direct hash of the {@link AbstractFieldDetails.value}.
		 *
		 * @return the hash value
		 *
		 * @since 0.6.0
		 */
		public virtual uint hash ();
		/**
		 * Same as {@link AbstractFieldDetails.hash}, but static, so we can use libgee
		 * 0.8 without an API break.
		 *
		 * See [[https://bugzilla.gnome.org/show_bug.cgi?id=673918|673918]]
		 * This can and should be removed next time we break the API.
		 * Note: This uses Gee.HashDataFunc signature, to avoid having to cast.
		 *
		 * @param value the value to hash
		 *
		 * @return the hash value
		 *
		 * @since 0.9.0
		 */
		public static uint hash_static (Folks.AbstractFieldDetails value);
		/**
		 * An equality function which only considers parameters.
		 *
		 * This function compares:
		 *
		 *  * {@link AbstractFieldDetails.parameters}
		 *
		 * And does not compare:
		 *
		 *  * {@link AbstractFieldDetails.value}s
		 *  * {@link AbstractFieldDetails.id}s
		 *
		 * @param that another {@link AbstractFieldDetails}
		 *
		 * @return whether the elements' {@link AbstractFieldDetails.value}s are
		 * equal.
		 *
		 * @see AbstractFieldDetails.equal
		 * @see AbstractFieldDetails.values_equal
		 * @since 0.6.5
		 */
		public virtual bool parameters_equal (Folks.AbstractFieldDetails<T> that);
		/**
		 * Remove all instances of a parameter.
		 *
		 * @param parameter_name the name of the parameter
		 *
		 * @since 0.6.0
		 */
		public void remove_parameter_all (string parameter_name);
		/**
		 * Set the value of a parameter.
		 *
		 * Sets the parameter called ``parameter_name`` to be ``parameter_value``.
		 * If there were already parameters with the same name they are replaced.
		 *
		 * @param parameter_name the name of the parameter
		 * @param parameter_value the value to add
		 *
		 * @since 0.6.0
		 */
		public void set_parameter (string parameter_name, string parameter_value);
		/**
		 * An equality function which does not consider parameters.
		 *
		 * Specific classes may override this function to provide "smart" value
		 * comparisons (eg, considering the phone number values "+1 555 123 4567" and
		 * "123-4567" equal). If you wish to do strict comparisons, simply compare the
		 * {@link AbstractFieldDetails.value}s directly.
		 *
		 * This function compares:
		 *
		 *  * {@link AbstractFieldDetails.value}s
		 *
		 * And does not compare:
		 *
		 *  * {@link AbstractFieldDetails.parameters}
		 *  * {@link AbstractFieldDetails.id}s
		 *
		 * This defaults to string comparison of the
		 * {@link AbstractFieldDetails.value}s if the generic type is string;
		 * otherwise, direct pointer comparison of the
		 * {@link AbstractFieldDetails.value}s.
		 *
		 * @param that another {@link AbstractFieldDetails}
		 *
		 * @return whether the elements' {@link AbstractFieldDetails.value}s are
		 * equal.
		 *
		 * @see AbstractFieldDetails.equal
		 * @see AbstractFieldDetails.parameters_equal
		 * @since 0.6.5
		 */
		public virtual bool values_equal (Folks.AbstractFieldDetails<T> that);
		/**
		 * A unique ID (if any) for this specific detail.
		 *
		 * This is primarily intended for {@link PersonaStore}s which need to track
		 * specific instances of details (because their backing store is wacky).
		 *
		 * In most cases, this will be an empty string.
		 *
		 * The content of this is opaque to all but the package which set it.
		 *
		 * @since 0.6.5
		 */
		public virtual string id { get; set; }
		/**
		 * The parameters associated with the value.
		 *
		 * A multi-map of the parameters associated with
		 * {@link Folks.AbstractFieldDetails.value}. The keys are the names of
		 * the parameters, while the values are a list of strings.
		 *
		 * @since 0.6.0
		 */
		public virtual Gee.MultiMap<string,string> parameters { get; set construct; }
		/**
		 * The value of the field.
		 *
		 * The value of the field, the exact type and content of which depends on what
		 * the structure is used for.
		 *
		 * @since 0.6.0
		 */
		public virtual T value { get; set construct; }
		/**
		 * The {@link GLib.Type} of the {@link AbstractFieldDetails.value}.
		 *
		 * This is particularly useful for treating collections of different types of
		 * {@link AbstractFieldDetails} in a uniform way without needing to name them
		 * explicitly.
		 *
		 * @since 0.6.5
		 */
		public GLib.Type value_type { get; }
	}
	/**
	 * A singleton persistent cache for avatars in folks.
	 *
	 * Avatars may be added to the cache, and referred to by a persistent
	 * URI from that point onwards. The avatars will be stored on disk in the user's
	 * XDG cache directory.
	 *
	 * The avatar cache is typically used by backends where retrieving avatars is an
	 * expensive operation (for example, they have to be downloaded from the network
	 * every time they're used).
	 *
	 * All avatars from all users of the {@link Folks.AvatarCache} are stored in the
	 * same namespace, so callers must ensure that the IDs they use for avatars are
	 * globally unique (e.g. by using the corresponding {@link Folks.Persona.uid}).
	 *
	 * Ongoing store operations ({@link Folks.AvatarCache.store_avatar}) are rate
	 * limited to try and prevent file descriptor exhaustion. Load operations
	 * ({@link Folks.AvatarCache.load_avatar}) must be rate limited by the client,
	 * as the file I/O occurs when calling {@link GLib.LoadableIcon.load} rather
	 * than when retrieving the {@link GLib.LoadableIcon} from the cache.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class AvatarCache : GLib.Object {
		/**
		 * Build the URI of an avatar file in the cache from a globally unique ID.
		 * This will always succeed, even if the avatar doesn't exist in the cache.
		 *
		 * @param id the globally unique ID for the avatar
		 * @return URI of the avatar file with the given globally unique ID
		 * @since 0.6.0
		 */
		public string build_uri_for_avatar (string id);
		/**
		 * Create or return the singleton {@link Folks.AvatarCache} class instance.
		 * If the instance doesn't exist already, it will be created.
		 *
		 * This function is thread-safe.
		 *
		 * @return Singleton {@link Folks.AvatarCache} instance
		 * @since 0.6.0
		 */
		public static Folks.AvatarCache dup ();
		/**
		 * Fetch an avatar from the cache by its globally unique ID.
		 *
		 * It is up to the caller to ensure that file I/O is rate-limited when loading
		 * many avatars in parallel, by limiting calls to
		 * {@link GLib.LoadableIcon.load}.
		 *
		 * @param id the globally unique ID for the avatar
		 * @return Avatar from the cache, or ``null`` if it doesn't exist in the cache
		 * @throws GLib.Error if checking for existence of the cache file failed
		 * @since 0.6.0
		 */
		public async GLib.LoadableIcon? load_avatar (string id) throws GLib.Error;
		/**
		 * Remove an avatar from the cache, if it exists in the cache. If the avatar
		 * exists in the cache but there is a problem in removing it, a
		 * {@link GLib.Error} will be thrown.
		 *
		 * @param id the globally unique ID for the avatar
		 * @throws GLib.Error if deleting the cache file failed
		 * @since 0.6.0
		 */
		public async void remove_avatar (string id) throws GLib.Error;
		/**
		 * Store an avatar in the cache, assigning the given globally unique ID to it,
		 * which can later be used to load and remove the avatar from the cache. For
		 * example, this ID could be the UID of a persona. The URI of the cached
		 * avatar file will be returned.
		 *
		 * This method may be called multiple times concurrently for the same avatar
		 * ID (e.g. an asynchronous call may be made, and a subsequent asynchronous
		 * call may begin before the first has finished).
		 *
		 * Concurrent file I/O may be rate limited within each {@link AvatarCache}
		 * instance to avoid file descriptor exhaustion.
		 *
		 * @param id the globally unique ID for the avatar
		 * @param avatar the avatar data to cache
		 * @return a URI for the file storing the cached avatar
		 * @throws GLib.Error if the avatar data couldn't be loaded, or if creating
		 * the avatar directory or cache file failed
		 * @since 0.6.0
		 */
		public async string store_avatar (string id, GLib.LoadableIcon avatar) throws GLib.Error;
	}
	/**
	 * A single backend to libfolks, such as Telepathy or evolution-data-server.
	 * Each backend provides {@link Persona}s which are aggregated to form
	 * {@link Individual}s.
	 *
	 * After creating a Backend instance, you must connect to the
	 * {@link Backend.persona_store_added} and
	 * {@link Backend.persona_store_removed} signals, //then// call
	 * {@link Backend.prepare}, otherwise a race condition may occur between
	 * emission of {@link Backend.persona_store_added} and your code connecting to
	 * it.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public abstract class Backend : GLib.Object {
		protected Backend ();
		/**
		 * Disable a {@link PersonaStore}.
		 *
		 * If the given persona store is in this backend {@link Backend.persona_stores},
		 * it will be removed, and we will disconnect from its signals.
		 *
		 * @param store the {@link PersonaStore} to disable.
		 *
		 * @since 0.9.0
		 */
		public abstract void disable_persona_store (Folks.PersonaStore store);
		/**
		 * Enable a {@link PersonaStore}.
		 *
		 * If the given persona store is not already in this backend
		 * {@link Backend.persona_stores}, it will be added to the backend and
		 * {@link Backend.persona_stores} property notification will be emitted,
		 * along with {@link Backend.persona_store_added}.
		 *
		 * @param store the {@link PersonaStore} to enable.
		 *
		 * @since 0.9.0
		 */
		public abstract void enable_persona_store (Folks.PersonaStore store);
		/**
		 * Prepare the Backend for use.
		 *
		 * This connects the Backend to whichever backend-specific services it
		 * requires, and causes it to create its {@link PersonaStore}s. This should be
		 * called //after// connecting to the {@link Backend.persona_store_added} and
		 * {@link Backend.persona_store_removed} signals, or a race condition could
		 * occur, with the signals being emitted before your code has connected to
		 * them, and {@link PersonaStore}s getting "lost" as a result.
		 *
		 * This is normally handled transparently by the {@link IndividualAggregator}.
		 *
		 * If this function throws an error, the Backend will not be functional.
		 *
		 * This function is guaranteed to be idempotent (since version 0.3.0).
		 *
		 * Concurrent calls to this function from different threads will block until
		 * preparation has completed. However, concurrent calls to this function from
		 * a single thread might not, i.e. the first call will block but subsequent
		 * calls might return before the first one. (Though they will be safe in every
		 * other respect.)
		 *
		 * @since 0.1.11
		 * @throws GLib.Error if preparing the backend-specific services failed — this
		 * will be a backend-specific error
		 * @throws GLib.DBusError.SERVICE_UNKNOWN if a required D-Bus service was not
		 * installed or could not be started
		 */
		public abstract async void prepare () throws GLib.Error;
		/**
		 * Set the {@link PersonaStore}s to use in this backend.
		 *
		 * This will cause {@link Backend.persona_store_removed} signals to be emitted
		 * for all removed stores, followed by {@link Backend.persona_store_added}
		 * signals for all added stores. As these signals are emitted, the sets of
		 * individuals in any associated {@link IndividualAggregator}s will be
		 * updated, and {@link IndividualAggregator.individuals_changed} may be
		 * emitted multiple times as appropriate. A property change notification for
		 * {@link Backend.persona_stores} will be emitted last.
		 * Note: pass null storeids to use all available persona stores.
		 *
		 * @param storeids a Set of {@link PersonaStore} IDs to use.
		 *
		 * @since 0.9.0
		 */
		public abstract void set_persona_stores (Gee.Set<string>? storeids);
		/**
		 * Revert the Backend to its pre-prepared state.
		 *
		 * This will disconnect this Backend and its dependencies from their
		 * respective services and the Backend will issue
		 * {@link Backend.persona_store_removed} for each of its
		 * {@link PersonaStore}s.
		 *
		 * Most users won't need to use this function.
		 *
		 * If this function throws an error, the Backend will not be functional.
		 *
		 * Concurrent calls to this function from different threads will block until
		 * preparation has completed. However, concurrent calls to this function from
		 * a single thread might not, i.e. the first call will block but subsequent
		 * calls might return before the first one. (Though they will be safe in every
		 * other respect.)
		 *
		 * @since 0.3.2
		 * @throws GLib.Error if unpreparing the backend-specific services failed —
		 * this will be a backend-specific error
		 */
		public abstract async void unprepare () throws GLib.Error;
		/**
		 * Whether {@link Backend.prepare} has successfully completed for this
		 * backend.
		 *
		 * @since 0.3.0
		 */
		public abstract bool is_prepared { get; }
		/**
		 * Whether the backend has reached a quiescent state. This will happen at some
		 * point after {@link Backend.prepare} has successfully completed for the
		 * backend. A backend is in a quiescent state when all the
		 * {@link PersonaStore}s that it originally knows about have been loaded.
		 *
		 * It's guaranteed that this property's value will only ever change after
		 * {@link Backend.is_prepared} has changed to ``true``.
		 *
		 * When {@link Backend.unprepare} is called, this will be reset to ``false``.
		 *
		 * @since 0.6.2
		 */
		public abstract bool is_quiescent { get; }
		/**
		 * A unique name for the backend.
		 *
		 * This will be used to identify the backend, and should also be used as the
		 * {@link PersonaStore.type_id} of the {@link PersonaStore}s used by the
		 * backend.
		 *
		 * This is guaranteed to always be available; even before
		 * {@link Backend.prepare} is called.
		 */
		public abstract string name { get; }
		/**
		 * The {@link PersonaStore}s in use by the backend.
		 *
		 * A backend may expose {@link Persona}s from multiple servers or accounts
		 * (for example), so may have a {@link PersonaStore} for each.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.Map<string,Folks.PersonaStore> persona_stores { get; }
		/**
		 * Emitted when a {@link PersonaStore} is added to the backend.
		 *
		 * This will not be emitted until after {@link Backend.prepare} has been
		 * called.
		 *
		 * @param store the {@link PersonaStore}
		 */
		public signal void persona_store_added (Folks.PersonaStore store);
		/**
		 * Emitted when a {@link PersonaStore} is removed from the backend.
		 *
		 * This will not be emitted until after {@link Backend.prepare} has been
		 * called.
		 *
		 * @param store the {@link PersonaStore}
		 */
		public signal void persona_store_removed (Folks.PersonaStore store);
	}
	/**
	 * Responsible for backend loading.
	 *
	 * The BackendStore manages the set of available Folks backends. The
	 * {@link BackendStore.load_backends} function loads all compatible and enabled
	 * backends and the {@link BackendStore.backend_available} signal notifies when
	 * these backends are ready.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class BackendStore : GLib.Object {
		/**
		 * This keyword in the keyfile acts as a wildcard for all backends not already
		 * listed in the same file.
		 *
		 * This is particularly useful for tests which want to ensure they're only
		 * operating with backends they were designed for (and thus may not be able to
		 * enumerate entries for).
		 *
		 * To avoid conflicts, backends must not use this as a name.
		 *
		 * @since 0.4.0
		 */
		public static string KEY_FILE_GROUP_ALL_OTHERS;
		/**
		 * Add a new {@link Backend} to the BackendStore.
		 *
		 * @param backend the {@link Backend} to add
		 */
		public void add_backend (Folks.Backend backend);
		/**
		 * Disable a backend.
		 *
		 * Mark a backend as disabled, such that it won't be loaded even when the
		 * client application is restarted. This will not remove the backend if it's
		 * already loaded.
		 *
		 * This method is safe to call multiple times concurrently (e.g. an
		 * asynchronous call may begin after a previous asynchronous call for the same
		 * backend name has begun and before it has finished).
		 *
		 * @param name the name of the backend to disable
		 * @since 0.3.2
		 */
		public async void disable_backend (string name);
		/**
		 * Create a new BackendStore.
		 */
		public static Folks.BackendStore dup ();
		/**
		 * Get a backend from the store by name. If a backend is returned, its
		 * reference count is increased.
		 *
		 * @param name the backend name to retrieve
		 * @return the backend, or ``null`` if none could be found
		 *
		 * @since 0.3.5
		 */
		public Folks.Backend? dup_backend_by_name (string name);
		/**
		 * Enable a backend.
		 *
		 * Mark a backend as enabled, such that the BackendStore will always attempt
		 * to load it when {@link BackendStore.load_backends} is called. This will
		 * not load the backend if it's not currently loaded.
		 *
		 * This method is safe to call multiple times concurrently (e.g. an
		 * asynchronous call may begin after a previous asynchronous call for the same
		 * backend name has begun and before it has finished).
		 *
		 * If the backend is disallowed by the FOLKS_BACKENDS_ALLOWED
		 * and/or FOLKS_BACKENDS_DISABLED environment variables, this method
		 * will store the fact that it should be enabled in future, but will
		 * not enable it during this application run.
		 *
		 * @param name the name of the backend to enable
		 * @since 0.3.2
		 */
		public async void enable_backend (string name);
		/**
		 * List the currently loaded backends.
		 *
		 * @return a list of the backends currently in the BackendStore
		 */
		public Gee.Collection<Folks.Backend> list_backends ();
		/**
		 * Find, load, and prepare all backends which are not disabled.
		 *
		 * Backends will be searched for in the path given by the
		 * ``FOLKS_BACKEND_PATH`` environment variable, if it's set. If it's not set,
		 * backends will be searched for in a path set at compilation time.
		 *
		 * This method is not safe to call multiple times concurrently.
		 *
		 * @throws GLib.Error currently unused
		 */
		public async void load_backends () throws GLib.Error;
		/**
		 * Prepare the BackendStore for use.
		 *
		 * This must only ever be called before {@link BackendStore.load_backends} is
		 * called for the first time. If it isn't called explicitly,
		 * {@link BackendStore.load_backends} will call it.
		 *
		 * This method is safe to call multiple times concurrently (e.g. an
		 * asynchronous call may begin between a subsequent asynchronous call
		 * beginning and finishing).
		 *
		 * @since 0.3.0
		 */
		public async void prepare ();
		/**
		 * The list of backends visible to this store which have not been explicitly
		 * disabled.
		 *
		 * This list will be empty before {@link BackendStore.load_backends} has been
		 * called.
		 *
		 * The backends in this list have been prepared and are ready to use.
		 *
		 * @since 0.5.1
		 */
		public Gee.Map<string,Folks.Backend> enabled_backends { get; private set; }
		/**
		 * Whether {@link BackendStore.prepare} has successfully completed for this
		 * store.
		 *
		 * @since 0.3.0
		 */
		public bool is_prepared { get; private set; }
		/**
		 * Emitted when a backend has been added to the BackendStore.
		 *
		 * This will not be emitted until after {@link BackendStore.load_backends}
		 * has been called.
		 *
		 * {@link Backend}s referenced in this signal are also included in
		 * {@link BackendStore.enabled_backends}.
		 *
		 * @param backend the new {@link Backend}
		 */
		public signal void backend_available (Folks.Backend backend);
	}
	/**
	 * Manages debug output and status reporting for all folks objects.
	 *
	 * All GLib debug logging calls are passed through a log handler in this class,
	 * which allows debug domains to be outputted according to whether they've been
	 * enabled by being passed to {@link Debug.dup}.
	 *
	 * @since 0.5.1
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class Debug : GLib.Object {
		/**
		 * Log domain for the status messages logged as a result of calling
		 * {@link Debug.emit_print_status}.
		 *
		 * This could be used in conjunction with a log handler to redirect the
		 * status information to a debug window or log file, for example.
		 *
		 * @since 0.5.1
		 */
		public const string STATUS_LOG_DOMAIN;
		/**
		 * Create or return the singleton {@link Folks.Debug} class instance.
		 * If the instance doesn't exist already, it will be created with no debug
		 * domains enabled.
		 *
		 * This function is thread-safe.
		 *
		 * @return  Singleton {@link Folks.Debug} instance
		 * @since 0.5.1
		 */
		public static Folks.Debug dup ();
		/**
		 * Create or return the singleton {@link Folks.Debug} class instance.
		 * If the instance doesn't exist already, it will be created with the given
		 * set of debug domains enabled. Otherwise, the existing instance will have
		 * its set of enabled domains changed to the provided set.
		 *
		 * @param debug_flags A comma-separated list of debug domains to enable, or
		 * null to disable debug output
		 * @param colour_enabled Whether debug output should be coloured using
		 * terminal escape sequences
		 * @return Singleton {@link Folks.Debug} instance
		 * @since 0.5.1
		 */
		public static Folks.Debug dup_with_flags (string? debug_flags, bool colour_enabled);
		/**
		 * Causes all significant objects in the library to print their current
		 * status to standard output, obeying the options set on this
		 * {@link Folks.Debug} instance for colouring and other formatting.
		 *
		 * @since 0.5.1
		 */
		public void emit_print_status ();
		/**
		 * Increment the indentation level used when printing output through the
		 * object.
		 *
		 * This is intended to be used by backend libraries only.
		 *
		 * @since 0.5.1
		 */
		public void indent ();
		/**
		 * Print a debug line as a heading. It will be coloured according to the
		 * current indentation level so that different levels of headings stand out.
		 *
		 * This is intended to be used by backend libraries only.
		 *
		 * @param domain The debug domain name
		 * @param level A set of log level flags for the message
		 * @param format A printf-style format string for the heading
		 * @param ... Arguments for the format string
		 * @since 0.5.1
		 */
		[PrintfFormat]
		public void print_heading (string domain, GLib.LogLevelFlags level, string format, ...);
		/**
		 * Print a set of key–value pairs in a table. The width of the key column is
		 * automatically set to the width of the longest key. The keys and values
		 * must be provided as a null-delimited list of alternating key–value varargs.
		 * Values may be null but keys may not.
		 *
		 * This is intended to be used by backend libraries only.
		 *
		 * The table will be printed at the current indentation level plus one.
		 *
		 * @param domain The debug domain name
		 * @param level A set of log level flags for the message
		 * @param ... Alternating keys and values, terminated with null
		 * @since 0.5.1
		 */
		public void print_key_value_pairs (string domain, GLib.LogLevelFlags level, ...);
		/**
		 * Print a debug line with the current indentation level for the specified
		 * debug domain.
		 *
		 * This is intended to be used by backend libraries only.
		 *
		 * @param domain The debug domain name
		 * @param level A set of log level flags for the message
		 * @param format A printf-style format string for the heading
		 * @param ... Arguments for the format string
		 * @since 0.5.1
		 */
		[PrintfFormat]
		public void print_line (string domain, GLib.LogLevelFlags level, string format, ...);
		/**
		 * Decrement the indentation level used when printing output through the
		 * object.
		 *
		 * This is intended to be used by backend libraries only.
		 *
		 * @since 0.5.1
		 */
		public void unindent ();
		public bool colour_enabled { get; set; }
		/**
		 * Whether debug output is enabled. This is orthogonal to the set of enabled
		 * debug domains; filtering of debug output as a whole is done after filtering
		 * by enabled domains.
		 *
		 * @since 0.5.1
		 */
		public bool debug_output_enabled { get; set; }
		/**
		 * Signal emitted in the main thread whenever objects should print their
		 * current status. All significant objects in the library should connect
		 * to this and print their current status in some suitable format when it's
		 * emitted.
		 *
		 * Client processes should emit this signal by calling
		 * {@link Debug.emit_print_status}.
		 *
		 * @since 0.5.1
		 */
		public signal void print_status ();
	}
	/**
	 * Object representing a email address that can have some parameters
	 * associated with it.
	 *
	 * See {@link Folks.AbstractFieldDetails} for details on common parameter names
	 * and values.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class EmailFieldDetails : Folks.AbstractFieldDetails<string> {
		/**
		 * Create a new EmailFieldDetails.
		 *
		 * @param value the value of the field, which should be a valid, non-empty
		 * e-mail address
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * an empty map of parameters.
		 *
		 * @return a new EmailFieldDetails
		 *
		 * @since 0.6.0
		 */
		public EmailFieldDetails (string value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
	}
	/**
	 * Object representing an arbitrary field that can have some parameters
	 * associated with it. This is intended to be as general-purpose as, for
	 * example, a vCard property. See the documentation for
	 * {@link Folks.ExtendedInfo} for information on when using this object is
	 * appropriate.
	 *
	 * See {@link Folks.AbstractFieldDetails} for details on common parameter names
	 * and values.
	 *
	 * @since 0.11.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class ExtendedFieldDetails : Folks.AbstractFieldDetails<string> {
		/**
		 * Create a new ExtendedFieldDetails.
		 *
		 * @param value the value of the field, which may be the empty string
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * an empty map of parameters.
		 *
		 * @return a new ExtendedFieldDetails
		 *
		 * @since 0.11.0
		 */
		public ExtendedFieldDetails (string value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.11.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.11.0
		 */
		public override uint hash ();
	}
	/**
	 * Object representing an IM address value that can have some parameters
	 * associated with it.
	 *
	 * See {@link Folks.AbstractFieldDetails}.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class ImFieldDetails : Folks.AbstractFieldDetails<string> {
		/**
		 * Create a new ImFieldDetails.
		 *
		 * @param value the value of the field, which should be a valid, non-empty
		 * IM address
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * an empty map of parameters.
		 *
		 * @return a new ImFieldDetails
		 *
		 * @since 0.6.0
		 */
		public ImFieldDetails (string value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
	}
	/**
	 * A physical person, aggregated from the various {@link Persona}s the person
	 * might have, such as their different IM addresses or vCard entries. An
	 * individual must always contain at least one {@link Persona}.
	 *
	 * When choosing the values of single-valued properties (such as
	 * {@link Individual.alias} and {@link Individual.avatar}; but not multi-valued
	 * properties such as {@link Individual.groups} and
	 * {@link Individual.im_addresses}) from the {@link Persona}s in the
	 * individual to present as the values of those properties of the individual,
	 * it is guaranteed that if the individual contains a persona from the primary
	 * persona store (see {@link IndividualAggregator.primary_store}), its property
	 * values will be chosen above all others. This means that any changes to
	 * property values made through folks (which are normally written to the primary
	 * store) will always be used by {@link Folks.Individual}s.
	 *
	 * No further guarantees are made about the order of preference used for
	 * choosing which property values to use for the {@link Folks.Individual}, other
	 * than that the order may vary between properties, but is guaranteed to be
	 * stable for a given property.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class Individual : GLib.Object, Folks.AliasDetails, Folks.AvatarDetails, Folks.BirthdayDetails, Folks.EmailDetails, Folks.ExtendedInfo, Folks.FavouriteDetails, Folks.GenderDetails, Folks.GroupDetails, Folks.ImDetails, Folks.InteractionDetails, Folks.LocalIdDetails, Folks.LocationDetails, Folks.NameDetails, Folks.NoteDetails, Folks.PresenceDetails, Folks.PhoneDetails, Folks.PostalAddressDetails, Folks.RoleDetails, Folks.UrlDetails, Folks.WebServiceDetails {
		/**
		 * Create a new Individual.
		 *
		 * The Individual can optionally be seeded with the {@link Persona}s in
		 * ``personas``. Otherwise, it will have to have personas added using the
		 * {@link Folks.Individual.personas} property after construction.
		 *
		 * @param personas a list of {@link Persona}s to initialise the
		 * {@link Folks.Individual} with, or ``null``
		 * @return a new Individual
		 *
		 * @since 0.5.1
		 */
		public Individual (Gee.Set<Folks.Persona>? personas);
		/**
		 * Anti-linked with an individual?
		 *
		 * Check whether this individual is anti-linked to any of the {@link Persona}s
		 * in {@link Folks.Individual} ``i``. If so, ``true`` will be returned —
		 * ``false`` will be returned otherwise.
		 *
		 * Note that this will check for anti-links in either direction, since
		 * anti-links are not necessarily symmetric.
		 *
		 * @param i individual to check for anti-links with
		 * @return ``true`` if this individual is anti-linked with individual ``i``;
		 * ``false`` otherwise
		 * @since 0.7.3
		 */
		public bool has_anti_link_with_individual (Folks.Individual i);
		/**
		 * Anti-linked with a persona?
		 *
		 * Check whether this individual is anti-linked to {@link Persona} ``p`` at
		 * all. If so, ``true`` will be returned — ``false`` will be returned
		 * otherwise.
		 *
		 * Note that this will check for anti-links in either direction, since
		 * anti-links are not necessarily symmetric.
		 *
		 * @param p persona to check for anti-links with
		 * @return ``true`` if this individual is anti-linked with persona ``p``;
		 * ``false``
		 * otherwise
		 * @since 0.7.3
		 */
		public bool has_anti_link_with_persona (Folks.Persona p);
		/**
		 * The name of this Individual to display in the UI.
		 *
		 * This value is set according to the following list of possibilities, each
		 * one being tried first on the primary persona, then on all other personas in
		 * the Individual, before falling back to the next item on the list:
		 * # Alias
		 * # Full name, structured name or nickname
		 * # E-mail address
		 * # Phone number
		 * # Display ID (e.g. foo@example.org)
		 * # Postal address
		 * # _("Unnamed Person")
		 *
		 * @since 0.9.7
		 */
		[CCode (notify = false)]
		public string display_name { get; }
		/**
		 * A unique identifier for the Individual.
		 *
		 * This uniquely identifies the Individual, and persists across
		 * {@link IndividualAggregator} instances. It may not persist across linking
		 * the Individual with other Individuals.
		 *
		 * This is an opaque string and has no structure.
		 *
		 * If an identifier is required which will be used for a long-lived link
		 * between different stored data, it may be more desirable to use the
		 * {@link Persona.uid} of the most relevant {@link Persona} in the Individual
		 * instead. For example, if storing references to Individuals who are tagged
		 * in a photo, it may be safer to store the UID of the Persona whose backend
		 * provided the photo (e.g. Facebook).
		 *
		 * As a special case, the ID defaults to an empty string when the individual
		 * has no personas (i.e. if it’s just been constructed).
		 */
		public string id { get; private set; }
		/**
		 * Whether the Individual is the user.
		 *
		 * Iff the Individual represents the user – the person who owns the
		 * account in the backend for each {@link Persona} in the Individual –
		 * this is ``true``.
		 *
		 * It is //not// guaranteed that every {@link Persona} in the Individual has
		 * its {@link Persona.is_user} set to the same value as the Individual. For
		 * example, the user could own two Telepathy accounts, and have added the
		 * other account as a contact in each account. The accounts will expose a
		 * {@link Persona} for the user (which will have {@link Persona.is_user} set
		 * to ``true``) //and// a {@link Persona} for the contact for the other
		 * account (which will have {@link Persona.is_user} set to ``false``).
		 *
		 * It is guaranteed that iff this property is set to ``true`` on an
		 * Individual, there will be at least one {@link Persona} in the Individual
		 * with its {@link Persona.is_user} set to ``true``.
		 *
		 * It is guaranteed that there will only ever be one Individual with this
		 * property set to ``true``.
		 *
		 * @since 0.3.0
		 */
		public bool is_user { get; private set; }
		/**
		 * The set of {@link Persona}s encapsulated by this Individual.
		 *
		 * There must always be at least one Persona in this set.
		 *
		 * No order is specified over the set of personas, as such an order may be
		 * different across each of the properties implemented by the personas (e.g.
		 * should they be ordered by presence, name, star sign, etc.?).
		 *
		 * Changing the set of personas may cause updates to the aggregated properties
		 * provided by the Individual, resulting in property notifications for them.
		 *
		 * Changing the set of personas will not cause permanent linking/unlinking of
		 * the added/removed personas to/from this Individual. To do that, call
		 * {@link IndividualAggregator.link_personas} or
		 * {@link IndividualAggregator.unlink_individual}, which will ensure the link
		 * changes are written to the appropriate backend.
		 *
		 * @since 0.5.1
		 */
		public Gee.Set<Folks.Persona> personas { get; set; }
		/**
		 * The trust level of the Individual.
		 *
		 * This specifies how far the Individual can be trusted to be who it claims
		 * to be. See the descriptions for the elements of {@link TrustLevel}.
		 *
		 * Clients should ''not'' allow linking of Individuals who have a trust level
		 * of {@link TrustLevel.NONE}.
		 *
		 * @since 0.1.15
		 */
		public Folks.TrustLevel trust_level { get; private set; }
		/**
		 * Emitted when one or more {@link Persona}s are added to or removed from
		 * the Individual. As the parameters are (unordered) sets, the orders of their
		 * elements are undefined.
		 *
		 * @param added a set of {@link Persona}s which have been added
		 * @param removed a set of {@link Persona}s which have been removed
		 *
		 * @since 0.5.1
		 */
		public signal void personas_changed (Gee.Set<Folks.Persona> added, Gee.Set<Folks.Persona> removed);
		/**
		 * Emitted when the last of the Individual's {@link Persona}s has been
		 * removed.
		 *
		 * At this point, the Individual is invalid, so any client referencing it
		 * should unreference it and remove it from their UI.
		 *
		 * @param replacement_individual the individual which has replaced this one
		 * due to linking, or ``null`` if this individual was removed for another
		 * reason
		 * @since 0.1.13
		 */
		public signal void removed (Folks.Individual? replacement_individual);
	}
	/**
	 * Stores {@link Individual}s which have been created through
	 * aggregation of all the {@link Persona}s provided by the various
	 * {@link Backend}s.
	 *
	 * This is the main interface for client applications.
	 *
	 * Linking and unlinking of personas and individuals is performed entirely
	 * through the aggregator. Personas may be linked together to form individuals;
	 * for example, the personas which form ``individual1`` and ``individual2`` may
	 * be linked together with ``another_persona`` to give a new {@link Individual}:
	 *
	 * {{{
	 *   var personas = new HashSet<Persona> ();
	 *   personas.add_all (individual1.personas);
	 *   personas.add_all (individual2.personas);
	 *   personas.add (another_persona);
	 *   yield my_individual_aggregator.link_personas (personas);
	 * }}}
	 *
	 * The individuals which contained those personas will be removed when
	 * {@link IndividualAggregator.link_personas} is called. Any personas in those
	 * individuals which were not included in the linking call may end up implicitly
	 * linked to the new individual, or may be aggregated into other new
	 * individuals.
	 *
	 * For example, consider the situation where ``individual1`` contains two
	 * personas, ``persona1A`` and ``persona1B``; ``individual2`` contains one
	 * persona, ``persona2A``; and ``another_persona`` comes from ``individual3``,
	 * which also contains ``persona3A`` and ``persona3B``. Calling
	 * {@link IndividualAggregator.link_personas} on ``persona1A``, ``persona1B``,
	 * ``persona2A`` and ``another_persona`` will result in ``individual1`` and
	 * ``individual2`` being removed. A new {@link Individual} will be created
	 * containing all the personas passed to the linking function. It might also
	 * contain ``persona3A`` and ``persona3B``; or they might be in one or two other
	 * new individuals.
	 *
	 * An existing individual may be unlinked to form singleton
	 * individuals for each of its personas:
	 * {{{
	 *   yield my_individual_aggregator.unlink_individual (my_individual);
	 * }}}
	 *
	 * Note that to link two individuals together, their two sets of personas must
	 * be linked together. There is no API to directly link the individuals
	 * themselves, as conceptually folks links {@link Persona}s, not
	 * {@link Individual}s.
	 *
	 * Folks does not support having more than one IndividualAggregator
	 * instantiated at the same time. Most clients should use
	 * {@link IndividualAggregator.dup} to retrieve the IndividualAggregator
	 * singleton.
	 *
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class IndividualAggregator : GLib.Object {
		/**
		 * Create a new IndividualAggregator.
		 *
		 * Clients should connect to the
		 * {@link IndividualAggregator.individuals_changed} signal (or the
		 * {@link IndividualAggregator.individuals_changed_detailed} signal), then
		 * call {@link IndividualAggregator.prepare} to load the backends and start
		 * aggregating individuals.
		 *
		 * An example of how to set up an IndividualAggregator:
		 * {{{
		 *   IndividualAggregator agg = new IndividualAggregator ();
		 *   agg.individuals_changed_detailed.connect (individuals_changed_cb);
		 *   agg.prepare ();
		 * }}}
		 *
		 * Folks does not support having more than one IndividualAggregator
		 * instantiated at the same time. So it's recommended to use
		 * {@link IndividualAggregator.dup} instead.
		 */
		[Version (deprecated = true, deprecated_since = "0.9.5", replacement = "IndividualAggregator.dup")]
		public IndividualAggregator ();
		/**
		 * Add a new persona in the given {@link PersonaStore} based on the
		 * ``details`` provided.
		 *
		 * If the target store is offline, this function will throw
		 * {@link IndividualAggregatorError.STORE_OFFLINE}. It's the responsibility of
		 * the caller to cache details and re-try this function if it wishes to make
		 * offline adds work.
		 *
		 * The details hash is a backend-specific mapping of key, value strings.
		 * Common keys include:
		 *
		 *  * contact - service-specific contact ID
		 *  * message - a user-readable message to pass to the persona being added
		 *
		 * If a {@link Persona} with the given details already exists in the store, no
		 * error will be thrown and this function will return ``null``.
		 *
		 * @param parent an optional {@link Individual} to add the new {@link Persona}
		 * to. This persona will be appended to its ordered list of personas.
		 * @param persona_store the {@link PersonaStore} to add the persona to
		 * @param details a key-value map of details to use in creating the new
		 * {@link Persona}
		 * @return the new {@link Persona} or ``null`` if the corresponding
		 * {@link Persona} already existed. If non-``null``, the new {@link Persona}
		 * will also be added to a new or existing {@link Individual} as necessary.
		 * @throws IndividualAggregatorError.STORE_OFFLINE if the persona store was
		 * offline
		 * @throws IndividualAggregatorError.ADD_FAILED if any other error occurred
		 * while adding the persona
		 *
		 * @since 0.3.5
		 */
		public async Folks.Persona? add_persona_from_details (Folks.Individual? parent, Folks.PersonaStore persona_store, GLib.HashTable<string,GLib.Value?> details) throws Folks.IndividualAggregatorError;
		/**
		 * Create or return the singleton {@link IndividualAggregator} class instance.
		 * If the instance doesn't exist already, it will be created with the
		 * default {@link BackendStore}.
		 *
		 * This function is thread-safe.
		 *
		 * @return Singleton {@link IndividualAggregator} instance
		 * @since 0.9.5
		 */
		public static Folks.IndividualAggregator dup ();
		/**
		 * Create or return the singleton {@link IndividualAggregator} class instance
		 * with a custom {@link BackendStore}.
		 * If the instance doesn't exist already, it will be created with
		 * the given {@link BackendStore} rather than the default one.
		 * If the instance already exists but is using another {@link BackendStore}
		 * then a warning is raised and null is returned.
		 *
		 * This function is thread-safe.
		 *
		 * @param store the {@link BackendStore} to use instead of the default one.
		 
		 * @return Singleton {@link IndividualAggregator} instance, or null
		 * @since 0.9.5
		 */
		public static Folks.IndividualAggregator? dup_with_backend_store (Folks.BackendStore store);
		/**
		 * Ensure that the given property is writeable for the given
		 * {@link Individual}.
		 *
		 * This makes sure that there is at least one {@link Persona} in the
		 * individual which has ``property_name`` in its
		 * {@link Persona.writeable_properties}. If no such persona exists in the
		 * individual, a new one will be created and linked to the individual. (Note
		 * that due to the design of the aggregator, this will result in the previous
		 * individual being removed and replaced by a new one with the new persona;
		 * listen to the {@link Individual.removed} signal to see the replacement.)
		 *
		 * It may not be possible to create a new persona which has the given property
		 * as writeable. In that case, a
		 * {@link IndividualAggregatorError.NO_PRIMARY_STORE} or
		 * {@link IndividualAggregatorError.PROPERTY_NOT_WRITEABLE} error will be
		 * thrown.
		 *
		 * This method is safe to call multiple times concurrently, although
		 * concurrent calls for the same individual may result in duplicate personas
		 * being created.
		 *
		 * @param individual the individual for which ``property_name`` should be
		 * writeable
		 * @param property_name the name of the property which needs to be writeable
		 * (this should be in lower case using hyphens, e.g. “web-service-addresses”)
		 * @return a persona (new or existing) which has the given property as
		 * writeable
		 * @throws IndividualAggregatorError.NO_PRIMARY_STORE if no primary store was
		 * configured for this individual aggregator
		 * @throws IndividualAggregatorError.PROPERTY_NOT_WRITEABLE if the given
		 * ``property_name`` referred to a non-writeable property
		 * @throws IndividualAggregatorError if adding a new persona (using
		 * {@link IndividualAggregator.add_persona_from_details}) failed, or if
		 * linking personas (using {@link IndividualAggregator.link_personas}) failed
		 *
		 * @since 0.6.2
		 */
		public async Folks.Persona ensure_individual_property_writeable (Folks.Individual individual, string property_name) throws Folks.IndividualAggregatorError;
		/**
		 * Get all combinations between all {@link Individual}s.
		 *
		 * @param min_threshold the threshold for accepting a match
		 * @return a map from each individual in the aggregator to a map of the
		 * other individuals in the aggregator which can be matched with that
		 * individual, mapped to the degree with which they match the original
		 * individual (which is guaranteed to at least equal ``min_threshold``)
		 *
		 * @since 0.5.1
		 */
		public Gee.Map<Folks.Individual,Gee.Map<Folks.Individual,Folks.MatchResult>> get_all_potential_matches (Folks.MatchResult min_threshold = MatchResult.VERY_HIGH);
		/**
		 * Get all matches for a given {@link Individual}.
		 *
		 * @param matchee the individual to find matches for
		 * @param min_threshold the threshold for accepting a match
		 * @return a map from matched individuals to the degree with which they match
		 * ``matchee`` (which is guaranteed to at least equal ``min_threshold``);
		 * if no matches could be found, an empty map is returned
		 *
		 * @since 0.5.1
		 */
		public Gee.Map<Folks.Individual,Folks.MatchResult> get_potential_matches (Folks.Individual matchee, Folks.MatchResult min_threshold = MatchResult.VERY_HIGH);
		/**
		 * Link the given {@link Persona}s together.
		 *
		 * Create links between the given {@link Persona}s so that they form a single
		 * {@link Individual}. The new {@link Individual} will be returned via the
		 * {@link IndividualAggregator.individuals_changed} signal.
		 *
		 * Removal of the {@link Individual}s which the {@link Persona}s were in
		 * before is signalled by {@link IndividualAggregator.individuals_changed} and
		 * {@link Individual.removed}.
		 *
		 * This method is safe to call multiple times concurrently.
		 *
		 * @param personas the {@link Persona}s to be linked
		 * @throws IndividualAggregatorError.NO_PRIMARY_STORE if no primary store has
		 * been configured for the individual aggregator
		 * @throws IndividualAggregatorError if adding the linking persona failed —
		 * this will be passed through from
		 * {@link IndividualAggregator.add_persona_from_details}
		 *
		 * @since 0.5.1
		 */
		public async void link_personas (Gee.Set<Folks.Persona> personas) throws Folks.IndividualAggregatorError;
		/**
		 * Look up an individual in the aggregator.
		 *
		 * This returns the {@link Individual} with the given ``id`` if it exists in
		 * the aggregator, and ``null`` otherwise.
		 *
		 * In future, when lazy-loading of individuals' properties is added to folks,
		 * this method guarantees to load all properties of the individual, even if
		 * the aggregator hasn't lazy-loaded anything else.
		 *
		 * This method is safe to call before {@link IndividualAggregator.prepare} has
		 * been called, and will call {@link IndividualAggregator.prepare} itself in
		 * that case.
		 *
		 * This method is safe to call multiple times concurrently.
		 *
		 * @param id ID of the individual to look up
		 * @return individual with ``id``, or ``null`` if no such individual was found
		 * @throws GLib.Error from {@link IndividualAggregator.prepare}
		 *
		 * @since 0.7.0
		 */
		public async Folks.Individual? look_up_individual (string id) throws GLib.Error;
		/**
		 * Prepare the IndividualAggregator for use.
		 *
		 * This loads all the available backends and prepares them for use by the
		 * IndividualAggregator. This should be called //after// connecting to the
		 * {@link IndividualAggregator.individuals_changed} signal (or
		 * {@link IndividualAggregator.individuals_changed_detailed} signal), or a
		 * race condition could occur, with the signal being emitted before your code
		 * has connected to them, and {@link Individual}s getting "lost" as a result.
		 *
		 * This function is guaranteed to be idempotent (since version 0.3.0).
		 *
		 * Concurrent calls to this function from different threads will block until
		 * preparation has completed. However, concurrent calls to this function from
		 * a single thread might not, i.e. the first call will block but subsequent
		 * calls might return before the first one. (Though they will be safe in every
		 * other respect.)
		 *
		 * @throws GLib.Error if preparing any of the backends failed — this error
		 * will be passed through from {@link BackendStore.load_backends}
		 *
		 * @since 0.1.11
		 */
		public async void prepare () throws GLib.Error;
		/**
		 * Completely remove the individual and all of its personas from their
		 * backing stores.
		 *
		 * This method is safe to call multiple times concurrently (for the same
		 * individual or different individuals).
		 *
		 * @param individual the {@link Individual} to remove
		 * @throws GLib.Error if removing the persona failed — this will be passed
		 * through from {@link PersonaStore.remove_persona}
		 *
		 * @since 0.1.11
		 */
		public async void remove_individual (Folks.Individual individual) throws GLib.Error;
		/**
		 * Completely remove the persona from its backing store.
		 *
		 * This will leave other personas in the same individual alone.
		 *
		 * This method is safe to call multiple times concurrently (for the same
		 * persona or different personas).
		 *
		 * @param persona the {@link Persona} to remove
		 * @throws GLib.Error if removing the persona failed — this will be passed
		 * through from {@link PersonaStore.remove_persona}
		 *
		 * @since 0.1.11
		 */
		public async void remove_persona (Folks.Persona persona) throws GLib.Error;
		/**
		 * Unlinks the given {@link Individual} into its constituent {@link Persona}s.
		 *
		 * This completely unlinks the given {@link Individual}, destroying all of
		 * its writeable {@link Persona}s.
		 *
		 * The {@link Individual}'s removal is signalled by
		 * {@link IndividualAggregator.individuals_changed} and
		 * {@link Individual.removed}.
		 *
		 * The {@link Persona}s comprising the {@link Individual} will be re-linked
		 * into one or more new {@link Individual}s, depending on how much linking
		 * data remains (typically only implicit links remain). The addition of these
		 * new {@link Individual}s will be signalled by
		 * {@link IndividualAggregator.individuals_changed}.
		 *
		 * This method is safe to call multiple times concurrently, although
		 * concurrent calls for the same individual may result in duplicate personas
		 * being created.
		 *
		 * @param individual the {@link Individual} to unlink
		 * @throws GLib.Error if removing the linking persona failed — this will be
		 * passed through from {@link PersonaStore.remove_persona}
		 *
		 * @since 0.1.13
		 */
		public async void unlink_individual (Folks.Individual individual) throws GLib.Error;
		/**
		 * Clean up and release resources used by the aggregator.
		 *
		 * This will disconnect the aggregator cleanly from any resources it or its
		 * persona stores are using. It is recommended to call this method before
		 * finalising the individual aggregator, but calling it is not required. If
		 * this method is not called then, for example, unsaved changes in backends
		 * may not be flushed.
		 *
		 * Concurrent calls to this function from different threads will block until
		 * preparation has completed. However, concurrent calls to this function from
		 * a single thread might not, i.e. the first call will block but subsequent
		 * calls might return before the first one. (Though they will be safe in every
		 * other respect.)
		 *
		 * @since 0.7.3
		 * @throws GLib.Error if unpreparing the backend-specific services failed —
		 * this will be a backend-specific error
		 */
		public async void unprepare () throws GLib.Error;
		/**
		 * Create a new IndividualAggregator with a custom {@link BackendStore}.
		 *
		 * This behaves the same as the default constructor for
		 * {@link IndividualAggregator}, but uses the given {@link BackendStore}
		 * rather than the default one.
		 *
		 * @param store the {@link BackendStore} to use instead of the default one.
		 *
		 * @since 0.9.0
		 */
		[Version (deprecated = true, deprecated_since = "0.9.5", replacement = "IndividualAggregator.dup_with_backend_store")]
		public IndividualAggregator.with_backend_store (Folks.BackendStore store);
		/**
		 * The backend store providing the persona stores for this aggregator.
		 *
		 * @since 0.9.7
		 */
		public Folks.BackendStore backend_store { get; construct; }
		/**
		 * A map from {@link Individual.id}s to their {@link Individual}s.
		 *
		 * This is the canonical set of {@link Individual}s provided by this
		 * IndividualAggregator.
		 *
		 * {@link Individual}s may be added or removed using
		 * {@link IndividualAggregator.add_persona_from_details} and
		 * {@link IndividualAggregator.remove_individual}, respectively.
		 *
		 * @since 0.5.1
		 */
		public Gee.Map<string,Folks.Individual> individuals { get; private set; }
		/**
		 * Whether {@link IndividualAggregator.prepare} has successfully completed for
		 * this aggregator.
		 *
		 * @since 0.3.0
		 */
		public bool is_prepared { get; }
		/**
		 * Whether the aggregator has reached a quiescent state. This will happen at
		 * some point after {@link IndividualAggregator.prepare} has successfully
		 * completed for the aggregator. An aggregator is in a quiescent state when
		 * all the {@link PersonaStore}s listed by its backends have reached a
		 * quiescent state. Once it's reached a quiescent state, this property will
		 * never change again (from ``true`` to ``false``).
		 *
		 * It's guaranteed that this property's value will only ever change after
		 * {@link IndividualAggregator.is_prepared} has changed to ``true``.
		 *
		 * @since 0.6.2
		 */
		public bool is_quiescent { get; }
		/**
		 * Our configured primary (writeable) store.
		 *
		 * Which one to use is decided (in order or precedence)
		 * by:
		 *
		 * - the FOLKS_PRIMARY_STORE env var (mostly for debugging)
		 * - the GSettings key set in ``_PRIMARY_STORE_CONFIG_KEY`` (system set store)
		 * - going with the ``key-file`` or ``eds`` store as the fall-back option
		 *
		 * @since 0.5.0
		 */
		public Folks.PersonaStore? primary_store { get; }
		/**
		 * The {@link Individual} representing the user.
		 *
		 * If it exists, this holds the {@link Individual} who is the user: the
		 * {@link Individual} containing the {@link Persona}s who are the owners of
		 * the accounts for their respective backends.
		 *
		 * @since 0.3.0
		 */
		public Folks.Individual? user { get; private set; }
		/**
		 * Emitted when one or more {@link Individual}s are added to or removed from
		 * the aggregator.
		 *
		 * If more information about the relationships between {@link Individual}s
		 * which have been linked and unlinked is needed, consider connecting to
		 * {@link IndividualAggregator.individuals_changed_detailed} instead, which is
		 * emitted at the same time as this signal.
		 *
		 * This will not be emitted until after {@link IndividualAggregator.prepare}
		 * has been called.
		 *
		 * @param added a list of {@link Individual}s which have been added
		 * @param removed a list of {@link Individual}s which have been removed
		 * @param message a string message from the backend, if any
		 * @param actor the {@link Persona} who made the change, if known
		 * @param reason the reason for the change
		 *
		 * @since 0.5.1
		 */
		[Version (deprecated = true, deprecated_since = "0.6.2", replacement = "IndividualAggregator.individuals_changed_detailed")]
		public signal void individuals_changed (Gee.Set<Folks.Individual> added, Gee.Set<Folks.Individual> removed, string? message, Folks.Persona? actor, Folks.GroupDetails.ChangeReason reason);
		/**
		 * Emitted when one or more {@link Individual}s are added to or removed from
		 * the aggregator.
		 *
		 * This is emitted at the same time as
		 * {@link IndividualAggregator.individuals_changed}, but includes more
		 * information about the relationships between {@link Individual}s which have
		 * been linked and unlinked.
		 *
		 * Individuals which have been linked will be listed in the multi-map as
		 * mappings from the old individuals to the single new individual which
		 * replaces them (i.e. each of the old individuals will map to the same new
		 * individual). This new individual is the one which will be specified as the
		 * ``replacement_individual`` in the {@link Individual.removed} signal for the
		 * old individuals.
		 *
		 * Individuals which have been unlinked will be listed in the multi-map as
		 * a mapping from the unlinked individual to a set of one or more individuals
		 * which replace it.
		 *
		 * Individuals which have been added will be listed in the multi-map as a
		 * mapping from ``null`` to the set of added individuals. If ``null`` doesn't
		 * map to anything, no individuals have been added to the aggregator.
		 *
		 * Individuals which have been removed will be listed in the multi-map as
		 * mappings from the removed individual to ``null``.
		 *
		 * This will not be emitted until after {@link IndividualAggregator.prepare}
		 * has been called.
		 *
		 * @param changes a mapping of old {@link Individual}s to new
		 * {@link Individual}s for the individuals which have changed in the
		 * aggregator
		 *
		 * @since 0.6.2
		 */
		public signal void individuals_changed_detailed (Gee.MultiMap<Folks.Individual?,Folks.Individual?> changes);
	}
	/**
	 * A location. Typically latitude and longitude will
	 * be based on WGS84. However, folks often has no
	 * way of verifying that and just has to assume
	 * it's true.
	 *
	 * @since 0.9.2
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class Location : GLib.Object {
		/**
		 * The latitude.
		 *
		 * @since 0.9.2
		 */
		public double latitude;
		/**
		 * The longitude.
		 *
		 * @since 0.9.2
		 */
		public double longitude;
		/**
		 * Constructs a new instance with the given coordinates.
		 * @param latitude latitude of the new instance
		 * @param longitude longitude of the new instance
		 * @since 0.9.2
		 */
		public Location (double latitude, double longitude);
		/**
		 * Compare this location to another by geographical position.
		 *
		 * @param other the instance to compare against
		 * @return true iff the coordinates are exactly the same
		 * @since 0.9.2
		 */
		public bool equal (Folks.Location other);
		/**
		 * Compare the geographical position of this location against
		 * another position.
		 *
		 * @param latitude latitude of the other position
		 * @param longitude longitude of the other position
		 * @return true iff the coordinates are exactly the same
		 * @since 0.9.2
		 */
		public bool equal_coordinates (double latitude, double longitude);
	}
	/**
	 * Object representing a note that can have some parameters associated with it.
	 *
	 * See {@link Folks.AbstractFieldDetails} for details on common parameter names
	 * and values.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class NoteFieldDetails : Folks.AbstractFieldDetails<string> {
		/**
		 * Create a new NoteFieldDetails.
		 *
		 * @param value the value of the field, which should be a non-empty free-form
		 * UTF-8 string as entered by the user
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * a empty map of parameters.
		 * @param uid UID for the note object itself, if known. A ``null`` value means
		 * the note has no unique ID.
		 *
		 * @return a new NoteFieldDetails
		 *
		 * @since 0.6.0
		 */
		public NoteFieldDetails (string value, Gee.MultiMap<string,string>? parameters = null, string? uid = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
		/**
		 * {@inheritDoc}
		 */
		public override string id { get; set; }
		/**
		 * The UID of the note (if any).
		 */
		[Version (deprecated = true, deprecated_since = "0.6.5", replacement = "AbstractFieldDetails.id")]
		public string uid { get; set; }
	}
	/**
	 * A generic abstract cache for sets of objects. This can be used by subclasses
	 * to implement caching of homogeneous sets of objects. Subclasses simply have
	 * to implement serialisation and deserialisation of the objects to and from
	 * {@link GLib.Variant}s.
	 *
	 * It's intended that this class be used for providing caching layers for
	 * {@link PersonaStore}s, for example.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public abstract class ObjectCache<T> : GLib.Object {
		/**
		 * Create a new cache instance using the given type ID and ID. This is
		 * protected as the ``type_id`` will typically be set statically by
		 * subclasses.
		 *
		 * @param type_id A string identifying the type of object being cached. This
		 * has to be suitable for use as a directory name; i.e. lower case,
		 * hyphen-separated.
		 * @param id A string identifying the particular cache instance. This will
		 * form the file name of the cache file, but will be escaped beforehand, so
		 * can be an arbitrary non-empty string.
		 * @return A new cache instance
		 *
		 * @since 0.6.0
		 */
		protected ObjectCache (string type_id, string id);
		/**
		 * Clear this cache object, deleting its backing file.
		 *
		 * @since 0.6.0
		 */
		public async void clear_cache ();
		/**
		 * Deserialise the given ``variant`` to a new instance of an object. The
		 * variant is guaranteed to have the type returned by
		 * {@link ObjectCache.get_serialised_object_type}.
		 *
		 * @param variant the serialised form to deserialise
		 * @param object_version the version of the object format to deserialise from
		 * @return the deserialised object
		 *
		 * @since 0.6.0
		 */
		protected abstract T deserialise_object (GLib.Variant variant, uint8 object_version);
		/**
		 * Get the {@link GLib.VariantType} of the serialised form of an object stored
		 * in this cache.
		 *
		 * If a smooth upgrade path is needed in future due to cache file format
		 * changes, this may be modified to take a version parameter.
		 *
		 * @param object_version the version of the object format to use, or
		 * ``uint8.MAX`` for the latest version
		 * @return variant type for that object version, or ``null`` if the version is
		 * unsupported
		 * @since 0.6.0
		 */
		protected abstract GLib.VariantType? get_serialised_object_type (uint8 object_version);
		/**
		 * Get the version of the variant type returned by
		 * {@link ObjectCache.get_serialised_object_type}. This must be incremented
		 * every time the variant type changes so that old cache files aren't
		 * misinterpreted.
		 *
		 * @since 0.6.0
		 */
		protected abstract uint8 get_serialised_object_version ();
		/**
		 * Load a set of objects from the cache and return them as a new set. If the
		 * cache file doesn't exist, ``null`` will be returned. An empty set will be
		 * returned if the cache file existed but was empty (i.e. was stored with
		 * an empty set originally).
		 *
		 * Loading the objects can be cancelled using ``cancellable``. If it is,
		 * ``null`` will be returned.
		 *
		 * If any errors are encountered while loading the objects, warnings will be
		 * logged as appropriate and ``null`` will be returned.
		 *
		 * This method is safe to call multiple times concurrently.
		 *
		 * @param cancellable A {@link GLib.Cancellable} for the operation, or
		 * ``null``.
		 * @return A set of objects from the cache, or ``null``.
		 *
		 * @since 0.6.0
		 */
		public async Gee.Set<T>? load_objects (GLib.Cancellable? cancellable = null);
		/**
		 * Serialise the given ``object`` to a {@link GLib.Variant} and return the
		 * variant. The variant must be of the type returned by
		 * {@link ObjectCache.get_serialised_object_type}.
		 *
		 * @param object the object to serialise
		 * @return serialised form of ``object``
		 *
		 * @since 0.6.0
		 */
		protected abstract GLib.Variant serialise_object (T object);
		/**
		 * Store a set of objects to the cache file, overwriting any existing set of
		 * objects in the cache, or creating the cache file from scratch if it didn't
		 * previously exist.
		 *
		 * Storing the objects can be cancelled using ``cancellable``. If it is, the
		 * cache will be left in a consistent state, but may be storing the old set
		 * of objects or the new set.
		 *
		 * This method is safe to call multiple times concurrently.
		 *
		 * @param objects A set of objects to store. This may be empty, but may not
		 * be ``null``.
		 * @param cancellable A {@link GLib.Cancellable} for the operation, or
		 * ``null``.
		 *
		 * @since 0.6.0
		 */
		public async void store_objects (Gee.Set<T> objects, GLib.Cancellable? cancellable = null);
		/**
		 * A string identifying the particular cache instance.
		 *
		 * This will form the file name of the cache file, but will be escaped
		 * beforehand, so can be an arbitrary non-empty string.
		 *
		 * @since 0.6.6
		 */
		public string id { get; construct; }
		/**
		 * A string identifying the type of object being cached.
		 *
		 * This has to be suitable for use as a directory name; i.e. lower case,
		 * hyphen-separated tokens.
		 *
		 * @since 0.6.6
		 */
		public string type_id { get; construct; }
	}
	/**
	 * Represents a "shard" of a person from a single source (a single
	 * {@link Backend}), such as an XMPP contact from Telepathy or a vCard contact
	 * from evolution-data-server.
	 *
	 * All the personas belonging to one physical person are aggregated to form a
	 * single {@link Individual} representing that person.
	 *
	 * Properties of a persona are provided by implementing "details" interfaces,
	 * such as {@link NameDetails} or {@link EmailDetails}. They must be accessed
	 * through these interfaces. Different backends' subclasses of {@link Persona}
	 * may implement different sets of interfaces. The set of interfaces implemented
	 * by a given persona is guaranteed not to change over the lifetime of that
	 * persona.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public abstract class Persona : GLib.Object {
		/**
		 * Callback into the aggregator to manipulate a link mapping.
		 *
		 * This is a callback provided by the {@link IndividualAggregator} whenever
		 * a {@link Persona.linkable_property_to_links} method is called, which should
		 * be called by the ``linkable_property_to_links`` implementation for each
		 * linkable-property-to-individual mapping it wants to add or remove in the
		 * aggregator.
		 *
		 * @param link the mapping string to be added to the
		 * {@link IndividualAggregator}
		 * @since 0.1.13
		 */
		public delegate void LinkablePropertyCallback (string link);
		protected Persona ();
		/**
		 * Build a UID from the given components.
		 *
		 * Each component is escaped before the UID is built. All components must be
		 * non-empty strings.
		 *
		 * @param backend_name the {@link Backend.name}
		 * @param persona_store_id the {@link PersonaStore.id}
		 * @param persona_id the Persona identifier (backend-specific)
		 * @return a valid UID
		 * @see Persona.split_uid
		 * @since 0.1.13
		 */
		public static string build_uid (string backend_name, string persona_store_id, string persona_id);
		/**
		 * Produce one or more mapping strings for the given property's value.
		 *
		 * This is a virtual method, to be overridden by subclasses of {@link Persona}
		 * who have linkable properties. Each of their linkable properties should be
		 * handled by their implementation of this function, examining the current
		 * value of the property and calling ``callback`` with one or more mapping
		 * strings for the property's value. Each of these mapping strings will be
		 * added to the {@link IndividualAggregator}'s link map, related to the
		 * {@link Individual} instance which contains this {@link Persona}.
		 *
		 * @param prop_name the name of the linkable property to use, which must be
		 * listed in {@link Persona.linkable_properties}
		 * @param callback a callback to execute for each of the mapping strings
		 * generated by this property
		 * @see Persona.linkable_properties
		 * @since 0.1.13
		 */
		public virtual void linkable_property_to_links (string prop_name, Folks.Persona.LinkablePropertyCallback callback);
		/**
		 * Split a UID into its component parts.
		 *
		 * Each component is unescaped before being returned. The UID //must// be
		 * correctly formed.
		 *
		 * @param uid a valid UID
		 * @param backend_name the {@link Backend.name}
		 * @param persona_store_id the {@link PersonaStore.id}
		 * @param persona_id the Persona identifier (backend-specific)
		 * @see Persona.build_uid
		 * @since 0.1.13
		 */
		public static void split_uid (string uid, out string backend_name, out string persona_store_id, out string persona_id);
		/**
		 * The human-readable, service-specific universal ID used to represent the
		 * Persona.
		 *
		 * For example: ``foo@@xmpp.example.org``.
		 *
		 * This should be used whenever the user needs to be presented with a
		 * familiar, service-specific ID. For instance, in a prompt for the user to
		 * select a specific IM contact within an {@link Individual} to begin a chat
		 * with.
		 *
		 * This is not guaranteed to be unique outside of the Persona's
		 * {@link PersonaStore}, but is guaranteed to be unique within it. If a
		 * suitable human-readable ID isn’t available from the backend, the display ID
		 * will be equal to the {@link Persona.iid}.
		 *
		 * @since 0.1.13
		 */
		public string display_id { get; construct; }
		/**
		 * The internal ID used to represent the Persona for linking.
		 *
		 * This is opaque, and shouldn't be parsed or considered meaningful by
		 * clients.
		 *
		 * The internal ID should be unique within a backend, but may not be unique
		 * across backends, so that links can be made between Personas with similar
		 * internal IDs.
		 */
		public string iid { get; construct; }
		/**
		 * The {@link Individual} which contains this Persona.
		 *
		 * This may be ``null``, but should only ever be so when the Persona has just
		 * been created, when its {@link PersonaStore} is being destroyed, or when
		 * it's moving between {@link Individual}s.
		 *
		 * @since 0.6.0
		 */
		public weak Folks.Individual? individual { get; internal set; }
		/**
		 * Whether the Persona is the user.
		 *
		 * Iff the Persona represents the user (the person who owns the account in
		 * the respective backend) this is ``true``.
		 *
		 * @since 0.3.0
		 */
		public bool is_user { get; construct; }
		/**
		 * The names of the properties of this Persona which are linkable.
		 *
		 * If a property name is in this list, and the Persona is from a
		 * {@link PersonaStore} whose trust level is {@link PersonaStoreTrust.FULL},
		 * the {@link IndividualAggregator} should be able to reliably use the value
		 * of the property from a given Persona instance to link the Persona with
		 * other Personas and form {@link Individual}s.
		 *
		 * Note that {@link Persona.uid} is always implicitly a member of this list,
		 * and doesn't need to be added explicitly.
		 *
		 * This list will have no effect if the Persona's {@link PersonaStore} trust
		 * level is not {@link PersonaStoreTrust.FULL}.
		 *
		 * This property value is guaranteed to be constant for a given persona,
		 * but may vary between personas in the same store.
		 *
		 * @since 0.1.13
		 */
		public abstract string[] linkable_properties { get; }
		/**
		 * The {@link PersonaStore} which contains this Persona.
		 */
		public weak Folks.PersonaStore store { get; construct; }
		/**
		 * The universal ID used to represent the Persona outside its {@link Backend}.
		 *
		 * This is opaque, and should only be parsed by clients using
		 * {@link Persona.split_uid}.
		 *
		 * This is the canonical way to refer to any Persona. It is guaranteed to be
		 * unique within the Persona's {@link PersonaStore}.
		 *
		 * A Persona's UID is immutable over the life of the Persona in the backing
		 * store, so a given UID is guaranteed to refer to the same Persona each time
		 * libfolks is used, until the Persona is permanently removed from its backing
		 * store.
		 *
		 * @see Persona.build_uid
		 * @see Persona.split_uid
		 */
		public string uid { get; construct; }
		/**
		 * The names of the properties of this Persona which are writeable.
		 *
		 * If a property name is in this list, setting the property should result in
		 * the updated value being stored in the backend's permanent storage (unless
		 * it gets rejected due to being invalid, or a different error occurs).
		 *
		 * It's intended that this property value will be constant for a given Persona
		 * subclass, but this isn't guaranteed; it's possible that Persona subclasses
		 * may vary the value of this property at run time.
		 *
		 * @since 0.6.0
		 */
		public abstract string[] writeable_properties { get; }
	}
	/**
	 * A store for {@link Persona}s.
	 *
	 * After creating a PersonaStore instance, you must connect to the
	 * {@link PersonaStore.personas_changed} signal, //then// call
	 * {@link PersonaStore.prepare}, otherwise a race condition may occur between
	 * emission of {@link PersonaStore.personas_changed} and your code connecting to
	 * it.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public abstract class PersonaStore : GLib.Object {
		protected PersonaStore ();
		protected void _emit_personas_changed (Gee.Set<Folks.Persona>? added, Gee.Set<Folks.Persona>? removed, string? message = null, Folks.Persona? actor = null, Folks.GroupDetails.ChangeReason reason = GroupDetails.ChangeReason.NONE);
		/**
		 * Add a new {@link Persona} to the PersonaStore.
		 *
		 * The {@link Persona} will be created by the PersonaStore backend from the
		 * key-value pairs given in ``details``.
		 *
		 * All additions through this function will later be emitted through the
		 * personas-changed signal to be notified of the new {@link Persona}. The
		 * return value is purely for convenience, since it can be complicated to
		 * correlate the provided details with the final Persona.
		 *
		 * If the store is offline (or {@link PersonaStore.prepare} hasn't yet been
		 * called successfully), this function will throw
		 * {@link PersonaStoreError.STORE_OFFLINE}. It's the responsibility of the
		 * caller to cache details and re-try this function if it wishes to make
		 * offline adds work.
		 *
		 * If the details are not recognised or are invalid,
		 * {@link PersonaStoreError.INVALID_ARGUMENT} will be thrown. A default set
		 * of possible details are defined by {@link Folks.PersonaDetail} but backends
		 * can either support a subset or superset of the suggested defaults.
		 *
		 * If a {@link Persona} with the given details already exists in the store, no
		 * error will be thrown and this function will return ``null``.
		 *
		 * @param details a key-value map of details to use in creating the new
		 * {@link Persona}
		 *
		 * @return the new {@link Persona} or ``null`` if the corresponding Persona
		 * already existed. If non-``null``, the new {@link Persona} will also be
		 * amongst the {@link Persona}(s) in a future emission of
		 * {@link PersonaStore.personas_changed}.
		 * @throws PersonaStoreError if adding the persona failed
		 */
		public abstract async Folks.Persona? add_persona_from_details (GLib.HashTable<string,GLib.Value?> details) throws Folks.PersonaStoreError;
		/**
		 * Returns the key corresponding to @detail, for use in
		 * the details param of {@link PersonaStore.add_persona_from_details}.
		 *
		 * @param detail the {@link PersonaDetail} to lookup
		 * @return the corresponding property name, or ``null`` if ``detail`` is
		 * invalid
		 *
		 * @since 0.5.0
		 */
		public static unowned string? detail_key (Folks.PersonaDetail detail);
		/**
		 * Flush any pending changes to the PersonaStore's backing store.
		 *
		 * PersonaStores may (transparently) implement caching or I/O queueing which
		 * means that changes to their {@link Persona}s may not be immediately written
		 * to the PersonaStore's backing store. Calling this function will force all
		 * pending changes to be flushed to the backing store.
		 *
		 * This must not be called before {@link PersonaStore.prepare}.
		 *
		 * @since 0.1.17
		 */
		public virtual async void flush ();
		/**
		 * Prepare the PersonaStore for use.
		 *
		 * This connects the PersonaStore to whichever backend-specific services it
		 * requires to be able to provide {@link Persona}s. This should be called
		 * //after// connecting to the {@link PersonaStore.personas_changed} signal,
		 * or a race condition could occur, with the signal being emitted before your
		 * code has connected to it, and {@link Persona}s getting "lost" as a result.
		 *
		 * This is normally handled transparently by the {@link IndividualAggregator}.
		 *
		 * If this function throws an error, the PersonaStore will not be functional.
		 *
		 * This function is guaranteed to be idempotent (since version 0.3.0).
		 *
		 * Concurrent calls to this function from different threads will block until
		 * preparation has completed. However, concurrent calls to this function from
		 * a single thread might not, i.e. the first call will block but subsequent
		 * calls might return before the first one. (Though they will be safe in every
		 * other respect.)
		 *
		 * @throws GLib.Error if preparing the backend-specific services failed — this
		 * will be a backend-specific error
		 *
		 * @since 0.1.11
		 */
		public abstract async void prepare () throws GLib.Error;
		/**
		 * Remove a {@link Persona} from the PersonaStore.
		 *
		 * It isn't guaranteed that the Persona will actually be removed by the time
		 * this asynchronous function finishes. The successful removal of the Persona
		 * will be signalled through emission of
		 * {@link PersonaStore.personas_changed}.
		 *
		 * If the store is offline (or {@link PersonaStore.prepare} hasn't yet been
		 * called successfully), this function will throw
		 * {@link PersonaStoreError.STORE_OFFLINE}. It's the responsibility of the
		 * caller to cache details and re-try this function if it wishes to make
		 * offline removals work.
		 *
		 * @param persona the {@link Persona} to remove
		 * @throws PersonaStoreError if removing the persona failed
		 *
		 * @since 0.1.11
		 */
		public abstract async void remove_persona (Folks.Persona persona) throws Folks.PersonaStoreError;
		/**
		 * The names of the properties of the {@link Persona}s in this store which are
		 * always writeable.
		 *
		 * If a property name is in this list, setting the property on a persona
		 * should result in the updated value being stored in the backend's permanent
		 * storage (unless it gets rejected due to being invalid, or a different error
		 * occurs).
		 *
		 * This property value is guaranteed to be constant for a given persona store,
		 * but may vary between persona stores in the same backend. It's guaranteed
		 * that this will always be a subset of the value of
		 * {@link Persona.writeable_properties} for the personas in this persona
		 * store.
		 *
		 * @since 0.6.2
		 */
		public abstract string[] always_writeable_properties { get; }
		/**
		 * Whether this {@link PersonaStore} can add {@link Persona}s.
		 *
		 * This value may change throughout the life of the {@link PersonaStore}.
		 *
		 * @since 0.3.1
		 */
		public abstract Folks.MaybeBool can_add_personas { get; }
		/**
		 * Whether this {@link PersonaStore} can set the alias of {@link Persona}s.
		 *
		 * @since 0.3.1
		 */
		[Version (deprecated = true, deprecated_since = "0.6.3.1", replacement = "PersonaStore.always_writeable_properties")]
		public abstract Folks.MaybeBool can_alias_personas { get; }
		/**
		 * Whether this {@link PersonaStore} can set the groups of {@link Persona}s.
		 *
		 * @since 0.3.1
		 */
		[Version (deprecated = true, deprecated_since = "0.6.3.1", replacement = "PersonaStore.always_writeable_properties")]
		public abstract Folks.MaybeBool can_group_personas { get; }
		/**
		 * Whether this {@link PersonaStore} can remove {@link Persona}s.
		 *
		 * This value may change throughout the life of the {@link PersonaStore}.
		 *
		 * @since 0.3.1
		 */
		public abstract Folks.MaybeBool can_remove_personas { get; }
		/**
		 * The human-readable, service-specific name used to represent the
		 * PersonaStore to the user.
		 *
		 * For example: ``foo@@xmpp.example.org``.
		 *
		 * This should be used whenever the user needs to be presented with a
		 * familiar, service-specific name. For instance, in a prompt for the user to
		 * select a specific IM account from which to initiate a chat.
		 *
		 * This is not guaranteed to be unique even within this PersonaStore's
		 * {@link Backend}. Its value may change throughout the life of the store.
		 *
		 * @since 0.1.13
		 */
		public string display_name { get; construct; }
		/**
		 * The instance identifier for this PersonaStore.
		 *
		 * Since each {@link Backend} can provide multiple different PersonaStores
		 * for different accounts or servers (for example), they each need an ID
		 * which is unique within the backend.
		 *
		 * It is immutable over the life of the {@link PersonaStore}.
		 */
		public string id { get; construct; }
		/**
		 * Whether {@link PersonaStore.prepare} has successfully completed for this
		 * store.
		 *
		 * It’s guaranteed that this will only ever change from ``false`` to ``true``
		 * in the lifetime of the {@link PersonaStore}.
		 *
		 * @since 0.3.0
		 */
		public abstract bool is_prepared { get; }
		/**
		 * Whether this {@link PersonaStore} is the primary store to be used for
		 * linking {@link Persona}s.
		 *
		 * @since 0.6.3
		 */
		public bool is_primary_store { get; internal set; }
		/**
		 * Whether the store has reached a quiescent state. This will happen at some
		 * point after {@link PersonaStore.prepare} has successfully completed for the
		 * store. A store is in a quiescent state when all the {@link Persona}s that
		 * it originally knows about have been loaded.
		 *
		 * It's guaranteed that this property's value will only ever change after
		 * {@link IndividualAggregator.is_prepared} has changed to ``true``.
		 *
		 * @since 0.6.2
		 */
		public abstract bool is_quiescent { get; }
		/**
		 * Whether this {@link PersonaStore} is marked as the default in its backend
		 * by the user.
		 *
		 * i.e. A {@link PersonaStore} for the EDS backend would set this to ``true``
		 * if it represents the user’s default address book.
		 *
		 * @since 0.6.3
		 */
		public bool is_user_set_default { get; internal set; }
		/**
		 * Whether the PersonaStore is writeable.
		 *
		 * Only if a PersonaStore is writeable will its {@link Persona}s be updated by
		 * changes to the {@link Individual}s containing them, and those changes then
		 * be written out to the relevant backing store.
		 *
		 * If this property is ``false``, it doesn't mean that {@link Persona}s in
		 * this persona store aren't writeable at all. If their properties are updated
		 * through the {@link Persona}, rather than through the {@link Individual}
		 * containing that persona, changes may be propagated to the backing store.
		 *
		 * PersonaStores must not set this property themselves; it will be set as
		 * appropriate by the {@link IndividualAggregator}.
		 *
		 * @since 0.1.13
		 */
		[Version (deprecated = true, deprecated_since = "0.6.3", replacement = "PersonaStore.is_primary_store")]
		public bool is_writeable { get; set; }
		/**
		 * The {@link Persona}s exposed by this PersonaStore.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.Map<string,Folks.Persona> personas { get; }
		/**
		 * The trust level of the PersonaStore for linking.
		 *
		 * Each {@link PersonaStore} is assigned a trust level by the
		 * IndividualAggregator, designating whether to trust the properties of its
		 * {@link Persona}s for linking to produce {@link Individual}s.
		 *
		 * This value may change throughout the life of the {@link PersonaStore}.
		 *
		 * The trust level may be queried by clients, but must not be set by them. The
		 * setter for this property is for libfolks internal use only.
		 *
		 * @see PersonaStoreTrust
		 * @since 0.1.13
		 */
		public Folks.PersonaStoreTrust trust_level { get; set; }
		/**
		 * The type of PersonaStore this is.
		 *
		 * This is the same for all PersonaStores provided by a given {@link Backend}.
		 *
		 * This is guaranteed to always be available; even before
		 * {@link PersonaStore.prepare} is called. It is immutable over the life of
		 * the {@link PersonaStore}.
		 */
		public abstract string type_id { get; }
		/**
		 * Emitted when one or more {@link Persona}s are added to or removed from
		 * the store.
		 *
		 * This will not be emitted until after {@link PersonaStore.prepare} has been
		 * called.
		 *
		 * @param added a set of {@link Persona}s which have been removed
		 * @param removed a set of {@link Persona}s which have been removed
		 * @param message a string message from the backend, if any
		 * @param actor the {@link Persona} who made the change, if known
		 * @param reason the reason for the change
		 *
		 * @since 0.5.1
		 */
		public signal void personas_changed (Gee.Set<Folks.Persona> added, Gee.Set<Folks.Persona> removed, string? message, Folks.Persona? actor, Folks.GroupDetails.ChangeReason reason);
		/**
		 * Emitted when the backing store for this PersonaStore has been removed.
		 *
		 * At this point, the PersonaStore and all its {@link Persona}s are invalid,
		 * so any client referencing it should unreference it.
		 *
		 * This will not be emitted until after {@link PersonaStore.prepare} has been
		 * called.
		 */
		public signal void removed ();
	}
	/**
	 * Object representing a phone number that can have some parameters associated
	 * with it.
	 *
	 * See {@link Folks.AbstractFieldDetails} for details on common parameter names
	 * and values.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class PhoneFieldDetails : Folks.AbstractFieldDetails<string> {
		/**
		 * Create a new PhoneFieldDetails.
		 *
		 * @param value the value of the field, which should be a non-empty phone
		 * number (no particular format is mandated)
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * an empty map of parameters.
		 *
		 * @return a new PhoneFieldDetails
		 *
		 * @since 0.6.0
		 */
		public PhoneFieldDetails (string value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * Return this object's normalised phone number.
		 *
		 * Typical normalisations:
		 *
		 *  - ``1-800-123-4567`` → ``18001234567``
		 *  - ``+1-800-123-4567`` → ``+18001234567``
		 *  - ``+1-800-123-4567P123`` → ``+18001234567P123``
		 *
		 * @return the normalised form of ``number``
		 *
		 * @since 0.6.0
		 */
		public string get_normalised ();
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
		/**
		 * {@inheritDoc}
		 */
		public override bool values_equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * {@inheritDoc}
		 */
		public override string id { get; set; }
	}
	/**
	 * Object representing a postal mail address.
	 *
	 * The components of the address are never ``null``: an empty string
	 * indicates that a property is not set.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class PostalAddress : GLib.Object {
		/**
		 * Create a PostalAddress.
		 *
		 * You can pass ``null`` if a component is not set.
		 *
		 * @param po_box the PO Box
		 * @param extension the address extension
		 * @param street the street name and number
		 * @param locality the locality (city, town or village) name
		 * @param region the region (state or province) name
		 * @param postal_code the postal code
		 * @param country the country name
		 * @param address_format the address format
		 * @param uid external UID for the address instance
		 * @since 0.5.1
		 */
		public PostalAddress (string? po_box, string? extension, string? street, string? locality, string? region, string? postal_code, string? country, string? address_format, string? uid);
		/**
		 * Compare if two postal addresses are equal. Addresses are equal if all their
		 * components are equal (where ``null`` compares equal only with ``null``) and
		 * they have the same set of types (or both have no types).
		 *
		 * This does not factor in the {@link PostalAddress.uid}.
		 *
		 * @param with another postal address to compare with
		 * @return ``true`` if the addresses are equal, ``false`` otherwise
		 */
		public bool equal (Folks.PostalAddress @with);
		/**
		 * Whether none of the components is set.
		 *
		 * @return ``true`` if all the components are the empty string, ``false``
		 * otherwise.
		 *
		 * @since 0.6.7
		 */
		public bool is_empty ();
		/**
		 * Get a formatted version of the address. The format is localised, and by
		 * default is comma-separated.
		 *
		 * @return a formatted address.
		 *
		 * @since 0.4.0
		 */
		public string to_string ();
		/**
		 * The address format.
		 *
		 * The two letter country code that determines the format or exact
		 * meaning of the other fields.
		 */
		public string address_format { get; set construct; }
		/**
		 * The country.
		 *
		 * The name of the country.
		 */
		public string country { get; set construct; }
		/**
		 * The address extension.
		 *
		 * Any additional part of the address, for instance a flat number.
		 */
		public string extension { get; set construct; }
		/**
		 * The locality.
		 *
		 * The locality, for instance the city name.
		 */
		public string locality { get; set construct; }
		/**
		 * The PO Box.
		 *
		 * The PO Box (also known as Postal office box or Postal box).
		 */
		public string po_box { get; set construct; }
		/**
		 * The postal code.
		 *
		 * The postal code (also known as post code, postcode or ZIP code).
		 */
		public string postal_code { get; set construct; }
		/**
		 * The region.
		 *
		 * The region, for instance the name of the state or province.
		 */
		public string region { get; set construct; }
		/**
		 * The street name and number.
		 *
		 * The street name including the optional building number.
		 * The number can be before or after the street name based on the
		 * language and country.
		 */
		public string street { get; set construct; }
		/**
		 * The UID of the Postal Address (if any).
		 */
		[Version (deprecated = true, deprecated_since = "0.6.5", replacement = "AbstractFieldDetails.id")]
		public string uid { get; set construct; }
	}
	/**
	 * Object representing a PostalAddress value that can have some parameters
	 * associated with it.
	 *
	 * See {@link Folks.AbstractFieldDetails} for details on common parameter names
	 * and values.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class PostalAddressFieldDetails : Folks.AbstractFieldDetails<Folks.PostalAddress> {
		/**
		 * Create a new PostalAddressFieldDetails.
		 *
		 * @param value the value of the field, a non-empty {@link PostalAddress}
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * an empty map of parameters.
		 *
		 *
		 * @return a new PostalAddressFieldDetails
		 *
		 * @since 0.6.0
		 */
		public PostalAddressFieldDetails (Folks.PostalAddress value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<Folks.PostalAddress> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
		/**
		 * {@inheritDoc}
		 */
		public override string id { get; set; }
	}
	/**
	 * Match calculator for pairs of individuals.
	 *
	 * This provides functionality to explore the degree of a potential match
	 * between two individuals. It compares the similarity of the individuals'
	 * properties to determine how likely it is that the individuals represent the
	 * same physical person.
	 *
	 * This can be used by folks clients to, for example, present suggestions of
	 * pairs of individuals which should be linked by the user.
	 *
	 * @since 0.5.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class PotentialMatch : GLib.Object {
		/**
		 * A set of e-mail addresses known to be aliases of each other, such as
		 * various forms of administrator address.
		 *
		 * @since 0.5.1
		 */
		public static Gee.Set<string> known_email_aliases;
		/**
		 * Create a new PotentialMatch.
		 *
		 * @return a new PotentialMatch
		 *
		 * @since 0.5.0
		 */
		public PotentialMatch ();
		/**
		 * Whether two individuals are likely to be the same person.
		 *
		 * @param a an individual to compare
		 * @param b another individual to compare
		 *
		 * @since 0.5.0
		 */
		public Folks.MatchResult potential_match (Folks.Individual a, Folks.Individual b);
	}
	/**
	 * A contact query.
	 *
	 * If any properties of the query change such that matches may change, the
	 * {@link GLib.Object.notify} signal will be emitted, potentially without a
	 * detail string. Views which are using this query should re-evaluate their
	 * matches on receiving this signal.
	 *
	 * @see SearchView
	 * @since 0.11.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public abstract class Query : GLib.Object {
		/**
		 * Set of address (email, IM, postal, phone number, etc.) match fields.
		 *
		 * These are ordered approximately by descending match likeliness to speed up
		 * calls to {@link is_match} when used as-is.
		 *
		 * @since 0.11.0
		 */
		public const string[] MATCH_FIELDS_ADDRESSES;
		/**
		 * Set of miscellaneous match fields.
		 *
		 * These are ordered approximately by descending match likeliness to speed up
		 * calls to {@link is_match} when used as-is.
		 *
		 * @since 0.11.0
		 */
		public const string[] MATCH_FIELDS_MISC;
		/**
		 * Set of name match fields.
		 *
		 * These are ordered approximately by descending match likeliness to speed up
		 * calls to {@link is_match} when used as-is.
		 *
		 * @since 0.11.0
		 */
		public const string[] MATCH_FIELDS_NAMES;
		protected Query ();
		/**
		 * Determines whether a given {@link Individual} matches this query.
		 *
		 * This returns a match strength, which is on an arbitrary scale which is not
		 * part of libfolks’ public API. These strengths should not be stored by user
		 * applications, or examined numerically — they should only be used for
		 * pairwise strength comparisons.
		 *
		 * This function is intended to be used in the {@link SearchView}
		 * implementation only. Use {@link SearchView.individuals} to retrieve search
		 * results.
		 *
		 * @param individual an {@link Individual} to match against
		 * @return a positive integer if the individual matches this query, or zero
		 *   if they do not match; higher numbers indicate a better match
		 * @since 0.11.0
		 */
		public abstract uint is_match (Folks.Individual individual);
		/**
		 * The names of the fields to match within
		 *
		 * The names of valid fields are available via
		 * {@link PersonaStore.detail_key}.
		 *
		 * The ordering of the fields determines the order they are checked for
		 * matches, which can have performance implications (these should ideally be
		 * ordered from most- to least-likely to match).
		 *
		 * Also note that more fields (particularly rarely-matched fields) will
		 * negatively impact performance, so only include important fields.
		 *
		 * Default value is {@link Query.MATCH_FIELDS_NAMES}.
		 *
		 * @since 0.11.0
		 * @see PersonaDetail
		 * @see PersonaStore.detail_key
		 * @see Query.MATCH_FIELDS_NAMES
		 * @see Query.MATCH_FIELDS_ADDRESSES
		 * @see Query.MATCH_FIELDS_MISC
		 */
		public virtual string[] match_fields { get; protected construct; }
	}
	/**
	 * Role a contact has in an organisation.
	 *
	 * This represents the role a {@link Persona} or {@link Individual} has in a
	 * single given organisation, such as a company.
	 *
	 * @since 0.4.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class Role : GLib.Object {
		/**
		 * Default constructor.
		 *
		 * @param title title of the position
		 * @param organisation_name organisation where the role is hold
		 * @param uid a Unique ID associated to this Role
		 * @return a new Role
		 *
		 * @since 0.4.0
		 */
		public Role (string? title = null, string? organisation_name = null, string? uid = null);
		/**
		 * Compare if two roles are equal. Roles are equal if their titles and
		 * organisation names are equal.
		 *
		 * @param a a role to compare
		 * @param b another role to compare
		 * @return ``true`` if the roles are equal, ``false`` otherwise
		 */
		public static bool equal (Folks.Role a, Folks.Role b);
		/**
		 * Hash function for the class. Suitable for use as a hash table key.
		 *
		 * @param r a role to hash
		 * @return hash value for the role instance
		 */
		public static uint hash (Folks.Role r);
		/**
		 * Whether none of the components is set.
		 *
		 * @return ``true`` if all the components are the empty string, ``false``
		 * otherwise.
		 *
		 * @since 0.6.7
		 */
		public bool is_empty ();
		/**
		 * Formatted version of this role.
		 *
		 * @since 0.4.0
		 */
		public string to_string ();
		/**
		 * The name of the organisation in which the role is held.
		 */
		public string organisation_name { get; set; }
		/**
		 * The role of the position.
		 *
		 * For example: “Programmer”
		 *
		 * @since 0.6.0
		 */
		public string role { get; set; }
		/**
		 * The title of the position held.
		 *
		 * For example: “Director, Ministry of Silly Walks”
		 */
		public string title { get; set; }
		/**
		 * The UID that distinguishes this role.
		 */
		[Version (deprecated = true, deprecated_since = "0.6.5", replacement = "AbstractFieldDetails.id")]
		public string uid { get; set; }
	}
	/**
	 * Object representing details of a contact in an organisation which can have
	 * some parameters associated with it.
	 *
	 * See {@link Folks.AbstractFieldDetails}.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class RoleFieldDetails : Folks.AbstractFieldDetails<Folks.Role> {
		/**
		 * Create a new RoleFieldDetails.
		 *
		 * @param value the non-empty {@link Role} of the field
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to an
		 * empty map of parameters.
		 *
		 * @return a new RoleFieldDetails
		 *
		 * @since 0.6.0
		 */
		public RoleFieldDetails (Folks.Role value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<Folks.Role> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
		/**
		 * {@inheritDoc}
		 */
		public override string id { get; set; }
	}
	/**
	 * A view of {@link Individual}s which match a given {@link Query}.
	 *
	 * The search view supports ‘live’ and ‘snapshot’ search results. Live results
	 * will continue to update over a long period of time as persona stores go
	 * online and offline or individuals are edited so they start or stop matching
	 * the {@link Query}.
	 *
	 * For a shell search provider, for example, snapshot results are appropriate.
	 * For a search in a contacts UI, live results are more appropriate as they will
	 * update over time as other edits are made in the application.
	 *
	 * In both cases, {@link SearchView.individuals} is guaranteed to be correct
	 * after {@link SearchView.prepare} finishes.
	 *
	 * For live results, continue listening to the
	 * {@link SearchView.individuals_changed_detailed} signal.
	 *
	 * @since 0.11.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class SearchView : GLib.Object {
		/**
		 * Create a new view of Individuals matching a given query.
		 *
		 * This view will be kept up-to-date as individuals change (which may change
		 * their membership in the results).
		 *
		 * @param query query to match upon
		 * @param aggregator the {@link IndividualAggregator} to match within
		 *
		 * @since 0.11.0
		 */
		public SearchView (Folks.IndividualAggregator aggregator, Folks.Query query);
		/**
		 * Prepare the view for use.
		 *
		 * This calls {@link IndividualAggregator.prepare} as necessary to start
		 * aggregating all {@link Individual}s.
		 *
		 * This function is guaranteed to be idempotent, so multiple search views may
		 * share a single aggregator; {@link SearchView.prepare} must be called on all
		 * of the views.
		 *
		 * For any clients only interested in a snapshot of search results,
		 * {@link SearchView.individuals} is valid once this async function is
		 * finished.
		 *
		 * @throws GLib.Error if preparation failed
		 *
		 * @since 0.11.0
		 */
		public async void prepare () throws GLib.Error;
		/**
		 * Refresh the view’s results.
		 *
		 * Explicitly re-match all the view’s results to ensure matches are up to
		 * date. For a normal {@link IndividualAggregator}, this is explicitly not
		 * necessary, as the view will watch signal emissions from the aggregator and
		 * keep itself up to date.
		 *
		 * However, for search-only persona stores, which do not support notification
		 * of changes to personas, this method is the only way to update the set of
		 * matches against the store.
		 *
		 * This method should be called whenever an explicit update is needed to the
		 * search results, e.g. if the user requests a refresh.
		 *
		 * @throws GLib.Error if matching failed
		 * @since 0.11.0
		 */
		public async void refresh () throws GLib.Error;
		/**
		 * Clean up and release resources used by the search view.
		 *
		 * This will disconnect the aggregator cleanly from any resources it is using.
		 * It is recommended to call this method before finalising the search view,
		 * but calling it is not required.
		 *
		 * Note that this will not unprepare the underlying aggregator: call
		 * {@link IndividualAggregator.unprepare} to do that. This allows multiple
		 * search views to use a single aggregator and unprepare at different times.
		 *
		 * Concurrent calls to this function from different threads will block until
		 * preparation has completed. However, concurrent calls to this function from
		 * a single thread might not, i.e. the first call will block but subsequent
		 * calls might return before the first one. (Though they will be safe in every
		 * other respect.)
		 *
		 * @since 0.11.0
		 * @throws GLib.Error if unpreparing the backend-specific services failed —
		 * this will be a backend-specific error
		 */
		public async void unprepare () throws GLib.Error;
		/**
		 * The {@link IndividualAggregator} that this view is based upon.
		 *
		 * @since 0.11.0
		 */
		public Folks.IndividualAggregator aggregator { get; }
		/**
		 * A sorted set of {@link Individual}s which match the search query.
		 *
		 * This is the canonical set of {@link Individual}s provided by this
		 * view. It is sorted by match strength, with the individual who is the best
		 * match to the search query as the {@link Gee.SortedSet.first} element of
		 * the set.
		 *
		 * Match strengths are not publicly exposed, as they are on an arbitrary
		 * scale. To compare two matching individuals for match strength, check for
		 * membership of one of them in the {@link Gee.SortedSet.head_set} of the
		 * other.
		 *
		 * For clients who only wish to have a snapshot of search results, this
		 * property is valid once {@link SearchView.prepare} is finished and this
		 * {@link SearchView} may be unreferenced and ignored afterward.
		 *
		 * @since 0.11.0
		 */
		public Gee.SortedSet<Folks.Individual> individuals { get; }
		/**
		 * Whether {@link IndividualAggregator.prepare} has successfully completed for
		 * this view's aggregator.
		 *
		 * @since 0.11.0
		 */
		public bool is_prepared { get; }
		/**
		 * Whether the search view has reached a quiescent state. This will happen at
		 * some point after {@link IndividualAggregator.prepare} has successfully
		 * completed for its aggregator.
		 *
		 * It's guaranteed that this property's value will only ever change after
		 * {@link SearchView.is_prepared} has changed to ``true``.
		 *
		 * @since 0.11.0
		 */
		public bool is_quiescent { get; }
		/**
		 * The {@link Query} that this view is based upon.
		 *
		 * If this {@link SearchView} has already been prepared, setting this will
		 * force a re-evaluation of all {@link Individual}s in the
		 * {@link IndividualAggregator} which can be an expensive operation.
		 *
		 * This re-evaluates the query immediately, so most clients should implement
		 * de-bouncing to ensure re-evaluation only happens when (for example) the
		 * user has stopped typing a new query.
		 *
		 * @since 0.11.0
		 */
		public Folks.Query query { get; set; }
		/**
		 * Emitted when one or more {@link Individual}s are added to or removed from
		 * the view.
		 *
		 * The sets of `added` and `removed` individuals are sorted by descending
		 * match strength. Using the {@link Gee.SortedSet.lower} and
		 * {@link Gee.SortedSet.higher} APIs with {@link SearchView.individuals}, the
		 * `added` individuals can be inserted at the correct positions in a UI
		 * representation of the search view.
		 *
		 * The match strengths are on the same scale as in
		 * {@link SearchView.individuals}, so orderings between the two sorted sets
		 * are valid. See {@link SearchView.individuals} for more information about
		 * match strengths.
		 *
		 * @param added a set of {@link Individual}s added to the search view
		 * @param removed a set of {@link Individual}s removed from the search view
		 *
		 * @see IndividualAggregator.individuals_changed_detailed
		 * @since 0.11.0
		 */
		public signal void individuals_changed_detailed (Gee.SortedSet<Folks.Individual> added, Gee.SortedSet<Folks.Individual> removed);
	}
	/**
	 * A simple text-based contact query.
	 *
	 * This is a generic implementation of the {@link Query} interface which
	 * supports general UI-style search use cases. It implements case-insensitive
	 * prefix matching, with transliteration of accents and other non-ASCII
	 * characters to improve matching against accented characters. It also
	 * normalises phone numbers to make matches invariant to hyphenation and spacing
	 * in phone numbers.
	 *
	 * @see SearchView
	 * @since 0.11.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class SimpleQuery : Folks.Query {
		/**
		 * Create a simple text query.
		 *
		 * @param query_string text to match contacts against. Results will match all
		 * tokens within the whitespace-delimited string (logical-ANDing the tokens).
		 * A value of "" will match all contacts. However, it is recommended to not
		 * use a query at all if filtering is not required.
		 * @param match_fields the field names to apply this query to. See
		 * {@link Query.match_fields} for more details. An empty array will match all
		 * contacts. However, it is recommended to use the
		 * {@link IndividualAggregator} directly if filtering is not required.
		 * {@link PersonaDetail} and {@link PersonaStore.detail_key} for pre-defined
		 * field names.
		 *
		 * @since 0.11.0
		 */
		public SimpleQuery (string query_string, string[] match_fields);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.11.0
		 */
		public override uint is_match (Folks.Individual individual);
		/**
		 * Locale to interpret the {@link SimpleQuery.query_string} in.
		 *
		 * If possible, locale-specific query string transliteration is done to
		 * increase the number of matches. Set this property to a POSIX locale name
		 * (e.g. ‘en’, ‘de_DE’, ‘de_DE@euro’ or ‘C’) to potentially improve the
		 * transliteration performed.
		 *
		 * This may be `null` if the locale is unknown, in which case the current
		 * locale will be used. To perform transliteration for no specific locale,
		 * use `C`.
		 *
		 * @since 0.11.0
		 */
		public string? query_locale { get; set; }
		/**
		 * The text query string.
		 *
		 * This re-evaluates the query immediately, so most clients should implement
		 * de-bouncing to ensure re-evaluation only happens when (for example) the
		 * user has stopped typing a new query.
		 *
		 * @since 0.11.0
		 */
		public string query_string { get; set; }
	}
	/**
	 * Structured name representation for human names.
	 *
	 * Represents a full name split in its constituent parts (given name,
	 * family name, etc.). This structure corresponds to the "N" field in
	 * vCards. The parts of the name are never ``null``: an empty string
	 * indicates that a property is not set.
	 *
	 * @since 0.3.5
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class StructuredName : GLib.Object {
		/**
		 * Create a StructuredName.
		 *
		 * You can pass ``null`` if a component is not set.
		 *
		 * @param family_name the family (last) name
		 * @param given_name the given (first) name
		 * @param additional_names additional names
		 * @param prefixes prefixes of the name
		 * @param suffixes suffixes of the name
		 * @return a new StructuredName
		 *
		 * @since 0.3.5
		 */
		public StructuredName (string? family_name, string? given_name, string? additional_names, string? prefixes, string? suffixes);
		/**
		 * Whether two StructuredNames are the same.
		 *
		 * @param other the other structured name to compare with
		 * @return ``true`` if all the components are the same, ``false``
		 * otherwise.
		 *
		 * @since 0.5.0
		 */
		public bool equal (Folks.StructuredName other);
		/**
		 * Whether none of the components is set.
		 *
		 * @return ``true`` if all the components are the empty string, ``false``
		 * otherwise.
		 *
		 * @since 0.3.5
		 */
		public bool is_empty ();
		/**
		 * Create a StructuredName.
		 *
		 * Shorthand for the common case of just having the family and given
		 * name of a contact. It's equivalent to calling
		 * {@link StructuredName.StructuredName} and passing ``null`` for all
		 * the other components.
		 *
		 * @param family_name the family (last) name
		 * @param given_name the given (first) name
		 * @return a new StructuredName
		 *
		 * @since 0.3.5
		 */
		public StructuredName.simple (string? family_name, string? given_name);
		/**
		 * Formatted version of the structured name.
		 *
		 * @return name formatted according to the current locale
		 * @since 0.4.0
		 */
		public string to_string ();
		/**
		 * Formatted version of the structured name.
		 *
		 * This allows a custom format string to be specified, using the placeholders
		 * described on [[http://lh.2xlibre.net/values/name_fmt/]]. This ``name_fmt``
		 * must almost always be translated to the current locale. (Ideally it would
		 * be translated to the locale of the persona whose name is being formatted,
		 * but such locale information isn’t available.)
		 *
		 * @param name_fmt format string for the name
		 * @return name formatted according to the given format
		 * @since 0.9.7
		 */
		public string to_string_with_format (string name_fmt);
		/**
		 * Additional names.
		 *
		 * The additional names of a contact, for instance the contact's
		 * middle name.
		 *
		 * @since 0.3.5
		 */
		public string additional_names { get; set construct; }
		/**
		 * The family name.
		 *
		 * The family name (also known as surname or last name) of a contact.
		 *
		 * @since 0.3.5
		 */
		public string family_name { get; set construct; }
		/**
		 * The given name.
		 *
		 * The family name (also known as first name) of a contact.
		 *
		 * @since 0.3.5
		 */
		public string given_name { get; set construct; }
		/**
		 * The prefixes of a name.
		 *
		 * The prefixes used in front of the name (for instance "Mr", "Mrs",
		 * "Doctor" or honorific titles).
		 *
		 * @since 0.3.5
		 */
		public string prefixes { get; set construct; }
		/**
		 * The suffixes of a name.
		 *
		 * The suffixes used after a name (for instance "PhD" or "Junior").
		 *
		 * @since 0.3.5
		 */
		public string suffixes { get; set construct; }
	}
	/**
	 * Object representing a URL that can have some parameters associated with it.
	 *
	 * See {@link Folks.AbstractFieldDetails} for details on common parameter names
	 * and values.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class UrlFieldDetails : Folks.AbstractFieldDetails<string> {
		/**
		 * Parameter value for URLs for the contact's personal or professional blog.
		 *
		 * Value for a parameter with name {@link AbstractFieldDetails.PARAM_TYPE}.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE_BLOG;
		/**
		 * Parameter value for URLs for the contact's personal or professional FTP
		 * server.
		 *
		 * Value for a parameter with name {@link AbstractFieldDetails.PARAM_TYPE}.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE_FTP;
		/**
		 * Parameter value for URLs for the contact's home page.
		 *
		 * Value for a parameter with name {@link AbstractFieldDetails.PARAM_TYPE}.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE_HOME_PAGE;
		/**
		 * Parameter value for URLs for the contact's social networking profile.
		 *
		 * Value for a parameter with name {@link AbstractFieldDetails.PARAM_TYPE}.
		 *
		 * @since 0.6.3
		 */
		public const string PARAM_TYPE_PROFILE;
		/**
		 * Create a new UrlFieldDetails.
		 *
		 * @param value the value of the field, a non-empty URI
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * an empty map of parameters.
		 *
		 * @return a new UrlFieldDetails
		 *
		 * @since 0.6.0
		 */
		public UrlFieldDetails (string value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
	}
	/**
	 * Utility functions to simplify common patterns in Folks client code.
	 *
	 * These may be used by folks clients as well, and are part of folks' supported
	 * stable API.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class Utils : GLib.Object {
		/**
		 * Create a new utilities object.
		 *
		 * This method is useless and should never be used. It will be removed in a
		 * future version in favour of making the Utils class into a nested namespace.
		 *
		 * @return a new utilities object
		 * @since 0.6.0
		 */
		[Version (deprecated = true, deprecated_since = "0.7.4", replacement = "Folks.Utils")]
		public Utils ();
		/**
		 * Check whether two multi-maps of strings to AbstractFieldDetails are equal.
		 *
		 * This performs a deep check for equality, checking whether both maps are of
		 * the same size, and that each key maps to the same set of values in both
		 * maps.
		 *
		 * @param a a multi-map to compare
		 * @param b another multi-map to compare
		 * @return ``true`` if the multi-maps are equal, ``false`` otherwise
		 *
		 * @since 0.6.0
		 */
		public static bool multi_map_str_afd_equal (Gee.MultiMap<string,Folks.AbstractFieldDetails> a, Gee.MultiMap<string,Folks.AbstractFieldDetails> b);
		/**
		 * Check whether two multi-maps of strings to strings are equal. This performs
		 * a deep check for equality, checking whether both maps are of the same size,
		 * and that each key maps to the same set of values in both maps.
		 *
		 * @param a a multi-map to compare
		 * @param b another multi-map to compare
		 * @return ``true`` if the multi-maps are equal, ``false`` otherwise
		 *
		 * @since 0.6.0
		 */
		public static bool multi_map_str_str_equal (Gee.MultiMap<string,string> a, Gee.MultiMap<string,string> b);
		/**
		 * Check whether a set of strings to AbstractFieldDetails are equal.
		 *
		 * This performs a deep check for equality, checking whether both sets are of
		 * the same size, and that each key maps to the same set of values in both
		 * maps.
		 *
		 * @param a a set to compare
		 * @param b another set to compare
		 * @return ``true`` if the sets are equal, ``false`` otherwise
		 *
		 * @since 0.6.0
		 */
		public static bool set_afd_equal (Gee.Set<Folks.AbstractFieldDetails> a, Gee.Set<Folks.AbstractFieldDetails> b);
		/**
		 * Check whether a set of AbstractFieldDetails with string values are equal.
		 *
		 * This performs a deep check for equality, checking whether both sets are of
		 * the same size, and that each set has the same values using string compaction
		 * instead of AbstractFieldDetails equal function
		 *
		 * @param a a set to compare
		 * @param b another set to compare
		 * @return ``true`` if the sets are equal, ``false`` otherwise
		 *
		 * @since 0.9.7
		 */
		public static bool set_string_afd_equal (Gee.Set<Folks.AbstractFieldDetails<string>> a, Gee.Set<Folks.AbstractFieldDetails<string>> b);
	}
	/**
	 * Object representing a web service contact that can have some parameters
	 * associated with it.
	 *
	 * See {@link Folks.AbstractFieldDetails}.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public class WebServiceFieldDetails : Folks.AbstractFieldDetails<string> {
		/**
		 * Create a new WebServiceFieldDetails.
		 *
		 * @param value the value of the field, a non-empty web service address
		 * @param parameters initial parameters. See
		 * {@link AbstractFieldDetails.parameters}. A ``null`` value is equivalent to
		 * an empty map of parameters.
		 *
		 * @return a new WebServiceFieldDetails
		 *
		 * @since 0.6.0
		 */
		public WebServiceFieldDetails (string value, Gee.MultiMap<string,string>? parameters = null);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override bool equal (Folks.AbstractFieldDetails<string> that);
		/**
		 * {@inheritDoc}
		 *
		 * @since 0.6.0
		 */
		public override uint hash ();
	}
	/**
	 * Alias for a contact.
	 *
	 * This allows representation of aliases for contacts, where the user has chosen
	 * their own name for the contact to better represent that contact to them. A
	 * typical example of this is the use of user-chosen aliases for contacts in
	 * instant messaging programs.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface AliasDetails : GLib.Object {
		/**
		 * Change the contact's alias.
		 *
		 * It's preferred to call this rather than setting {@link AliasDetails.alias}
		 * directly, as this method gives error notification and will only return
		 * once the alias has been written to the relevant backing store (or the
		 * operation's failed).
		 *
		 * @param alias the new alias
		 * @throws PropertyError if setting the alias failed
		 * @since 0.6.2
		 */
		public virtual async void change_alias (string alias) throws Folks.PropertyError;
		/**
		 * An alias for the contact.
		 *
		 * An alias is a user-given name, to be used in UIs as the sole way to
		 * represent the contact to the user.
		 *
		 * This may not be ``null``: an empty string represents an unset alias.
		 */
		public abstract string alias { get; set; }
	}
	/**
	 * Interface for {@link Persona} subclasses from backends which support storage
	 * of, anti-linking data.
	 *
	 * Anti-links are stored as a set of {@link Persona.uid}s with each
	 * {@link Persona} (A), specifying that A must not be linked into an
	 * {@link Individual} with any of the personas in its anti-links set.
	 *
	 * @since 0.7.3
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface AntiLinkable : Folks.Persona {
		/**
		 * Add anti-links to other personas.
		 *
		 * The UIDs of all personas in ``other_personas`` will be added to this
		 * persona's anti-links set and the changes propagated to backends.
		 *
		 * Any attempt to anti-link a persona with itself is not an error, but is
		 * ignored.
		 *
		 * This method is safe to call multiple times concurrently (e.g. begin one
		 * asynchronous call, then begin another before the first has finished).
		 *
		 * @param other_personas the personas to anti-link to this one
		 * @throws PropertyError if setting the anti-links failed
		 * @since 0.7.3
		 */
		public async void add_anti_links (Gee.Set<Folks.Persona> other_personas) throws Folks.PropertyError;
		/**
		 * Prevent persona from being linked with any other personas
		 *
		 * This function will add a wildcard ``*`` to the set of anti-links, which will
		 * prevent the persona from being linked with any other personas.
		 *
		 * To make the persona linkable again you need to remove the global anti-link
		 *
		 * This method is safe to call multiple times concurrently (e.g. begin one
		 * asynchronous call, then begin another before the first has finished).
		 *
		 * @throws PropertyError if setting the anti-links failed
		 * @since 0.9.7
		 */
		public async void add_global_anti_link () throws Folks.PropertyError;
		/**
		 * Change the {@link Persona}'s set of anti-links.
		 *
		 * It's preferred to call this rather than setting
		 * {@link AntiLinkable.anti_links} directly, as this method gives error
		 * notification and will only return once the anti-links have been written
		 * to the relevant backing store (or the operation's failed).
		 *
		 * It should be noted that {@link IndividualAggregator.link_personas} and
		 * {@link IndividualAggregator.unlink_individual} will modify the anti-links
		 * sets of the personas they touch, in order to remove and add anti-links,
		 * respectively. It is expected that these {@link IndividualAggregator}
		 * methods will be used to modify anti-links indirectly, rather than calling
		 * {@link AntiLinkable.change_anti_links} directly.
		 *
		 * @param anti_links the new set of anti-links from this persona
		 * @throws PropertyError if setting the anti-links failed
		 * @since 0.7.3
		 */
		public virtual async void change_anti_links (Gee.Set<string> anti_links) throws Folks.PropertyError;
		/**
		 * Check for an anti-link with another persona.
		 *
		 * This will return ``true`` if ``other_persona``'s UID is listed in this
		 * persona's anti-links set. Note that this check is not symmetric.
		 *
		 * @param other_persona the persona to check is anti-linked
		 * @return ``true`` if an anti-link exists, ``false`` otherwise
		 * @since 0.7.3
		 */
		public bool has_anti_link_with_persona (Folks.Persona other_persona);
		/**
		 * Check if the persona has a global anti link.
		 *
		 * If the persona has global anti link this means that the persona can not be
		 * linked with any other persona.
		 *
		 * @since 0.9.7
		 */
		public bool has_global_anti_link ();
		/**
		 * Remove anti-links to other personas.
		 *
		 * The UIDs of all personas in ``other_personas`` will be removed from this
		 * persona's anti-links set and the changes propagated to backends.
		 *
		 * If the global anti-link is set, this will not have any effect until the
		 * global anti-link is removed.
		 *
		 * This method is safe to call multiple times concurrently (e.g. begin one
		 * asynchronous call, then begin another before the first has finished).
		 *
		 * @param other_personas the personas to remove anti-links from this one
		 * @throws PropertyError if setting the anti-links failed
		 * @since 0.7.3
		 */
		public async void remove_anti_links (Gee.Set<Folks.Persona> other_personas) throws Folks.PropertyError;
		/**
		 * Allow persona to be linked with other personas
		 *
		 * This function removes the wildcard ``*`` from the set of anti-links, allowing
		 * the persona to be linked again.
		 *
		 * This method is safe to call multiple times concurrently (e.g. begin one
		 * asynchronous call, then begin another before the first has finished).
		 *
		 * @throws PropertyError if setting the anti-links failed
		 * @since 0.9.7
		 */
		public async void remove_global_anti_link () throws Folks.PropertyError;
		/**
		 * UIDs of anti-linked {@link Persona}s.
		 *
		 * The {@link Persona}s identified by their UIDs in this set are guaranteed to
		 * not be linked to this {@link Persona}, even if their linkable properties
		 * match.
		 *
		 * No UIDs may be ``null``. Well-formed but non-existent UIDs (i.e. UIDs which
		 * can be successfully parsed, but which don't currently correspond to a
		 * {@link Persona} instance) are permitted, as personas may appear and
		 * disappear over time.
		 *
		 * The special UID ``*`` is used as a wildcard to mark the persona as globally
		 * anti-linked. See {@link AntiLinkable.has_global_anti_link}.
		 *
		 * It is expected, but not guaranteed, that anti-links made between personas
		 * will be reciprocal. That is, if persona A lists persona B's UID in its
		 * {@link AntiLinkable.anti_links} set, persona B will typically also list
		 * persona A in its anti-links set.
		 *
		 * @since 0.7.3
		 */
		public abstract Gee.Set<string> anti_links { get; set; }
	}
	/**
	 * Avatar for a contact.
	 *
	 * This allows avatars to be associated with contacts. An avatar is a small
	 * image file which represents the contact, such as a photo of them.
	 *
	 * @since 0.6.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface AvatarDetails : GLib.Object {
		/**
		 * Change the contact's avatar.
		 *
		 * It's preferred to call this rather than setting
		 * {@link AvatarDetails.avatar} directly, as this method gives error
		 * notification and will only return once the avatar has been written to the
		 * relevant backing store (or the operation's failed).
		 *
		 * @param avatar the new avatar (or ``null`` to unset the avatar)
		 * @throws PropertyError if setting the avatar failed
		 * @since 0.6.2
		 */
		public virtual async void change_avatar (GLib.LoadableIcon? avatar) throws Folks.PropertyError;
		/**
		 * An avatar for the contact.
		 *
		 * The avatar may be ``null`` if unset. Otherwise, the image data may be
		 * asynchronously loaded using the methods of the {@link GLib.LoadableIcon}
		 * implementation.
		 *
		 * @since 0.6.0
		 */
		public abstract GLib.LoadableIcon? avatar { get; set; }
	}
	/**
	 * Birthday details for a contact.
	 *
	 * This allows representation of the birth date and associated calendar event ID
	 * of a contact.
	 *
	 * @since 0.4.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface BirthdayDetails : GLib.Object {
		/**
		 * Change the contact's birthday.
		 *
		 * It's preferred to call this rather than setting
		 * {@link BirthdayDetails.birthday} directly, as this method gives error
		 * notification and will only return once the birthday has been written to the
		 * relevant backing store (or the operation's failed).
		 *
		 * @param birthday the new birthday (or ``null`` to unset the birthday)
		 * @throws PropertyError if setting the birthday failed
		 * @since 0.6.2
		 */
		public virtual async void change_birthday (GLib.DateTime? birthday) throws Folks.PropertyError;
		/**
		 * Change the contact's birthday event ID.
		 *
		 * It's preferred to call this rather than setting
		 * {@link BirthdayDetails.calendar_event_id} directly, as this method gives
		 * error notification and will only return once the event has been written to
		 * the relevant backing store (or the operation's failed).
		 *
		 * @param event_id the new birthday event ID (or ``null`` to unset the event
		 * ID)
		 * @throws PropertyError if setting the birthday event ID failed
		 * @since 0.6.2
		 */
		public virtual async void change_calendar_event_id (string? event_id) throws Folks.PropertyError;
		/**
		 * The birthday of the {@link Persona} and {@link Individual}. This
		 * is assumed to be in UTC.
		 *
		 * If this is ``null``, the contact's birthday isn't known.
		 *
		 * @since 0.4.0
		 */
		public abstract GLib.DateTime? birthday { get; set; }
		/**
		 * The event ID of the birthday event from the source calendar.
		 *
		 * If this is ``null``, the birthday event is unknown. The semantics of the
		 * event ID are left unspecified by folks.
		 *
		 * @since 0.4.0
		 */
		public abstract string? calendar_event_id { get; set; }
	}
	/**
	 * Interface for classes that have email addresses, such as {@link Persona}
	 * and {@link Individual}.
	 *
	 * @since 0.3.5
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface EmailDetails : GLib.Object {
		/**
		 * Change the contact's set of e-mail addresses.
		 *
		 * It's preferred to call this rather than setting
		 * {@link EmailDetails.email_addresses} directly, as this method gives error
		 * notification and will only return once the e-mail addresses have been
		 * written to the relevant backing store (or the operation's failed).
		 *
		 * @param email_addresses the new set of e-mail addresses
		 * @throws PropertyError if setting the e-mail addresses failed
		 * @since 0.6.2
		 */
		public virtual async void change_email_addresses (Gee.Set<Folks.EmailFieldDetails> email_addresses) throws Folks.PropertyError;
		/**
		 * The email addresses of the contact.
		 *
		 * Each of the values in this property contains just an e-mail address (e.g.
		 * “foo@bar.com”), rather than any other way of formatting an e-mail address
		 * (such as “John Smith &lt;foo@bar.com&gt;”).
		 *
		 * @since 0.6.0
		 */
		public abstract Gee.Set<Folks.EmailFieldDetails> email_addresses { get; set; }
	}
	/**
	 * Arbitrary field interface.
	 *
	 * This interface allows clients to store arbitrary fields for contacts in
	 * backends that support it.
	 *
	 * This interface should be used for application-specific data, in which case
	 * the application should use the vCard approach to prefixing non-standard
	 * property names: `X-[APPLICATION NAME]-*’. Note that this is a global
	 * namespace, shared between all consumers of the backend’s data, so please
	 * namespace application-specific data with the application’s name.
	 *
	 * This interface should not be used for more general-purpose data which could
	 * be better represented with a type-safe interface implemented in libfolks.
	 * It must not be used for data which is already represented with a type-safe
	 * interface in libfolks.
	 *
	 * A good example of data which could be stored on this interface is an e-mail
	 * application’s setting of whether a content prefers to receive HTML or
	 * plaintext e-mail.
	 *
	 * A good example of data which should not be stored on this interface is a
	 * contact’s anniversary. That should be added in a separate interface in
	 * libfolks.
	 *
	 * @since 0.11.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface ExtendedInfo : GLib.Object {
		/**
		 * Change the value of an arbitrary field.
		 *
		 * @param name name of the arbitrary field to change value
		 * @param value new value for the arbitrary field
		 * @throws PropertyError if setting the value failed
		 *
		 * @since 0.11.0
		 */
		public virtual async void change_extended_field (string name, Folks.ExtendedFieldDetails value) throws Folks.PropertyError;
		/**
		 * Retrieve the value for an arbitrary field.
		 *
		 * @return The value of the extended field, which may be empty, or `null` if
		 *   the field is not set
		 *
		 * @since 0.11.0
		 */
		public abstract Folks.ExtendedFieldDetails? get_extended_field (string name);
		/**
		 * Remove an arbitrary field.
		 *
		 * @param name name of the arbitrary field to remove
		 * @throws PropertyError if removing the property failed
		 *
		 * @since 0.11.0
		 */
		public virtual async void remove_extended_field (string name) throws Folks.PropertyError;
	}
	/**
	 * Favourite status for a contact.
	 *
	 * This allows user-defined favourite contacts to be specified. A contact is a
	 * favourite if the user has selected them as such; the semantics of 'favourite'
	 * are left unspecified by folks. Typically, a user might select the contacts
	 * that they talk to most frequently as their favourite contacts in an instant
	 * messaging program, for example.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface FavouriteDetails : GLib.Object {
		/**
		 * Change whether the contact is a user-defined favourite.
		 *
		 * It's preferred to call this rather than setting
		 * {@link FavouriteDetails.is_favourite} directly, as this method gives error
		 * notification and will only return once the favouriteness has been written
		 * to the relevant backing store (or the operation's failed).
		 *
		 * @param is_favourite ``true`` if the contact is a favourite; ``false``
		 * otherwise
		 * @throws PropertyError if setting the favouriteness failed
		 * @since 0.6.2
		 */
		public virtual async void change_is_favourite (bool is_favourite) throws Folks.PropertyError;
		/**
		 * Whether this contact is a user-defined favourite.
		 */
		public abstract bool is_favourite { get; set; }
	}
	/**
	 * Gender of a contact.
	 *
	 * This allows representation of the gender of a contact.
	 *
	 * @since 0.3.5
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface GenderDetails : GLib.Object {
		/**
		 * Change the contact's gender.
		 *
		 * It's preferred to call this rather than setting
		 * {@link GenderDetails.gender} directly, as this method gives error
		 * notification and will only return once the gender has been written to the
		 * relevant backing store (or the operation's failed).
		 *
		 * @param gender the contact's gender
		 * @throws PropertyError if setting the gender failed
		 * @since 0.6.2
		 */
		public virtual async void change_gender (Folks.Gender gender) throws Folks.PropertyError;
		/**
		 * The gender of the contact.
		 *
		 * @since 0.3.5
		 */
		public abstract Folks.Gender gender { get; set; }
	}
	/**
	 * Groups for a contact.
	 *
	 * This allows contacts to be collected into user-defined groups (or categories)
	 * for organisational purposes. Groups are non-exclusive and non-hierarchical,
	 * so a single contact can be put into many groups, but groups may not
	 * themselves be put into groups.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface GroupDetails : GLib.Object {
		/**
		 * The reason a group member has changed its membership in the group.
		 *
		 * These closely follow the
		 * [[http://telepathy.freedesktop.org/spec/Channel_Interface_Group.html#Channel_Group_Change_Reason|Channel_Group_Change_Reason]]
		 * interface in the Telepathy specification.
		 */
		public enum ChangeReason {
			/**
			 * No reason was provided for this change.
			 *
			 * This is used when a member joins or leaves a group normally.
			 */
			NONE,
			/**
			 * The change is due to a member going offline.
			 *
			 * Also used when member is already offline, but this wasn't known
			 * previously.
			 */
			OFFLINE,
			/**
			 * The change is due to a kick operation.
			 */
			KICKED,
			/**
			 * The change is due to a busy indication.
			 */
			BUSY,
			/**
			 * The change is due to an invitation.
			 */
			INVITED,
			/**
			 * The change is due to a kick+ban operation.
			 */
			BANNED,
			/**
			 * The change is due to an error occurring.
			 */
			ERROR,
			/**
			 * The change is because the requested member does not exist.
			 *
			 * For instance, if the user invites a nonexistent contact to a chatroom
			 * or attempts to call a nonexistent contact
			 */
			INVALID_MEMBER,
			/**
			 * The change is because the requested contact did not respond.
			 */
			NO_ANSWER,
			/**
			 * The change is because a member's unique identifier changed.
			 *
			 * There must be exactly one member in the removed set and exactly one
			 * member in one of the added sets.
			 */
			RENAMED,
			/**
			 * The change is because there was no permission to contact the requested
			 * member.
			 */
			PERMISSION_DENIED,
			/**
			 * If members are removed with this reason code, the change is because the
			 * group has split into unconnected parts which can only communicate
			 * within themselves (e.g. netsplits on IRC use this reason code).
			 *
			 * If members are added with this reason code, the change is because
			 * unconnected parts of the group have rejoined. If this channel carries
			 * messages (e.g. Text or Tubes channels) applications must assume that
			 * the contacts being added are likely to have missed some messages as a
			 * result of the separation, and that the contacts in the group are likely
			 * to have missed some messages from the contacts being added.
			 *
			 * Note that from the added contacts' perspective, they have been in the
			 * group all along, and the contacts we indicate to be in the group
			 * (including the local user) have just rejoined the group with reason
			 * Separated. Application protocols in Tubes should be prepared to cope
			 * with this situation.
			 */
			SEPARATED
		}
		/**
		 * Add or remove the contact from the specified group.
		 *
		 * If ``is_member`` is ``true``, the contact will be added to the ``group``.
		 * If it is ``false``, they will be removed from the ``group``.
		 *
		 * @param group a freeform group identifier
		 * @param is_member whether the contact should be a member of the group
		 * @throws GLib.Error if changing the group failed in the backing store
		 *
		 * @since 0.1.11
		 */
		public abstract async void change_group (string group, bool is_member) throws GLib.Error;
		/**
		 * Change the contact's groups.
		 *
		 * It's preferred to call this rather than setting {@link GroupDetails.groups}
		 * directly, as this method gives error notification and will only return once
		 * the groups have been written to the relevant backing store (or the
		 * operation's failed).
		 *
		 * @param groups the complete set of groups the contact should be a member of
		 * @throws PropertyError if setting the groups failed
		 * @since 0.6.2
		 */
		public virtual async void change_groups (Gee.Set<string> groups) throws Folks.PropertyError;
		/**
		 * A set of group IDs for groups containing the member.
		 *
		 * The complete set of freeform identifiers for all the groups the contact is
		 * a member of.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.Set<string> groups { get; set; }
		/**
		 * Emitted when the contact's membership status changes for a group.
		 *
		 * This is emitted if the contact becomes a member of a group they weren't in
		 * before, or leaves a group they were in.
		 *
		 * @param group a freeform group identifier for the group being left or joined
		 * @param is_member whether the contact is joining or leaving the group
		 * @since 0.1.11
		 */
		public signal void group_changed (string group, bool is_member);
	}
	/**
	 * IM addresses exposed by an object implementing {@link PresenceDetails}.
	 *
	 * @since 0.1.13
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface ImDetails : GLib.Object {
		/**
		 * Change the contact's set of IM addresses.
		 *
		 * It's preferred to call this rather than setting
		 * {@link ImDetails.im_addresses} directly, as this method gives error
		 * notification and will only return once the IM addresses have been written
		 * to the relevant backing store (or the operation's failed).
		 *
		 * @param im_addresses the new map of protocols to IM addresses
		 * @throws PropertyError if setting the IM addresses failed
		 * @since 0.6.2
		 */
		public virtual async void change_im_addresses (Gee.MultiMap<string,Folks.ImFieldDetails> im_addresses) throws Folks.PropertyError;
		/**
		 * Normalise an IM address so that it's suitable for string comparison.
		 *
		 * IM addresses for various protocols can be represented in different ways,
		 * only one of which is canonical. In order to allow simple string comparisons
		 * of IM addresses to work, the IM addresses must be normalised beforehand.
		 *
		 * If the provided IM address is invalid,
		 * {@link Folks.ImDetailsError.INVALID_IM_ADDRESS} will be thrown. Note that
		 * this isn't guaranteed to be thrown for all invalid addresses, but if it is
		 * thrown, the address is guaranteed to be invalid.
		 *
		 * @param im_address the address to normalise
		 * @param protocol the protocol of this im_address
		 *
		 * @since 0.2.0
		 * @throws Folks.ImDetailsError if the provided IM address was invalid
		 */
		public static string normalise_im_address (string im_address, string protocol) throws Folks.ImDetailsError;
		/**
		 * A mapping of IM protocol to an (unordered) set of IM addresses.
		 *
		 * Each mapping is from an arbitrary protocol identifier to a set of IM
		 * addresses on that protocol for the contact, listed in no particular order.
		 *
		 * There must be no duplicate IM addresses in each set, though a given
		 * IM address may be present in the sets for different protocols.
		 *
		 * All the IM addresses must be normalised using
		 * {@link ImDetails.normalise_im_address} before being added to this property.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.MultiMap<string,Folks.ImFieldDetails> im_addresses { get; set; }
	}
	/**
	 * Interaction details of a contact.
	 *
	 * Interaction details are the number and date/time of calls or IM interactions
	 * with a contact, giving an idea of the recent interactions the user has had
	 * with that contact.
	 *
	 * @since 0.7.1
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface InteractionDetails : GLib.Object {
		/**
		 * The call interaction associated with a Persona
		 *
		 * @since 0.7.1
		 */
		public abstract uint call_interaction_count { get; }
		/**
		 * The IM interaction associated with a Persona
		 *
		 * @since 0.7.1
		 */
		public abstract uint im_interaction_count { get; }
		/**
		 * The latest call interaction timestamp associated with a Persona
		 *
		 * @since 0.7.1
		 */
		public abstract GLib.DateTime? last_call_interaction_datetime { get; }
		/**
		 * The latest IM interaction timestamp associated with a Persona
		 *
		 * @since 0.7.1
		 */
		public abstract GLib.DateTime? last_im_interaction_datetime { get; }
	}
	/**
	 * This interface represents the list of {@link Persona.iid}s
	 * corresponding to {@link Persona}s from backends with write
	 * support so that they can be linked.
	 *
	 * This is necessary so that personas from the same backend
	 * can be linked together even if they have no other linkeable
	 * properties set.
	 *
	 * @since 0.5.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface LocalIdDetails : GLib.Object {
		/**
		 * Change the contact's local IDs.
		 *
		 * It's preferred to call this rather than setting
		 * {@link LocalIdDetails.local_ids} directly, as this method gives error
		 * notification and will only return once the local IDs have been written to
		 * the relevant backing store (or the operation's failed).
		 *
		 * @param local_ids the set of local IDs
		 * @throws PropertyError if setting the local IDs failed
		 * @since 0.6.2
		 */
		public virtual async void change_local_ids (Gee.Set<string> local_ids) throws Folks.PropertyError;
		/**
		 * The IIDs corresponding to {@link Persona}s in a
		 * backend that we fully trust.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.Set<string> local_ids { get; set; }
	}
	/**
	 * Location of a contact. folks tries to keep track of
	 * the current location and thus favors live data (say,
	 * as advertised by a chat service) over static data (from
	 * an address book). Static addresses, such as a contact's home or work address,
	 * should be presented using the {@link PostalAddressDetails} interface.
	 * {@link LocationDetails} is purely for exposing the contact's current or
	 * recent location.
	 *
	 * Backends are expected to report only relevant changes
	 * in a persona's location. For storage backends like EDS,
	 * all changes must have been triggered by a person (e.g.
	 * editing the contact) and thus all are relevant.
	 *
	 * A backend pulling in live data, for example from a GPS,
	 * is expected to filter the data to minimize noise.
	 *
	 * folks itself will then apply all changes coming
	 * from backends without further filtering.
	 *
	 * @since 0.9.2
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface LocationDetails : GLib.Object {
		/**
		 * Set or remove the contact's currently advertised location.
		 *
		 * It's preferred to call this rather than setting
		 * {@link LocationDetails.location} directly, as this method gives error
		 * notification and will only return once the location has been written to the
		 * relevant backing store (or the operation's failed).
		 *
		 * @param location the contact's location, null to remove the information
		 * @throws PropertyError if setting the location failed
		 * @since 0.9.2
		 */
		public virtual async void change_location (Folks.Location? location) throws Folks.PropertyError;
		/**
		 * The current location of the contact. Null if the contact’s
		 * current location isn’t known, or they’re keeping it private.
		 *
		 * @since 0.9.2
		 */
		public abstract Folks.Location? location { get; set; }
	}
	/**
	 * Interface for classes which represent contacts with names, such as
	 * {@link Persona} and {@link Individual}.
	 *
	 * @since 0.3.5
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface NameDetails : GLib.Object {
		/**
		 * Change the contact's full name.
		 *
		 * It's preferred to call this rather than setting
		 * {@link NameDetails.full_name} directly, as this method gives error
		 * notification and will only return once the name has been written to the
		 * relevant backing store (or the operation's failed).
		 *
		 * @param full_name the full name (empty string to unset it)
		 * @throws PropertyError if setting the full name failed
		 * @since 0.6.2
		 */
		public virtual async void change_full_name (string full_name) throws Folks.PropertyError;
		/**
		 * Change the contact's nickname.
		 *
		 * It's preferred to call this rather than setting
		 * {@link NameDetails.nickname} directly, as this method gives error
		 * notification and will only return once the name has been written to the
		 * relevant backing store (or the operation's failed).
		 *
		 * @param nickname the nickname (empty string to unset it)
		 * @throws PropertyError if setting the nickname failed
		 * @since 0.6.2
		 */
		public virtual async void change_nickname (string nickname) throws Folks.PropertyError;
		/**
		 * Change the contact's structured name.
		 *
		 * It's preferred to call this rather than setting
		 * {@link NameDetails.structured_name} directly, as this method gives error
		 * notification and will only return once the name has been written to the
		 * relevant backing store (or the operation's failed).
		 *
		 * @param name the structured name (``null`` to unset it)
		 * @throws PropertyError if setting the structured name failed
		 * @since 0.6.2
		 */
		public virtual async void change_structured_name (Folks.StructuredName? name) throws Folks.PropertyError;
		/**
		 * The full name of the contact.
		 *
		 * The full name is the name of the contact written in the way the contact
		 * prefers. For instance for English names this is usually the given name
		 * followed by the family name, but Chinese names are usually the family
		 * name followed by the given name.
		 * The full name could or could not contain additional names (like a
		 * middle name), prefixes or suffixes.
		 *
		 * The full name must not be ``null``: the empty string represents an unset
		 * full name.
		 *
		 * @since 0.3.5
		 */
		public abstract string full_name { get; set; }
		/**
		 * The nickname of the contact.
		 *
		 * The nickname is the name that the contact chose for himself. This is
		 * different from {@link AliasDetails.alias} as aliases can be chosen by
		 * the user and not by the contacts themselves.
		 *
		 * Consequently, setting the nickname only makes sense in the context of an
		 * address book when updating the information a contact has specified about
		 * themselves.
		 *
		 * The nickname must not be ``null``: the empty string represents an unset
		 * nickname.
		 *
		 * @since 0.3.5
		 */
		public abstract string nickname { get; set; }
		/**
		 * The contact name split in its constituent parts.
		 *
		 * Note that most of the time the structured name is not set (i.e.
		 * it's ``null``) or just some of the components are set.
		 * The components are immutable. To get notification of changes of
		 * the structured name, you just have to connect to the ``notify`` signal
		 * of this property.
		 *
		 * @since 0.3.5
		 */
		public abstract Folks.StructuredName? structured_name { get; set; }
	}
	/**
	 * This interface represents the list of notes associated
	 * to a {@link Persona} and {@link Individual}.
	 *
	 * @since 0.4.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface NoteDetails : GLib.Object {
		/**
		 * Change the contact's notes.
		 *
		 * It's preferred to call this rather than setting {@link NoteDetails.notes}
		 * directly, as this method gives error notification and will only return once
		 * the notes have been written to the relevant backing store (or the
		 * operation's failed).
		 *
		 * @param notes the set of notes
		 * @throws PropertyError if setting the notes failed
		 * @since 0.6.2
		 */
		public virtual async void change_notes (Gee.Set<Folks.NoteFieldDetails> notes) throws Folks.PropertyError;
		/**
		 * The notes about the contact.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.Set<Folks.NoteFieldDetails> notes { get; set; }
	}
	/**
	 * Interface for classes that can provide a phone number, such as
	 * {@link Persona} and {@link Individual}.
	 *
	 * @since 0.3.5
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface PhoneDetails : GLib.Object {
		/**
		 * Change the contact's phone numbers.
		 *
		 * It's preferred to call this rather than setting
		 * {@link PhoneDetails.phone_numbers} directly, as this method gives error
		 * notification and will only return once the phone numbers have been written
		 * to the relevant backing store (or the operation's failed).
		 *
		 * @param phone_numbers the set of phone numbers
		 * @throws PropertyError if setting the phone numbers failed
		 * @since 0.6.2
		 */
		public virtual async void change_phone_numbers (Gee.Set<Folks.PhoneFieldDetails> phone_numbers) throws Folks.PropertyError;
		/**
		 * The phone numbers of the contact.
		 *
		 * A list of phone numbers associated to the contact.
		 *
		 * @since 0.6.0
		 */
		public abstract Gee.Set<Folks.PhoneFieldDetails> phone_numbers { get; set; }
	}
	/**
	 * Interface for classes that can provide postal addresses, such as
	 * {@link Persona} and {@link Individual}.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface PostalAddressDetails : GLib.Object {
		/**
		 * Change the contact's postal addresses.
		 *
		 * It's preferred to call this rather than setting
		 * {@link PostalAddressDetails.postal_addresses} directly, as this method
		 * gives error notification and will only return once the addresses have been
		 * written to the relevant backing store (or the operation's failed).
		 *
		 * @param postal_addresses the set of postal addresses
		 * @throws PropertyError if setting the addresses failed
		 * @since 0.6.2
		 */
		public virtual async void change_postal_addresses (Gee.Set<Folks.PostalAddressFieldDetails> postal_addresses) throws Folks.PropertyError;
		/**
		 * The postal addresses of the contact.
		 *
		 * A list of postal addresses associated to the contact.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.Set<Folks.PostalAddressFieldDetails> postal_addresses { get; set; }
	}
	/**
	 * Interface exposing a {@link Persona}'s or {@link Individual}'s presence;
	 * their current availability, such as for chatting.
	 *
	 * If the {@link Backend} providing the {@link Persona} doesn't support
	 * presence, the {@link Persona}'s ``presence_type`` will be set to
	 * {@link PresenceType.UNSET} and their ``presence_message`` will be an empty
	 * string.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface PresenceDetails : GLib.Object {
		/**
		 * The default message for a presence type.
		 *
		 * @param type a {@link PresenceType} for which to retrieve a translated
		 * display string
		 * @return a default translated display string for the given
		 * {@link PresenceType}
		 * @since 0.7.1
		 */
		public static unowned string get_default_message_from_type (Folks.PresenceType type);
		/**
		 * Whether the contact is online.
		 *
		 * This will be ``true`` if the contact's presence type is higher than
		 * {@link PresenceType.OFFLINE}, as determined by
		 * {@link PresenceDetails.typecmp}.
		 *
		 * @return ``true`` if the contact is online, ``false`` otherwise
		 */
		public bool is_online ();
		/**
		 * Compare two {@link PresenceType}s.
		 *
		 * ``0`` will be returned if the types are equal, a positive number will be
		 * returned if ``type_a`` is more available than ``type_b``, and a negative
		 * number will be returned if the opposite is true.
		 *
		 * @param type_a the first {@link PresenceType} to compare
		 * @param type_b the second {@link PresenceType} to compare
		 * @return a number representing the similarity of the two types
		 * @since 0.1.11
		 */
		public static int typecmp (Folks.PresenceType type_a, Folks.PresenceType type_b);
		/**
		 * The contact's client types.
		 *
		 * One can connect to instant messaging networks on a huge variety of devices,
		 * from PCs, to phones to consoles.
		 * The client types are represented in strings, using the values
		 * [[http://xmpp.org/registrar/disco-categories.html#client|documented by the XMPP registrar]]
		 *
		 * @since 0.9.5
		 */
		public abstract string[] client_types { get; set; }
		/**
		 * The contact's presence message.
		 *
		 * This is a short message written by the contact to add detail to their
		 * presence type ({@link Folks.PresenceDetails.presence_type}). If the contact
		 * hasn't set a message, it will be an empty string.
		 */
		public abstract string presence_message { get; set; }
		/**
		 * The contact's detailed presence status.
		 *
		 * This is a more detailed representation of the contact's presence than
		 * {@link PresenceDetails.presence_type}. It may be empty, or one of a
		 * well-known set of strings, as defined in the Telepathy specification:
		 * [[http://telepathy.freedesktop.org/spec/Connection_Interface_Simple_Presence.html#description|Telepathy Specification]]
		 *
		 * @since 0.6.0
		 */
		public abstract string presence_status { get; set; }
		/**
		 * The contact's presence type.
		 *
		 * Each contact can have one and only one presence type at any one time,
		 * representing their availability for communication. The default presence
		 * type is {@link PresenceType.UNSET}.
		 */
		public abstract Folks.PresenceType presence_type { get; set; }
	}
	/**
	 * This interfaces represents the list of roles a {@link Persona} and
	 * {@link Individual} might have.
	 *
	 * @since 0.4.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface RoleDetails : GLib.Object {
		/**
		 * Change the contact's roles.
		 *
		 * It's preferred to call this rather than setting {@link RoleDetails.roles}
		 * directly, as this method gives error notification and will only return once
		 * the roles have been written to the relevant backing store (or the
		 * operation's failed).
		 *
		 * @param roles the set of roles
		 * @throws PropertyError if setting the roles failed
		 * @since 0.6.2
		 */
		public virtual async void change_roles (Gee.Set<Folks.RoleFieldDetails> roles) throws Folks.PropertyError;
		/**
		 * The roles of the contact.
		 *
		 * @since 0.6.0
		 */
		public abstract Gee.Set<Folks.RoleFieldDetails> roles { get; set; }
	}
	/**
	 * Associates a list of URLs with a contact.
	 *
	 * @since 0.3.5
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface UrlDetails : GLib.Object {
		/**
		 * Change the contact's URLs.
		 *
		 * It's preferred to call this rather than setting {@link UrlDetails.urls}
		 * directly, as this method gives error notification and will only return once
		 * the URLs have been written to the relevant backing store (or the
		 * operation's failed).
		 *
		 * @param urls the set of URLs
		 * @throws PropertyError if setting the URLs failed
		 * @since 0.6.2
		 */
		public virtual async void change_urls (Gee.Set<Folks.UrlFieldDetails> urls) throws Folks.PropertyError;
		/**
		 * The websites of the contact.
		 *
		 * A list or websites associated to the contact.
		 *
		 * @since 0.5.1
		 */
		public abstract Gee.Set<Folks.UrlFieldDetails> urls { get; set; }
	}
	/**
	 * Web service contact details.
	 *
	 * @since 0.5.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public interface WebServiceDetails : GLib.Object {
		/**
		 * Change the contact's web service addresses.
		 *
		 * It's preferred to call this rather than setting
		 * {@link WebServiceDetails.web_service_addresses} directly, as this method
		 * gives error notification and will only return once the addresses have been
		 * written to the relevant backing store (or the operation's failed).
		 *
		 * @param web_service_addresses the set of addresses
		 * @throws PropertyError if setting the addresses failed
		 * @since 0.6.2
		 */
		public virtual async void change_web_service_addresses (Gee.MultiMap<string,Folks.WebServiceFieldDetails> web_service_addresses) throws Folks.PropertyError;
		/**
		 * A mapping of web service to an (unordered) set of web service addresses.
		 *
		 * Each mapping is from an arbitrary web service identifier to a set of web
		 * service addresses for the contact, listed in no particular order.
		 *
		 * Web service addresses are guaranteed to be unique per web service, but
		 * not necessarily unique amongst all web services.
		 *
		 * @since 0.6.0
		 */
		public abstract Gee.MultiMap<string,Folks.WebServiceFieldDetails> web_service_addresses { get; set; }
	}
	/**
	 * The gender of a contact
	 *
	 * @since 0.3.5
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public enum Gender {
		/**
		 * The gender of the contact is unknown or the contact didn't specify it.
		 */
		UNSPECIFIED,
		/**
		 * The contact is male.
		 */
		MALE,
		/**
		 * The contact is female.
		 */
		FEMALE
	}
	/**
	 * Likely-ness of a potential match.
	 *
	 * Note that the order should be maintained.
	 *
	 * @since 0.5.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public enum MatchResult {
		/**
		 * Zero likelihood of a match.
		 *
		 * This is used in situations where two individuals should never be linked,
		 * such as when one of them has a {@link Individual.trust_level} of
		 * {@link TrustLevel.NONE}, or when the individuals are explicitly
		 * anti-linked.
		 *
		 * @since 0.6.8
		 */
		NONE,
		/**
		 * Very low likelihood of a match.
		 */
		VERY_LOW,
		/**
		 * Low likelihood of a match.
		 */
		LOW,
		/**
		 * Medium likelihood of a match.
		 */
		MEDIUM,
		/**
		 * High likelihood of a match.
		 */
		HIGH,
		/**
		 * Very high likelihood of a match.
		 */
		VERY_HIGH,
		/**
		 * Minimum likelihood of a match.
		 */
		MIN,
		/**
		 * Maximum likelihood of a match.
		 */
		MAX
	}
	/**
	 * A 'boolean' type that has a distinct 'unset' state.
	 *
	 * @since 0.3.1
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public enum MaybeBool {
		/**
		 * This value is explicitly unset.
		 */
		UNSET,
		/**
		 * False (this value was set from its default of UNSET).
		 */
		FALSE,
		/**
		 * True (this value was set from its default of UNSET).
		 */
		TRUE
	}
	/**
	 * Definition of the available fields to be looked up with
	 * {@link PersonaStore.detail_key}.
	 *
	 * @since 0.5.0
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public enum PersonaDetail {
		/**
		 * Invalid field for use in error returns.
		 *
		 * @since 0.6.2
		 */
		INVALID,
		/**
		 * Field for {@link AliasDetails.alias}.
		 *
		 * @since 0.5.0
		 */
		ALIAS,
		/**
		 * Field for {@link AvatarDetails.avatar}.
		 *
		 * @since 0.5.0
		 */
		AVATAR,
		/**
		 * Field for {@link BirthdayDetails.birthday}.
		 *
		 * @since 0.5.0
		 */
		BIRTHDAY,
		/**
		 * Field for {@link EmailDetails.email_addresses}.
		 *
		 * @since 0.5.0
		 */
		EMAIL_ADDRESSES,
		/**
		 * Field for {@link NameDetails.full_name}.
		 *
		 * @since 0.5.0
		 */
		FULL_NAME,
		/**
		 * Field for {@link GenderDetails.gender}.
		 *
		 * @since 0.5.0
		 */
		GENDER,
		/**
		 * Field for {@link ImDetails.im_addresses}.
		 *
		 * @since 0.5.0
		 */
		IM_ADDRESSES,
		/**
		 * Field for {@link FavouriteDetails.is_favourite}.
		 *
		 * @since 0.5.0
		 */
		IS_FAVOURITE,
		/**
		 * Field for {@link LocalIdDetails.local_ids}.
		 *
		 * @since 0.5.0
		 */
		LOCAL_IDS,
		/**
		 * Field for {@link LocationDetails.location}.
		 *
		 * @since 0.9.2
		 */
		LOCATION,
		/**
		 * Field for {@link NameDetails.nickname}.
		 *
		 * @since 0.5.0
		 */
		NICKNAME,
		/**
		 * Field for {@link NoteDetails.notes}.
		 *
		 * @since 0.5.0
		 */
		NOTES,
		/**
		 * Field for {@link PhoneDetails.phone_numbers}.
		 *
		 * @since 0.5.0
		 */
		PHONE_NUMBERS,
		/**
		 * Field for {@link PostalAddressDetails.postal_addresses}.
		 *
		 * @since 0.5.0
		 */
		POSTAL_ADDRESSES,
		/**
		 * Field for {@link RoleDetails.roles}.
		 *
		 * @since 0.5.0
		 */
		ROLES,
		/**
		 * Field for {@link NameDetails.structured_name}.
		 *
		 * @since 0.5.0
		 */
		STRUCTURED_NAME,
		/**
		 * Field for {@link UrlDetails.urls}.
		 *
		 * @since 0.5.0
		 */
		URLS,
		/**
		 * Field for {@link WebServiceDetails.web_service_addresses}.
		 *
		 * @since 0.5.0
		 */
		WEB_SERVICE_ADDRESSES,
		/**
		 * Field for {@link GroupDetails.groups}.
		 *
		 * @since 0.6.2
		 */
		GROUPS,
		/**
		 * Field for {@link InteractionDetails.im_interaction_count}.
		 *
		 * @since 0.7.1
		 */
		IM_INTERACTION_COUNT,
		/**
		 * Field for {@link InteractionDetails.last_im_interaction_datetime}.
		 *
		 * @since 0.7.1
		 */
		LAST_IM_INTERACTION_DATETIME,
		/**
		 * Field for {@link InteractionDetails.call_interaction_count}.
		 *
		 * @since 0.7.1
		 */
		CALL_INTERACTION_COUNT,
		/**
		 * Field for {@link InteractionDetails.last_call_interaction_datetime}.
		 *
		 * @since 0.7.1
		 */
		LAST_CALL_INTERACTION_DATETIME,
		/**
		 * Field for {@link AntiLinkable.anti_links}.
		 *
		 * @since 0.7.3
		 */
		ANTI_LINKS,
		/**
		 * Field for {@link ExtendedFieldDetails}.
		 *
		 * @since 0.11.0
		 */
		EXTENDED_INFO
	}
	/**
	 * Trust level for a {@link PersonaStore}'s {@link Persona}s for linking
	 * purposes.
	 *
	 * Trust levels are set internally by the backends, and must not be modified by
	 * clients.
	 *
	 * @since 0.1.13
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public enum PersonaStoreTrust {
		/**
		 * The {@link Persona}s aren't trusted at all, and cannot be linked.
		 *
		 * This should be used for {@link PersonaStore}s where even the
		 * {@link Persona} UID could be maliciously edited to corrupt {@link Persona}
		 * links, or where the UID changes regularly.
		 *
		 * @since 0.1.13
		 */
		NONE,
		/**
		 * Only the {@link Persona.uid} property is trusted for linking.
		 *
		 * In practice, this means that {@link Persona}s from this
		 * {@link PersonaStore} will not contribute towards the linking process, but
		 * can be linked together by their UIDs using data from {@link Persona}s from
		 * a fully-trusted {@link PersonaStore}.
		 *
		 * @since 0.1.13
		 */
		PARTIAL,
		/**
		 * Every property in {@link Persona.linkable_properties} is trusted.
		 *
		 * This should only be used for user-controlled {@link PersonaStore}s, as if a
		 * remote store is compromised, malicious changes could be made to its data
		 * which corrupt the user's {@link Persona} links.
		 *
		 * @since 0.1.13
		 */
		FULL
	}
	/**
	 * The possible presence states an object implementing {@link PresenceDetails}
	 * could be in.
	 *
	 * These closely follow the
	 * [[http://telepathy.freedesktop.org/spec/Connection_Interface_Simple_Presence.html#Connection_Presence_Type|SimplePresence]]
	 * interface in the Telepathy specification.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public enum PresenceType {
		/**
		 * never set
		 */
		UNSET,
		/**
		 * offline
		 */
		OFFLINE,
		/**
		 * available
		 */
		AVAILABLE,
		/**
		 * away from keyboard
		 */
		AWAY,
		/**
		 * away from keyboard for an extended period of time
		 */
		EXTENDED_AWAY,
		/**
		 * also known as "invisible" or "appear offline"
		 */
		HIDDEN,
		/**
		 * at keyboard, but too busy to chat
		 */
		BUSY,
		/**
		 * presence not received from server
		 */
		UNKNOWN,
		/**
		 * an error occurred with fetching the presence
		 */
		ERROR
	}
	/**
	 * Trust level for an {@link Individual} for use in the UI.
	 *
	 * @since 0.1.15
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public enum TrustLevel {
		/**
		 * The {@link Individual}'s {@link Persona}s aren't trusted at all.
		 *
		 * This is the trust level for an {@link Individual} which contains one or
		 * more {@link Persona}s which cannot be guaranteed to be the same
		 * {@link Persona}s as were originally linked together.
		 *
		 * For example, an {@link Individual} containing a link-local XMPP
		 * {@link Persona} would have this trust level, since someone else could
		 * easily spoof the link-local XMPP {@link Persona}'s identity.
		 *
		 * @since 0.1.15
		 */
		NONE,
		/**
		 * The {@link Individual}'s {@link Persona}s are trusted.
		 *
		 * This trust level is for {@link Individual}s where it can be guaranteed
		 * that all the {@link Persona}s are the same ones as when they were
		 * originally linked together.
		 *
		 * Note that this doesn't guarantee that the user who behind each
		 * {@link Persona} is who they claim to be.
		 *
		 * @since 0.1.15
		 */
		PERSONAS
	}
	/**
	 * Errors related to IM addresses and IM address handling.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public errordomain ImDetailsError {
		/**
		 * The specified IM address could not be parsed.
		 */
		INVALID_IM_ADDRESS
	}
	/**
	 * Errors from {@link IndividualAggregator}s.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public errordomain IndividualAggregatorError {
		/**
		 * Adding a {@link Persona} to a {@link PersonaStore} failed.
		 */
		ADD_FAILED,
		/**
		 * An operation which required the use of a writeable store failed because no
		 * writeable store was available.
		 *
		 * @since 0.1.13
		 */
		[Version (deprecated = true, deprecated_since = "0.6.2.1", replacement = "IndividualAggregatorError.NO_PRIMARY_STORE")]
		NO_WRITEABLE_STORE,
		/**
		 * The {@link PersonaStore} was offline (ie, this is a temporary failure).
		 *
		 * @since 0.3.0
		 */
		STORE_OFFLINE,
		/**
		 * The {@link PersonaStore} did not support writing to a property which the
		 * user requested to write to, or which was necessary to write to for storing
		 * linking information.
		 *
		 * @since 0.6.2
		 */
		PROPERTY_NOT_WRITEABLE,
		/**
		 * An operation which required the use of a primary store failed because no
		 * primary store was available.
		 *
		 * @since 0.6.3
		 */
		NO_PRIMARY_STORE
	}
	/**
	 * Errors from {@link PersonaStore}s.
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public errordomain PersonaStoreError {
		/**
		 * An argument to the method was invalid.
		 */
		INVALID_ARGUMENT,
		/**
		 * Creation of a {@link Persona} failed.
		 */
		CREATE_FAILED,
		/**
		 * Such an operation may not be performed on a {@link Persona} with
		 * {@link Persona.is_user} set to ``true``.
		 *
		 * @since 0.3.0
		 */
		UNSUPPORTED_ON_USER,
		/**
		 * The {@link PersonaStore} was offline (ie, this is a temporary failure).
		 *
		 * @since 0.3.0
		 */
		STORE_OFFLINE,
		/**
		 * The {@link PersonaStore} doesn't support write operations.
		 *
		 * @since 0.3.4
		 */
		READ_ONLY,
		/**
		 * The operation was denied due to not having sufficient permissions.
		 *
		 * @since 0.6.0
		 */
		PERMISSION_DENIED,
		/**
		 * Removal of a {@link Persona} failed. This is a generic error which is used
		 * if no other error code (such as, e.g.,
		 * {@link PersonaStoreError.PERMISSION_DENIED}) is applicable.
		 *
		 * @since 0.6.0
		 */
		REMOVE_FAILED,
		/**
		 * Such an operation may only be performed on a {@link Persona} with
		 * {@link Persona.is_user} set to ``true``.
		 *
		 * @since 0.6.4
		 */
		UNSUPPORTED_ON_NON_USER
	}
	/**
	 * Errors which can be thrown when asynchronously setting a property of a
	 * {@link Persona} using a setter method defined on an interface such as
	 * {@link AliasDetails}.
	 *
	 * @since 0.6.2
	 */
	[CCode (cheader_filename = "folks/folks.h")]
	public errordomain PropertyError {
		/**
		 * Property is not writeable for this particular object.
		 *
		 * @since 0.6.2
		 */
		NOT_WRITEABLE,
		/**
		 * Value was invalid for the property.
		 *
		 * @since 0.6.2
		 */
		INVALID_VALUE,
		/**
		 * Unknown error when setting the property.
		 *
		 * @since 0.6.2
		 */
		UNKNOWN_ERROR,
		/**
		 * The backing store is offline or otherwise unavailable.
		 *
		 * This is a temporary error which should be retifiable by going online or
		 * ensuring the backing store is logged in.
		 *
		 * @since 0.7.4
		 */
		UNAVAILABLE
	}
}
